<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>加密算法之java实现AES</title>
    <url>/2022/04/18/jia-mi-suan-fa-zhi-java-shi-xian-aes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>AESUtil</code>工具类</p>
<pre><code class="prettyprint">public class AESUtil &#123;
    //自己定义
    public static String AES_KEY_VALUE = &quot;&quot;;
    private static final String KEY_ALGORITHM = &quot;AES&quot;;
    /**
     * 默认的加密算法
     */
    private static final String DEFAULT_CIPHER_ALGORITHM = &quot;AES/ECB/PKCS5Padding&quot;;

    /**
     * 随机生成密钥
     *
     * @return
     */
    public static String getAESRandomKey() &#123;
        SecureRandom random = new SecureRandom();
        long randomKey = random.nextLong();
        return String.valueOf(randomKey);
    &#125;

    /**
     * AES 加密操作
     *
     * @param content 待加密内容
     * @param key     加密密钥
     * @return 返回Base64转码后的加密数据
     */
    public static String encrypt(String content, String key)  &#123;
        try &#123;
            // 创建密码器
            Cipher cipher = Cipher.getInstance(DEFAULT_CIPHER_ALGORITHM);
            byte[] byteContent = content.getBytes(&quot;utf-8&quot;);
            // 初始化为加密模式的密码器
            cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(key));
            // 加密
            byte[] result = cipher.doFinal(byteContent);
            //通过Base64转码返回
            return HexUtil.getHexString(result);
        &#125; catch (Exception ex) &#123;
            ex.printStackTrace();
        &#125;

        return null;
    &#125;

    /**
     * AES 解密操作
     *
     * @param content
     * @param key
     * @return
     */
    public static String decrypt(String content, String key) &#123;
        try &#123;
            //实例化
            Cipher cipher = Cipher.getInstance(DEFAULT_CIPHER_ALGORITHM);
            //使用密钥初始化，设置为解密模式
            cipher.init(Cipher.DECRYPT_MODE, getSecretKey(key));
            //执行操作
            byte[] result = cipher.doFinal(HexUtil.hexStringToBytes(content));
            return new String(result, &quot;utf-8&quot;);
        &#125; catch (Exception ex) &#123;
            ex.printStackTrace();
        &#125;

        return null;
    &#125;

    /**
     * 生成加密秘钥
     *
     * @return
     */
    private static SecretKeySpec getSecretKey(final String key) &#123;
        //返回生成指定算法密钥生成器的 KeyGenerator 对象
        try &#123;
            KeyGenerator kg = KeyGenerator.getInstance(KEY_ALGORITHM);
            // 此类提供加密的强随机数生成器 (RNG)，该实现在windows上每次生成的key都相同，但是在部分linux或solaris系统上则不同。
            // SecureRandom random = new SecureRandom(key.getBytes());
            // 指定算法名称，不同的系统上生成的key是相同的。
            SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);
            random.setSeed(key.getBytes());
            //AES 要求密钥长度为 128
            kg.init(128, random);
            //生成一个密钥
            SecretKey secretKey = kg.generateKey();
            // 转换为AES专用密钥
            return new SecretKeySpec(secretKey.getEncoded(), KEY_ALGORITHM);
        &#125; catch (NoSuchAlgorithmException ex) &#123;
            ex.printStackTrace();
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<p><code>AESUtilTest</code>测试类</p>
<pre><code class="prettyprint">@Test
    public void encodeAndDecode() throws Exception &#123;
//        String data = &quot;阿斯达斯&quot;;
        SecureRandom random = new SecureRandom();
        String data = String.valueOf(random.nextInt(50));
        data += &quot;123456789789456123&quot;;
        String secretKey = AESUtil.AES_KEY_VALUE;
        System.out.println(&quot;传输数据:&quot;+data);
        //加密
        String encrypte = AESUtil.encrypt(data, secretKey);
        System.out.println(&quot;加密后数据:&quot;+encrypte+&quot;，长度：&quot;+encrypte.length());
        //数据解密
        String decryptDatas = AESUtil.decrypt(encrypte, secretKey);
        System.out.println(&quot;解密后数据：&quot;+decryptDatas);
    &#125;
</code></pre>
<p>转载:[Java加密-AES加解密](<a href="https://www.jianshu.com/p/7f17792609cc">Java加密-AES加解密 - 简书 (jianshu.com)</a>)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>加密算法之java实现SM4</title>
    <url>/2022/04/18/jia-mi-suan-fa-zhi-java-shi-xian-sm4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 1、引入依赖</p>
<pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;commons-codec&lt;/groupId&gt;
    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
    &lt;version&gt;1.15&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;
    &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;
    &lt;version&gt;1.56&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、构造工具类</p>
<pre><code class="prettyprint">public class SM4Util &#123;
    static &#123;
        Security.addProvider(new BouncyCastleProvider());
    &#125;

    private static final String ENCODING = &quot;UTF-8&quot;;
    public static final String ALGORITHM_NAME = &quot;SM4&quot;;
    // 加密算法/分组加密模式/分组填充方式
    // PKCS5Padding-以8个字节为一组进行分组加密
    // 定义分组加密模式使用：PKCS5Padding
    public static final String ALGORITHM_NAME_ECB_PADDING = &quot;SM4/ECB/PKCS5Padding&quot;;
    // 128-32位16进制；256-64位16进制
    public static final int DEFAULT_KEY_SIZE = 128;

    /**
     * 自动生成密钥
     *
     * @return
     * @explain
     */
    public static String generateKey() throws Exception &#123;
        return new String(Hex.encodeHex(generateKey(DEFAULT_KEY_SIZE),false));
    &#125;

    /**
     * @param keySize
     * @return
     * @throws Exception
     * @explain
     */
    public static byte[] generateKey(int keySize) throws Exception &#123;
        KeyGenerator kg = KeyGenerator.getInstance(ALGORITHM_NAME, BouncyCastleProvider.PROVIDER_NAME);
        kg.init(keySize, new SecureRandom());
        return kg.generateKey().getEncoded();
    &#125;

    /**
     * 生成ECB暗号
     *
     * @param algorithmName 算法名称
     * @param mode          模式
     * @param key
     * @return
     * @throws Exception
     * @explain ECB模式（电子密码本模式：Electronic codebook）
     */
    private static Cipher generateEcbCipher(String algorithmName, int mode, byte[] key) throws Exception &#123;
        Cipher cipher = Cipher.getInstance(algorithmName, BouncyCastleProvider.PROVIDER_NAME);
        Key sm4Key = new SecretKeySpec(key, ALGORITHM_NAME);
        cipher.init(mode, sm4Key);
        return cipher;
    &#125;

    /**
     * sm4加密
     *
     * @param hexKey   16进制密钥（忽略大小写）
     * @param paramStr 待加密字符串
     * @return 返回16进制的加密字符串
     * @explain 加密模式：ECB
     * 密文长度不固定，会随着被加密字符串长度的变化而变化
     */
    public static String encryptEcb(String hexKey, String paramStr) &#123;
        try &#123;
            String cipherText = &quot;&quot;;
            // 16进制字符串--&amp;gt;byte[]
            byte[] keyData = ByteUtils.fromHexString(hexKey);
            // String--&amp;gt;byte[]
            byte[] srcData = paramStr.getBytes(ENCODING);
            // 加密后的数组
            byte[] cipherArray = encrypt_Ecb_Padding(keyData, srcData);
            // byte[]--&amp;gt;hexString
            cipherText = ByteUtils.toHexString(cipherArray);
            return cipherText;
        &#125; catch (Exception e) &#123;
            return paramStr;
        &#125;
    &#125;

    /**
     * 加密模式之Ecb
     *
     * @param key
     * @param data
     * @return
     * @throws Exception
     * @explain
     */
    public static byte[] encrypt_Ecb_Padding(byte[] key, byte[] data) throws Exception &#123;
        Cipher cipher = generateEcbCipher(ALGORITHM_NAME_ECB_PADDING, Cipher.ENCRYPT_MODE, key);
        return cipher.doFinal(data);
    &#125;

    /**
     * sm4解密
     *
     * @param hexKey     16进制密钥
     * @param cipherText 16进制的加密字符串（忽略大小写）
     * @return 解密后的字符串
     * @throws Exception
     * @explain 解密模式：采用ECB
     */
    public static String decryptEcb(String hexKey, String cipherText) &#123;
        // 用于接收解密后的字符串
        String decryptStr = &quot;&quot;;
        // hexString--&amp;gt;byte[]
        byte[] keyData = ByteUtils.fromHexString(hexKey);
        // hexString--&amp;gt;byte[]
        byte[] cipherData = ByteUtils.fromHexString(cipherText);
        // 解密
        byte[] srcData = new byte[0];
        try &#123;
            srcData = decrypt_Ecb_Padding(keyData, cipherData);
            // byte[]--&amp;gt;String
            decryptStr = new String(srcData, ENCODING);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return decryptStr;
    &#125;

    /**
     * 解密
     *
     * @param key
     * @param cipherText
     * @return
     * @throws Exception
     * @explain
     */
    public static byte[] decrypt_Ecb_Padding(byte[] key, byte[] cipherText) throws Exception &#123;
        Cipher cipher = generateEcbCipher(ALGORITHM_NAME_ECB_PADDING, Cipher.DECRYPT_MODE, key);
        return cipher.doFinal(cipherText);
    &#125;

    /**
     * 校验加密前后的字符串是否为同一数据
     *
     * @param hexKey     16进制密钥（忽略大小写）
     * @param cipherText 16进制加密后的字符串
     * @param paramStr   加密前的字符串
     * @return 是否为同一数据
     * @throws Exception
     * @explain
     */
    public static boolean verifyEcb(String hexKey, String cipherText, String paramStr) throws Exception &#123;
        // 用于接收校验结果
        boolean flag = false;
        // hexString--&amp;gt;byte[]
        byte[] keyData = ByteUtils.fromHexString(hexKey);
        // 将16进制字符串转换成数组
        byte[] cipherData = ByteUtils.fromHexString(cipherText);
        // 解密
        byte[] decryptData = decrypt_Ecb_Padding(keyData, cipherData);
        // 将原字符串转换成byte[]
        byte[] srcData = paramStr.getBytes(ENCODING);
        // 判断2个数组是否一致
        flag = Arrays.equals(decryptData, srcData);
        return flag;
    &#125;

&#125;
</code></pre>
<pre><code class="prettyprint">@Test
public void encodeAndDecode()&#123;
    try &#123;
        String json = &quot;BF7B6BD7C1204BC4F3C87D235692DE9DBF7B6BD7C1204BC4F3C87D235692DE9DBF7B6BD7C1204BC4F3C87D235692DE9D&quot;;
        System.out.println(&quot;加密前源数据————&quot; + json);
        // 生成32位16进制密钥(key不能随便取药使用生成的)
        //            String key = SM4Util.generateKey();
        String key = &quot;888368581322491ace9q79348a2757d1&quot;;
        System.out.println(key + &quot;-----生成key&quot;);
        String cipher = SM4Util.encryptEcb(key, json);
        System.out.println(&quot;加密串---&quot; + cipher);
        System.out.println(SM4Util.verifyEcb(key, cipher, json));
        json = SM4Util.decryptEcb(key, cipher);
        System.out.println(&quot;解密后数据---&quot; + json);
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>测试图标</title>
    <url>/2022/04/17/ce-shi-tu-biao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div>
    <a href="/archives/"><i class="fa fa-glass" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-music" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-search" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-envelope-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-heart" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-star" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-star-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-user" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-film" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-th-large" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-th" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-th-list" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-check" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-remove" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-search-plus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-search-minus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-power-off" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-signal" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gear" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-trash-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-home" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-clock-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-road" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-download" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-circle-o-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-circle-o-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-inbox" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-play-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-rotate-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-refresh" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-list-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-lock" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-flag" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-headphones" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-volume-off" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-volume-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-volume-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-qrcode" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-barcode" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tag" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tags" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-book" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bookmark" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-print" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-camera" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-font" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bold" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-italic" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-text-height" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-text-width" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-align-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-align-center" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-align-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-align-justify" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-list" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-dedent" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-indent" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-video-camera" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-photo" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pencil" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-map-marker" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-adjust" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tint" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-edit" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-share-square-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-check-square-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrows" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-step-backward" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fast-backward" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-backward" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-play" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pause" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-stop" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-forward" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fast-forward" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-step-forward" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-eject" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chevron-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chevron-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-plus-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-minus-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-times-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-check-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-question-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-info-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-crosshairs" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-times-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-check-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ban" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mail-forward" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-expand" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-compress" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-plus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-minus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-asterisk" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-exclamation-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gift" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-leaf" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fire" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-eye" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-eye-slash" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-warning" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-plane" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-calendar" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-random" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-comment" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-magnet" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chevron-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chevron-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-retweet" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-shopping-cart" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-folder" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-folder-open" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrows-v" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrows-h" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bar-chart-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-twitter-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-facebook-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-camera-retro" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-key" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gears" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-comments" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thumbs-o-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thumbs-o-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-star-half" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-heart-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sign-out" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-linkedin-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thumb-tack" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-external-link" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sign-in" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-trophy" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-github-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-upload" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-lemon-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-phone" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-square-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bookmark-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-phone-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-twitter" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-facebook-f" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-github" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-unlock" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-credit-card" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-feed" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hdd-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bullhorn" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bell" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-certificate" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-o-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-o-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-o-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-o-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-circle-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-circle-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-circle-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-globe" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wrench" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tasks" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-filter" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-briefcase" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrows-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-group" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chain" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cloud" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-flask" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cut" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-copy" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-paperclip" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-save" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-navicon" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-list-ul" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-list-ol" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-strikethrough" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-underline" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-table" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-magic" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-truck" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pinterest" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pinterest-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-google-plus-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-google-plus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-money" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-caret-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-caret-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-caret-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-caret-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-columns" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-unsorted" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sort-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sort-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-envelope" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-linkedin" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-rotate-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-legal" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-dashboard" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-comment-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-comments-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-flash" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sitemap" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-umbrella" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-paste" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-lightbulb-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-exchange" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cloud-download" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cloud-upload" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-user-md" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-stethoscope" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-suitcase" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bell-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-coffee" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cutlery" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-text-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-building-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hospital-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ambulance" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-medkit" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fighter-jet" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-beer" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-h-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-plus-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angle-double-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angle-double-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angle-double-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angle-double-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angle-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angle-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angle-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angle-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-desktop" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-laptop" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tablet" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mobile-phone" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-quote-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-quote-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-spinner" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mail-reply" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-github-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-folder-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-folder-open-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-smile-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-frown-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-meh-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gamepad" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-keyboard-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-flag-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-flag-checkered" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-terminal" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-code" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mail-reply-all" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-star-half-empty" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-location-arrow" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-crop" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-code-fork" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-unlink" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-question" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-info" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-exclamation" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-superscript" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-subscript" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-eraser" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-puzzle-piece" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-microphone" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-microphone-slash" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-shield" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-calendar-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fire-extinguisher" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-rocket" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-maxcdn" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chevron-circle-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chevron-circle-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chevron-circle-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chevron-circle-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-html5" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-css3" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-anchor" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-unlock-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bullseye" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ellipsis-h" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ellipsis-v" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-rss-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-play-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ticket" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-minus-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-minus-square-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-level-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-level-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-check-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pencil-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-external-link-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-share-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-compass" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-toggle-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-toggle-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-toggle-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-euro" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gbp" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-dollar" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-rupee" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cny" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ruble" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-won" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bitcoin" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-text" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sort-alpha-asc" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sort-alpha-desc" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sort-amount-asc" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sort-amount-desc" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sort-numeric-asc" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sort-numeric-desc" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thumbs-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thumbs-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-youtube-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-youtube" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-xing" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-xing-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-youtube-play" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-dropbox" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-stack-overflow" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-instagram" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-flickr" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-adn" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bitbucket" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bitbucket-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tumblr" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tumblr-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-long-arrow-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-long-arrow-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-long-arrow-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-long-arrow-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-apple" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-windows" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-android" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-linux" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-dribbble" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-skype" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-foursquare" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-trello" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-female" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-male" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gittip" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sun-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-moon-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-archive" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bug" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-vk" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-weibo" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-renren" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pagelines" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-stack-exchange" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-circle-o-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-circle-o-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-toggle-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-dot-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wheelchair" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-vimeo-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-turkish-lira" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-plus-square-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-space-shuttle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-slack" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-envelope-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wordpress" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-openid" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-institution" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mortar-board" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-yahoo" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-google" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-reddit" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-reddit-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-stumbleupon-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-stumbleupon" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-delicious" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-digg" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pied-piper-pp" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pied-piper-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-drupal" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-joomla" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-language" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fax" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-building" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-child" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-paw" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-spoon" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cube" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cubes" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-behance" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-behance-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-steam" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-steam-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-recycle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-automobile" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cab" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tree" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-spotify" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-deviantart" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-soundcloud" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-database" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-pdf-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-word-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-excel-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-powerpoint-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-photo-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-zip-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-sound-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-movie-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-code-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-vine" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-codepen" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-jsfiddle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-life-bouy" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-circle-o-notch" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ra" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ge" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-git-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-git" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-y-combinator-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tencent-weibo" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-qq" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wechat" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-send" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-send-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-history" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-circle-thin" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-header" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-paragraph" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sliders" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-share-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-share-alt-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bomb" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-soccer-ball-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tty" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-binoculars" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-plug" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-slideshare" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-twitch" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-yelp" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-newspaper-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wifi" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-calculator" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-paypal" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-google-wallet" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc-visa" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc-mastercard" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc-discover" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc-amex" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc-paypal" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc-stripe" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bell-slash" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bell-slash-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-trash" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-copyright" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-at" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-eyedropper" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-paint-brush" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-birthday-cake" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-area-chart" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pie-chart" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-line-chart" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-lastfm" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-lastfm-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-toggle-off" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-toggle-on" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bicycle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ioxhost" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angellist" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-shekel" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-meanpath" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-buysellads" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-connectdevelop" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-dashcube" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-forumbee" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-leanpub" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sellsy" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-shirtsinbulk" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-simplybuilt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-skyatlas" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cart-plus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cart-arrow-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-diamond" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ship" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-user-secret" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-motorcycle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-street-view" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-heartbeat" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-venus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mars" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mercury" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-intersex" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-transgender-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-venus-double" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mars-double" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-venus-mars" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mars-stroke" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mars-stroke-v" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mars-stroke-h" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-neuter" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-genderless" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-facebook-official" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pinterest-p" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-whatsapp" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-server" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-user-plus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-user-times" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hotel" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-viacoin" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-train" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-subway" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-medium" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-yc" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-optin-monster" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-opencart" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-expeditedssl" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-battery-4" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-battery-3" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-battery-2" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-battery-1" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-battery-0" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mouse-pointer" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-i-cursor" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-object-group" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-object-ungroup" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sticky-note" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sticky-note-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc-jcb" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc-diners-club" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-clone" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-balance-scale" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hourglass-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hourglass-1" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hourglass-2" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hourglass-3" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hourglass" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-grab-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-stop-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-scissors-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-lizard-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-spock-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-pointer-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-peace-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-trademark" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-registered" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-creative-commons" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gg" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gg-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tripadvisor" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-odnoklassniki" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-odnoklassniki-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-get-pocket" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wikipedia-w" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-safari" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chrome" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-firefox" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-opera" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-internet-explorer" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tv" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-contao" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-500px" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-amazon" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-calendar-plus-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-calendar-minus-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-calendar-times-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-calendar-check-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-industry" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-map-pin" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-map-signs" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-map-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-map" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-commenting" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-commenting-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-houzz" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-vimeo" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-black-tie" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fonticons" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-reddit-alien" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-edge" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-credit-card-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-codiepie" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-modx" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fort-awesome" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-usb" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-product-hunt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mixcloud" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-scribd" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pause-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pause-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-stop-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-stop-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-shopping-bag" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-shopping-basket" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hashtag" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bluetooth" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bluetooth-b" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-percent" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gitlab" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wpbeginner" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wpforms" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-envira" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-universal-access" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wheelchair-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-question-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-blind" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-audio-description" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-volume-control-phone" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-braille" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-assistive-listening-systems" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-asl-interpreting" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-deafness" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-glide" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-glide-g" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-signing" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-low-vision" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-viadeo" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-viadeo-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-snapchat" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-snapchat-ghost" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-snapchat-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pied-piper" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-first-order" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-yoast" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-themeisle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-google-plus-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fa" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-handshake-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-envelope-open" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-envelope-open-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-linode" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-address-book" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-address-book-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-vcard" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-vcard-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-user-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-user-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-user-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-id-badge" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-drivers-license" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-drivers-license-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-quora" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-free-code-camp" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-telegram" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thermometer-4" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thermometer-3" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thermometer-2" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thermometer-1" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thermometer-0" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-shower" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bathtub" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-podcast" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-window-maximize" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-window-minimize" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-window-restore" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-times-rectangle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-times-rectangle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bandcamp" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-grav" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-etsy" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-imdb" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ravelry" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-eercast" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-microchip" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-snowflake-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-superpowers" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wpexplorer" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-meetup" aria-hidden="true"></i> </a>
</div>








]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>加密算法之java实现DES</title>
    <url>/2022/04/18/jia-mi-suan-fa-zhi-java-shi-xian-des/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>简介：</strong></p>
<p>数据加密算法（Data Encryption Algorithm，DEA）是一种对称加密算法，很可能是使用最广泛的密钥系统，特别是在保护金融数据的安全中，最初开发的DEA是嵌入硬件中的。通常，自动取款机（Automated Teller Machine，ATM）都使用DEA。它出自IBM的研究工作，IBM也曾对它拥有几年的专利权，但是在1983年已到期后，处于公有范围中，允许在特定条件下可以免除专利使用费而使用。1977年被美国政府正式采纳。</p>
<p>1998年后实用化DES破译机的出现彻底宣告DES算法已不具备安全性，1999年NIST颁布新标准，规定DES算法只能用于遗留加密系统，但不限制使用DESede算法。当今DES算法正是推出历史舞台，AES算法称为他的替代者。</p>
<p><strong>加密原理：</strong></p>
<p>DES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位，产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但 最后一个循环不交换。DES 使用 16 个循环，使用异或，置换，代换，移位操作四种基本运算。</p>
<p><strong>JDK对DES算法的支持</strong></p>
<p>密钥长度：56位</p>
<p>工作模式：ECB&#x2F;CBC&#x2F;PCBC&#x2F;CTR&#x2F;CTS&#x2F;CFB&#x2F;CFB8 to CFB128&#x2F;OFB&#x2F;OBF8 to OFB128</p>
<p>填充方式：Nopadding&#x2F;PKCS5Padding&#x2F;ISO10126Padding&#x2F;</p>
<p><strong>Java 加密解密之对称加密算法DESede</strong></p>
<p>DESede 即三重DES加密算法，也被称为3DES或者Triple DES。使用三(或两)个不同的密钥对数据块进行三次(或两次)DES加密(加密一次要比进行普通加密的三次要快)。三重DES的强度大约和112- bit的密钥强度相当。通过迭代次数的提高了安全性，但同时也造成了加密效率低的问题。正因DESede算法效率问题，AES算法诞生了。</p>
<p>到目前为止，还没有人给出攻击三重DES的有效方法。对其密钥空间中密钥进行蛮干搜索，那么由于空间太大，这实际上是不可行的。若用差分攻击的方法，相对于单一DES来说复杂性以指数形式增长。</p>
<p><strong>三重DES有四种模型</strong></p>
<ul>
<li>DES-EEE3，使用三个不同密钥，顺序进行三次加密变换。</li>
<li>DES-EDE3，使用三个不同密钥，依次进行加密-解密-加密变换。</li>
<li>DES-EEE2，其中密钥K1&#x3D;K3，顺序进行三次加密变换。</li>
<li>DES-EDE2， 其中密钥K1&#x3D;K3，依次进行加密-解密-加密变换。</li>
</ul>
<p><code>DESUtil</code>工具类</p>
<pre><code class="prettyprint">public final class DESUtil &#123;
    //自己定义
    public static String DES_KEY_VALUE = &quot;&quot;;
    private DESUtil() &#123;
    &#125;
    private final static String DES = &quot;DES&quot;;

    public static byte[] encrypt(byte[] src, byte[] key) throws Exception &#123;
        // DES算法要求有一个可信任的随机数源
        SecureRandom sr = new SecureRandom();
        // 从原始密匙数据创建DESKeySpec对象
        DESKeySpec dks = new DESKeySpec(key);
        // 创建一个密匙工厂，然后用它把DESKeySpec转换成一个SecretKey对象
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);
        SecretKey securekey = keyFactory.generateSecret(dks);
        // Cipher对象实际完成加密操作
        Cipher cipher = Cipher.getInstance(DES);
        // 用密匙初始化Cipher对象
        cipher.init(Cipher.ENCRYPT_MODE, securekey, sr);
        // 正式执行加密操作
        return cipher.doFinal(src);
    &#125;

    /**
     *
     * @param password 密码
     * @param key 加密字符串
     * @return
     */
    public final static String encrypt(String password, String key) &#123;
        try &#123;
            return byte2String(encrypt(password.getBytes(), key.getBytes()));
        &#125; catch (Exception e) &#123;
        &#125;
        return null;
    &#125;

    public static String byte2String(byte[] b) &#123;
        String hs = &quot;&quot;;
        String stmp = &quot;&quot;;
        for (int n = 0; n &lt; b.length; n++) &#123;
            stmp = (Integer.toHexString(b[n] &amp; 0XFF));
            if (stmp.length() == 1) &#123;
                hs = hs + &quot;0&quot; + stmp;
            &#125; else &#123;
                hs = hs + stmp;
            &#125;
        &#125;
        return hs.toUpperCase();
    &#125;

    /**
     *
     * @param src 数据源
     * @param key 密钥，长度必须是8的倍数
     * @return
     * @throws Exception
     */
    public static byte[] decrypt(byte[] src, byte[] key) throws Exception &#123;
        // DES算法要求有一个可信任的随机数源
        SecureRandom sr = new SecureRandom();
        // 从原始密匙数据创建一个DESKeySpec对象
        DESKeySpec dks = new DESKeySpec(key);
        // 创建一个密匙工厂，然后用它把DESKeySpec对象转换成一个SecretKey对象
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);
        SecretKey securekey = keyFactory.generateSecret(dks);
        // Cipher对象实际完成解密操作
        Cipher cipher = Cipher.getInstance(DES);
        // 用密匙初始化Cipher对象
        cipher.init(Cipher.DECRYPT_MODE, securekey, sr);

        // 正式执行解密操作
        return cipher.doFinal(src);
    &#125;

    public final static String decrypt(String data, String key) &#123;
        try &#123;
            return new String(decrypt(String2byte(data.getBytes()), key.getBytes()));
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;

    public static byte[] String2byte(byte[] b) &#123;
        if ((b.length % 2) != 0)&#123;
            throw new IllegalArgumentException(&quot;长度不是偶数&quot;);
        &#125;
        byte[] b2 = new byte[b.length / 2];
        for (int n = 0; n &lt; b.length; n += 2) &#123;
            String item = new String(b, n, 2);
            b2[n / 2] = (byte) Integer.parseInt(item, 16);
        &#125;
        return b2;
    &#125;
&#125;
</code></pre>
<p><code>DESUtilTest</code> 测试类</p>
<pre><code class="prettyprint">@Test
public void encodeAndDecode()&#123;
    //        String data = &quot;阿斯达斯&quot;;
    SecureRandom random = new SecureRandom();
    String data = String.valueOf(random.nextInt(50));
    data += &quot;123456789789456123&quot;;
    String secretKey = DESUtil.DES_KEY_VALUE;
    System.out.println(&quot;传输数据:&quot;+data);
    //加密
    String encrypte = DESUtil.encrypt(data, secretKey);
    System.out.println(&quot;加密后数据:&quot;+encrypte+&quot;，长度：&quot;+encrypte.length());
    //数据解密
    String decryptDatas = DESUtil.decrypt(encrypte, secretKey);
    System.out.println(&quot;解密后数据：&quot;+decryptDatas);
&#125;
</code></pre>
<p><a href="https://gitee.com/RocPengHua/crypto.git">gitee地址</a></p>
<p>转载：[Java实现DES加解密算法解析](<a href="http://www.zzvips.com/article/78986.html">Java实现DES加解密算法解析_JAVA教程_服务器之家 (zzvips.com)</a>)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle之base64</title>
    <url>/2022/04/19/oracle-zhi-base64/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>oracle:</p>
<pre><code class="prettyprint">select utl_raw.cast_to_varchar2(utl_encode.base64_encode(utl_raw.cast_to_raw(&#39;qwertyqwerty&#39;))) from dual;
select utl_raw.cast_to_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(&#39;cXdlcnR5cXdlcnR5&#39;))) from dual;

//hex
select rawtohex(utl_raw.cast_to_varchar2(utl_encode.base64_encode(utl_raw.cast_to_raw(&#39;130000000.56&#39;)))) from dual;
select utl_raw.cast_to_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(UTL_RAW.CAST_TO_varchar2(&#39;4D544D774D4441774D4441774C6A5532&#39;)))) from dual;
</code></pre>
<img src="/2022/04/19/oracle-zhi-base64/1650362471008.png" class="asset-class" width="1650362471008">

<p>java:</p>
<pre><code class="prettyprint">public class Base64Util &#123;
    public static String encode(String source) &#123;
        return Base64.encodeBase64String(StringUtils.getBytesUtf8(source));
    &#125;
    public static String decode(String target) &#123;
        return StringUtils.newStringUtf8(Base64.decodeBase64(target));
    &#125;
    public static String encrypt(String source) &#123;
        return HexUtil.getHexString(Base64.encodeBase64String(StringUtils.getBytesUtf8(source)).getBytes());
    &#125;
    public static String decrypt(String target) &#123;
        return StringUtils.newStringUtf8(Base64.decodeBase64(new String(HexUtil.hexStringToBytes(target))));
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>加密算法之java实现SM4简单版</title>
    <url>/2022/04/18/jia-mi-suan-fa-zhi-java-shi-xian-sm4-jian-dan-ban/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>HexUtil</code>字节字符转换工具</p>
<pre><code class="prettyprint">public class HexUtil
&#123;
    private static final char[] DIGITS_LOWER = &#123; &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; &#125;;

    private static final char[] DIGITS_UPPER = &#123; &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39; &#125;;

    public static byte[] intToBytes(int num)
    &#123;
        byte[] bytes = new byte[4];
        bytes[0] = (byte)(0xFF &amp; num &gt;&gt; 0);
        bytes[1] = (byte)(0xFF &amp; num &gt;&gt; 8);
        bytes[2] = (byte)(0xFF &amp; num &gt;&gt; 16);
        bytes[3] = (byte)(0xFF &amp; num &gt;&gt; 24);
        return bytes;
    &#125;

    public static int byteToInt(byte[] bytes)
    &#123;
        int num = 0;

        int temp = (0xFF &amp; bytes[0]) &lt;&lt; 0;
        num |= temp;
        temp = (0xFF &amp; bytes[1]) &lt;&lt; 8;
        num |= temp;
        temp = (0xFF &amp; bytes[2]) &lt;&lt; 16;
        num |= temp;
        temp = (0xFF &amp; bytes[3]) &lt;&lt; 24;
        num |= temp;
        return num;
    &#125;

    public static byte[] longToBytes(long num)
    &#123;
        byte[] bytes = new byte[8];
        for (int i = 0; i &lt; 8; i++) &#123;
            bytes[i] = (byte)(int)(0xFF &amp; num &gt;&gt; i * 8);
        &#125;

        return bytes;
    &#125;

    public static byte[] byteConvert32Bytes(BigInteger n)
    &#123;
        byte[] tmpd = (byte[])null;
        if (n == null) &#123;
            return null;
        &#125;

        if (n.toByteArray().length == 33) &#123;
            tmpd = new byte[32];
            System.arraycopy(n.toByteArray(), 1, tmpd, 0, 32);
        &#125; else if (n.toByteArray().length == 32) &#123;
            tmpd = n.toByteArray();
        &#125; else &#123;
            tmpd = new byte[32];
            for (int i = 0; i &lt; 32 - n.toByteArray().length; i++) &#123;
                tmpd[i] = 0;
            &#125;
            System.arraycopy(n.toByteArray(), 0, tmpd, 32 - n.toByteArray().length, n.toByteArray().length);
        &#125;
        return tmpd;
    &#125;

    public static BigInteger byteConvertInteger(byte[] b)
    &#123;
        if (b[0] &lt; 0) &#123;
            byte[] temp = new byte[b.length + 1];
            temp[0] = 0;
            System.arraycopy(b, 0, temp, 1, b.length);
            return new BigInteger(temp);
        &#125;
        return new BigInteger(b);
    &#125;

    public static String getHexString(byte[] bytes)
    &#123;
        return getHexString(bytes, true);
    &#125;

    public static String getHexString(byte[] bytes, boolean upperCase)
    &#123;
        String ret = &quot;&quot;;
        for (int i = 0; i &lt; bytes.length; i++) &#123;
            ret = ret + Integer.toString((bytes[i] &amp; 0xFF) + 256, 16).substring(1);
        &#125;
        return upperCase ? ret.toUpperCase() : ret;
    &#125;

    public static void printHexString(byte[] bytes)
    &#123;
        for (int i = 0; i &lt; bytes.length; i++) &#123;
            String hex = Integer.toHexString(bytes[i] &amp; 0xFF);
            if (hex.length() == 1)
                hex = &#39;0&#39; + hex;
        &#125;
    &#125;

    public static byte[] hexStringToBytes(String hexString)
    &#123;
        if ((hexString == null) || (hexString.equals(&quot;&quot;))) &#123;
            return null;
        &#125;

        hexString = hexString.toUpperCase();
        int length = hexString.length() / 2;
        char[] hexChars = hexString.toCharArray();
        byte[] d = new byte[length];
        for (int i = 0; i &lt; length; i++) &#123;
            int pos = i * 2;
            d[i] = (byte)(charToByte(hexChars[pos]) &lt;&lt; 4 | charToByte(hexChars[(pos + 1)]));
        &#125;
        return d;
    &#125;

    public static byte charToByte(char c)
    &#123;
        return (byte)&quot;0123456789ABCDEF&quot;.indexOf(c);
    &#125;

    public static char[] encodeHex(byte[] data)
    &#123;
        return encodeHex(data, true);
    &#125;

    public static char[] encodeHex(byte[] data, boolean toLowerCase)
    &#123;
        return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);
    &#125;

    protected static char[] encodeHex(byte[] data, char[] toDigits)
    &#123;
        int l = data.length;
        char[] out = new char[l &lt;&lt; 1];

        int i = 0; for (int j = 0; i &lt; l; i++) &#123;
        out[(j++)] = toDigits[((0xF0 &amp; data[i]) &gt;&gt;&gt; 4)];
        out[(j++)] = toDigits[(0xF &amp; data[i])];
    &#125;
        return out;
    &#125;

    public static String encodeHexString(byte[] data)
    &#123;
        return encodeHexString(data, true);
    &#125;

    public static String encodeHexString(byte[] data, boolean toLowerCase)
    &#123;
        return encodeHexString(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);
    &#125;

    protected static String encodeHexString(byte[] data, char[] toDigits)
    &#123;
        return new String(encodeHex(data, toDigits));
    &#125;

    public static byte[] decodeHex(char[] data)
    &#123;
        int len = data.length;

        if ((len &amp; 0x1) != 0) &#123;
            throw new RuntimeException(&quot;Odd number of characters.&quot;);
        &#125;

        byte[] out = new byte[len &gt;&gt; 1];

        int i = 0; for (int j = 0; j &lt; len; i++) &#123;
        int f = toDigit(data[j], j) &lt;&lt; 4;
        j++;
        f |= toDigit(data[j], j);
        j++;
        out[i] = (byte)(f &amp; 0xFF);
    &#125;

        return out;
    &#125;

    protected static int toDigit(char ch, int index)
    &#123;
        int digit = Character.digit(ch, 16);
        if (digit == -1) &#123;
            throw new RuntimeException(&quot;Illegal hexadecimal character &quot; + ch + &quot; at index &quot; + index);
        &#125;

        return digit;
    &#125;

    public static String StringToAsciiString(String content)
    &#123;
        String result = &quot;&quot;;
        int max = content.length();
        for (int i = 0; i &lt; max; i++) &#123;
            char c = content.charAt(i);
            String b = Integer.toHexString(c);
            result = result + b;
        &#125;
        return result;
    &#125;

    public static String hexStringToString(String hexString, int encodeType)
    &#123;
        String result = &quot;&quot;;
        int max = hexString.length() / encodeType;
        for (int i = 0; i &lt; max; i++) &#123;
            char c = (char)hexStringToAlgorism(hexString.substring(i * encodeType, (i + 1) * encodeType));

            result = result + c;
        &#125;
        return result;
    &#125;

    public static int hexStringToAlgorism(String hex)
    &#123;
        hex = hex.toUpperCase();
        int max = hex.length();
        int result = 0;
        for (int i = max; i &gt; 0; i--) &#123;
            char c = hex.charAt(i - 1);
            int algorism = 0;
            if ((c &gt;= &#39;0&#39;) &amp;&amp; (c &lt;= &#39;9&#39;))
                algorism = c - &#39;0&#39;;
            else &#123;
                algorism = c - &#39;7&#39;;
            &#125;
            result = (int)(result + Math.pow(16.0D, max - i) * algorism);
        &#125;
        return result;
    &#125;

    public static String hexStringToBinary(String hex)
    &#123;
        hex = hex.toUpperCase();
        String result = &quot;&quot;;
        int max = hex.length();
        for (int i = 0; i &lt; max; i++) &#123;
            char c = hex.charAt(i);
            switch (c) &#123;
                case &#39;0&#39;:
                    result = result + &quot;0000&quot;;
                    break;
                case &#39;1&#39;:
                    result = result + &quot;0001&quot;;
                    break;
                case &#39;2&#39;:
                    result = result + &quot;0010&quot;;
                    break;
                case &#39;3&#39;:
                    result = result + &quot;0011&quot;;
                    break;
                case &#39;4&#39;:
                    result = result + &quot;0100&quot;;
                    break;
                case &#39;5&#39;:
                    result = result + &quot;0101&quot;;
                    break;
                case &#39;6&#39;:
                    result = result + &quot;0110&quot;;
                    break;
                case &#39;7&#39;:
                    result = result + &quot;0111&quot;;
                    break;
                case &#39;8&#39;:
                    result = result + &quot;1000&quot;;
                    break;
                case &#39;9&#39;:
                    result = result + &quot;1001&quot;;
                    break;
                case &#39;A&#39;:
                    result = result + &quot;1010&quot;;
                    break;
                case &#39;B&#39;:
                    result = result + &quot;1011&quot;;
                    break;
                case &#39;C&#39;:
                    result = result + &quot;1100&quot;;
                    break;
                case &#39;D&#39;:
                    result = result + &quot;1101&quot;;
                    break;
                case &#39;E&#39;:
                    result = result + &quot;1110&quot;;
                    break;
                case &#39;F&#39;:
                    result = result + &quot;1111&quot;;
                case &#39;:&#39;:
                case &#39;;&#39;:
                case &#39;&lt;&#39;:
                case &#39;=&#39;:
                case &#39;&gt;&#39;:
                case &#39;?&#39;:
                case &#39;@&#39;: &#125;  &#125; return result;
    &#125;

    public static String AsciiStringToString(String content)
    &#123;
        String result = &quot;&quot;;
        int length = content.length() / 2;
        for (int i = 0; i &lt; length; i++) &#123;
            String c = content.substring(i * 2, i * 2 + 2);
            int a = hexStringToAlgorism(c);
            char b = (char)a;
            String d = String.valueOf(b);
            result = result + d;
        &#125;
        return result;
    &#125;

    public static String algorismToHexString(int algorism, int maxLength)
    &#123;
        String result = &quot;&quot;;
        result = Integer.toHexString(algorism);

        if (result.length() % 2 == 1) &#123;
            result = &quot;0&quot; + result;
        &#125;
        return patchHexString(result.toUpperCase(), maxLength);
    &#125;

    public static String byteToString(byte[] bytearray)
    &#123;
        String result = &quot;&quot;;

        int length = bytearray.length;
        for (int i = 0; i &lt; length; i++) &#123;
            char temp = (char)bytearray[i];
            result = result + temp;
        &#125;
        return result;
    &#125;

    public static int binaryToAlgorism(String binary)
    &#123;
        int max = binary.length();
        int result = 0;
        for (int i = max; i &gt; 0; i--) &#123;
            char c = binary.charAt(i - 1);
            int algorism = c - &#39;0&#39;;
            result = (int)(result + Math.pow(2.0D, max - i) * algorism);
        &#125;
        return result;
    &#125;

    public static String algorismToHEXString(int algorism)
    &#123;
        String result = &quot;&quot;;
        result = Integer.toHexString(algorism);

        if (result.length() % 2 == 1) &#123;
            result = &quot;0&quot; + result;
        &#125;

        result = result.toUpperCase();

        return result;
    &#125;

    public static String patchHexString(String str, int maxLength)
    &#123;
        String temp = &quot;&quot;;
        for (int i = 0; i &lt; maxLength - str.length(); i++) &#123;
            temp = &quot;0&quot; + temp;
        &#125;
        str = (temp + str).substring(0, maxLength);
        return str;
    &#125;

    public static int parseToInt(String s, int defaultInt, int radix)
    &#123;
        int i = 0;
        try &#123;
            i = Integer.parseInt(s, radix);
        &#125; catch (NumberFormatException ex) &#123;
            i = defaultInt;
        &#125;
        return i;
    &#125;

    public static int parseToInt(String s, int defaultInt)
    &#123;
        int i = 0;
        try &#123;
            i = Integer.parseInt(s);
        &#125; catch (NumberFormatException ex) &#123;
            i = defaultInt;
        &#125;
        return i;
    &#125;

    public static byte[] hexToByte(String hex)
            throws IllegalArgumentException
    &#123;
        if (hex.length() % 2 != 0) &#123;
            throw new IllegalArgumentException();
        &#125;
        char[] arr = hex.toCharArray();
        byte[] b = new byte[hex.length() / 2];
        int i = 0; int j = 0; for (int l = hex.length(); i &lt; l; j++) &#123;
        String swap = &quot;&quot; + arr[(i++)] + arr[i];
        int byteint = Integer.parseInt(swap, 16) &amp; 0xFF;
        b[j] = new Integer(byteint).byteValue();

        i++;
    &#125;

        return b;
    &#125;

    public static String byteToHex(byte[] b)
    &#123;
        if (b == null) &#123;
            throw new IllegalArgumentException(&quot;Argument b ( byte array ) is null! &quot;);
        &#125;

        String hs = &quot;&quot;;
        String stmp = &quot;&quot;;
        for (int n = 0; n &lt; b.length; n++) &#123;
            stmp = Integer.toHexString(b[n] &amp; 0xFF);
            if (stmp.length() == 1)
                hs = hs + &quot;0&quot; + stmp;
            else &#123;
                hs = hs + stmp;
            &#125;
        &#125;
        return hs.toUpperCase();
    &#125;

    public static byte[] subByte(byte[] input, int startIndex, int length) &#123;
        byte[] bt = new byte[length];
        for (int i = 0; i &lt; length; i++) &#123;
            bt[i] = input[(i + startIndex)];
        &#125;
        return bt;
    &#125;
&#125;
</code></pre>
<p><code>SM4Context</code></p>
<pre><code class="prettyprint">public class SM4Context &#123;

    public int mode = 1;
    public long[] sk = new long[32];
    public boolean isPadding = true;

    public SM4Context() &#123;
    &#125;
&#125;
</code></pre>
<p><code>SM4</code></p>
<pre><code class="prettyprint">public class SM4 &#123;
    public static final int SM4_ENCRYPT = 1;

    public static final int SM4_DECRYPT = 0;

    private long GET_ULONG_BE(byte[] b, int i) &#123;
        long n = (long) (b[i] &amp; 0xff) &lt;&lt; 24 | (long) ((b[i + 1] &amp; 0xff) &lt;&lt; 16) | (long) ((b[i + 2] &amp; 0xff) &lt;&lt; 8) | (long) (b[i + 3] &amp; 0xff) &amp; 0xffffffffL;
        return n;
    &#125;

    private void PUT_ULONG_BE(long n, byte[] b, int i) &#123;
        b[i] = (byte) (int) (0xFF &amp; n &gt;&gt; 24);
        b[i + 1] = (byte) (int) (0xFF &amp; n &gt;&gt; 16);
        b[i + 2] = (byte) (int) (0xFF &amp; n &gt;&gt; 8);
        b[i + 3] = (byte) (int) (0xFF &amp; n);
    &#125;

    private long SHL(long x, int n) &#123;
        return (x &amp; 0xFFFFFFFF) &lt;&lt; n;
    &#125;

    private long ROTL(long x, int n) &#123;
        return SHL(x, n) | x &gt;&gt; (32 - n);
    &#125;

    private void SWAP(long[] sk, int i) &#123;
        long t = sk[i];
        sk[i] = sk[(31 - i)];
        sk[(31 - i)] = t;
    &#125;

    public static final byte[] SboxTable = &#123;
            (byte) 0xd6, (byte) 0x90, (byte) 0xe9, (byte) 0xfe,
            (byte) 0xcc, (byte) 0xe1, 0x3d, (byte) 0xb7, 0x16, (byte) 0xb6,
            0x14, (byte) 0xc2, 0x28, (byte) 0xfb, 0x2c, 0x05, 0x2b, 0x67,
            (byte) 0x9a, 0x76, 0x2a, (byte) 0xbe, 0x04, (byte) 0xc3,
            (byte) 0xaa, 0x44, 0x13, 0x26, 0x49, (byte) 0x86, 0x06,
            (byte) 0x99, (byte) 0x9c, 0x42, 0x50, (byte) 0xf4, (byte) 0x91,
            (byte) 0xef, (byte) 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43,
            (byte) 0xed, (byte) 0xcf, (byte) 0xac, 0x62, (byte) 0xe4,
            (byte) 0xb3, 0x1c, (byte) 0xa9, (byte) 0xc9, 0x08, (byte) 0xe8,
            (byte) 0x95, (byte) 0x80, (byte) 0xdf, (byte) 0x94, (byte) 0xfa,
            0x75, (byte) 0x8f, 0x3f, (byte) 0xa6, 0x47, 0x07, (byte) 0xa7,
            (byte) 0xfc, (byte) 0xf3, 0x73, 0x17, (byte) 0xba, (byte) 0x83,
            0x59, 0x3c, 0x19, (byte) 0xe6, (byte) 0x85, 0x4f, (byte) 0xa8,
            0x68, 0x6b, (byte) 0x81, (byte) 0xb2, 0x71, 0x64, (byte) 0xda,
            (byte) 0x8b, (byte) 0xf8, (byte) 0xeb, 0x0f, 0x4b, 0x70, 0x56,
            (byte) 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, (byte) 0xd1,
            (byte) 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, (byte) 0x87,
            (byte) 0xd4, 0x00, 0x46, 0x57, (byte) 0x9f, (byte) 0xd3, 0x27,
            0x52, 0x4c, 0x36, 0x02, (byte) 0xe7, (byte) 0xa0, (byte) 0xc4,
            (byte) 0xc8, (byte) 0x9e, (byte) 0xea, (byte) 0xbf, (byte) 0x8a,
            (byte) 0xd2, 0x40, (byte) 0xc7, 0x38, (byte) 0xb5, (byte) 0xa3,
            (byte) 0xf7, (byte) 0xf2, (byte) 0xce, (byte) 0xf9, 0x61, 0x15,
            (byte) 0xa1, (byte) 0xe0, (byte) 0xae, 0x5d, (byte) 0xa4,
            (byte) 0x9b, 0x34, 0x1a, 0x55, (byte) 0xad, (byte) 0x93, 0x32,
            0x30, (byte) 0xf5, (byte) 0x8c, (byte) 0xb1, (byte) 0xe3, 0x1d,
            (byte) 0xf6, (byte) 0xe2, 0x2e, (byte) 0x82, 0x66, (byte) 0xca,
            0x60, (byte) 0xc0, 0x29, 0x23, (byte) 0xab, 0x0d, 0x53, 0x4e, 0x6f,
            (byte) 0xd5, (byte) 0xdb, 0x37, 0x45, (byte) 0xde, (byte) 0xfd,
            (byte) 0x8e, 0x2f, 0x03, (byte) 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b,
            0x51, (byte) 0x8d, 0x1b, (byte) 0xaf, (byte) 0x92, (byte) 0xbb,
            (byte) 0xdd, (byte) 0xbc, 0x7f, 0x11, (byte) 0xd9, 0x5c, 0x41,
            0x1f, 0x10, 0x5a, (byte) 0xd8, 0x0a, (byte) 0xc1, 0x31,
            (byte) 0x88, (byte) 0xa5, (byte) 0xcd, 0x7b, (byte) 0xbd, 0x2d,
            0x74, (byte) 0xd0, 0x12, (byte) 0xb8, (byte) 0xe5, (byte) 0xb4,
            (byte) 0xb0, (byte) 0x89, 0x69, (byte) 0x97, 0x4a, 0x0c,
            (byte) 0x96, 0x77, 0x7e, 0x65, (byte) 0xb9, (byte) 0xf1, 0x09,
            (byte) 0xc5, 0x6e, (byte) 0xc6, (byte) 0x84, 0x18, (byte) 0xf0,
            0x7d, (byte) 0xec, 0x3a, (byte) 0xdc, 0x4d, 0x20, 0x79,
            (byte) 0xee, 0x5f, 0x3e, (byte) 0xd7, (byte) 0xcb, 0x39, 0x48
    &#125;;

    public static final int[] FK = &#123;0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc&#125;;

    public static final int[] CK = &#123;0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,
            0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,
            0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,
            0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,
            0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,
            0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,
            0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,
            0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279&#125;;

    private byte sm4Sbox(byte inch) &#123;
        int i = inch &amp; 0xFF;
        byte retVal = SboxTable[i];
        return retVal;
    &#125;

    private long sm4Lt(long ka) &#123;
        long bb = 0L;
        long c = 0L;
        byte[] a = new byte[4];
        byte[] b = new byte[4];
        PUT_ULONG_BE(ka, a, 0);
        b[0] = sm4Sbox(a[0]);
        b[1] = sm4Sbox(a[1]);
        b[2] = sm4Sbox(a[2]);
        b[3] = sm4Sbox(a[3]);
        bb = GET_ULONG_BE(b, 0);
        c = bb ^ ROTL(bb, 2) ^ ROTL(bb, 10) ^ ROTL(bb, 18) ^ ROTL(bb, 24);
        return c;
    &#125;

    private long sm4F(long x0, long x1, long x2, long x3, long rk) &#123;
        return x0 ^ sm4Lt(x1 ^ x2 ^ x3 ^ rk);
    &#125;

    private long sm4CalciRK(long ka) &#123;
        long bb = 0L;
        long rk = 0L;
        byte[] a = new byte[4];
        byte[] b = new byte[4];
        PUT_ULONG_BE(ka, a, 0);
        b[0] = sm4Sbox(a[0]);
        b[1] = sm4Sbox(a[1]);
        b[2] = sm4Sbox(a[2]);
        b[3] = sm4Sbox(a[3]);
        bb = GET_ULONG_BE(b, 0);
        rk = bb ^ ROTL(bb, 13) ^ ROTL(bb, 23);
        return rk;
    &#125;

    private void sm4_setkey(long[] SK, byte[] key) &#123;
        long[] MK = new long[4];
        long[] k = new long[36];
        int i = 0;
        MK[0] = GET_ULONG_BE(key, 0);
        MK[1] = GET_ULONG_BE(key, 4);
        MK[2] = GET_ULONG_BE(key, 8);
        MK[3] = GET_ULONG_BE(key, 12);
        k[0] = MK[0] ^ (long) FK[0];
        k[1] = MK[1] ^ (long) FK[1];
        k[2] = MK[2] ^ (long) FK[2];
        k[3] = MK[3] ^ (long) FK[3];
        for (; i &lt; 32; i++) &#123;
            k[(i + 4)] = (k[i] ^ sm4CalciRK(k[(i + 1)] ^ k[(i + 2)] ^ k[(i + 3)] ^ (long) CK[i]));
            SK[i] = k[(i + 4)];
        &#125;
    &#125;

    private void sm4_one_round(long[] sk, byte[] input, byte[] output) &#123;
        int i = 0;
        long[] ulbuf = new long[36];
        ulbuf[0] = GET_ULONG_BE(input, 0);
        ulbuf[1] = GET_ULONG_BE(input, 4);
        ulbuf[2] = GET_ULONG_BE(input, 8);
        ulbuf[3] = GET_ULONG_BE(input, 12);
        while (i &lt; 32) &#123;
            ulbuf[(i + 4)] = sm4F(ulbuf[i], ulbuf[(i + 1)], ulbuf[(i + 2)], ulbuf[(i + 3)], sk[i]);
            i++;
        &#125;
        PUT_ULONG_BE(ulbuf[35], output, 0);
        PUT_ULONG_BE(ulbuf[34], output, 4);
        PUT_ULONG_BE(ulbuf[33], output, 8);
        PUT_ULONG_BE(ulbuf[32], output, 12);
    &#125;

    private byte[] padding(byte[] input, int mode) &#123;
        if (input == null) &#123;
            return null;
        &#125;

        byte[] ret = (byte[]) null;
        if (mode == SM4_ENCRYPT) &#123;
            int p = 16 - input.length % 16;
            ret = new byte[input.length + p];
            System.arraycopy(input, 0, ret, 0, input.length);
            for (int i = 0; i &lt; p; i++) &#123;
                ret[input.length + i] = (byte) p;
            &#125;
        &#125; else &#123;
            int p = input[input.length - 1];
            ret = new byte[input.length - p];
            System.arraycopy(input, 0, ret, 0, input.length - p);
        &#125;
        return ret;
    &#125;

    public void sm4_setkey_enc(SM4Context ctx, byte[] key) throws Exception &#123;
        if (ctx == null) &#123;
            throw new Exception(&quot;ctx is null!&quot;);
        &#125;

        if (key == null || (key.length != 16 &amp;&amp; key.length != 32)) &#123;
            throw new Exception(&quot;key error!&quot;);
        &#125;

        ctx.mode = SM4_ENCRYPT;
        sm4_setkey(ctx.sk, key);
    &#125;

    public void sm4_setkey_dec(SM4Context ctx, byte[] key) throws Exception &#123;
        if (ctx == null) &#123;
            throw new Exception(&quot;ctx is null!&quot;);
        &#125;

        if (key == null || (key.length != 16 &amp;&amp; key.length != 32)) &#123;
            throw new Exception(&quot;key error!&quot;);
        &#125;

        int i = 0;
        ctx.mode = SM4_DECRYPT;
        sm4_setkey(ctx.sk, key);
        for (i = 0; i &lt; 16; i++) &#123;
            SWAP(ctx.sk, i);
        &#125;
    &#125;

    public byte[] sm4_crypt_ecb(SM4Context ctx, byte[] input) throws Exception &#123;
        if (input == null) &#123;
            throw new Exception(&quot;input is null!&quot;);
        &#125;

        if ((ctx.isPadding) &amp;&amp; (ctx.mode == SM4_ENCRYPT)) &#123;
            input = padding(input, SM4_ENCRYPT);
        &#125;

        int length = input.length;
        ByteArrayInputStream bins = new ByteArrayInputStream(input);
        ByteArrayOutputStream bous = new ByteArrayOutputStream();
        for (; length &gt; 0; length -= 16) &#123;
            byte[] in = new byte[16];
            byte[] out = new byte[16];
            int read = bins.read(in);
            sm4_one_round(ctx.sk, in, out);
            bous.write(out);
        &#125;

        byte[] output = bous.toByteArray();
        if (ctx.isPadding &amp;&amp; ctx.mode == SM4_DECRYPT) &#123;
            output = padding(output, SM4_DECRYPT);
        &#125;
        bins.close();
        bous.close();
        return output;
    &#125;

    public byte[] sm4_crypt_cbc(SM4Context ctx, byte[] iv, byte[] input) throws Exception &#123;
        if (iv == null || (iv.length != 16 &amp;&amp; iv.length != 32)) &#123;
            throw new Exception(&quot;iv error!&quot;);
        &#125;

        if (input == null) &#123;
            throw new Exception(&quot;input is null!&quot;);
        &#125;

        if (ctx.isPadding &amp;&amp; ctx.mode == SM4_ENCRYPT) &#123;
            input = padding(input, SM4_ENCRYPT);
        &#125;

        int i = 0;
        int length = input.length;
        ByteArrayInputStream bins = new ByteArrayInputStream(input);
        ByteArrayOutputStream bous = new ByteArrayOutputStream();
        if (ctx.mode == SM4_ENCRYPT) &#123;
            for (; length &gt; 0; length -= 16) &#123;
                byte[] in = new byte[16];
                byte[] out = new byte[16];
                byte[] out1 = new byte[16];

                int read = bins.read(in);
                for (i = 0; i &lt; 16; i++) &#123;
                    out[i] = ((byte) (in[i] ^ iv[i]));
                &#125;
                sm4_one_round(ctx.sk, out, out1);
                System.arraycopy(out1, 0, iv, 0, 16);
                bous.write(out1);
            &#125;
        &#125; else &#123;
            byte[] temp = new byte[16];
            for (; length &gt; 0; length -= 16) &#123;
                byte[] in = new byte[16];
                byte[] out = new byte[16];
                byte[] out1 = new byte[16];

                int read = bins.read(in);
                System.arraycopy(in, 0, temp, 0, 16);
                sm4_one_round(ctx.sk, in, out);
                for (i = 0; i &lt; 16; i++) &#123;
                    out1[i] = ((byte) (out[i] ^ iv[i]));
                &#125;
                System.arraycopy(temp, 0, iv, 0, 16);
                bous.write(out1);
            &#125;
        &#125;

        byte[] output = bous.toByteArray();
        if (ctx.isPadding &amp;&amp; ctx.mode == SM4_DECRYPT) &#123;
            output = padding(output, SM4_DECRYPT);
        &#125;
        bins.close();
        bous.close();
        return output;
    &#125;
&#125;
</code></pre>
<p><code>SM4SimpleUtil</code>SM4工具类</p>
<pre><code class="prettyprint">public class SM4SimpleUtil extends HexUtil &#123;
    //自己定义
    public static String SM4_KEY_VALUE = &quot;&quot;;
    public static String encrypt(String plainText, String secretKey) &#123;
        try &#123;
            SM4Context ctx = new SM4Context();
            ctx.isPadding = true;
            ctx.mode = 1;
            byte[] keyBytes = null;
            if (secretKey.length() &lt; 32) &#123;
                keyBytes = hexToByte(getHexString(secretKey.getBytes()));
            &#125; else &#123;
                keyBytes = hexStringToBytes(secretKey);
            &#125;
            SM4 sm4 = new SM4();
            sm4.sm4_setkey_enc(ctx, keyBytes);
            byte[] encrypted = sm4.sm4_crypt_ecb(ctx, plainText.getBytes(&quot;UTF-8&quot;));
            return getHexString(encrypted);
        &#125; catch (Exception var8) &#123;
            var8.printStackTrace();
            return null;
        &#125;
    &#125;
    public static String decrypt(String cipherTextString, String secretKey) &#123;
        try &#123;
            SM4Context ctx = new SM4Context();
            ctx.isPadding = true;
            ctx.mode = 0;
            byte[] keyBytes = null;
            if (secretKey.length() &lt; 32) &#123;
                keyBytes = hexToByte(getHexString(secretKey.getBytes()));
            &#125; else &#123;
                keyBytes = hexStringToBytes(secretKey);
            &#125;
            byte[] cipherText = hexToByte(cipherTextString);
            SM4 sm4 = new SM4();
            sm4.sm4_setkey_dec(ctx, keyBytes);
            byte[] decrypted = sm4.sm4_crypt_ecb(ctx, cipherText);
            return new String(decrypted);
        &#125; catch (Exception var6) &#123;
            var6.printStackTrace();
            return null;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="prettyprint">public class SM4 &#123;
    public static final int SM4_ENCRYPT = 1;

    public static final int SM4_DECRYPT = 0;

    private long GET_ULONG_BE(byte[] b, int i) &#123;
        long n = (long) (b[i] &amp; 0xff) &lt;&lt; 24 | (long) ((b[i + 1] &amp; 0xff) &lt;&lt; 16) | (long) ((b[i + 2] &amp; 0xff) &lt;&lt; 8) | (long) (b[i + 3] &amp; 0xff) &amp; 0xffffffffL;
        return n;
    &#125;

    private void PUT_ULONG_BE(long n, byte[] b, int i) &#123;
        b[i] = (byte) (int) (0xFF &amp; n &gt;&gt; 24);
        b[i + 1] = (byte) (int) (0xFF &amp; n &gt;&gt; 16);
        b[i + 2] = (byte) (int) (0xFF &amp; n &gt;&gt; 8);
        b[i + 3] = (byte) (int) (0xFF &amp; n);
    &#125;

    private long SHL(long x, int n) &#123;
        return (x &amp; 0xFFFFFFFF) &lt;&lt; n;
    &#125;

    private long ROTL(long x, int n) &#123;
        return SHL(x, n) | x &gt;&gt; (32 - n);
    &#125;

    private void SWAP(long[] sk, int i) &#123;
        long t = sk[i];
        sk[i] = sk[(31 - i)];
        sk[(31 - i)] = t;
    &#125;

    public static final byte[] SboxTable = &#123;
            (byte) 0xd6, (byte) 0x90, (byte) 0xe9, (byte) 0xfe,
            (byte) 0xcc, (byte) 0xe1, 0x3d, (byte) 0xb7, 0x16, (byte) 0xb6,
            0x14, (byte) 0xc2, 0x28, (byte) 0xfb, 0x2c, 0x05, 0x2b, 0x67,
            (byte) 0x9a, 0x76, 0x2a, (byte) 0xbe, 0x04, (byte) 0xc3,
            (byte) 0xaa, 0x44, 0x13, 0x26, 0x49, (byte) 0x86, 0x06,
            (byte) 0x99, (byte) 0x9c, 0x42, 0x50, (byte) 0xf4, (byte) 0x91,
            (byte) 0xef, (byte) 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43,
            (byte) 0xed, (byte) 0xcf, (byte) 0xac, 0x62, (byte) 0xe4,
            (byte) 0xb3, 0x1c, (byte) 0xa9, (byte) 0xc9, 0x08, (byte) 0xe8,
            (byte) 0x95, (byte) 0x80, (byte) 0xdf, (byte) 0x94, (byte) 0xfa,
            0x75, (byte) 0x8f, 0x3f, (byte) 0xa6, 0x47, 0x07, (byte) 0xa7,
            (byte) 0xfc, (byte) 0xf3, 0x73, 0x17, (byte) 0xba, (byte) 0x83,
            0x59, 0x3c, 0x19, (byte) 0xe6, (byte) 0x85, 0x4f, (byte) 0xa8,
            0x68, 0x6b, (byte) 0x81, (byte) 0xb2, 0x71, 0x64, (byte) 0xda,
            (byte) 0x8b, (byte) 0xf8, (byte) 0xeb, 0x0f, 0x4b, 0x70, 0x56,
            (byte) 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, (byte) 0xd1,
            (byte) 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, (byte) 0x87,
            (byte) 0xd4, 0x00, 0x46, 0x57, (byte) 0x9f, (byte) 0xd3, 0x27,
            0x52, 0x4c, 0x36, 0x02, (byte) 0xe7, (byte) 0xa0, (byte) 0xc4,
            (byte) 0xc8, (byte) 0x9e, (byte) 0xea, (byte) 0xbf, (byte) 0x8a,
            (byte) 0xd2, 0x40, (byte) 0xc7, 0x38, (byte) 0xb5, (byte) 0xa3,
            (byte) 0xf7, (byte) 0xf2, (byte) 0xce, (byte) 0xf9, 0x61, 0x15,
            (byte) 0xa1, (byte) 0xe0, (byte) 0xae, 0x5d, (byte) 0xa4,
            (byte) 0x9b, 0x34, 0x1a, 0x55, (byte) 0xad, (byte) 0x93, 0x32,
            0x30, (byte) 0xf5, (byte) 0x8c, (byte) 0xb1, (byte) 0xe3, 0x1d,
            (byte) 0xf6, (byte) 0xe2, 0x2e, (byte) 0x82, 0x66, (byte) 0xca,
            0x60, (byte) 0xc0, 0x29, 0x23, (byte) 0xab, 0x0d, 0x53, 0x4e, 0x6f,
            (byte) 0xd5, (byte) 0xdb, 0x37, 0x45, (byte) 0xde, (byte) 0xfd,
            (byte) 0x8e, 0x2f, 0x03, (byte) 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b,
            0x51, (byte) 0x8d, 0x1b, (byte) 0xaf, (byte) 0x92, (byte) 0xbb,
            (byte) 0xdd, (byte) 0xbc, 0x7f, 0x11, (byte) 0xd9, 0x5c, 0x41,
            0x1f, 0x10, 0x5a, (byte) 0xd8, 0x0a, (byte) 0xc1, 0x31,
            (byte) 0x88, (byte) 0xa5, (byte) 0xcd, 0x7b, (byte) 0xbd, 0x2d,
            0x74, (byte) 0xd0, 0x12, (byte) 0xb8, (byte) 0xe5, (byte) 0xb4,
            (byte) 0xb0, (byte) 0x89, 0x69, (byte) 0x97, 0x4a, 0x0c,
            (byte) 0x96, 0x77, 0x7e, 0x65, (byte) 0xb9, (byte) 0xf1, 0x09,
            (byte) 0xc5, 0x6e, (byte) 0xc6, (byte) 0x84, 0x18, (byte) 0xf0,
            0x7d, (byte) 0xec, 0x3a, (byte) 0xdc, 0x4d, 0x20, 0x79,
            (byte) 0xee, 0x5f, 0x3e, (byte) 0xd7, (byte) 0xcb, 0x39, 0x48
    &#125;;

    public static final int[] FK = &#123;0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc&#125;;

    public static final int[] CK = &#123;0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,
            0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,
            0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,
            0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,
            0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,
            0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,
            0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,
            0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279&#125;;

    private byte sm4Sbox(byte inch) &#123;
        int i = inch &amp; 0xFF;
        byte retVal = SboxTable[i];
        return retVal;
    &#125;

    private long sm4Lt(long ka) &#123;
        long bb = 0L;
        long c = 0L;
        byte[] a = new byte[4];
        byte[] b = new byte[4];
        PUT_ULONG_BE(ka, a, 0);
        b[0] = sm4Sbox(a[0]);
        b[1] = sm4Sbox(a[1]);
        b[2] = sm4Sbox(a[2]);
        b[3] = sm4Sbox(a[3]);
        bb = GET_ULONG_BE(b, 0);
        c = bb ^ ROTL(bb, 2) ^ ROTL(bb, 10) ^ ROTL(bb, 18) ^ ROTL(bb, 24);
        return c;
    &#125;

    private long sm4F(long x0, long x1, long x2, long x3, long rk) &#123;
        return x0 ^ sm4Lt(x1 ^ x2 ^ x3 ^ rk);
    &#125;

    private long sm4CalciRK(long ka) &#123;
        long bb = 0L;
        long rk = 0L;
        byte[] a = new byte[4];
        byte[] b = new byte[4];
        PUT_ULONG_BE(ka, a, 0);
        b[0] = sm4Sbox(a[0]);
        b[1] = sm4Sbox(a[1]);
        b[2] = sm4Sbox(a[2]);
        b[3] = sm4Sbox(a[3]);
        bb = GET_ULONG_BE(b, 0);
        rk = bb ^ ROTL(bb, 13) ^ ROTL(bb, 23);
        return rk;
    &#125;

    private void sm4_setkey(long[] SK, byte[] key) &#123;
        long[] MK = new long[4];
        long[] k = new long[36];
        int i = 0;
        MK[0] = GET_ULONG_BE(key, 0);
        MK[1] = GET_ULONG_BE(key, 4);
        MK[2] = GET_ULONG_BE(key, 8);
        MK[3] = GET_ULONG_BE(key, 12);
        k[0] = MK[0] ^ (long) FK[0];
        k[1] = MK[1] ^ (long) FK[1];
        k[2] = MK[2] ^ (long) FK[2];
        k[3] = MK[3] ^ (long) FK[3];
        for (; i &lt; 32; i++) &#123;
            k[(i + 4)] = (k[i] ^ sm4CalciRK(k[(i + 1)] ^ k[(i + 2)] ^ k[(i + 3)] ^ (long) CK[i]));
            SK[i] = k[(i + 4)];
        &#125;
    &#125;

    private void sm4_one_round(long[] sk, byte[] input, byte[] output) &#123;
        int i = 0;
        long[] ulbuf = new long[36];
        ulbuf[0] = GET_ULONG_BE(input, 0);
        ulbuf[1] = GET_ULONG_BE(input, 4);
        ulbuf[2] = GET_ULONG_BE(input, 8);
        ulbuf[3] = GET_ULONG_BE(input, 12);
        while (i &lt; 32) &#123;
            ulbuf[(i + 4)] = sm4F(ulbuf[i], ulbuf[(i + 1)], ulbuf[(i + 2)], ulbuf[(i + 3)], sk[i]);
            i++;
        &#125;
        PUT_ULONG_BE(ulbuf[35], output, 0);
        PUT_ULONG_BE(ulbuf[34], output, 4);
        PUT_ULONG_BE(ulbuf[33], output, 8);
        PUT_ULONG_BE(ulbuf[32], output, 12);
    &#125;

    private byte[] padding(byte[] input, int mode) &#123;
        if (input == null) &#123;
            return null;
        &#125;

        byte[] ret = (byte[]) null;
        if (mode == SM4_ENCRYPT) &#123;
            int p = 16 - input.length % 16;
            ret = new byte[input.length + p];
            System.arraycopy(input, 0, ret, 0, input.length);
            for (int i = 0; i &lt; p; i++) &#123;
                ret[input.length + i] = (byte) p;
            &#125;
        &#125; else &#123;
            int p = input[input.length - 1];
            ret = new byte[input.length - p];
            System.arraycopy(input, 0, ret, 0, input.length - p);
        &#125;
        return ret;
    &#125;

    public void sm4_setkey_enc(SM4Context ctx, byte[] key) throws Exception &#123;
        if (ctx == null) &#123;
            throw new Exception(&quot;ctx is null!&quot;);
        &#125;

        if (key == null || (key.length != 16 &amp;&amp; key.length != 32)) &#123;
            throw new Exception(&quot;key error!&quot;);
        &#125;

        ctx.mode = SM4_ENCRYPT;
        sm4_setkey(ctx.sk, key);
    &#125;

    public void sm4_setkey_dec(SM4Context ctx, byte[] key) throws Exception &#123;
        if (ctx == null) &#123;
            throw new Exception(&quot;ctx is null!&quot;);
        &#125;

        if (key == null || (key.length != 16 &amp;&amp; key.length != 32)) &#123;
            throw new Exception(&quot;key error!&quot;);
        &#125;

        int i = 0;
        ctx.mode = SM4_DECRYPT;
        sm4_setkey(ctx.sk, key);
        for (i = 0; i &lt; 16; i++) &#123;
            SWAP(ctx.sk, i);
        &#125;
    &#125;

    public byte[] sm4_crypt_ecb(SM4Context ctx, byte[] input) throws Exception &#123;
        if (input == null) &#123;
            throw new Exception(&quot;input is null!&quot;);
        &#125;

        if ((ctx.isPadding) &amp;&amp; (ctx.mode == SM4_ENCRYPT)) &#123;
            input = padding(input, SM4_ENCRYPT);
        &#125;

        int length = input.length;
        ByteArrayInputStream bins = new ByteArrayInputStream(input);
        ByteArrayOutputStream bous = new ByteArrayOutputStream();
        for (; length &gt; 0; length -= 16) &#123;
            byte[] in = new byte[16];
            byte[] out = new byte[16];
            int read = bins.read(in);
            sm4_one_round(ctx.sk, in, out);
            bous.write(out);
        &#125;

        byte[] output = bous.toByteArray();
        if (ctx.isPadding &amp;&amp; ctx.mode == SM4_DECRYPT) &#123;
            output = padding(output, SM4_DECRYPT);
        &#125;
        bins.close();
        bous.close();
        return output;
    &#125;

    public byte[] sm4_crypt_cbc(SM4Context ctx, byte[] iv, byte[] input) throws Exception &#123;
        if (iv == null || (iv.length != 16 &amp;&amp; iv.length != 32)) &#123;
            throw new Exception(&quot;iv error!&quot;);
        &#125;

        if (input == null) &#123;
            throw new Exception(&quot;input is null!&quot;);
        &#125;

        if (ctx.isPadding &amp;&amp; ctx.mode == SM4_ENCRYPT) &#123;
            input = padding(input, SM4_ENCRYPT);
        &#125;

        int i = 0;
        int length = input.length;
        ByteArrayInputStream bins = new ByteArrayInputStream(input);
        ByteArrayOutputStream bous = new ByteArrayOutputStream();
        if (ctx.mode == SM4_ENCRYPT) &#123;
            for (; length &gt; 0; length -= 16) &#123;
                byte[] in = new byte[16];
                byte[] out = new byte[16];
                byte[] out1 = new byte[16];

                int read = bins.read(in);
                for (i = 0; i &lt; 16; i++) &#123;
                    out[i] = ((byte) (in[i] ^ iv[i]));
                &#125;
                sm4_one_round(ctx.sk, out, out1);
                System.arraycopy(out1, 0, iv, 0, 16);
                bous.write(out1);
            &#125;
        &#125; else &#123;
            byte[] temp = new byte[16];
            for (; length &gt; 0; length -= 16) &#123;
                byte[] in = new byte[16];
                byte[] out = new byte[16];
                byte[] out1 = new byte[16];

                int read = bins.read(in);
                System.arraycopy(in, 0, temp, 0, 16);
                sm4_one_round(ctx.sk, in, out);
                for (i = 0; i &lt; 16; i++) &#123;
                    out1[i] = ((byte) (out[i] ^ iv[i]));
                &#125;
                System.arraycopy(temp, 0, iv, 0, 16);
                bous.write(out1);
            &#125;
        &#125;

        byte[] output = bous.toByteArray();
        if (ctx.isPadding &amp;&amp; ctx.mode == SM4_DECRYPT) &#123;
            output = padding(output, SM4_DECRYPT);
        &#125;
        bins.close();
        bous.close();
        return output;
    &#125;
&#125;
</code></pre>
<p>测试调用</p>
<pre><code class="prettyprint">@Test
    public void encodeAndDecode()&#123;
        //        String data = &quot;阿斯达斯&quot;;
        SecureRandom random = new SecureRandom();
        String data = String.valueOf(random.nextInt(50));
        data += &quot;123456789789456123&quot;;
        String secretKey = SM4SimpleUtil.SM4_KEY_VALUE;
        System.out.println(&quot;传输数据:&quot;+data);
        //加密
        String encrypte = SM4SimpleUtil.encrypt(data, secretKey);
        System.out.println(encrypte+&quot;，长度：&quot;+encrypte.length());
        //数据解密
        String decryptDatas = SM4SimpleUtil.decrypt(encrypte, secretKey);
        System.out.println(decryptDatas);
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle函数实现des算法</title>
    <url>/2022/04/19/oracle-han-shu-shi-xian-des-suan-fa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>oracle函数实现des算法（CBC模式:hex&#x2F;base64）</p>
<p>加密<code>encrypt_des</code></p>
<pre><code class="prettyprint">create or replace function encrypt_des(p_text varchar2,p_key varchar2) return varchar2 is
  v_text        varchar2(4000);
    v_enc         varchar2(4000);
    raw_input     RAW(128);
    key_input     RAW(128);
    decrypted_raw RAW(2048);
  begin
    v_text    := rpad(p_text, (trunc(length(p_text) / 8) + 1) * 8, chr(0));
    raw_input := UTL_RAW.CAST_TO_RAW(v_text);
    key_input := UTL_RAW.CAST_TO_RAW(p_key);
    dbms_obfuscation_toolkit.DESEncrypt(input          =&gt; raw_input,
                                        key            =&gt; key_input,
                                        encrypted_data =&gt; decrypted_raw);
    /*hex转字符输出
    v_enc := rawtohex(decrypted_raw);*/
    /*转base64*/
    select utl_raw.cast_to_varchar2(utl_encode.base64_encode(decrypted_raw)) into v_enc from dual;
    dbms_output.put_line(v_enc);
    return v_enc;
end encrypt_des;
</code></pre>
<p>解密<code>decrypt_des</code></p>
<pre><code class="prettyprint">create or replace function decrypt_des(p_text varchar2, p_key varchar2) return varchar2 is
  v_text varchar2(2000);
  begin
    /*hex转字符输出
    dbms_obfuscation_toolkit.DESDECRYPT(input_string     =&gt; UTL_RAW.CAST_TO_varchar2(p_text),
                                        key_string       =&gt; p_key,
                                        decrypted_string =&gt; v_text);
                                        */
    /*base64转字符输出*/
    dbms_obfuscation_toolkit.DESDECRYPT(input_string     =&gt; UTL_RAW.CAST_TO_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(p_text))),
                                        key_string       =&gt; p_key,
                                        decrypted_string =&gt; v_text);
                                        
    v_text := rtrim(v_text, chr(0));
    dbms_output.put_line(v_text);
    return v_text;
end decrypt_des;
</code></pre>
<p>hex:</p>
<img src="/2022/04/19/oracle-han-shu-shi-xian-des-suan-fa/1650360630842.png" class="asset-class" width="1650360630842">





<img src="/2022/04/19/oracle-han-shu-shi-xian-des-suan-fa/1650360647718.png" class="asset-class" width="1650360647718">

<p>base64:</p>
<img src="/2022/04/19/oracle-han-shu-shi-xian-des-suan-fa/1650361954868.png" class="asset-class" width="1650361954868">

<img src="/2022/04/19/oracle-han-shu-shi-xian-des-suan-fa/1650361965256.png" class="asset-class" width="1650361965256">

<p>java版本</p>
<pre><code class="prettyprint">public class OracleDesUtil &#123;
    private OracleDesUtil() &#123;
    &#125;
    public static String DES_KEY_VALUE = &quot;QAZXSW!@#123654*&quot;;
    private final static String DES = &quot;DES&quot;;
    private final static String CIPHER_DES = &quot;DES/CBC/NoPadding&quot;;

    /**
     *
     * @param data 数据
     * @param key 密钥
     * @return
     */
    public static String encrypt(String data, String key) &#123;
        try &#123;
            DESKeySpec desKey = new DESKeySpec(key.getBytes());
            SecretKey securekey = SecretKeyFactory.getInstance(DES).generateSecret(desKey);

            Cipher cipher = Cipher.getInstance(CIPHER_DES);
            cipher.init(Cipher.ENCRYPT_MODE, securekey, new IvParameterSpec(new byte[8]));

            byte[] inBytes = new byte[((int) (data.length() / 8) + 1) * 8];
            for (int i = 0; i &lt; data.length(); i++) &#123;
                inBytes[i] = data.getBytes()[i];
            &#125;

            byte[] enBytes = cipher.doFinal(inBytes);
            //base64
            //return Base64.encodeBase64String(enBytes);
            //hex
            return HexUtil.getHexString(enBytes);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;


    public static String decrypt(String data, String key) &#123;
        try &#123;
            DESKeySpec desKey = new DESKeySpec(key.getBytes());
            SecretKey secretKey = SecretKeyFactory.getInstance(DES).generateSecret(desKey);

            Cipher cipher = Cipher.getInstance(CIPHER_DES);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(new byte[8]));
            //base64
            //byte[]decryptBytes = cipher.doFinal(Base64.decodeBase64(data));
            //hex
            byte[]decryptBytes = cipher.doFinal(HexUtil.hexStringToBytes(data));

            return new String(decryptBytes);
        &#125;
        catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;

&#125;
</code></pre>
<img src="/2022/04/19/oracle-han-shu-shi-xian-des-suan-fa/1650360699530.png" class="asset-class" width="1650360699530">

<img src="/2022/04/19/oracle-han-shu-shi-xian-des-suan-fa/1650362060815.png" class="asset-class" width="1650362060815">

<p>转载:<a href="https://www.jianshu.com/p/332e13a49b6b">Oracle DES加密、Java 解密</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>记录执行时间工具类</title>
    <url>/2022/04/19/ji-lu-zhi-xing-shi-jian-gong-ju-lei/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code class="prettyprint">public class TimeTool &#123;
    private static final SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss:SSS&quot;);
    public interface Task&#123;
        void execute() throws Exception;
    &#125;
    public static void check(String title,Task task) throws Exception &#123;
        if(task == null)&#123;
            return;
        &#125;
        title = (title == null) ? &quot;&quot;:(&quot;【&quot;+title+&quot;】&quot;);
        System.out.println(title);
        System.out.println(&quot;开始：&quot; + sdf.format(new Date()));
        long begin = System.currentTimeMillis();
        task.execute();
        long end = System.currentTimeMillis();
        System.out.println(&quot;结束：&quot;+sdf.format(new Date()));
        long delta = (end - begin);
        System.out.println(&quot;耗时-----&quot;+delta+&quot;----毫秒&quot;);
        System.out.println(&quot;-----------------------&quot;);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>jmeter启动报错</title>
    <url>/2022/04/21/jmeter-qi-dong-bao-cuo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>jmeter-5.4启动时报错 could not create JAVA … </p>
<p>无法创建jvm,配置本地环境变量问题 jdk安装64位的</p>
<p><a href="https://dlcdn.apache.org//jmeter/binaries/apache-jmeter-5.4.3.zip">https://dlcdn.apache.org//jmeter/binaries/apache-jmeter-5.4.3.zip</a></p>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
  </entry>
  <entry>
    <title>centos7手动安装rocketmq</title>
    <url>/2022/04/23/centos7-shou-dong-an-zhuang-rocketmq/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="download"><a href="#download" class="headerlink" title="download"></a>download</h2><p><a href="https://dlcdn.apache.org/rocketmq/4.9.3/rocketmq-all-4.9.3-bin-release.zip">https://dlcdn.apache.org/rocketmq/4.9.3/rocketmq-all-4.9.3-bin-release.zip</a></p>
<h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul>
<li><p>linux64位系统</p>
</li>
<li><p>jdk1.8(64位)</p>
</li>
<li><p>源码安装需要maven3.2</p>
</li>
</ul>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="解压安装"><a href="#解压安装" class="headerlink" title="解压安装"></a>解压安装</h3><pre><code class="prettyprint">unzip rocketmq-all-4.9.3-bin-release.zip -d /usr/local/mq
cd /usr/local/mq
mv rocketmq-all-4.9.3-bin-release rocketmq
</code></pre>
<h3 id="创建文件存储文件夹"><a href="#创建文件存储文件夹" class="headerlink" title="创建文件存储文件夹"></a>创建文件存储文件夹</h3><pre><code class="prettyprint">mkdir /opt/module/rocketmq/logs
mkdir /opt/module/rocketmq/store
mkdir /opt/module/rocketmq/store/commitlog
mkdir /opt/module/rocketmq/store/consumequeue
mkdir /opt/module/rocketmq/store/index
</code></pre>
<h3 id="单机模式配置"><a href="#单机模式配置" class="headerlink" title="单机模式配置"></a>单机模式配置</h3><pre><code class="prettyprint"># 配置properties
cd rocketmq/conf/
# 2m-2s-async:2主2从异步
# 2m-2s-sync:2主2从同步
# 2m-noslaves:2主没有从
vim 2m-2s-async/brock.a.properties
</code></pre>
<img src="/2022/04/23/centos7-shou-dong-an-zhuang-rocketmq/image-20220423210803203.png" class="asset-class" title="image-20220423210803203">

<img src="/2022/04/23/centos7-shou-dong-an-zhuang-rocketmq/image-20220423210729592.png" class="asset-class" title="image-20220423210729592">

<h3 id="brock-a-properties配置内容"><a href="#brock-a-properties配置内容" class="headerlink" title="brock.a.properties配置内容"></a><code>brock.a.properties</code>配置内容</h3><pre><code class="prettyprint">#所属集群名字
brokerClusterName=rocketmq-cluster
#broker名字，注意此处不同的配置文件填写的不一样
brokerName=broker-a
#0 表示 Master，&gt;0 表示 Slave
brokername=0
#nameServer地址，分号分割 ---在hosts里面配置rocketmq-nameserver1  /etc/hosts
namesrvAddr=rocketmq-nameserver1:9876
#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数
defaultTopicQueueNums=4
#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭
autoCreateTopicEnable=true
#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭
autoCreateSubscriptionGroup=true
#Broker 对外服务的监听端口
listenPort=10911
#删除文件时间点，默认凌晨 4点
deleteWhen=04
#文件保留时间，默认 48 小时
fileReservedTime=120
#commitLog每个文件的大小默认1G
mapedFileSizeCommitLog=1073741824
#ConsumeQueue每个文件默认存30W条，根据业务情况调整
mapedFileSizeConsumeQueue=300000
#destroyMapedFileIntervalForcibly=120000
#redeleteHangedFileInterval=120000
#检测物理文件磁盘空间
diskMaxUsedSpaceRatio=88
#存储路径
storePathRootDir=/opt/module/rocketmq/store
#commitLog 存储路径
storePathCommitLog=/opt/module/rocketmq/store/commitlog
#消费队列存储路径存储路径
storePathConsumeQueue=/opt/module/rocketmq/store/comsumequeue
#消息索引存储路径
storePathIndex=/opt/module/rocketmq/store/index
#checkpoint 文件存储路径
storeCheckpoint=/opt/module/rocketmq/store/checkpoint
#abort 文件存储路径
abortFile=/opt/module/rocketmq/store/abort
#限制的消息大小
maxMessageSize=65536
#flushCommitLogLeastPages=4
#flushConsumeQueueLeastPages=2
#flushCommitLogThoroughInterval=10000
#flushConsumeQueueThoroughInterval=60000
#Broker 的角色
#- ASYNC_MASTER 异步复制Master
#- SYNC_MASTER 同步双写Master
#- SLAVE
brokerRole=ASYNC_MASTER
#刷盘方式
#- ASYNC_FLUSH 异步刷盘
#- SYNC_FLUSH 同步刷盘
flushDiskType=ASYNC_FLUSH
#checkTransactionMessageEnable=false
#发消息线程池数量
#sendMessageThreadPoolNums=128
#拉消息线程池数量
#pullMessageThreadPoolNums=128
</code></pre>
<h3 id="修改xml的文件路径"><a href="#修改xml的文件路径" class="headerlink" title="修改xml的文件路径"></a>修改xml的文件路径</h3><pre><code class="prettyprint">sed -i &#39;s#$&#123;user.home&#125;#/opt/module/rocketmq#g&#39; *.xml
</code></pre>
<p>注意：sed -i在这里起批量的作用</p>
<pre><code class="prettyprint">sed -i &#39;s#原字符#新字符#g&#39; 替换的文件
</code></pre>
<h3 id="修改启动脚本配置"><a href="#修改启动脚本配置" class="headerlink" title="修改启动脚本配置"></a>修改启动脚本配置</h3><p><code>/opt/module/rocketmq/bin/runbroker.sh</code></p>
<pre><code class="prettyprint">#改之前
JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms8g -Xmx8g&quot;
#改之后
JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g&quot;
</code></pre>
<p><code>/opt/module/rocketmq/bin/runserver.sh</code></p>
<pre><code class="prettyprint">#改之前
JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;
#改之后
JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;
</code></pre>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code class="prettyprint">cd /opt/module/rocketmq/bin
# 启动server
sh mqnamersrv &amp;
#启动brocker 指定文件路径(前面配置的文件)
sh mqbrocker -c ../conf/2m-2s-async/brock.a.properties &amp;
</code></pre>
<h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><pre><code class="prettyprint">cd /opt/module/rocketmq/bin
# 停止broker
sh mqshutdown broker
#停止namesrv
sh mqshutdown namesrv
</code></pre>
<h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><pre><code class="prettyprint"># 查看nameServer日志
tail -500f /opt/module/rabbitmq/logs/rocketmqlogs/namesrv.log
# 查看broker日志
tail -500f /opt/module/rabbitmq/logs/rocketmqlogs/broker.log
</code></pre>
<h2 id="监控程序"><a href="#监控程序" class="headerlink" title="监控程序"></a>监控程序</h2><h3 id="下载rocketmq-console"><a href="#下载rocketmq-console" class="headerlink" title="下载rocketmq-console"></a>下载<code>rocketmq-console</code></h3><p><a href="https://github.com/apache/rocketmq-externals">https://github.com/apache/rocketmq-externals</a></p>
<p><code>git clone -b release-rocketmq-console-1.0.0 https://github.com/apache/rocketmq-externals</code></p>
<p>修改配置文件rocketmq.config.namesrvAddr&#x3D;192.168.101.123:9876</p>
<p>然后打包启动</p>
<p>访问<a href="http://localhost:8080/">http://localhost:8080</a></p>
<img src="/2022/04/23/centos7-shou-dong-an-zhuang-rocketmq/image-20220423212702216.png" class="asset-class" title="image-20220423212702216">

]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>中文锚点跳转问题修复</title>
    <url>/2022/04/24/zhong-wen-mao-dian-tiao-zhuan-wen-ti-xiu-fu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>在content.ejs下增加脚本，将h标签的id调用<code>encodeURIComponent</code>使得和toc生成的锚点对应</li>
</ul>
<pre><code class="prettyprint">&lt;script&gt;
    //解决中文转义无法跳转锚点问题
    var blog = document.querySelector(&quot;#blog-content&quot;);
    var content = blog.innerHTML;
    var regExp2 = /&lt;h([1-6]) id=\&quot;(\S*?)\&quot;&gt;/g;
    var	data = content.replace(regExp2, function(word,i)&#123;
        var ws = word.split(&quot;\&quot;&quot;);
            return ws[0]+&quot;\&quot;&quot;+encodeURIComponent(ws[1])+&quot;\&quot;&quot;+ws[2];
        &#125;,&quot;g&quot;);
    blog.innerHTML = data;
&lt;/script&gt;
</code></pre>
<p>hexo无法在powershell使用</p>
<pre><code class="prettyprint">Set-ExecutionPolicy -ExecutionPolicy UNRESTRICTED
</code></pre>
<h3 id="这是标题一"><a href="#这是标题一" class="headerlink" title="这是标题一"></a>这是标题一</h3><img src="/2022/04/24/zhong-wen-mao-dian-tiao-zhuan-wen-ti-xiu-fu/image-20220528141523254.png" class="asset-class" title="image-20220528141523254">

<center class="half">
    <img src="/2022/04/24/zhong-wen-mao-dian-tiao-zhuan-wen-ti-xiu-fu/image-20220528141523254.png" class="asset-class" width="300" height="200" title="image-20220528141523254.png">
    <img src="/2022/04/24/zhong-wen-mao-dian-tiao-zhuan-wen-ti-xiu-fu/image-20220528141523254.png" class="asset-class" width="300" height="200" title="image-20220528141523254.png">
</center>

<h4 id="这是标题一一"><a href="#这是标题一一" class="headerlink" title="这是标题一一"></a>这是标题一一</h4><pre><code># msi文件权限不够
# 以管理员命令启动cmd
# 进入msi所在目录
# 执行脚本   msiexec /package xxxx.msi
#
#
#
#
</code></pre>
<h3 id="这是标题二"><a href="#这是标题二" class="headerlink" title="这是标题二"></a>这是标题二</h3><h4 id="这是标题二二"><a href="#这是标题二二" class="headerlink" title="这是标题二二"></a>这是标题二二</h4><pre><code>#
#
#
#
#
#
#
</code></pre>
<h3 id="这是标题三"><a href="#这是标题三" class="headerlink" title="这是标题三"></a>这是标题三</h3><h4 id="这是标题三三"><a href="#这是标题三三" class="headerlink" title="这是标题三三"></a>这是标题三三</h4><pre><code>#
#
#
#
#
#
#
</code></pre>
<h3 id="这是标题四"><a href="#这是标题四" class="headerlink" title="这是标题四"></a>这是标题四</h3><h4 id="这是标题四四"><a href="#这是标题四四" class="headerlink" title="这是标题四四"></a>这是标题四四</h4><pre><code>#
#
#
#
#
#
#
</code></pre>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq之Batch模式</title>
    <url>/2022/04/25/rocketmq-zhi-batch-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;
    &lt;version&gt;4.9.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.producer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.springframework.stereotype.Component;

/**
 * @author 
 * @date 2021/10/20.
 */
@Slf4j
@Component
public class Producer &#123;
    private String producerGroup = &quot;please_rename_unique_group_name&quot;;
    private DefaultMQProducer producer;

    public Producer()&#123;
        //示例生产者
        producer = new DefaultMQProducer(producerGroup);
        //不开启vip通道 开通口端口会减2
        producer.setVipChannelEnabled(false);
        //绑定name server
        producer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        start();
    &#125;
    /**
     * 对象在使用之前必须要调用一次，只能初始化一次
     */
    public void start()&#123;
        try &#123;
            this.producer.start();
        &#125; catch (MQClientException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public DefaultMQProducer getProducer()&#123;
        return this.producer;
    &#125;
    /**
     * 一般在应用上下文，使用上下文监听器，进行关闭
     */
    public void shutdown()&#123;
        this.producer.shutdown();
    &#125;
&#125;
</code></pre>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.consumer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;

/**
 * @author 
 * @date 2021/10/20.
 */
@Slf4j
@Component
public class BatchConsumer &#123;

    /**
     * 消费者实体对象
     */
    private DefaultMQPushConsumer consumer;
    /**
     * 主题名称 主题一般是服务器设置好 而不能在代码里去新建topic（ 如果没有创建好，生产者往该主题发送消息 会报找不到topic错误）
     */
    public static final String TOPIC = &quot;TOPIC_BATCH_CONSUMER&quot;;
    /**
     * 消费者组
     */
    public static final String CONSUMER_GROUP = &quot;batch_group_name&quot;;
    /**
     * 通过构造函数 实例化对象
     */
    public BatchConsumer() throws MQClientException &#123;

        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
        consumer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        //消费模式:一个新的订阅组第一次启动从队列的最后位置开始消费 后续再启动接着上次消费的进度开始消费
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);
        //订阅主题和 标签（ * 代表所有标签)下信息
        consumer.subscribe(TOPIC, &quot;*&quot;);
        // //注册消费的监听 并在此监听中消费信息，并返回消费的状态信息
        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;
            // msgs中只收集同一个topic，同一个tag，并且key相同的message
            // 会把不同的消息分别放置到不同的队列中
            try &#123;
                for (Message msg : msgs) &#123;

                    //消费者获取消息 这里只输出 不做后面逻辑处理
                    String body = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);
                    log.info(&quot;Batch-Consumer-获取消息-主题topic为=&#123;&#125;, 消费消息为=&#123;&#125;&quot;, msg.getTopic(), body);
                &#125;
            &#125; catch (UnsupportedEncodingException e) &#123;
                e.printStackTrace();
                return ConsumeConcurrentlyStatus.RECONSUME_LATER;
            &#125;
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        &#125;);

        consumer.start();
        System.out.println(&quot;BatchConsumer消费者 启动成功=======&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.web;

import com.pengpeng.rocketmq.consumer.BatchConsumer;
import com.pengpeng.rocketmq.consumer.Consumer;
import com.pengpeng.rocketmq.producer.Producer;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.List;

/**
 * Describe:
 * Created by AlexP on 2022/4/25.
 */
@Slf4j
@RestController
@RequestMapping(&quot;/batch&quot;)
public class BatchController &#123;
    @Autowired
    private Producer producer;

    @RequestMapping(&quot;/batchProducer&quot;)
    public Object batchProducer() throws Exception &#123;
        List&lt;Message&gt; messages = new ArrayList&lt;&gt;();
        //总共发送五次消息
        for (int i = 0; i &lt; 20; i++) &#123;
            //创建生产信息
            Message message = new Message(BatchConsumer.TOPIC, &quot;BatchTagA&quot;, (&quot;Hello RocketMQ:&quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
            messages.add(message);
        &#125;
        //发送
        SendResult sendResult = producer.getProducer().send(messages);
        log.info(&quot;输出生产者信息=&#123;&#125;&quot;,sendResult);
        return &quot;成功&quot;;
    &#125;

    /**
     * 仅当您发送大批量时，复杂性才会增加，您可能不确定它是否超过大小限制（1MiB）。此时，您最好拆分列表
     * @return
     * @throws Exception
     */
    @RequestMapping(&quot;/splitterProducer&quot;)
    public Object splitterProducer() throws Exception &#123;
        List&lt;Message&gt; messages = new ArrayList&lt;&gt;();
        //总共发送五次消息
        for (int i = 0; i &lt; 20; i++) &#123;
            //创建生产信息
            Message message = new Message(BatchConsumer.TOPIC, &quot;BatchTagA&quot;, (&quot;Hello RocketMQ:&quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
            messages.add(message);
        &#125;
        //then you could split the large list into small ones:
        ListSplitter splitter = new ListSplitter(messages);
        while (splitter.hasNext()) &#123;
            try &#123;
                List&lt;Message&gt;  listItem = splitter.next();
                SendResult sendResult =producer.getProducer().send(listItem);
                log.info(&quot;输出生产者信息=&#123;&#125;&quot;,sendResult);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
                //handle the error
            &#125;
        &#125;
        return &quot;成功&quot;;
    &#125;
&#125;
</code></pre>
<h4 id="数据拆分工具"><a href="#数据拆分工具" class="headerlink" title="数据拆分工具"></a>数据拆分工具</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.web;

import org.apache.rocketmq.common.message.Message;

import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * Describe:
 * Created by AlexP on 2022/4/25.
 */
public class ListSplitter implements Iterator&lt;List&lt;Message&gt;&gt; &#123;
    private static final int SIZE_LIMIT = 1000 * 1000;
    private final List&lt;Message&gt; messages;
    private int currIndex;
    public ListSplitter(List&lt;Message&gt; messages) &#123;
        this.messages = messages;
    &#125;
    @Override public boolean hasNext() &#123;
        return currIndex &lt; messages.size();
    &#125;
    @Override public List&lt;Message&gt; next() &#123;
        int nextIndex = currIndex;
        int totalSize = 0;
        for (; nextIndex &lt; messages.size(); nextIndex++) &#123;
            Message message = messages.get(nextIndex);
            int tmpSize = message.getTopic().length() + message.getBody().length;
            Map&lt;String, String&gt; properties = message.getProperties();
            for (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;
                tmpSize += entry.getKey().length() + entry.getValue().length();
            &#125;
            //for log overhead
            tmpSize = tmpSize + 20;
            if (tmpSize &gt; SIZE_LIMIT) &#123;
                //it is unexpected that single message exceeds the SIZE_LIMIT
                //here just let it go, otherwise it will block the splitting process
                if (nextIndex - currIndex == 0) &#123;
                    //if the next sublist has no element, add this one and then break, otherwise just break
                    nextIndex++;
                &#125;
                break;
            &#125;
            if (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;
                break;
            &#125; else &#123;
                totalSize += tmpSize;
            &#125;

        &#125;
        List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);
        currIndex = nextIndex;
        return subList;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq之Filter模式</title>
    <url>/2022/04/25/rocketmq-zhi-filter-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;
    &lt;version&gt;4.9.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.producer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.springframework.stereotype.Component;

/**
 * @author 彭鹏
 * @date 2021/10/20.
 */
@Slf4j
@Component
public class FilterProducer &#123;
    private String producerGroup = &quot;filter_group_name&quot;;
    private DefaultMQProducer producer;

    public FilterProducer()&#123;
        //示例生产者
        producer = new DefaultMQProducer(producerGroup);
        //不开启vip通道 开通口端口会减2
        producer.setVipChannelEnabled(false);
        //绑定name server
        producer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        start();
    &#125;
    /**
     * 对象在使用之前必须要调用一次，只能初始化一次
     */
    public void start()&#123;
        try &#123;
            this.producer.start();
        &#125; catch (MQClientException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public DefaultMQProducer getProducer()&#123;
        return this.producer;
    &#125;
    /**
     * 一般在应用上下文，使用上下文监听器，进行关闭
     */
    public void shutdown()&#123;
        this.producer.shutdown();
    &#125;
&#125;
</code></pre>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.consumer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.MessageSelector;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;

/**
 * @author 
 * @date 2021/10/20.
 * borker服务需要配置 broker.conf   enablePropertyFilter=true
 */
@Slf4j
@Component
public class FilterConsumer &#123;

    /**
     * 消费者实体对象
     */
    private DefaultMQPushConsumer consumer;
    /**
     * 主题名称 主题一般是服务器设置好 而不能在代码里去新建topic（ 如果没有创建好，生产者往该主题发送消息 会报找不到topic错误）
     */
    public static final String TOPIC = &quot;TOPIC_FILTER_CONSUMER&quot;;
    /**
     * 消费者组
     */
    public static final String CONSUMER_GROUP = &quot;filter_group_name&quot;;
    /**
     * 通过构造函数 实例化对象
     */
    public FilterConsumer() throws MQClientException &#123;

        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
        consumer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        //消费模式:一个新的订阅组第一次启动从队列的最后位置开始消费 后续再启动接着上次消费的进度开始消费
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);
        // only subsribe messages have property a, also a &gt;=0 and a &lt;= 3 sql模式 默认Tag, *表示所有，|| 多个
        consumer.subscribe(TOPIC, MessageSelector.bySql(&quot;a between 0 and 3&quot;));
        // //注册消费的监听 并在此监听中消费信息，并返回消费的状态信息
        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;
            // msgs中只收集同一个topic，同一个tag，并且key相同的message
            // 会把不同的消息分别放置到不同的队列中
            try &#123;
                for (Message msg : msgs) &#123;

                    //消费者获取消息 这里只输出 不做后面逻辑处理
                    String body = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);
                    log.info(&quot;FilterConsumer-获取消息-主题topic为=&#123;&#125;, 消费消息为=&#123;&#125;&quot;, msg.getTopic(), body);
                &#125;
            &#125; catch (UnsupportedEncodingException e) &#123;
                e.printStackTrace();
                return ConsumeConcurrentlyStatus.RECONSUME_LATER;
            &#125;
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        &#125;);

        consumer.start();
        System.out.println(&quot;FilterConsumer消费者 启动成功=======&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.web;

import com.pengpeng.rocketmq.consumer.FilterConsumer;
import com.pengpeng.rocketmq.producer.FilterProducer;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author  
 * @date 2021/10/25.
 */
@Slf4j
@RestController
@RequestMapping(&quot;/filter&quot;)
public class FilterController &#123;

    @Autowired
    private FilterProducer producer;

    @RequestMapping(&quot;/filterProducer&quot;)
    public Object filterProducer() throws Exception &#123;
        int totalMessagesToSend = 20;
        for (int i = 0; i &lt; totalMessagesToSend; i++) &#123;
            Message msg = new Message(FilterConsumer.TOPIC,
                    &quot;filter1&quot;,
                    (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET)
            );
            // Set some properties.
            msg.putUserProperty(&quot;a&quot;, String.valueOf(i));
            // Send the message
            SendResult sendResult = producer.getProducer().send(msg);
            System.out.printf(&quot;%s%n&quot;, sendResult);
        &#125;
        return &quot;成功&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq之Order模式</title>
    <url>/2022/04/25/rocketmq-zhi-order-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;
    &lt;version&gt;4.9.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.producer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.springframework.stereotype.Component;

/**
 * @author 
 * @date 2021/10/25.
 */
@Slf4j
@Component
public class OrderedProducer &#123;
    private String producerGroup = &quot;ordered_group_name&quot;;
    private DefaultMQProducer producer;

    public OrderedProducer()&#123;
        //示例生产者
        producer = new DefaultMQProducer(producerGroup);
        //不开启vip通道 开通口端口会减2
        producer.setVipChannelEnabled(false);
        //绑定name server
        producer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        start();
    &#125;
    /**
     * 对象在使用之前必须要调用一次，只能初始化一次
     */
    public void start()&#123;
        try &#123;
            this.producer.start();
        &#125; catch (MQClientException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public DefaultMQProducer getProducer()&#123;
        return this.producer;
    &#125;
    /**
     * 一般在应用上下文，使用上下文监听器，进行关闭
     */
    public void shutdown()&#123;
        this.producer.shutdown();
    &#125;
&#125;
</code></pre>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.consumer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;
import org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageExt;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;

/**
 * @author 
 * @date 2021/10/25.
 */
@Slf4j
@Component
public class OrderedConsumer &#123;

    /**
     * 消费者实体对象
     */
    private DefaultMQPushConsumer consumer;
    /**
     * 消费者组
     */
    public static final String CONSUMER_GROUP = &quot;ordered_group_name&quot;;

    public static final String TOPIC = &quot;TOPIC_ORDERED_CONSUMER&quot;;
    /**
     * 通过构造函数 实例化对象
     */
    public OrderedConsumer() throws MQClientException &#123;

        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
        consumer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        //消费模式:一个新的订阅组第一次启动从队列的最后位置开始消费 后续再启动接着上次消费的进度开始消费
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
        //订阅主题和 标签（ * 代表所有标签)下信息
        consumer.subscribe(TOPIC, &quot;TagB || TagC || TagD|| TagE || TagF&quot;);
        // //注册消费的监听 并在此监听中消费信息，并返回消费的状态信息
        consumer.registerMessageListener(new MessageListenerOrderly() &#123;
            AtomicLong consumeTimes = new AtomicLong(0);
            @SneakyThrows
            @Override
            public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,
                                                       ConsumeOrderlyContext context) &#123;
                context.setAutoCommit(true);
                for (Message msg : msgs) &#123;
                    //消费者获取消息 这里只输出 不做后面逻辑处理
                    String body = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);
                    log.info(&quot;OrderConsumer-获取消息-主题topic为=&#123;&#125;, 消费消息为=&#123;&#125;&quot;, msg.getTopic(), body);
                &#125;
                this.consumeTimes.incrementAndGet();
                if ((this.consumeTimes.get() % 2) == 0) &#123;
                    return ConsumeOrderlyStatus.SUCCESS;
                &#125; else if ((this.consumeTimes.get() % 3) == 0) &#123;
                    return ConsumeOrderlyStatus.ROLLBACK;
                &#125; else if ((this.consumeTimes.get() % 4) == 0) &#123;
                    return ConsumeOrderlyStatus.COMMIT;
                &#125; else if ((this.consumeTimes.get() % 5) == 0) &#123;
                    context.setSuspendCurrentQueueTimeMillis(3000);
                    return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;
                &#125;
                return ConsumeOrderlyStatus.SUCCESS;

            &#125;
        &#125;);

        consumer.start();
        System.out.println(&quot;OrderedConsumer消费者 启动成功=======&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.web;

import com.pengpeng.rocketmq.consumer.OrderedConsumer;
import com.pengpeng.rocketmq.producer.OrderedProducer;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.producer.MessageQueueSelector;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageQueue;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * @author 彭鹏 顺序消息
 * @date 2021/10/25.
 */
@Slf4j
@RestController
@RequestMapping(&quot;/ordered&quot;)
public class OrderedController &#123;

    @Autowired
    private OrderedProducer producer;

    @RequestMapping(&quot;/orderedProducer&quot;)
    public Object orderedProducer() throws Exception &#123;
        String[] tags = new String[] &#123;&quot;TagB&quot;, &quot;TagC&quot;, &quot;TagD&quot;, &quot;TagE&quot;, &quot;TagF&quot;&#125;;
        for (int i = 1; i &lt; 21; i++) &#123;
            int orderId = i % 5;
            //Create a message instance, specifying topic, tag and message body.
            Message msg = new Message(OrderedConsumer.TOPIC, tags[i % tags.length], &quot;KEY&quot; + i,
                    (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
            /**
             * 1、消息对象
             * 2、消息队列的选择器
             * 3、选择队列的业务标识（orderId）
             */
            SendResult sendResult = producer.getProducer().send(msg, new MessageQueueSelector() &#123;
                /**
                 *
                 * @param mqs 队列集合
                 * @param msg 消息对象
                 * @param arg 业务标识参数 orderId
                 * @return
                 */
                @Override
                public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;
                    Integer id = (Integer) arg;
                    int index = id % mqs.size();
                    return mqs.get(index);
                &#125;
            &#125;, orderId);

            System.out.printf(&quot;%s%n&quot;, sendResult);
        &#125;
        return &quot;成功&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq之Schedule模式</title>
    <url>/2022/04/25/rocketmq-zhi-schedule-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;
    &lt;version&gt;4.9.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.producer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.springframework.stereotype.Component;

/**
 * @author 
 * @date 2021/10/20.
 */
@Slf4j
@Component
public class ScheduleProducer &#123;
    private String producerGroup = &quot;schedule_group_name&quot;;
    private DefaultMQProducer producer;

    public ScheduleProducer()&#123;
        //示例生产者
        producer = new DefaultMQProducer(producerGroup);
        //不开启vip通道 开通口端口会减2
        producer.setVipChannelEnabled(false);
        //绑定name server
        producer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        start();
    &#125;
    /**
     * 对象在使用之前必须要调用一次，只能初始化一次
     */
    public void start()&#123;
        try &#123;
            this.producer.start();
        &#125; catch (MQClientException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public DefaultMQProducer getProducer()&#123;
        return this.producer;
    &#125;
    /**
     * 一般在应用上下文，使用上下文监听器，进行关闭
     */
    public void shutdown()&#123;
        this.producer.shutdown();
    &#125;
&#125;
</code></pre>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.consumer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.MessageExt;
import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.stereotype.Component;

import java.util.List;

/**
 * @author 
 * @date 2021/10/25.
 */
@Slf4j
@Component
public class ScheduleConsumer &#123;
    /**
     * 消费者实体对象
     */
    private DefaultMQPushConsumer consumer;
    /**
     * 主题名称 主题一般是服务器设置好 而不能在代码里去新建topic（ 如果没有创建好，生产者往该主题发送消息 会报找不到topic错误）
     */
    public static final String TOPIC = &quot;TOPIC_SCHEDULE_CONSUMER&quot;;
    /**
     * 消费者组
     */
    public static final String CONSUMER_GROUP = &quot;schedule_group_name&quot;;

    /**
     * 通过构造函数 实例化对象
     */
    public ScheduleConsumer() throws MQClientException &#123;
        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
        consumer.setNamesrvAddr(JmsConfig.NAME_SERVER);

        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);

        consumer.subscribe(TOPIC, &quot;SCHEDULE1 || SCHEDULE2 || SCHEDULE3&quot;);

        consumer.registerMessageListener(new MessageListenerConcurrently() &#123;
            @SneakyThrows
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context) &#123;
                for (MessageExt msg : messages) &#123;
                    // Print approximate delay time period
                    String body = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);
                    log.info(&quot;ScheduleConsumer-获取消息-主题topic为=&#123;&#125;, 消费消息为=&#123;&#125;, 消息id=&#123;&#125;,&#123;&#125;ms&quot;,
                            msg.getTopic(), body,msg.getMsgId(),(System.currentTimeMillis() - msg.getStoreTimestamp()));
                &#125;
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            &#125;
        &#125;);

        consumer.start();
        System.out.println(&quot;ScheduledConsumer 消费者 启动成功=======&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.web;

import com.pengpeng.rocketmq.consumer.ScheduleConsumer;
import com.pengpeng.rocketmq.producer.OrderedProducer;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * @author 彭鹏 顺序消息
 * @date 2021/10/25.
 */
@Slf4j
@RestController
@RequestMapping(&quot;/schedule&quot;)
public class ScheduleController &#123;

    @Autowired
    private OrderedProducer producer;

    @RequestMapping(&quot;/scheduleProducer&quot;)
    public Object scheduleProducer() throws Exception &#123;
        int totalMessagesToSend = 20;
        for (int i = 0; i &lt; totalMessagesToSend; i++) &#123;
            Message message = new Message(ScheduleConsumer.TOPIC,&quot;SCHEDULE1&quot;, (&quot;Hello scheduled message &quot; + i).getBytes());

            /*
            *  delivered
            *  1s  5s  10s 30s 1m  2m  3m  4m  5m  6m  7m  8m  9m  10m 20m 30m 1h  2h
            *  1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18
            * */
            // This message will be delivered to consumer 10 seconds later.
            message.setDelayTimeLevel(3);
            // Send the message
            SendResult sendResult = producer.getProducer().send(message);
            System.out.printf(&quot;%s%n&quot;, sendResult);
        &#125;
        return &quot;成功&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq之事务模式</title>
    <url>/2022/04/25/rocketmq-zhi-shi-wu-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;
    &lt;version&gt;4.9.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.producer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.apache.rocketmq.client.producer.TransactionListener;
import org.apache.rocketmq.client.producer.TransactionMQProducer;
import org.springframework.stereotype.Component;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @author 
 * @date 2021/10/20.
 */
@Slf4j
@Component
public class TransactionProducer &#123;
    private String producerGroup = &quot;transaction_group_name&quot;;
    private TransactionMQProducer producer;

    public TransactionProducer()&#123;
        TransactionListener transactionListener = new TransactionListenerImpl();
        producer = new TransactionMQProducer(producerGroup);
        ExecutorService executorService = new ThreadPoolExecutor(2, 5, 100, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2000), new ThreadFactory() &#123;
            @Override
            public Thread newThread(Runnable r) &#123;
                Thread thread = new Thread(r);
                thread.setName(&quot;client-transaction-msg-check-thread&quot;);
                return thread;
            &#125;
        &#125;);

        producer.setExecutorService(executorService);
        //添加事务监听器
        producer.setTransactionListener(transactionListener);
        start();
    &#125;
    /**
     * 对象在使用之前必须要调用一次，只能初始化一次
     */
    public void start()&#123;
        try &#123;
            this.producer.start();
        &#125; catch (MQClientException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public DefaultMQProducer getProducer()&#123;
        return this.producer;
    &#125;
    /**
     * 一般在应用上下文，使用上下文监听器，进行关闭
     */
    public void shutdown()&#123;
        this.producer.shutdown();
    &#125;
&#125;
</code></pre>
<h4 id="事务监听"><a href="#事务监听" class="headerlink" title="事务监听"></a>事务监听</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.producer;

import org.apache.rocketmq.client.producer.LocalTransactionState;
import org.apache.rocketmq.client.producer.TransactionListener;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageExt;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * @author 
 * @date 2021/10/26.
 */
public class TransactionListenerImpl implements TransactionListener &#123;
    private AtomicInteger transactionIndex = new AtomicInteger(0);

    private ConcurrentHashMap&lt;String, Integer&gt; localTrans = new ConcurrentHashMap&lt;&gt;();

    /**
    * 在该方法中执行本地事务
    * @param msg
    * @param arg
    * @return
    */
    @Override
    public LocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;
        int value = transactionIndex.getAndIncrement();
        int status = value % 3;
        localTrans.put(msg.getTransactionId(), status);
        return LocalTransactionState.UNKNOW;
    &#125;
    /**
    * 该方法是MQ进行消息事务状态回查
    * @param msg
    * @return
    */
    @Override
    public LocalTransactionState checkLocalTransaction(MessageExt msg) &#123;
        Integer status = localTrans.get(msg.getTransactionId());
        if (null != status) &#123;
            switch (status) &#123;
                case 0:
                    return LocalTransactionState.UNKNOW;
                case 1:
                    return LocalTransactionState.COMMIT_MESSAGE;
                case 2:
                    return LocalTransactionState.ROLLBACK_MESSAGE;
            &#125;
        &#125;
        return LocalTransactionState.COMMIT_MESSAGE;
    &#125;
&#125;
</code></pre>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.consumer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;

/**
 * @author 
 * @date 2021/10/20.
 */
@Slf4j
@Component
public class TransactionConsumer &#123;

    /**
     * 消费者实体对象
     */
    private DefaultMQPushConsumer consumer;
    /**
     * 主题名称 主题一般是服务器设置好 而不能在代码里去新建topic（ 如果没有创建好，生产者往该主题发送消息 会报找不到topic错误）
     */
    public static final String TOPIC = &quot;TOPIC_TANSACTION_CONSUMER&quot;;
    /**
     * 消费者组
     */
    public static final String CONSUMER_GROUP = &quot;transaction_group_name&quot;;
    /**
     * 通过构造函数 实例化对象
     */
    public TransactionConsumer() throws MQClientException &#123;

        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
        consumer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        //消费模式:一个新的订阅组第一次启动从队列的最后位置开始消费 后续再启动接着上次消费的进度开始消费
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);
        //订阅主题和 标签（ * 代表所有标签)下信息
        consumer.subscribe(TOPIC, &quot;*&quot;);
        // //注册消费的监听 并在此监听中消费信息，并返回消费的状态信息
        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;
            // msgs中只收集同一个topic，同一个tag，并且key相同的message
            // 会把不同的消息分别放置到不同的队列中
            try &#123;
                for (Message msg : msgs) &#123;

                    //消费者获取消息 这里只输出 不做后面逻辑处理
                    String body = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);
                    log.info(&quot;TransactionConsumer-获取消息-主题topic为=&#123;&#125;, 消费消息为=&#123;&#125;&quot;, msg.getTopic(), body);
                &#125;
            &#125; catch (UnsupportedEncodingException e) &#123;
                e.printStackTrace();
                return ConsumeConcurrentlyStatus.RECONSUME_LATER;
            &#125;
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        &#125;);

        consumer.start();
        System.out.println(&quot;TransactionConsumer消费者 启动成功=======&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.web;

import com.pengpeng.rocketmq.consumer.TransactionConsumer;
import com.pengpeng.rocketmq.producer.TransactionProducer;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.UnsupportedEncodingException;

/**
 * @author  顺序消息
 * @date 2021/10/25.
 */
@Slf4j
@RestController
@RequestMapping(&quot;/transaction&quot;)
public class TransactionController &#123;

    @Autowired
    private TransactionProducer producer;

    @RequestMapping(&quot;/transactionProducer&quot;)
    public Object transactionProducer() throws Exception &#123;
        String[] tags = new String[] &#123;&quot;TagA&quot;, &quot;TagB&quot;, &quot;TagC&quot;, &quot;TagD&quot;, &quot;TagE&quot;&#125;;
        for (int i = 0; i &lt; 10; i++) &#123;
            try &#123;
                Message msg =
                        new Message(TransactionConsumer.TOPIC, tags[i % tags.length], &quot;KEY&quot; + i,
                                (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
                SendResult sendResult = producer.getProducer().sendMessageInTransaction(msg, null);
                System.out.printf(&quot;%s%n&quot;, sendResult);

                Thread.sleep(10);
            &#125; catch (MQClientException | UnsupportedEncodingException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        for (int i = 0; i &lt; 100000; i++) &#123;
            Thread.sleep(1000);
        &#125;
        return &quot;成功&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq之广播模式</title>
    <url>/2022/04/25/rocketmq-zhi-guang-bo-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;
    &lt;version&gt;4.9.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.producer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.springframework.stereotype.Component;

/**
 * @author 
 * @date 2021/10/25.
 */
@Slf4j
@Component
public class BroadcastProducer &#123;
    private String producerGroup = &quot;broadcast_group_name&quot;;
    private DefaultMQProducer producer;

    public BroadcastProducer()&#123;
        //示例生产者
        producer = new DefaultMQProducer(producerGroup);
        //不开启vip通道 开通口端口会减2
        producer.setVipChannelEnabled(false);
        //绑定name server
        producer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        start();
    &#125;
    /**
     * 对象在使用之前必须要调用一次，只能初始化一次
     */
    public void start()&#123;
        try &#123;
            this.producer.start();
        &#125; catch (MQClientException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public DefaultMQProducer getProducer()&#123;
        return this.producer;
    &#125;
    /**
     * 一般在应用上下文，使用上下文监听器，进行关闭
     */
    public void shutdown()&#123;
        this.producer.shutdown();
    &#125;
&#125;
</code></pre>
<h4 id="消费者1"><a href="#消费者1" class="headerlink" title="消费者1"></a>消费者1</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.consumer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageExt;
import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;
import java.util.List;


/**
 * @author 
 * @date 2021/10/25.
 * 广播需要多个消费者
 */
@Slf4j
@Component
public class BroadcastConsumer &#123;
    /**
     * 消费者实体对象
     */
    private DefaultMQPushConsumer consumer;
    /**
     * 主题名称 主题一般是服务器设置好 而不能在代码里去新建topic（ 如果没有创建好，生产者往该主题发送消息 会报找不到topic错误）
     */
    public static final String TOPIC = &quot;TOPIC_BROADCAST_CONSUMER&quot;;
    /**
     * 消费者组
     */
    public static final String CONSUMER_GROUP = &quot;broadcast_group_name&quot;;

    /**
     * 通过构造函数 实例化对象
     */
    public BroadcastConsumer() throws MQClientException &#123;
        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
        consumer.setNamesrvAddr(JmsConfig.NAME_SERVER);

        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
       //设置消费模式：负载均衡|广播模式(默认负载均衡)
        consumer.setMessageModel(MessageModel.BROADCASTING);

        consumer.subscribe(TOPIC, &quot;Broadcast1 || Broadcast3 || Broadcast5&quot;);

        consumer.registerMessageListener(new MessageListenerConcurrently() &#123;

            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,
                                                            ConsumeConcurrentlyContext context) &#123;
                try &#123;
                    for (Message msg : msgs) &#123;

                        //消费者获取消息 这里只输出 不做后面逻辑处理
                        String body = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);
                        log.info(&quot;BroadcastConsumer-获取消息-主题topic为=&#123;&#125;, 消费消息为=&#123;&#125;&quot;, msg.getTopic(), body);
                    &#125;
                &#125; catch (UnsupportedEncodingException e) &#123;
                    e.printStackTrace();
                    return ConsumeConcurrentlyStatus.RECONSUME_LATER;
                &#125;
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            &#125;
        &#125;);

        consumer.start();
        System.out.println(&quot;BroadcastConsumer消费者 启动成功=======&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="消费者2"><a href="#消费者2" class="headerlink" title="消费者2"></a>消费者2</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.consumer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageExt;
import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;
import java.util.List;


/**
 * @author 
 * @date 2021/10/25.
 */
@Slf4j
@Component
public class BroadcastConsumer2 &#123;
    /**
     * 消费者实体对象
     */
    private DefaultMQPushConsumer consumer;
    /**
     * 主题名称 主题一般是服务器设置好 而不能在代码里去新建topic（ 如果没有创建好，生产者往该主题发送消息 会报找不到topic错误）
     */
    public static final String TOPIC = &quot;TOPIC_BROADCAST_CONSUMER&quot;;
    /**
     * 消费者组
     */
    public static final String CONSUMER_GROUP = &quot;broadcast_group_name2&quot;;

    /**
     * 通过构造函数 实例化对象
     */
    public BroadcastConsumer2() throws MQClientException &#123;
        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
        consumer.setNamesrvAddr(JmsConfig.NAME_SERVER);

        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
        //设置消费模式：负载均衡|广播模式(默认负载均衡)
        consumer.setMessageModel(MessageModel.BROADCASTING);

        consumer.subscribe(TOPIC, &quot;Broadcast1 || Broadcast2 || Broadcast3&quot;);

        consumer.registerMessageListener(new MessageListenerConcurrently() &#123;

            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,
                                                            ConsumeConcurrentlyContext context) &#123;
                try &#123;
                    for (Message msg : msgs) &#123;

                        //消费者获取消息 这里只输出 不做后面逻辑处理
                        String body = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);
                        log.info(&quot;BroadcastConsumer2-获取消息-主题topic为=&#123;&#125;, 消费消息为=&#123;&#125;&quot;, msg.getTopic(), body);
                    &#125;
                &#125; catch (UnsupportedEncodingException e) &#123;
                    e.printStackTrace();
                    return ConsumeConcurrentlyStatus.RECONSUME_LATER;
                &#125;
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            &#125;
        &#125;);

        consumer.start();
        System.out.println(&quot;BroadcastConsumer2消费者 启动成功=======&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.web;

import com.pengpeng.rocketmq.consumer.BroadcastConsumer;
import com.pengpeng.rocketmq.producer.BroadcastProducer;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


/**
 * @author 彭鹏  广播消息
 * @date 2021/10/25.
 */
@Slf4j
@RestController
@RequestMapping(&quot;/broadcast&quot;)
public class BroadcastController &#123;

    @Autowired
    private BroadcastProducer producer;

    @RequestMapping(&quot;/broadcastProducer&quot;)
    public Object broadcastProducer() throws Exception &#123;
        for (int i = 0; i &lt; 15; i++) &#123;
            Message msg = new Message(BroadcastConsumer.TOPIC,
                    &quot;Broadcast1&quot;,
                    &quot;OrderID111&quot;,
                    &quot;Hello world&quot;.getBytes(RemotingHelper.DEFAULT_CHARSET));
            SendResult sendResult = producer.getProducer().send(msg);
            System.out.printf(&quot;%s%n&quot;, sendResult);
        &#125;
        Thread.sleep(5000);
        return &quot;成功&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq快速入门</title>
    <url>/2022/04/25/rocketmq-kuai-su-ru-men/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;
    &lt;version&gt;4.9.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.producer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.springframework.stereotype.Component;

/**
 * @author 
 * @date 2021/10/20.
 */
@Slf4j
@Component
public class Producer &#123;
    private String producerGroup = &quot;please_rename_unique_group_name&quot;;
    private DefaultMQProducer producer;

    public Producer()&#123;
        //示例生产者
        producer = new DefaultMQProducer(producerGroup);
        //不开启vip通道 开通口端口会减2
        producer.setVipChannelEnabled(false);
        //绑定name server
        producer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        start();
    &#125;
    /**
     * 对象在使用之前必须要调用一次，只能初始化一次
     */
    public void start()&#123;
        try &#123;
            this.producer.start();
        &#125; catch (MQClientException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public DefaultMQProducer getProducer()&#123;
        return this.producer;
    &#125;
    /**
     * 一般在应用上下文，使用上下文监听器，进行关闭
     */
    public void shutdown()&#123;
        this.producer.shutdown();
    &#125;
&#125;
</code></pre>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.consumer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;

/**
 * @author 
 * @date 2021/10/20.
 */
@Slf4j
@Component
public class Consumer &#123;

    /**
     * 消费者实体对象
     */
    private DefaultMQPushConsumer consumer;
    /**
     * 主题名称 主题一般是服务器设置好 而不能在代码里去新建topic（ 如果没有创建好，生产者往该主题发送消息 会报找不到topic错误）
     */
    public static final String TOPIC = &quot;TOPIC_CONSUMER&quot;;
    /**
     * 消费者组
     */
    public static final String CONSUMER_GROUP = &quot;please_rename_unique_group_name&quot;;
    /**
     * 通过构造函数 实例化对象
     */
    public Consumer() throws MQClientException &#123;

        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
        consumer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        //消费模式:一个新的订阅组第一次启动从队列的最后位置开始消费 后续再启动接着上次消费的进度开始消费
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);
        //订阅主题和 标签（ * 代表所有标签)下信息
        consumer.subscribe(TOPIC, &quot;*&quot;);
        // //注册消费的监听 并在此监听中消费信息，并返回消费的状态信息
        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;
            // msgs中只收集同一个topic，同一个tag，并且key相同的message
            // 会把不同的消息分别放置到不同的队列中
            try &#123;
                for (Message msg : msgs) &#123;

                    //消费者获取消息 这里只输出 不做后面逻辑处理
                    String body = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);
                    log.info(&quot;Consumer-获取消息-主题topic为=&#123;&#125;, 消费消息为=&#123;&#125;&quot;, msg.getTopic(), body);
                &#125;
            &#125; catch (UnsupportedEncodingException e) &#123;
                e.printStackTrace();
                return ConsumeConcurrentlyStatus.RECONSUME_LATER;
            &#125;
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        &#125;);

        consumer.start();
        System.out.println(&quot;Consumer消费者 启动成功=======&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.web;

import com.pengpeng.rocketmq.consumer.Consumer;
import com.pengpeng.rocketmq.producer.Producer;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.producer.SendCallback;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.concurrent.CountDownLatch;

/**
 * @author 
 * @date 2021/10/20.
 */
@Slf4j
@RestController
@RequestMapping(&quot;/test&quot;)
public class Controller &#123;

    @Autowired
    private Producer producer;

    /**
     * 可靠的同步传输广泛应用于大量场景，如重要通知消息、短信通知、短信营销系统等。
     * @return
     * @throws Exception
     */
    @RequestMapping(&quot;/syncProducer&quot;)
    public Object syncProducer() throws Exception &#123;
        //总共发送五次消息
        for (int i = 0; i &lt; 20; i++) &#123;
            //创建生产信息
            Message message = new Message(Consumer.TOPIC, &quot;TagA&quot;, (&quot;Hello RocketMQ:&quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
            //发送
            SendResult sendResult = producer.getProducer().send(message);
            log.info(&quot;输出生产者信息=&#123;&#125;&quot;,sendResult);
        &#125;
        return &quot;成功&quot;;
    &#125;

    /**
     * 异步传输通常用于响应时间敏感型业务场景。
     * @return
     * @throws Exception
     */
    @RequestMapping(&quot;/asyncProducer&quot;)
    public Object callback() throws Exception &#123;
        //总共发送五次消息
        int messageCount = 20;
        final CountDownLatch countDownLatch = new CountDownLatch(messageCount);
        for (int i = 0;i&lt;messageCount;i++) &#123;
            try &#123;

                final int index = i;
                //创建生产信息
                Message message = new Message(Consumer.TOPIC, &quot;TagA&quot;, &quot;OrderID188&quot;, (&quot;Hello World&quot;).getBytes(RemotingHelper.DEFAULT_CHARSET));
                //发送
                producer.getProducer().send(message, new SendCallback() &#123;
                    @Override
                    public void onSuccess(SendResult sendResult) &#123;
                        countDownLatch.countDown();
                        System.out.printf(&quot;%-10d OK %s %n&quot;, index, sendResult.getMsgId());
                    &#125;

                    @Override
                    public void onException(Throwable e) &#123;
                        countDownLatch.countDown();
                        System.out.printf(&quot;%-10d Exception %s %n&quot;, index, e);
                        e.printStackTrace();
                    &#125;
                &#125;);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        return &quot;成功&quot;;
    &#125;

    /**
     * 单向传输用于需要中等可靠性的情况，例如日志收集。
     * @return
     * @throws Exception
     */
    @RequestMapping(&quot;/onewayProducer&quot;)
    public Object onewayProducer() throws Exception &#123;
        //总共发送五次消息
        for (int i = 0; i &lt; 20; i++) &#123;
            //创建生产信息
            Message message = new Message(Consumer.TOPIC, &quot;TagA&quot;, (&quot;Hello RocketMQ:&quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
            //发送
            producer.getProducer().sendOneway(message);
        &#125;
        Thread.sleep(5000);
        return &quot;成功&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7安装kafka</title>
    <url>/2022/04/26/centos7-an-zhuang-kafka/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="download"><a href="#download" class="headerlink" title="download"></a>download</h4><p><a href="https://kafka.apache.org/downloads">Apache Kafka</a></p>
<p><a href="https://dlcdn.apache.org/kafka/3.1.0/kafka_2.12-3.1.0.tgz"><strong>https://dlcdn.apache.org/kafka/3.1.0/kafka_2.12-3.1.0.tgz</strong></a></p>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><pre><code class="prettyprint">tar -zxvf kafka_2.12-3.1.0.tgz -C /opt/module/
</code></pre>
<h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><pre><code class="prettyprint">cd /opt/module/kafka/config
vim server.properties
vim zookeeper.properties
</code></pre>
<h5 id="修改server-properties"><a href="#修改server-properties" class="headerlink" title="修改server.properties"></a>修改server.properties</h5><pre><code class="prettyprint">#存储数据文件夹
log.dirs=/opt/module/kafka/datas
#如果集群要修改broker.id数字不重复
#broker.id=0
#集群后面改成集群配置
#zookeeper.connect=localhost:2181/kafka
</code></pre>
<h5 id="修改zookeeper-properties"><a href="#修改zookeeper-properties" class="headerlink" title="修改zookeeper.properties"></a>修改zookeeper.properties</h5><pre><code class="prettyprint">#存储数据文件夹
dataDir=/opt/module/kafka/zookeeper
</code></pre>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><pre><code class="prettyprint">cd /opt/module/kafka/bin
#先启动zookeeper
./zookeeper-server-start.sh ../config/zookeeper.properties
</code></pre>
<p>打开新的窗口启动kafka</p>
<pre><code class="prettyprint">cd /opt/module/kafka/bin
#先启动zookeeper
./kafka-server-start.sh ../config/server.properties
</code></pre>
<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>先关闭kafka再关闭zookeeper</p>
<pre><code class="prettyprint">cd /opt/module/kafka/bin
./kafka-server-stop.sh
./zookeeper-server-stop.sh
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><h5 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h5><pre><code class="prettyprint">--bootstrap-server &lt;String: server toconnect to&gt; 连接的 Kafka Broker 主机名称和端口号。
--topic &lt;String: topic&gt; 操作的 topic 名称。
--create 创建主题。
--delete 删除主题。
--alter 修改主题。
--list 查看所有主题。
--describe 查看主题详细描述。
--partitions &lt;Integer: # of partitions&gt; 设置分区数。
--replication-factor&lt;Integer: replication factor&gt; 设置分区副本。
--config &lt;String: name=value&gt; 更新系统默认的配置。
</code></pre>
<h5 id="kafka-topics-sh"><a href="#kafka-topics-sh" class="headerlink" title="kafka-topics.sh"></a><code>kafka-topics.sh</code></h5><pre><code class="prettyprint">cd /opt/module/kafka/bin
#集群需要设置分区
./kafka-topics.sh --create --topic &quot;first1&quot; --bootstrap-server 192.168.101.123:9092 --partitions 4 --replication-factor 1
#--list
./kafka-topics.sh --list --bootstrap-server 192.168.101.123:9092
#--describe
./kafka-topics.sh --describe --topic order-test1 --bootstrap-server 192.168.101.123:9092
</code></pre>
<h5 id="kafka-console-consumer-sh"><a href="#kafka-console-consumer-sh" class="headerlink" title="kafka-console-consumer.sh"></a><code>kafka-console-consumer.sh</code></h5><pre><code class="prettyprint"># from-beginning 从头开始
./kafka-console-consumer.sh --bootstrap-server 192.168.101.123:9092 --from-beginning --topic first
</code></pre>
<h5 id="kafka-console-producer-sh"><a href="#kafka-console-producer-sh" class="headerlink" title="kafka-console-producer.sh"></a><code>kafka-console-producer.sh</code></h5><pre><code class="prettyprint">./kafka-console-producer.sh --bootstrap-server 192.168.101.123:9092 --topic first
</code></pre>
<h5 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h5><h6 id="kafka-producer-perf-test-sh"><a href="#kafka-producer-perf-test-sh" class="headerlink" title="kafka-producer-perf-test.sh"></a><code>kafka-producer-perf-test.sh</code></h6><pre><code class="prettyprint">#生产数量10万个 每个数据1000字节 每秒两千个
./kafka-producer-perf-test.sh --topic first1 --num-records 100000 --record-size 1000 --throughput 2000 --producer-props bootstrap.servers=192.168.101.123:9092
</code></pre>
<h6 id="kafka-consumer-perf-test-sh"><a href="#kafka-consumer-perf-test-sh" class="headerlink" title="kafka-consumer-perf-test.sh"></a><code>kafka-consumer-perf-test.sh</code></h6><pre><code class="prettyprint">#消费数量10万个
./kafka-consumer-perf-test.sh --bootstrap-server 192.168.101.123:9092 --topic first1 --fetch-size 1048576 --messages 100000 --threads 1
</code></pre>
<h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><p><code>kafka-manage</code></p>
<p><a href="https://www.jianshu.com/p/00090d770ca3">kafka-manager(cmak)安装及使用 - 简书 (jianshu.com)</a></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7安装rabbitmq</title>
    <url>/2022/04/28/centos7-an-zhuang-rabbitmq/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>安装rabbitmq需要erlang环境，推荐使用rabbitmq封装的erlang的rpm包</p>
<ul>
<li>rabbitmq软件包</li>
</ul>
<p><a href="https://www.rabbitmq.com/download.html">Downloading and Installing RabbitMQ — RabbitMQ</a></p>
<p>选择你的系统对应的安装（我的是centos7）</p>
<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428215438858.png" class="asset-class" title="image-20220428215438858">

<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428215547092.png" class="asset-class" title="image-20220428215547092">

<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428215617098.png" class="asset-class" title="image-20220428215617098">

<ul>
<li><p>erlang包</p>
<p>先找到适应版本</p>
<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428215802459.png" class="asset-class" title="image-20220428215802459"></li>
</ul>
<p>再到下载rabbitmq页面找到依赖</p>
<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428220212284.png" class="asset-class" title="image-20220428220212284">

<p>选择去仓库下载 支持的erlang</p>
<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428220427026.png" class="asset-class" title="image-20220428220427026">

<p>去github下载</p>
<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428220536750.png" class="asset-class" title="image-20220428220536750">

<p>选择自己需要的</p>
<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428220619925.png" class="asset-class" title="image-20220428220619925">

<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>将<a href="https://github.com/rabbitmq/erlang-rpm/releases/download/v23.3.4.11/erlang-23.3.4.11-1.el7.x86_64.rpm">erlang-23.3.4.11-1.el7.x86_64.rpm</a>上传到服务器</p>
<p>将<a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.9.16/rabbitmq-server-3.9.16-1.el8.noarch.rpm">rabbitmq-server-3.9.16-1.el8.noarch.rpm</a>上传到服务器</p>
<pre><code class="prettyprint">rpm -ivh erlang-23.3.4.11-1.el7.x86_64.rpm
yum install socat -y
rpm -ivh rabbitmq-server-3.9.16-1.el8.noarch.rpm

#启动 
systemctl start rabbitmq-server
#停止 
systemctl stop rabbitmq-server
#重启 
systemctl restart rabbitmq-server
#状态 
systemctl status rabbitmq-server
#开机启动
chkconfig rabbitmq-server on
#开启web管理插件
rabbitmq-plugin enable rabbitmq_management
#关闭web管理插件
rabbitmq-plugin disable rabbitmq_management
</code></pre>
<h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428221219387.png" class="asset-class" title="image-20220428221219387">

<p>默认账号密码guest无法登录</p>
<h5 id="新建账号"><a href="#新建账号" class="headerlink" title="新建账号"></a>新建账号</h5><pre><code class="prettyprint"># 设置用户
rabbitmqctl add_user admin admin
# 设置用户角色
rabbitmqctl set_user_tags admin administrator
# 设置用户权限
set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;
rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
# 查看所有用户
rabbitmqctl list_users
# 关闭应用的命令为
rabbitmqctl stop_app
# 清除的命令为
rabbitmqctl reset
# 重新启动命令为
rabbitmqctl start_app
</code></pre>
<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428221729109.png" class="asset-class" title="image-20220428221729109">

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>开启防火墙或者开放端口</li>
<li>如果时云服务器还需要开放安全组</li>
</ul>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq</title>
    <url>/2022/04/29/rabbitmq/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> <a href="%E5%B0%9A%E7%A1%85%E8%B0%B7_%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ_%E8%AF%BE%E4%BB%B6.pdf">尚硅谷_消息中间件RabbitMQ_课件.pdf</a> </p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq交换机direct</title>
    <url>/2022/05/02/rabbitmq-jiao-huan-ji-direct/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="直接模式"><a href="#直接模式" class="headerlink" title="直接模式"></a>直接模式</h4><ul>
<li>同一个交换机根据绑定的路由键消费信息</li>
</ul>
<h4 id="创建信道"><a href="#创建信道" class="headerlink" title="创建信道"></a>创建信道</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.utils;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rocpenghua.rabbitmq.config.JmsConfig;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/4/29.
 */
public class RabbitmqUtils &#123;
    public static Channel getChannel() throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(JmsConfig.HOST);
        factory.setUsername(JmsConfig.USERNAME);
        factory.setPassword(JmsConfig.PASSWORD);
        //创建链接
        Connection connection = factory.newConnection();
        //获取信道
        Channel channel = connection.createChannel();
        return channel;
    &#125;
&#125;
</code></pre>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.six;

import com.rabbitmq.client.Channel;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class DirectLog &#123;
    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();

        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;info&quot;,&quot;这是个info消息&quot;);
        map.put(&quot;warning&quot;,&quot;这是个warning消息&quot;);
        map.put(&quot;error&quot;,&quot;这是个error消息&quot;);
        for(Map.Entry&lt;String, String&gt; entry:map.entrySet())&#123;
            channel.basicPublish(EXCHANGE_NAME, entry.getKey(), null, entry.getValue().getBytes(StandardCharsets.UTF_8));
            System.out.println(&quot;生产者发出消息：&quot; + entry.getValue());
        &#125;


    &#125;
&#125;
</code></pre>
<h4 id="消费者1"><a href="#消费者1" class="headerlink" title="消费者1"></a>消费者1</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.six;

import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class ReceiveLogsDirect01 &#123;
    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;
    private static final String EXCHANGE_TYPE = &quot;direct&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        //声明一个交换机
        channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);
        //声明一个队列
        String queueName = &quot;console&quot;;
        channel.queueDeclare(queueName,false,false,false,null);
        /*
         * 绑定交换机和队列
         */
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;info&quot;);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;warning&quot;);
        System.out.println(&quot;等待接收消息，把接收到的消息打印在屏幕上。。。。。。&quot;);
        //接受消息
        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;
            System.out.println(&quot;ReceiveLogsDirect01 控制台打印接收到的消息：&quot; + new String(message.getBody(), StandardCharsets.UTF_8));
        &#125;;
        //消费者取消消息的回调
        CancelCallback cancelCallback = consumerTag -&gt; &#123;&#125;;
        channel.basicConsume(queueName, true, deliverCallback, cancelCallback);
    &#125;
&#125;
</code></pre>
<h4 id="消费者2"><a href="#消费者2" class="headerlink" title="消费者2"></a>消费者2</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.six;

import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class ReceiveLogsDirect02 &#123;
    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;
    private static final String EXCHANGE_TYPE = &quot;direct&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        //声明一个交换机
        channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);
        //声明一个队列
        String queueName = &quot;disk&quot;;
        channel.queueDeclare(queueName,false,false,false,null);
        /*
         * 绑定交换机和队列
         */
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;error&quot;);
        System.out.println(&quot;等待接收消息，把接收到的消息打印在屏幕上。。。。。。&quot;);
        //接受消息
        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;
            System.out.println(&quot;ReceiveLogsDirect02 控制台打印接收到的消息：&quot; + new String(message.getBody(), StandardCharsets.UTF_8));
        &#125;;
        //消费者取消消息的回调
        CancelCallback cancelCallback = consumerTag -&gt; &#123;&#125;;
        channel.basicConsume(queueName, true, deliverCallback, cancelCallback);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq交换机fanout</title>
    <url>/2022/05/02/rabbitmq-jiao-huan-ji-fanout/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><ul>
<li>所有的绑定该交换机，路由键的消费者都能消费信息</li>
</ul>
<h4 id="创建信道"><a href="#创建信道" class="headerlink" title="创建信道"></a>创建信道</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.utils;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rocpenghua.rabbitmq.config.JmsConfig;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/4/29.
 */
public class RabbitmqUtils &#123;
    public static Channel getChannel() throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(JmsConfig.HOST);
        factory.setUsername(JmsConfig.USERNAME);
        factory.setPassword(JmsConfig.PASSWORD);
        //创建链接
        Connection connection = factory.newConnection();
        //获取信道
        Channel channel = connection.createChannel();
        return channel;
    &#125;
&#125;
</code></pre>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.five;

import com.rabbitmq.client.Channel;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class EmitLog &#123;
    private static final String EXCHANGE_NAME = &quot;log&quot;;
    private static final String EXCHANGE_TYPE = &quot;fanout&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);

        Scanner scanner = new Scanner(System.in);

        while (scanner.hasNext()) &#123;
            String message = scanner.next();
            channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes(StandardCharsets.UTF_8));
            System.out.println(&quot;生产者发出消息：&quot; + message);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="消费者1"><a href="#消费者1" class="headerlink" title="消费者1"></a>消费者1</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.five;

import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * Describe: 消息接受
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class ReceiveLogs01 &#123;
    private static final String EXCHANGE_NAME = &quot;log&quot;;
    private static final String EXCHANGE_TYPE = &quot;fanout&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        //声明一个交换机
        channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);
        //声明一个临时队列,队列名称随机,当消费者断开连接，队列自动删除
        String queueName = channel.queueDeclare().getQueue();
        /*
         * 绑定交换机和队列
         */
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;);
        System.out.println(&quot;等待接收消息，把接收到的消息打印在屏幕上。。。。。。&quot;);
        //接受消息
        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;
            System.out.println(&quot;ReceiveLogs01控制台打印接收到的消息：&quot; + new String(message.getBody(), StandardCharsets.UTF_8));
        &#125;;
        //消费者取消消息的回调
        CancelCallback cancelCallback = consumerTag -&gt; &#123;&#125;;
        channel.basicConsume(queueName, true, deliverCallback, cancelCallback);
    &#125;
&#125;
</code></pre>
<h4 id="消费者2"><a href="#消费者2" class="headerlink" title="消费者2"></a>消费者2</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.five;

import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * Describe: 消息接受
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class ReceiveLogs02 &#123;
    private static final String EXCHANGE_NAME = &quot;log&quot;;
    private static final String EXCHANGE_TYPE = &quot;fanout&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        //声明一个交换机
        channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);
        //声明一个临时队列,队列名称随机,当消费者断开连接，队列自动删除
        String queueName = channel.queueDeclare().getQueue();
        /*
         * 绑定交换机和队列
         */
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;);
        System.out.println(&quot;等待接收消息，把接收到的消息打印在屏幕上。。。。。。&quot;);
        //接受消息
        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;
            System.out.println(&quot;ReceiveLogs02控制台打印接收到的消息：&quot; + new String(message.getBody(), StandardCharsets.UTF_8));
        &#125;;
        //消费者取消消息的回调
        CancelCallback cancelCallback = consumerTag -&gt; &#123;&#125;;
        channel.basicConsume(queueName, true, deliverCallback, cancelCallback);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq交换机topics</title>
    <url>/2022/05/02/rabbitmq-jiao-huan-ji-topics/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="主题模式"><a href="#主题模式" class="headerlink" title="主题模式"></a>主题模式</h4><ul>
<li>根据路由键的匹配规则消费信息<ul>
<li><code>*(星号)</code>可以代替一个单词 <ul>
<li><code>*.demo.*</code>：匹配中间为<code>demo</code>的3个单词字符串路由键</li>
<li><code>*.*.demo</code>：匹配以<code>demo</code>结尾的3个单词字符串路由键</li>
</ul>
</li>
<li><code>#(井号)</code>可以替代零个或多个单词<ul>
<li><code>demo.#</code>：匹配以<code>demo</code>开头的多个单词</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="创建信道"><a href="#创建信道" class="headerlink" title="创建信道"></a>创建信道</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.utils;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rocpenghua.rabbitmq.config.JmsConfig;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/4/29.
 */
public class RabbitmqUtils &#123;
    public static Channel getChannel() throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(JmsConfig.HOST);
        factory.setUsername(JmsConfig.USERNAME);
        factory.setPassword(JmsConfig.PASSWORD);
        //创建链接
        Connection connection = factory.newConnection();
        //获取信道
        Channel channel = connection.createChannel();
        return channel;
    &#125;
&#125;
</code></pre>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.seven;

import com.rabbitmq.client.Channel;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class EmitLogTopic &#123;
    private static final String EXCHANGE_NAME = &quot;topic_log&quot;;
    private static final String EXCHANGE_TYPE = &quot;topic&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);
        /*
         * Q1--&gt;绑定的是
         *  中间带 orange 带 3 个单词的字符串(*.orange.*)
         * Q2--&gt;绑定的是
         *  最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)
         *  第一个单词是 lazy 的多个单词(lazy.#)
         *
         */
        Map&lt;String, String&gt; bindingKeyMap = new HashMap&lt;&gt;();
        bindingKeyMap.put(&quot;quick.orange.rabbit&quot;, &quot;被队列 Q1Q2 接收到&quot;);
        bindingKeyMap.put(&quot;lazy.orange.elephant&quot;, &quot;被队列 Q1Q2 接收到&quot;);
        bindingKeyMap.put(&quot;quick.orange.fox&quot;, &quot;被队列 Q1 接收到&quot;);
        bindingKeyMap.put(&quot;lazy.brown.fox&quot;, &quot;被队列 Q2 接收到&quot;);
        bindingKeyMap.put(&quot;lazy.pink.rabbit&quot;, &quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;);
        bindingKeyMap.put(&quot;quick.brown.fox&quot;, &quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;);
        bindingKeyMap.put(&quot;quick.orange.male.rabbit&quot;, &quot;是四个单词不匹配任何绑定会被丢弃&quot;);
        bindingKeyMap.put(&quot;lazy.orange.male.rabbit&quot;, &quot;是四个单词但匹配 Q2&quot;);

        for (Map.Entry&lt;String, String&gt; entry : bindingKeyMap.entrySet()) &#123;
            String message = entry.getValue();
            channel.basicPublish(EXCHANGE_NAME, entry.getKey(), null, message.getBytes(StandardCharsets.UTF_8));
            System.out.println(&quot;生产者发出消息：&quot; + message);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="消费者1"><a href="#消费者1" class="headerlink" title="消费者1"></a>消费者1</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.seven;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class ReceiveLogsTopic01 &#123;
    private static final String EXCHANGE_NAME = &quot;topic_log&quot;;
    private static final String EXCHANGE_TYPE = &quot;topic&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);
        //声明一个队列
        String queueName = &quot;Q1&quot;;
        channel.queueDeclare(queueName, false, false, false, null);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;*.orange.*&quot;);

        System.out.println(queueName + &quot;等待消息接收。。。。。。&quot;);
        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;
            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);
            System.out.println(&quot;接受队列：&quot; + queueName + &quot;绑定键：&quot; + delivery.getEnvelope().getRoutingKey() + &quot;,消息：&quot; + message);
        &#125;;
        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; &#123;
        &#125;);
    &#125;
&#125;
</code></pre>
<h4 id="消费者2"><a href="#消费者2" class="headerlink" title="消费者2"></a>消费者2</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.seven;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class ReceiveLogsTopic02 &#123;
    private static final String EXCHANGE_NAME = &quot;topic_log&quot;;
    private static final String EXCHANGE_TYPE = &quot;topic&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);
        //声明一个队列
        String queueName = &quot;Q2&quot;;
        channel.queueDeclare(queueName, false, false, false, null);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;*.*.rabbit&quot;);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;lazy.#&quot;);

        System.out.println(queueName + &quot;等待消息接收。。。。。。&quot;);
        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;
            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);
            System.out.println(&quot;接受队列：&quot; + queueName + &quot;绑定键：&quot; + delivery.getEnvelope().getRoutingKey() + &quot;,消息：&quot; + message);
        &#125;;
        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; &#123;
        &#125;);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq死信队列</title>
    <url>/2022/05/02/rabbitmq-si-xin-dui-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="死信队列产生的几种方式"><a href="#死信队列产生的几种方式" class="headerlink" title="死信队列产生的几种方式"></a>死信队列产生的几种方式</h4><ul>
<li><p>过期时间</p>
<ul>
<li><p>队列声明扩展参数设置过期时间</p>
<pre><code class="prettyprint">Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
arguments.put(&quot;x-message-ttl&quot;,10000);
//正常队列设置死信交换机
arguments.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE);
//设置死信RoutingKey
arguments.put(&quot;x-dead-letter-routing-key&quot;, DEAD_ROUTING_KEY);
channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);
</code></pre>
</li>
<li><p>发送消息设置过期时间</p>
<pre><code class="prettyprint">AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build();
channel.basicPublish(NORMAL_EXCHANGE,NORMAL_ROUTING_KEY,properties,message.getBytes(StandardCharsets.UTF_8));
</code></pre>
</li>
</ul>
</li>
<li><p>队列长度</p>
<ul>
<li><p>队列声明扩展参数设置队列最大长度</p>
<pre><code class="prettyprint">Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
arguments.put(&quot;x-max-length&quot;,6);
//正常队列设置死信交换机
arguments.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE);
//设置死信RoutingKey
arguments.put(&quot;x-dead-letter-routing-key&quot;, DEAD_ROUTING_KEY);
channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);
</code></pre>
</li>
</ul>
</li>
<li><p>消费拒绝</p>
<ul>
<li><p>消息接收时拒绝策略</p>
<pre><code class="prettyprint">DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;
    String msg = new String(message.getBody(), StandardCharsets.UTF_8);
    if(&quot;info5&quot;.equals(msg))&#123;
        System.out.println(&quot;Consumer01 接收的消息是:&quot; + msg+&quot;---此消息时被C1拒绝的&quot;);
        /*
                 *  消息拒绝 死信队列
                 * 1、被拒绝的消息标签
                 * 2、是否放回原队列
                 */
        channel.basicReject(message.getEnvelope().getDeliveryTag(),false);
    &#125;else &#123;
        System.out.println(&quot;Consumer01 接收的消息是:&quot; + msg);
        //消息确认
        channel.basicAck(message.getEnvelope().getDeliveryTag(),false);
    &#125;
&#125;;
//测试死信队列 应答ack为false 手动应答
channel.basicConsume(NORMAL_QUEUE, false, deliverCallback, consumerTag -&gt; &#123;
&#125;);
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><h5 id="创建信道"><a href="#创建信道" class="headerlink" title="创建信道"></a>创建信道</h5><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.utils;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rocpenghua.rabbitmq.config.JmsConfig;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/4/29.
 */
public class RabbitmqUtils &#123;
    public static Channel getChannel() throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(JmsConfig.HOST);
        factory.setUsername(JmsConfig.USERNAME);
        factory.setPassword(JmsConfig.PASSWORD);
        //创建链接
        Connection connection = factory.newConnection();
        //获取信道
        Channel channel = connection.createChannel();
        return channel;
    &#125;
&#125;
</code></pre>
<h5 id="消费者1（声明交换机和队列绑定）"><a href="#消费者1（声明交换机和队列绑定）" class="headerlink" title="消费者1（声明交换机和队列绑定）"></a>消费者1（声明交换机和队列绑定）</h5><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.eight;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeoutException;

/**
 * Describe: 死信队列实战
 * 消费者1
 *
 * @author RocPengHua
 * @date 2022/5/2.
 */
public class Consumer01 &#123;
    /**
     * 普通交换机
     */
    private static final String NORMAL_EXCHANGE = &quot;normal_exchange&quot;;

    /**
     * 普通队列
     */
    private static final String NORMAL_QUEUE = &quot;normal_queue&quot;;

    /**
     * 普通RoutingKey
     */
    private static final String NORMAL_ROUTING_KEY = &quot;zhangsan&quot;;

    /**
     * 死信交换机
     */
    private static final String DEAD_EXCHANGE = &quot;dead_exchange&quot;;

    /**
     * 死信队列
     */
    private static final String DEAD_QUEUE = &quot;dead_queue&quot;;

    /**
     * 死信RoutingKey
     */
    private static final String DEAD_ROUTING_KEY = &quot;lisi&quot;;


    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        //声明死信和普通交换机 类型为direct
        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);
        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);
        //声明普通队列
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        //过期时间(发送时候设置)
//        arguments.put(&quot;x-message-ttl&quot;,10000);

        //正常队列设置死信交换机
        arguments.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE);
        //设置死信RoutingKey
        arguments.put(&quot;x-dead-letter-routing-key&quot;, DEAD_ROUTING_KEY);
        //设置普通队列的长度的限制 测试死信队列
//        arguments.put(&quot;x-max-length&quot;,6);

        channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);

        //声明死信队列
        channel.queueDeclare(DEAD_QUEUE, false, false, false, null);
        //绑定普通的交换机与普通队列
        channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, NORMAL_ROUTING_KEY);
        //绑定死信的交换机与死信队列
        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, DEAD_ROUTING_KEY);
        System.out.println(&quot;Consumer01 等待接收消息。。。。&quot;);
        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;
            String msg = new String(message.getBody(), StandardCharsets.UTF_8);
            if(&quot;info5&quot;.equals(msg))&#123;
                System.out.println(&quot;Consumer01 接收的消息是:&quot; + msg+&quot;---此消息时被C1拒绝的&quot;);
                /*
                 *  消息拒绝 死信队列
                 * 1、被拒绝的消息标签
                 * 2、是否放回原队列
                 */
                channel.basicReject(message.getEnvelope().getDeliveryTag(),false);
            &#125;else &#123;
                System.out.println(&quot;Consumer01 接收的消息是:&quot; + msg);
                //消息确认
                channel.basicAck(message.getEnvelope().getDeliveryTag(),false);
            &#125;
        &#125;;
        //测试死信队列 应答ack为false 手动应答
        channel.basicConsume(NORMAL_QUEUE, false, deliverCallback, consumerTag -&gt; &#123;
        &#125;);
    &#125;
&#125;
</code></pre>
<h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.eight;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * Describe: 死信队列生产者
 *
 * @author RocPengHua
 * @date 2022/5/2.
 */
public class Producer &#123;
    /**
     * 普通交换机
     */
    private static final String NORMAL_EXCHANGE = &quot;normal_exchange&quot;;
    /**
     * 普通RoutingKey
     */
    private static final String NORMAL_ROUTING_KEY = &quot;zhangsan&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        //发送死信消息 设置 ttl time to live  单位ms
//        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build();
        //发送死信消息 测试队列长度
        AMQP.BasicProperties properties = null;
        for (int i = 1; i &lt; 11; i++) &#123;
            String message = &quot;info&quot; + i;
            channel.basicPublish(NORMAL_EXCHANGE,NORMAL_ROUTING_KEY,properties,message.getBytes(StandardCharsets.UTF_8));
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="消费者2（消费死信队列）"><a href="#消费者2（消费死信队列）" class="headerlink" title="消费者2（消费死信队列）"></a>消费者2（消费死信队列）</h5><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.eight;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/2.
 */
public class Consumer02 &#123;
    /**
     * 死信交换机
     */
    private static final String DEAD_EXCHANGE = &quot;dead_exchange&quot;;

    /**
     * 死信队列
     */
    private static final String DEAD_QUEUE = &quot;dead_queue&quot;;

    /**
     * 死信RoutingKey
     */
    private static final String DEAD_ROUTING_KEY = &quot;lisi&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();

        System.out.println(&quot;Consumer01 等待接收消息。。。。&quot;);
        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;
            System.out.println(&quot;Consumer02 接收的消息是:&quot; + new String(message.getBody(), StandardCharsets.UTF_8));
        &#125;;
        channel.basicConsume(DEAD_QUEUE, true, deliverCallback, consumerTag -&gt; &#123;
        &#125;);
    &#125;
&#125;
</code></pre>
<h5 id="注：每一次测试重新声明队列时先删除旧的"><a href="#注：每一次测试重新声明队列时先删除旧的" class="headerlink" title="注：每一次测试重新声明队列时先删除旧的"></a>注：每一次测试重新声明队列时先删除旧的</h5>]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq消息确认模式</title>
    <url>/2022/05/02/rabbitmq-xiao-xi-que-ren-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="消息确认几种模式"><a href="#消息确认几种模式" class="headerlink" title="消息确认几种模式"></a>消息确认几种模式</h4><ul>
<li>单个确认<ul>
<li>发送一个消息确认一次</li>
</ul>
</li>
<li>批量确认<ul>
<li>发送多个消息确认一次</li>
</ul>
</li>
<li>异步批量确认<ul>
<li>添加消息确认监听器</li>
</ul>
</li>
</ul>
<h4 id="创建信道"><a href="#创建信道" class="headerlink" title="创建信道"></a>创建信道</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.utils;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rocpenghua.rabbitmq.config.JmsConfig;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/4/29.
 */
public class RabbitmqUtils &#123;
    public static Channel getChannel() throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(JmsConfig.HOST);
        factory.setUsername(JmsConfig.USERNAME);
        factory.setPassword(JmsConfig.PASSWORD);
        //创建链接
        Connection connection = factory.newConnection();
        //获取信道
        Channel channel = connection.createChannel();
        return channel;
    &#125;
&#125;
</code></pre>
<h4 id="单个确认"><a href="#单个确认" class="headerlink" title="单个确认"></a>单个确认</h4><pre><code class="prettyprint">public static void publishMessageIndividually() throws IOException, TimeoutException, InterruptedException &#123;
    Channel channel = RabbitmqUtils.getChannel();
    //队列声明
    String queueName = UUID.randomUUID().toString();
    channel.queueDeclare(queueName, true, false, false, null);
    //开启发布确认
    channel.confirmSelect();

    long start = System.currentTimeMillis();

    //批量发消息
    for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123;
        String message = i + &quot;&quot;;
        channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes(StandardCharsets.UTF_8));
        //单个消息马上进行发布确认
        boolean flag = channel.waitForConfirms();
        if (flag) &#123;
            System.out.println(i + &quot;--消息发送成功&quot;);
        &#125;
    &#125;

    long end = System.currentTimeMillis();
    System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;个单独确认消息，耗时&quot; + (end - start) + &quot;ms&quot;);


&#125;
</code></pre>
<h4 id="批量确认"><a href="#批量确认" class="headerlink" title="批量确认"></a>批量确认</h4><pre><code class="prettyprint">public static void publishMessageBatch() throws IOException, TimeoutException, InterruptedException &#123;
    Channel channel = RabbitmqUtils.getChannel();
    //队列声明
    String queueName = UUID.randomUUID().toString();
    channel.queueDeclare(queueName, true, false, false, null);
    //开启发布确认
    channel.confirmSelect();

    long start = System.currentTimeMillis();

    //批量确认消息的大小(100条确认一次)
    int batchSize = 100;

    //批量发消息批量确认
    for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123;
        String message = i + &quot;&quot;;
        channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes(StandardCharsets.UTF_8));

        //判断达到100条消息的时候  批量确认一次
        if (i % batchSize == 99) &#123;
            channel.waitForConfirms();
        &#125;
    &#125;

    long end = System.currentTimeMillis();
    System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;个批量确认消息，耗时&quot; + (end - start) + &quot;ms&quot;);
&#125;
</code></pre>
<h4 id="异步批量确认"><a href="#异步批量确认" class="headerlink" title="异步批量确认"></a>异步批量确认</h4><pre><code class="prettyprint">public static void publishMessageAsync() throws IOException, TimeoutException &#123;
    Channel channel = RabbitmqUtils.getChannel();
    //队列声明
    String queueName = UUID.randomUUID().toString();
    channel.queueDeclare(queueName, true, false, false, null);
    //开启发布确认
    channel.confirmSelect();
    /*
         * 线程安全有序的一个哈希表 适用于高并发的情况下
         * 1、轻松的将序号和消息进行关联
         * 2、轻松的批量删除条目，只要给到序号
         * 3、支持高并发（多线程）
         */
    ConcurrentSkipListMap&lt;Long, String&gt; outStandingConfirms = new ConcurrentSkipListMap&lt;&gt;();

    /* 消息确认成功回调
         * 1.消息的标记
         * 2.是否批量确认
         */
    ConfirmCallback ackCallback = (deliveryTag, multiple) -&gt; &#123;
        //2、删除已经确认的消息 剩下就是未确认的消息
        if (multiple) &#123;
            ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outStandingConfirms.headMap(deliveryTag);
        &#125; else &#123;
            outStandingConfirms.remove(deliveryTag);
        &#125;
        System.out.println(&quot;确认的消息：&quot; + deliveryTag);
    &#125;;

    /* 消息确认失败回调
         * 1.消息的标记
         * 2.是否批量确认
         */
    ConfirmCallback nackCallback = (deliveryTag, multiple) -&gt; &#123;
        //3、打印未确认的消息
        String message = outStandingConfirms.get(deliveryTag);
        System.out.println(&quot;未确认的消息是：&quot; + message + &quot;----未确认的消息序号：&quot; + deliveryTag);
    &#125;;

    /*
         * 准备监听器 监听哪些消息成功了  哪些消息失败了   异步通知
         * 1.监听哪些消息成功
         * 2.监听哪些消息失败
         */
    channel.addConfirmListener(ackCallback, nackCallback);
    long start = System.currentTimeMillis();
    //批量发送消息
    for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123;
        String message = &quot;消息&quot; + i;
        channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes(StandardCharsets.UTF_8));

        //1、记录所有发送的消息
        outStandingConfirms.put(channel.getNextPublishSeqNo(), message);
    &#125;

    long end = System.currentTimeMillis();
    System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;个异步发布确认消息，耗时&quot; + (end - start) + &quot;ms&quot;);
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq队列声明扩展参数说明</title>
    <url>/2022/05/02/rabbitmq-dui-lie-sheng-ming-kuo-zhan-can-shu-shuo-ming/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="queueDeclare"><a href="#queueDeclare" class="headerlink" title="queueDeclare"></a>queueDeclare</h4><p>声明队列</p>
<pre><code>Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete,
                             Map&lt;String, Object&gt; arguments) throws IOException;
</code></pre>
<ul>
<li>queue：队列名称</li>
<li>durable：是否持久化</li>
<li>exclusive：排外<ul>
<li>当前定义的队列connection中的channel是共享的，其他的connection是访问不到的<br>当conneciton.close的时候，queue被删除</li>
</ul>
</li>
<li>autoDelete：自动删除<ul>
<li>当前最后一个consumer断开之后，autoDelete队列</li>
</ul>
</li>
<li>arguments：rabbitmq扩展参数</li>
</ul>
<h5 id="rabbitmq扩展参数"><a href="#rabbitmq扩展参数" class="headerlink" title="rabbitmq扩展参数"></a>rabbitmq扩展参数</h5><ul>
<li><p><code>x-message-ttl</code>消息过期时间设置</p>
<p>标识队列中的所有消息的过期时间</p>
<p>可以再消息发送时指定消息过期时间</p>
<pre><code class="prettyprint">//10s过期时间
AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build();
channel.basicPublish(NORMAL_EXCHANGE,NORMAL_ROUTING_KEY,properties,message.getBytes(StandardCharsets.UTF_8));
</code></pre>
</li>
<li><p><code>x-expires</code>自动删除时间</p>
</li>
<li><p><code>x-overflow</code></p>
<ul>
<li>设置‎<a href="https://www.rabbitmq.com/maxlength.html#overflow-behaviour">‎队列溢出行为‎</a>‎。这决定了当达到队列的最大长度时，消息会发生什么情况。有效值为 或 。仲裁队列类型仅支持 和 。‎<code>drop-head``reject-publish``reject-publish-dlx``drop-head``reject-publish</code></li>
</ul>
</li>
<li><p><code>x-single-active-consumer</code></p>
<ul>
<li>如果设置，请确保一次只有一个消费者从队列中消费，并在活动消费者被取消或死亡时故障转移到另一个已注册的使用者。</li>
</ul>
</li>
<li><p><code>x-max-length</code>最大队列长度</p>
</li>
<li><p><code>x-max-length-bytes</code>最大大小</p>
</li>
<li><p><code>x-dead-letter-exchange</code></p>
<ul>
<li>消息被拒绝或者过期的时候设置的交换机</li>
</ul>
</li>
<li><p><code>x-dead-letter-routing-key</code></p>
<ul>
<li>在消息为死信时要使用的可选替换路由键。如果未设置，则将使用邮件的原始路由键。</li>
</ul>
</li>
<li><p><code>x-max-priority</code>队列优先级</p>
</li>
<li><p><code>x-queue-mode=lazy</code></p>
<ul>
<li>将队列设置为延迟模式，在磁盘上保留尽可能多的消息以减少RAM使用量;如果未设置，队列将保留内存中缓存，以尽可能快地传递消息。‎</li>
</ul>
</li>
<li><p><code>x-queue-master-locator</code></p>
<ul>
<li>‎将队列设置为主位置模式，确定在节点群集上声明队列主节点时所依据的规则。‎</li>
</ul>
</li>
</ul>
<pre><code class="prettyprint">Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();
args.put(&quot;x-message-ttl&quot;,10000);
args.put(&quot;x-expires&quot;,10000);
args.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE);
args.put(&quot;x-dead-letter-routing-key&quot;, DEAD_ROUTING_KEY);
args.put(&quot;x-max-length&quot;,6);
args.put(&quot;x-max-length-bytes&quot;,2048);
args.put(&quot;x-max-priority&quot;,10);
channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);
</code></pre>
<h4 id="QueueDeclareNoWait"><a href="#QueueDeclareNoWait" class="headerlink" title="QueueDeclareNoWait"></a>QueueDeclareNoWait</h4><p>声明队列，不等待队列创建结果，异步</p>
<h4 id="QueueDeclarePassive"><a href="#QueueDeclarePassive" class="headerlink" title="QueueDeclarePassive"></a>QueueDeclarePassive</h4><p>消极的声明创建，判断队列是否存在，不存在报错</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq插件rabbitmq_delayed_message_exchange实现延迟队列</title>
    <url>/2022/05/03/rabbitmq-cha-jian-rabbitmq-delayed-message-exchange-shi-xian-yan-chi-dui-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>在使用死信队列实现延迟队列效果时，RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行</p>
<img src="/2022/05/03/rabbitmq-cha-jian-rabbitmq-delayed-message-exchange-shi-xian-yan-chi-dui-lie/image-20220503194822388.png" class="asset-class" title="image-20220503194822388"></li>
</ul>
<h4 id="download"><a href="#download" class="headerlink" title="download"></a>download</h4><h5 id="插件下载"><a href="#插件下载" class="headerlink" title="插件下载"></a>插件下载</h5><ul>
<li><a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></li>
</ul>
 <img src="/2022/05/03/rabbitmq-cha-jian-rabbitmq-delayed-message-exchange-shi-xian-yan-chi-dui-lie/image-20220503193505947.png" class="asset-class" title="image-20220503193505947">

<img src="/2022/05/03/rabbitmq-cha-jian-rabbitmq-delayed-message-exchange-shi-xian-yan-chi-dui-lie/image-20220503193710704.png" class="asset-class" title="image-20220503193710704">

<h5 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h5><pre><code class="prettyprint">#上传插件到 /usr/lib/rabbitmq/lib/rabbitmq_server-3.9.16/plugins
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
systemctl restart rabbitmq-server
</code></pre>
<h5 id="验证成功"><a href="#验证成功" class="headerlink" title="验证成功"></a>验证成功</h5><p>查看Exchanges的选择类型是否存在<code>x-delayed-message</code></p>
<img src="/2022/05/03/rabbitmq-cha-jian-rabbitmq-delayed-message-exchange-shi-xian-yan-chi-dui-lie/image-20220503194138103.png" class="asset-class" title="image-20220503194138103">

<h4 id="延迟队列使用"><a href="#延迟队列使用" class="headerlink" title="延迟队列使用"></a>延迟队列使用</h4><h5 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h5><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.springbootrabbitmq.config;

import org.springframework.amqp.core.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/3.
 */
@Configuration
public class DelayedQueueConfig &#123;
    /**
     * 队列
     */
    public static final String DELAYED_QUEUE_NAME = &quot;delayed.queue&quot;;
    /**
     * 交换机
     */
    public static final String DELAYED_EXCHANGE_NAME = &quot;delayed.exchange&quot;;
    /**
     * RoutingKey
     */
    public static final String DELAYED_ROUTING_KEY = &quot;delayed.routingkey&quot;;

    /**
     * 声明自定义交换机（x-delayed-message）
     */
    @Bean
    public CustomExchange delayedExchange() &#123;
        Map&lt;String,Object&gt; args = new HashMap&lt;&gt;();
        args.put(&quot;x-delayed-type&quot;,&quot;direct&quot;);
        /*
         * 1、交换机名称
         * 2、交换机类型
         * 3、是否持久化
         * 4、是否自动删除
         */
        return new CustomExchange(DELAYED_EXCHANGE_NAME, &quot;x-delayed-message&quot;, true, false, args);
    &#125;

    /**
     * 队列声明
     */
    @Bean
    public Queue delayedQueue() &#123;
        return QueueBuilder.durable(DELAYED_QUEUE_NAME).build();
    &#125;

    /**
     * 绑定队列和交换机
     */
    @Bean
    public Binding delayedQueueBindingDelayedExchange(@Qualifier(&quot;delayedQueue&quot;) Queue delayedQueue,
                                                      @Qualifier(&quot;delayedExchange&quot;) CustomExchange delayedExchange)&#123;
       return BindingBuilder.bind(delayedQueue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();
    &#125;
&#125;
</code></pre>
<h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.springbootrabbitmq.controller;

import com.rocpenghua.rabbitmq.springbootrabbitmq.config.DelayedQueueConfig;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.AmqpException;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.core.MessagePostProcessor;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Slf4j
@RestController
@RequestMapping(&quot;/ttl&quot;)
public class SendMsgController &#123;

    private final RabbitTemplate rabbitTemplate;

    public SendMsgController(RabbitTemplate rabbitTemplate) &#123;
        this.rabbitTemplate = rabbitTemplate;
    &#125;
 /**
     * 开始发消息 基于插件的消息及延迟时间
     * http://localhost:8080/ttl/sendDelayedMsg/你好 1/20000
     * http://localhost:8080/ttl/sendDelayedMsg/你好 2/2000
     */
    @GetMapping(&quot;/sendDelayedMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)
    public void sendDelayedMsg(@PathVariable(&quot;message&quot;) String message,@PathVariable(&quot;delayTime&quot;) Integer delayTime) &#123;
        log.info(&quot;当前时间：&#123;&#125;，发送一条时长&#123;&#125;毫秒延迟信息给延迟队列delayed.queue:&#123;&#125;&quot;, new Date().toString(), delayTime, message);
        MessagePostProcessor messagePostProcessor = msg -&gt; &#123;
            //发送消息时 延期时长 毫秒
            msg.getMessageProperties().setDelay(delayTime);
            return msg;
        &#125;;
        rabbitTemplate.convertAndSend(DelayedQueueConfig.DELAYED_EXCHANGE_NAME, DelayedQueueConfig.DELAYED_ROUTING_KEY,&quot;消息：&quot; + message,messagePostProcessor);
    &#125;
&#125;
</code></pre>
<h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.springbootrabbitmq.consumer;

import com.rabbitmq.client.Channel;
import com.rocpenghua.rabbitmq.springbootrabbitmq.config.DelayedQueueConfig;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;
import java.util.Date;

/**
 * Describe:
 * 消费者 基于插件的延迟消息
 * @author RocPengHua
 * @date 2022/5/3.
 */
@Component
@Slf4j
public class DelayQueueConsumer &#123;
    //监听消息

    @RabbitListener(queues = DelayedQueueConfig.DELAYED_QUEUE_NAME)
    public void receiveDelayQueue(Message message, Channel channel) &#123;
        String msg = new String(message.getBody(), StandardCharsets.UTF_8);
        log.info(&quot;当前时间：&#123;&#125;，收到延迟队列的消息：&#123;&#125;&quot;, new Date().toString(), msg);
    &#125;
&#125;
</code></pre>
<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><img src="/2022/05/03/rabbitmq-cha-jian-rabbitmq-delayed-message-exchange-shi-xian-yan-chi-dui-lie/image-20220503194656205.png" class="asset-class" title="image-20220503194656205">
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq集群搭建</title>
    <url>/2022/05/06/rabbitmq-ji-qun-da-jian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="rabbitmq安装"><a href="#rabbitmq安装" class="headerlink" title="rabbitmq安装"></a>rabbitmq安装</h4><p><a href="https://rocpenghua.gitee.io/2022/04/28/centos7-an-zhuang-rabbitmq/">centos7安装rabbitmq | 小鹏驿站 (gitee.io)</a></p>
<h4 id="集群环境准备"><a href="#集群环境准备" class="headerlink" title="集群环境准备"></a>集群环境准备</h4><ul>
<li><p>准备三台虚拟机，修改hostname</p>
<pre><code class="prettyprint">vim /etc/hostname
#分别命名node1,node2,node3
</code></pre>
<p>修改之后重启虚拟机<code>reboot</code>命令或者直接操作<code>vmware</code></p>
</li>
<li><p>修改各节点的hosts,让各个节点能互相识别</p>
<pre><code class="prettyprint">vim /etc/hosts
</code></pre>
<p>配置如下：</p>
<pre><code class="prettyprint">192.168.101.125 node1
192.168.101.129 node2
192.168.101.128 node3
</code></pre>
</li>
<li><p>确保各个节点erlang的cokkie一样,将node1中<code>.erlang.cookie</code>拷贝过去</p>
<pre><code class="prettyprint">scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/.erlang.cookie
scp /var/lib/rabbitmq/.erlang.cookie root@node3:/var/lib/rabbitmq/.erlang.cookie
</code></pre>
</li>
</ul>
<h4 id="集群命令"><a href="#集群命令" class="headerlink" title="集群命令"></a>集群命令</h4><h5 id="启动rabbitmq服务"><a href="#启动rabbitmq服务" class="headerlink" title="启动rabbitmq服务"></a>启动rabbitmq服务</h5><ul>
<li><p>node1</p>
<pre><code class="prettyprint">rabbitmq-server -detached
#停止（rabbitmqctl stop 会将Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务）
rabbitmqctl stop_app
#重置
rabbitmqctl reset
#启动
rabbitmqctl start_app
</code></pre>
</li>
<li><p>node2</p>
<pre><code class="prettyprint">rabbitmq-server -detached
#停止（rabbitmqctl stop 会将Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务）
rabbitmqctl stop_app
#重置
rabbitmqctl reset
#集群方式加入node1
rabbitmqctl join_cluster rabbit@node1
#启动
rabbitmqctl start_app
</code></pre>
</li>
<li><p>node3</p>
<pre><code class="prettyprint">rabbitmq-server -detached
#停止（rabbitmqctl stop 会将Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务）
rabbitmqctl stop_app
#重置
rabbitmqctl reset
#集群方式加入node2,也可以加入node1
rabbitmqctl join_cluster rabbit@node2
#启动
rabbitmqctl start_app
</code></pre>
</li>
</ul>
<h5 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h5><pre><code class="prettyprint">rabbitmqctl cluster_status
</code></pre>
<img src="/2022/05/06/rabbitmq-ji-qun-da-jian/image-20220506204436347.png" class="asset-class" title="image-20220506204436347">

<h5 id="重新创建并设置用户"><a href="#重新创建并设置用户" class="headerlink" title="重新创建并设置用户"></a>重新创建并设置用户</h5><ul>
<li><p>创建账号</p>
<pre><code class="prettyprint">rabbitmqctl add_user admin admin
</code></pre>
</li>
<li><p>设置用户超级管理员角色</p>
<pre><code class="prettyprint">rabbitmqctl set_user_tags admin administrator
</code></pre>
</li>
<li><p>设置用户权限</p>
<pre><code class="prettyprint">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
</code></pre>
</li>
</ul>
<img src="/2022/05/06/rabbitmq-ji-qun-da-jian/image-20220506204513466.png" class="asset-class" title="image-20220506204513466">

<h5 id="解除集群节点"><a href="#解除集群节点" class="headerlink" title="解除集群节点"></a>解除集群节点</h5><pre><code class="prettyprint">#在node2 node3 执行
rabbitmqctl stop_app
rabbitmqctl reset
rabbitmqctl start_app
rabbitmqctl cluster_status
#node1上面执行
rabbitmqctl forget_cluster_node rabbit@node2
</code></pre>
<h4 id="集群模式下镜像队列配置"><a href="#集群模式下镜像队列配置" class="headerlink" title="集群模式下镜像队列配置"></a>集群模式下镜像队列配置</h4><img src="/2022/05/06/rabbitmq-ji-qun-da-jian/image-20220506210406153.png" class="asset-class" title="image-20220506210406153">

<ul>
<li>Name：策略名称</li>
<li>Pattern：正则匹配规则</li>
<li>Apply to：应用于<ul>
<li><code>Exchanges and queues</code>：交换机和队列</li>
<li><code>Exchanges</code>：交换机</li>
<li><code>Queues</code>：队列</li>
</ul>
</li>
<li>Priority：优先级，默认0</li>
<li>Definition：自定义配置<ul>
<li><code>ha-mode</code><ul>
<li><code>all</code>集群所有节点</li>
<li><code>exactly</code>集群中部分节点，需要配合<code>ha-params</code>使用</li>
</ul>
</li>
<li><code>ha-params</code>：镜像的节点个数</li>
<li><code>ha-sync-mode</code><ul>
<li><code>automatic</code>：自动</li>
<li><code>manual</code>：手动</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/2022/05/06/rabbitmq-ji-qun-da-jian/image-20220506211201527.png" class="asset-class" title="image-20220506211201527">
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>maven小知识</title>
    <url>/2022/05/11/maven-xiao-zhi-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="打印依赖树"><a href="#打印依赖树" class="headerlink" title="打印依赖树"></a>打印依赖树</h4><pre><code class="prettyprint">#在pom目录下执行
mvn dependency:tree &gt;&gt; tree.txt
</code></pre>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq集群搭建</title>
    <url>/2022/05/10/rocketmq-ji-qun-da-jian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="rocketmq下载安装"><a href="#rocketmq下载安装" class="headerlink" title="rocketmq下载安装"></a>rocketmq下载安装</h3><p><a href="https://rocpenghua.gitee.io/2022/04/23/centos7-shou-dong-an-zhuang-rocketmq/">centos7手动安装rocketmq | 小鹏驿站 (gitee.io)</a></p>
<h3 id="集群模式配置"><a href="#集群模式配置" class="headerlink" title="集群模式配置"></a>集群模式配置</h3><h4 id="集群搭建介绍"><a href="#集群搭建介绍" class="headerlink" title="集群搭建介绍"></a>集群搭建介绍</h4><ul>
<li>本次采用两台虚拟机，<code>192.168.101.132:MASTER1/SLAVE2</code>,<code>192.168.101.131:MASTER2/SLAVE1</code></li>
<li>使用<code>2m-2s-sync</code>配置下的配置文件</li>
</ul>
<h4 id="HOST配置-在两台虚拟机中修改"><a href="#HOST配置-在两台虚拟机中修改" class="headerlink" title="HOST配置(在两台虚拟机中修改)"></a>HOST配置(在两台虚拟机中修改)</h4><pre><code class="prettyprint">vim /etc/hosts
</code></pre>
<ul>
<li>配置文件如下</li>
</ul>
<pre><code class="prettyprint">192.168.101.132 rocketmq-nameserver1
192.168.101.131 rocketmq-nameserver2
192.168.101.132 rocketmq-master1
192.168.101.132 rocketmq-slave2
192.168.101.131 rocketmq-master2
192.168.101.131 rocketmq-slave1
</code></pre>
<ul>
<li>确保两台机器通信（可以关闭防火墙或者开放端口）</li>
</ul>
<h4 id="环境变量配置-在两台虚拟机中修改"><a href="#环境变量配置-在两台虚拟机中修改" class="headerlink" title="环境变量配置(在两台虚拟机中修改)"></a>环境变量配置(在两台虚拟机中修改)</h4><pre><code class="prettyprint">vim /etc/profile
</code></pre>
<ul>
<li>在最后加入如下配置</li>
</ul>
<pre><code class="prettyprint">#ROCKETMQ_HOME
ROCKETMQ_HOME=/opt/module/rocketmq
PATH=$PATH:$ROCKETMQ_HOME/bin
export PATH ROCKETMQ_HOME PATH
</code></pre>
<ul>
<li>使配置生效</li>
</ul>
<pre><code class="prettyprint">source /etc/profile
</code></pre>
<h4 id="创建消息存储位置"><a href="#创建消息存储位置" class="headerlink" title="创建消息存储位置"></a>创建消息存储位置</h4><pre><code class="prettyprint">#主
mkdir /opt/module/rocketmq/store
mkdir /opt/module/rocketmq/store/commitlog
mkdir /opt/module/rocketmq/store/consumequeue
mkdir /opt/module/rocketmq/store/index
#拷贝一份作为从节点的配置
cp -r /opt/module/rocketmq/store /opt/module/rocketmq/store-slave
</code></pre>
<h4 id="修改broker配置文件"><a href="#修改broker配置文件" class="headerlink" title="修改broker配置文件"></a>修改broker配置文件</h4><h5 id="MASTER1-192-168-101-132"><a href="#MASTER1-192-168-101-132" class="headerlink" title="MASTER1(192.168.101.132)"></a>MASTER1(192.168.101.132)</h5><pre><code class="prettyprint">vim /opt/module/rocketmq/conf/2m-2s-sync/broker-a.properties
</code></pre>
<p>修改配置如下：</p>
<pre><code class="prettyprint">#所属集群名字
brokerClusterName=rocketmq-cluster
#broker名字，注意此处不同的配置文件填写的不一样
brokerName=broker-a
#0 表示 Master，&gt;0 表示 Slave
brokerId=0
#nameServer地址，分号分割
namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876
#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数
defaultTopicQueueNums=4
#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭
autoCreateTopicEnable=true
#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭
autoCreateSubscriptionGroup=true
#Broker 对外服务的监听端口
listenPort=10911
#删除文件时间点，默认凌晨 4点
deleteWhen=04
#文件保留时间，默认 48 小时
fileReservedTime=120
#commitLog每个文件的大小默认1G
mapedFileSizeCommitLog=1073741824
#ConsumeQueue每个文件默认存30W条，根据业务情况调整
mapedFileSizeConsumeQueue=300000
#destroyMapedFileIntervalForcibly=120000
#redeleteHangedFileInterval=120000
#检测物理文件磁盘空间
diskMaxUsedSpaceRatio=88
#存储路径
storePathRootDir=/opt/module/rocketmq/store
#commitLog 存储路径
storePathCommitLog=/opt/module/rocketmq/store/commitlog
#消费队列存储路径存储路径
storePathConsumeQueue=/opt/module/rocketmq/store/consumequeue
#消息索引存储路径
storePathIndex=/opt/module/rocketmq/store/index
#checkpoint 文件存储路径
storeCheckpoint=/opt/module/rocketmq/store/checkpoint
#abort 文件存储路径
abortFile=/opt/module/rocketmq/store/abort
#限制的消息大小
maxMessageSize=65536
#flushCommitLogLeastPages=4
#flushConsumeQueueLeastPages=2
#flushCommitLogThoroughInterval=10000
#flushConsumeQueueThoroughInterval=60000
#Broker 的角色
#- ASYNC_MASTER 异步复制Master
#- SYNC_MASTER 同步双写Master
#- SLAVE
brokerRole=SYNC_MASTER
#刷盘方式
#- ASYNC_FLUSH 异步刷盘
#- SYNC_FLUSH 同步刷盘
flushDiskType=SYNC_FLUSH
#checkTransactionMessageEnable=false
#发消息线程池数量
#sendMessageThreadPoolNums=128
#拉消息线程池数量
#pullMessageThreadPoolNums=128
</code></pre>
<h5 id="SLAVE2-192-168-101-132"><a href="#SLAVE2-192-168-101-132" class="headerlink" title="SLAVE2(192.168.101.132)"></a>SLAVE2(192.168.101.132)</h5><pre><code class="prettyprint">vim /opt/module/rocketmq/conf/2m-2s-sync/broker-b-s.properties
</code></pre>
<p>修改配置如下：</p>
<pre><code class="prettyprint">#所属集群名字
brokerClusterName=rocketmq-cluster
#broker名字，注意此处不同的配置文件填写的不一样
brokerName=broker-b
#0 表示 Master，&gt;0 表示 Slave
brokerId=1
#nameServer地址，分号分割
namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876
#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数
defaultTopicQueueNums=4
#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭
autoCreateTopicEnable=true
#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭
autoCreateSubscriptionGroup=true
#Broker 对外服务的监听端口
listenPort=11011
#删除文件时间点，默认凌晨 4点
deleteWhen=04
#文件保留时间，默认 48 小时
fileReservedTime=120
#commitLog每个文件的大小默认1G
mapedFileSizeCommitLog=1073741824
#ConsumeQueue每个文件默认存30W条，根据业务情况调整
mapedFileSizeConsumeQueue=300000
#destroyMapedFileIntervalForcibly=120000
#redeleteHangedFileInterval=120000
#检测物理文件磁盘空间
diskMaxUsedSpaceRatio=88
#存储路径
storePathRootDir=/opt/module/rocketmq/store-slave
#commitLog 存储路径
storePathCommitLog=/opt/module/rocketmq/store-slave/commitlog
#消费队列存储路径存储路径
storePathConsumeQueue=/opt/module/rocketmq/store-slave/consumequeue
#消息索引存储路径
storePathIndex=/opt/module/rocketmq/store-slave/index
#checkpoint 文件存储路径
storeCheckpoint=/opt/module/rocketmq/store-slave/checkpoint
#abort 文件存储路径
abortFile=/opt/module/rocketmq/store-slave/abort
#限制的消息大小
maxMessageSize=65536
#flushCommitLogLeastPages=4
#flushConsumeQueueLeastPages=2
#flushCommitLogThoroughInterval=10000
#flushConsumeQueueThoroughInterval=60000
#Broker 的角色
#- ASYNC_MASTER 异步复制Master
#- SYNC_MASTER 同步双写Master
#- SLAVE
brokerRole=SLAVE
#刷盘方式
#- ASYNC_FLUSH 异步刷盘
#- SYNC_FLUSH 同步刷盘
flushDiskType=ASYNC_FLUSH
#checkTransactionMessageEnable=false
#发消息线程池数量
#sendMessageThreadPoolNums=128
#拉消息线程池数量
#pullMessageThreadPoolNums=128
</code></pre>
<h5 id="MASTER2-192-168-101-131"><a href="#MASTER2-192-168-101-131" class="headerlink" title="MASTER2(192.168.101.131)"></a>MASTER2(192.168.101.131)</h5><pre><code class="prettyprint">vim /opt/module/rocketmq/conf/2m-2s-sync/broker-b.properties
</code></pre>
<p>修改配置如下：</p>
<pre><code class="prettyprint">#所属集群名字
brokerClusterName=rocketmq-cluster
#broker名字，注意此处不同的配置文件填写的不一样
brokerName=broker-b
#0 表示 Master，&gt;0 表示 Slave
brokerId=0
#nameServer地址，分号分割
namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876
#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数
defaultTopicQueueNums=4
#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭
autoCreateTopicEnable=true
#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭
autoCreateSubscriptionGroup=true
#Broker 对外服务的监听端口
listenPort=10911
#删除文件时间点，默认凌晨 4点
deleteWhen=04
#文件保留时间，默认 48 小时
fileReservedTime=120
#commitLog每个文件的大小默认1G
mapedFileSizeCommitLog=1073741824
#ConsumeQueue每个文件默认存30W条，根据业务情况调整
mapedFileSizeConsumeQueue=300000
#destroyMapedFileIntervalForcibly=120000
#redeleteHangedFileInterval=120000
#检测物理文件磁盘空间
diskMaxUsedSpaceRatio=88
#存储路径
storePathRootDir=/opt/module/rocketmq/store
#commitLog 存储路径
storePathCommitLog=/opt/module/rocketmq/store/commitlog
#消费队列存储路径存储路径
storePathConsumeQueue=/opt/module/rocketmq/store/consumequeue
#消息索引存储路径
storePathIndex=/opt/module/rocketmq/store/index
#checkpoint 文件存储路径
storeCheckpoint=/opt/module/rocketmq/store/checkpoint
#abort 文件存储路径
abortFile=/opt/module/rocketmq/store/abort
#限制的消息大小
maxMessageSize=65536
#flushCommitLogLeastPages=4
#flushConsumeQueueLeastPages=2
#flushCommitLogThoroughInterval=10000
#flushConsumeQueueThoroughInterval=60000
#Broker 的角色
#- ASYNC_MASTER 异步复制Master
#- SYNC_MASTER 同步双写Master
#- SLAVE
brokerRole=SYNC_MASTER
#刷盘方式
#- ASYNC_FLUSH 异步刷盘
#- SYNC_FLUSH 同步刷盘
flushDiskType=SYNC_FLUSH
#checkTransactionMessageEnable=false
#发消息线程池数量
#sendMessageThreadPoolNums=128
#拉消息线程池数量
#pullMessageThreadPoolNums=128
</code></pre>
<h5 id="SLAVE1-192-168-101-131"><a href="#SLAVE1-192-168-101-131" class="headerlink" title="SLAVE1(192.168.101.131)"></a>SLAVE1(192.168.101.131)</h5><pre><code class="prettyprint">vim /opt/module/rocketmq/conf/2m-2s-sync/broker-a-s.properties
</code></pre>
<p>修改配置如下：</p>
<pre><code class="prettyprint">#所属集群名字
brokerClusterName=rocketmq-cluster
#broker名字，注意此处不同的配置文件填写的不一样
brokerName=broker-a
#0 表示 Master，&gt;0 表示 Slave
brokerId=1
#nameServer地址，分号分割
namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876
#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数
defaultTopicQueueNums=4
#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭
autoCreateTopicEnable=true
#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭
autoCreateSubscriptionGroup=true
#Broker 对外服务的监听端口
listenPort=11011
#删除文件时间点，默认凌晨 4点
deleteWhen=04
#文件保留时间，默认 48 小时
fileReservedTime=120
#commitLog每个文件的大小默认1G
mapedFileSizeCommitLog=1073741824
#ConsumeQueue每个文件默认存30W条，根据业务情况调整
mapedFileSizeConsumeQueue=300000
#destroyMapedFileIntervalForcibly=120000
#redeleteHangedFileInterval=120000
#检测物理文件磁盘空间
diskMaxUsedSpaceRatio=88
#存储路径
storePathRootDir=/opt/module/rocketmq/store-slave
#commitLog 存储路径
storePathCommitLog=/opt/module/rocketmq/store-slave/commitlog
#消费队列存储路径存储路径
storePathConsumeQueue=/opt/module/rocketmq/store-slave/consumequeue
#消息索引存储路径
storePathIndex=/opt/module/rocketmq/store-slave/index
#checkpoint 文件存储路径
storeCheckpoint=/opt/module/rocketmq/store-slave/checkpoint
#abort 文件存储路径
abortFile=/opt/module/rocketmq/store-slave/abort
#限制的消息大小
maxMessageSize=65536
#flushCommitLogLeastPages=4
#flushConsumeQueueLeastPages=2
#flushCommitLogThoroughInterval=10000
#flushConsumeQueueThoroughInterval=60000
#Broker 的角色
#- ASYNC_MASTER 异步复制Master
#- SYNC_MASTER 同步双写Master
#- SLAVE
brokerRole=SLAVE
#刷盘方式
#- ASYNC_FLUSH 异步刷盘
#- SYNC_FLUSH 同步刷盘
flushDiskType=ASYNC_FLUSH
#checkTransactionMessageEnable=false
#发消息线程池数量
#sendMessageThreadPoolNums=128
#拉消息线程池数量
#pullMessageThreadPoolNums=128
</code></pre>
<h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><h4 id="启动NameServer集群"><a href="#启动NameServer集群" class="headerlink" title="启动NameServer集群"></a>启动NameServer集群</h4><ul>
<li>分别在<code>192.168.101.132</code>,<code>192.168.101.131</code>执行如下命令</li>
</ul>
<pre><code class="prettyprint">cd /opt/module/rocketmq/bin
sh mqnamesrv &amp;
</code></pre>
<h4 id="启动broker集群"><a href="#启动broker集群" class="headerlink" title="启动broker集群"></a>启动broker集群</h4><ul>
<li>在<code>192.168.101.132</code>启动MASTER1和SLAVE2</li>
</ul>
<pre><code class="prettyprint">cd /opt/module/rocketmq/bin
#启动MASTER1
sh mqbroker -c ../conf/2m-2s-sync/broker-a.properties &amp;
#启动SLAVE2
sh mqbroker -c ../conf/2m-2s-sync/broker-b-s.properties &amp;
</code></pre>
<ul>
<li>在<code>192.168.101.131</code>启动MASTER2和SLAVE1</li>
</ul>
<pre><code class="prettyprint">cd /opt/module/rocketmq/bin
#启动MASTER2
sh mqbroker -c ../conf/2m-2s-sync/broker-b.properties &amp;
#启动SLAVE1
sh mqbroker -c ../conf/2m-2s-sync/broker-a-s.properties &amp;
</code></pre>
<h3 id="验证启动成功"><a href="#验证启动成功" class="headerlink" title="验证启动成功"></a>验证启动成功</h3><h4 id="使用jps查看状态"><a href="#使用jps查看状态" class="headerlink" title="使用jps查看状态"></a>使用jps查看状态</h4><pre><code class="prettyprint">jps
</code></pre>
<img src="/2022/05/10/rocketmq-ji-qun-da-jian/image-20220510205542048.png" class="asset-class" title="image-20220510205542048">

<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><pre><code class="prettyprint"># 查看nameServer日志
tail -500f /opt/module/rabbitmq/logs/rocketmqlogs/namesrv.log
# 查看broker日志
tail -500f /opt/module/rabbitmq/logs/rocketmqlogs/broker.log
</code></pre>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>旧版本主从节点storePath可以在同一个路径下，新版本需要两个不同路径</li>
</ul>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq源码调试环境搭建</title>
    <url>/2022/05/15/rocketmq-yuan-ma-diao-shi-huan-jing-da-jian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="download"><a href="#download" class="headerlink" title="download"></a>download</h4><p><a href="https://dlcdn.apache.org/rocketmq/4.9.3/rocketmq-all-4.9.3-source-release.zip">官网源码地址</a></p>
<p><a href="https://github.com/apache/rocketmq">github源码地址</a></p>
<h4 id="目录结构说明"><a href="#目录结构说明" class="headerlink" title="目录结构说明"></a>目录结构说明</h4><ul>
<li>broker: broker 模块（broke 启动进程） </li>
<li>client ：消息客户端，包含消息生产者、消息消费者相关类 </li>
<li>common ：公共包 </li>
<li>dev ：开发者信息（非源代码） </li>
<li>distribution ：部署实例文件夹（非源代码） </li>
<li>example: RocketMQ 例代码 </li>
<li>filter ：消息过滤相关基础类</li>
<li>filtersrv：消息过滤服务器实现相关类（Filter启动进程）</li>
<li>logappender：日志实现相关类</li>
<li>namesrv：NameServer实现相关类（NameServer启动进程）</li>
<li>openmessageing：消息开放标准</li>
<li>remoting：远程通信模块，给予Netty</li>
<li>srcutil：服务工具类</li>
<li>store：消息存储实现相关类</li>
<li>style：checkstyle相关实现</li>
<li>test：测试相关类</li>
<li>tools：工具类，监控命令相关实现类</li>
</ul>
<h4 id="导入ide开发工具"><a href="#导入ide开发工具" class="headerlink" title="导入ide开发工具"></a>导入ide开发工具</h4><img src="/2022/05/15/rocketmq-yuan-ma-diao-shi-huan-jing-da-jian/image-20220515182156550.png" class="asset-class" title="image-20220515182156550">

<h5 id="执行安装脚本"><a href="#执行安装脚本" class="headerlink" title="执行安装脚本"></a>执行安装脚本</h5><pre><code class="prettyprint">mvn clean install -Dmaven.test.skip=true
</code></pre>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ul>
<li><p>在根目录下创建conf文件夹</p>
</li>
<li><p>拷贝<code>distribution</code>目录下<code>broker.conf</code>和<code>logback_broker.xml</code>和<code>logback_namesrv.xml</code></p>
<ul>
<li><code>broker.conf</code>配置broker启动配置i文件</li>
<li><code>logback_broker.xml</code> broker日志配置</li>
<li><code>logback_namesrv.xml</code> namesrv日志配置</li>
</ul>
</li>
<li><p>修改<code>broker.conf</code>配置</p>
<pre><code class="prettyprint"># Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the &quot;License&quot;); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
brokerClusterName = DefaultCluster
brokerName = broker-a
brokerId = 0
# namesrvAddr地址
namesrvAddr=127.0.0.1:9876
deleteWhen = 04
fileReservedTime = 48
brokerRole = ASYNC_MASTER
flushDiskType = ASYNC_FLUSH
autoCreateTopicEnable=true

# 存储路径
storePathRootDir=E:\\code\\rocketmq\\data\\rocketmq\\dataDir
# commitLog路径
storePathCommitLog=E:\\code\\rocketmq\\data\\rocketmq\\dataDir\\commitlog
# 消息队列存储路径
storePathConsumeQueue=E:\\code\\rocketmq\\data\\rocketmq\\dataDir\\consumequeue
# 消息索引存储路径
storePathIndex=E:\\code\\rocketmq\\data\\rocketmq\\dataDir\\index
# checkpoint文件路径
storeCheckpoint=E:\\code\\rocketmq\\data\\rocketmq\\dataDir\\checkpoint
# abort文件存储路径
abortFile=E:\\code\\rocketmq\\data\\rocketmq\\dataDir\\abort
</code></pre>
</li>
</ul>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><ul>
<li><p><code>namesrv</code>启动</p>
<ul>
<li>需要配置ROCKETMQ_HOME环境，<code>ROCKETMQ_HOME=E:\code\rocketmq\rocketmq-all-4.9.3</code></li>
</ul>
<img src="/2022/05/15/rocketmq-yuan-ma-diao-shi-huan-jing-da-jian/image-20220515182558374.png" class="asset-class" title="image-20220515182558374">

<ul>
<li>执行<code>namesrv</code>工程下面的<code>org.apache.rocketmq.namesrv.NamesrvStartup#main</code>方法启动</li>
</ul>
<img src="/2022/05/15/rocketmq-yuan-ma-diao-shi-huan-jing-da-jian/image-20220515182844276.png" class="asset-class" title="image-20220515182844276">
</li>
<li><p><code>broker</code>启动配置</p>
<ul>
<li><p>需要配置ROCKETMQ_HOME环境，<code>ROCKETMQ_HOME=E:\code\rocketmq\rocketmq-all-4.9.3</code></p>
</li>
<li><p>指定conf路径启动 <code>-c E:\code\rocketmq\rocketmq-all-4.9.3\conf\broker.conf</code></p>
</li>
</ul>
<img src="/2022/05/15/rocketmq-yuan-ma-diao-shi-huan-jing-da-jian/image-20220515183024715.png" class="asset-class" title="image-20220515183024715">

<ul>
<li>执行<code>broker</code>工程下面的<code>org.apache.rocketmq.broker.BrokerStartup#main</code>方法</li>
</ul>
<img src="/2022/05/15/rocketmq-yuan-ma-diao-shi-huan-jing-da-jian/image-20220515183148021.png" class="asset-class" title="image-20220515183148021"></li>
</ul>
<h5 id="测试org-apache-rocketmq-example-quickstart"><a href="#测试org-apache-rocketmq-example-quickstart" class="headerlink" title="测试org.apache.rocketmq.example.quickstart"></a>测试<code>org.apache.rocketmq.example.quickstart</code></h5><ul>
<li><p>生产者</p>
<pre><code class="prettyprint">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.rocketmq.example.quickstart;

import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;

/**
 * This class demonstrates how to send messages to brokers using provided &#123;@link DefaultMQProducer&#125;.
 */
public class Producer &#123;
    public static void main(String[] args) throws MQClientException, InterruptedException &#123;

        /*
         * Instantiate with a producer group name.
         */
        DefaultMQProducer producer = new DefaultMQProducer(&quot;please_rename_unique_group_name&quot;);
        producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);
        /*
         * Specify name server addresses.
         * &lt;p/&gt;
         *
         * Alternatively, you may specify name server addresses via exporting environmental variable: NAMESRV_ADDR
         * &lt;pre&gt;
         * &#123;@code
         * producer.setNamesrvAddr(&quot;name-server1-ip:9876;name-server2-ip:9876&quot;);
         * &#125;
         * &lt;/pre&gt;
         */

        /*
         * Launch the instance.
         */
        producer.start();

        for (int i = 0; i &lt; 10; i++) &#123;
            try &#123;

                /*
                 * Create a message instance, specifying topic, tag and message body.
                 */
                Message msg = new Message(&quot;TopicTest&quot; /* Topic */,
                    &quot;TagA&quot; /* Tag */,
                    (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */
                );

                /*
                 * Call send message to deliver message to one of brokers.
                 */
                SendResult sendResult = producer.send(msg);
                /*
                 * There are different ways to send message, if you don&#39;t care about the send result,you can use this way
                 * &#123;@code
                 * producer.sendOneway(msg);
                 * &#125;
                 */

                /*
                 * if you want to get the send result in a synchronize way, you can use this send method
                 * &#123;@code
                 * SendResult sendResult = producer.send(msg);
                 * System.out.printf(&quot;%s%n&quot;, sendResult);
                 * &#125;
                 */

                /*
                 * if you want to get the send result in a asynchronize way, you can use this send method
                 * &#123;@code
                 *
                 *  producer.send(msg, new SendCallback() &#123;
                 *  @Override
                 *  public void onSuccess(SendResult sendResult) &#123;
                 *      // do something
                 *  &#125;
                 *
                 *  @Override
                 *  public void onException(Throwable e) &#123;
                 *      // do something
                 *  &#125;
                 *&#125;);
                 *
                 *&#125;
                 */

                System.out.printf(&quot;%s%n&quot;, sendResult);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
                Thread.sleep(1000);
            &#125;
        &#125;

        /*
         * Shut down once the producer instance is not longer in use.
         */
        producer.shutdown();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<img src="/2022/05/15/rocketmq-yuan-ma-diao-shi-huan-jing-da-jian/image-20220515183358912.png" class="asset-class" title="image-20220515183358912">

<ul>
<li>消费者</li>
</ul>
<pre><code class="prettyprint">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.rocketmq.example.quickstart;

import java.util.List;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.MessageExt;

/**
 * This example shows how to subscribe and consume messages using providing &#123;@link DefaultMQPushConsumer&#125;.
 */
public class Consumer &#123;

    public static void main(String[] args) throws InterruptedException, MQClientException &#123;

        /*
         * Instantiate with specified consumer group name.
         */
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;please_rename_unique_group_name_4&quot;);
        consumer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);
        /*
         * Specify name server addresses.
         * &lt;p/&gt;
         *
         * Alternatively, you may specify name server addresses via exporting environmental variable: NAMESRV_ADDR
         * &lt;pre&gt;
         * &#123;@code
         * consumer.setNamesrvAddr(&quot;name-server1-ip:9876;name-server2-ip:9876&quot;);
         * &#125;
         * &lt;/pre&gt;
         */

        /*
         * Specify where to start in case the specific consumer group is a brand-new one.
         */
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);

        /*
         * Subscribe one more topic to consume.
         */
        consumer.subscribe(&quot;TopicTest&quot;, &quot;*&quot;);

        /*
         *  Register callback to execute on arrival of messages fetched from brokers.
         */
        consumer.registerMessageListener(new MessageListenerConcurrently() &#123;

            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,
                ConsumeConcurrentlyContext context) &#123;
                System.out.printf(&quot;%s Receive New Messages: %s %n&quot;, Thread.currentThread().getName(), msgs);
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            &#125;
        &#125;);

        /*
         *  Launch the consumer instance.
         */
        consumer.start();

        System.out.printf(&quot;Consumer Started.%n&quot;);
    &#125;
&#125;
</code></pre>
<img src="/2022/05/15/rocketmq-yuan-ma-diao-shi-huan-jing-da-jian/image-20220515183513129.png" class="asset-class" title="image-20220515183513129">

]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>javac编译找不到同包下面的类</title>
    <url>/2022/05/19/javac-bian-yi-zhao-bu-dao-tong-bao-xia-mian-de-lei/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>目录结构</li>
</ul>
<img src="/2022/05/19/javac-bian-yi-zhao-bu-dao-tong-bao-xia-mian-de-lei/image-20220519221633534.png" class="asset-class" title="image-20220519221633534">

<ul>
<li><p><code>MovingAverageTest</code>类中有依赖<code>MovingAverage</code>这时如果在jvm目录下执行命令</p>
<pre><code class="prettyprint">javac MovingAverageTest.java
</code></pre>
<p>会出现找不到类的错误</p>
</li>
</ul>
<p>​		<img src="/2022/05/19/javac-bian-yi-zhao-bu-dao-tong-bao-xia-mian-de-lei/image-20220519221958178.png" class="asset-class" title="image-20220519221958178"></p>
<ul>
<li><p>这时需要在包根目录<code>E:\code\java\jike\src\main\java\</code>下执行</p>
<pre><code class="prettyprint">javac com/rocpenghua/jvm/MovingAverageTest.java
</code></pre>
<img src="/2022/05/19/javac-bian-yi-zhao-bu-dao-tong-bao-xia-mian-de-lei/image-20220519222203897.png" class="asset-class" title="image-20220519222203897">
</li>
<li><p><code>javap</code>可以查看字节码</p>
<pre><code class="prettyprint">javap -c com.rocpenghua.jvm/MovingAverageTest
#详细信息
javap -c -verbose com.rocpenghua.jvm/MovingAverageTest
</code></pre>
</li>
</ul>
<img src="/2022/05/19/javac-bian-yi-zhao-bu-dao-tong-bao-xia-mian-de-lei/image-20220519222345324.png" class="asset-class" title="image-20220519222345324">

<img src="/2022/05/19/javac-bian-yi-zhao-bu-dao-tong-bao-xia-mian-de-lei/image-20220519222431144.png" class="asset-class" title="image-20220519222431144">
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm学习</title>
    <url>/2022/05/21/jvm-xue-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li><p><code>jps</code>查看java进程</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521214845003.png" class="asset-class" title="image-20220521214845003">
</li>
<li><p><code>jstat</code>查看jvm内部gc相关信息</p>
<ul>
<li><p><code>jstat -gc 5048 1000 1000</code></p>
<ul>
<li>S0C：0号存活区的当前容量，单位kb</li>
<li>S1C：1号存活区的当前容量，单位kb</li>
<li>S0U：0号存活区的使用量，单位kb</li>
<li>S1U：1号存活区的使用量，单位kb</li>
<li>EC：Eden区，新生代的当前容量，单位kb</li>
<li>EU：Eden区，新生代的使用量，单位kb</li>
<li>OC：Old区，老年代的当前容量，单位kb</li>
<li>OU：Old区，老年代的使用量，单位kb</li>
<li>MC：元数据区的当前容量，单位kb</li>
<li>MU：元数据区的使用量，单位kb</li>
<li>CCSC：压缩class空间容量，单位kb</li>
<li>CCSU：压缩class空间使用量，单位kb</li>
<li>YGC：年轻代FC的次数</li>
<li>YGCT：年轻代GC消耗的总时间</li>
<li>FGC：Full GC的次数</li>
<li>FGCT：Full GC消耗的时间</li>
<li>GCT：垃圾收集消耗的总时间</li>
</ul>
<img src="/2022/05/21/jvm-xue-xi/image-20220521215543036.png" class="asset-class" title="image-20220521215543036">
</li>
<li><p><code>jstat -gcutil 5048 1000 1000</code></p>
<ul>
<li>S0：0号存活区的百分百使用率，0%是因为S0,S1随时有一个是空的</li>
<li>S1：1号存活区的百分百使用率</li>
<li>E：Eden区，新生代百分比使用率</li>
<li>O：Old区，老年代百分比使用率</li>
<li>M：元数据区百分比使用率</li>
<li>CCS：压缩class空间（Compressed class space）的百分比使用率</li>
<li>YGC：年轻代FC的次数</li>
<li>YGCT：年轻代GC消耗的总时间</li>
<li>FGC：Full GC的次数</li>
<li>FGCT：Full GC消耗的时间</li>
<li>GCT：垃圾收集消耗的总时间</li>
</ul>
<img src="/2022/05/21/jvm-xue-xi/image-20220521215214755.png" class="asset-class" title="image-20220521215214755"></li>
</ul>
</li>
<li><p><code>jmap</code>查看heap或类占用空间统计</p>
<ul>
<li><p><code>jmap -heap 5048</code></p>
<ul>
<li>JDK8默认使用<code>Parallel GC</code>线程数为物理机cpu处理器个数（8）</li>
<li>默认最大堆内存<code>MaxHeapSize</code>为物理机的1&#x2F;4</li>
<li>默认堆内存为物理机的1&#x2F;64</li>
<li>最大年轻代<code>MaxNewSize</code>为堆内存的1&#x2F;3</li>
<li>年轻代老年代比例为2</li>
<li>E区和S区比例为8</li>
<li>压缩class空间<code>CompressedClassSpaceSize</code>堆1&#x2F;4</li>
<li>最大元数据空间<code>MaxMetaspaceSize</code>,jdk8之后使用的时物理内存</li>
<li><code>G1HeapRegionSize</code> G1 GC是存在</li>
</ul>
<img src="/2022/05/21/jvm-xue-xi/image-20220521220545424.png" class="asset-class" title="image-20220521220545424">
</li>
<li><p><code>jmap -histo 5048</code>查看那些类占用的空间最多</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521221754253.png" class="asset-class" title="image-20220521221754253">
</li>
<li><p><code>jmap -dump:format=b,file=5048.hprof</code>Dump堆内存</p>
</li>
</ul>
</li>
<li><p><code>jstack</code>查看线程信息</p>
<ul>
<li><p><code>jstack -l 5048</code>长列表模式. 将线程相关的 locks 信息一起输出， 比如持有的锁，等待的锁。</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521221935294.png" class="asset-class" title="image-20220521221935294"></li>
</ul>
</li>
<li><p><code>jcmd</code>执行jvm相关分析命令</p>
<ul>
<li><p><code>jcmd 5048 help</code>查看当前进程有哪些命令</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521222209216.png" class="asset-class" title="image-20220521222209216">
</li>
<li><p><code>jcmd 5048 VM.version </code>jvm版本信息</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521222239451.png" class="asset-class" title="image-20220521222239451">
</li>
<li><p><code>jcmd 5048 VM.flags </code>java进程参数</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521222327043.png" class="asset-class" title="image-20220521222327043">
</li>
<li><p><code>jcmd 5048 VM.command_line </code> 命令行</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521222352234.png" class="asset-class" title="image-20220521222352234">
</li>
<li><p><code>jcmd 5048 VM.system_properties </code>系统参数</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521222450042.png" class="asset-class" title="image-20220521222450042">
</li>
<li><p><code>jcmd 5048 Thread.print </code>运行线程类似&#96;jstack -l 5048</p>
</li>
<li><p><code>jcmd 5048 GC.class_histogram </code>类似<code>jmap -histo 5048</code></p>
</li>
<li><p><code>jcmd 5048 GC.heap_info</code></p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521222624101.png" class="asset-class" title="image-20220521222624101"></li>
</ul>
</li>
</ul>
<h3 id="图形化工具"><a href="#图形化工具" class="headerlink" title="图形化工具"></a>图形化工具</h3><ul>
<li><code>jconsole</code></li>
<li><code>jvisualvm</code></li>
<li><code>jmc</code></li>
<li><code>VisualGC</code>：idea插件</li>
</ul>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><h4 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h4><ul>
<li><p>标记清除算法（Mark and Sweep）Parallel GC和CMSGC的基本原理</p>
<ul>
<li><p>Marking（标记）: 遍历所有的可达对象，并在 本地内存(native)中分门别类记下</p>
</li>
<li><p>Sweeping（清除）: 这一步保证了，不可达对象 所占用的内存，在之后进行内存分配时可以重用</p>
</li>
</ul>
</li>
<li><p>标记-复制算法(Mark-Copy)</p>
</li>
<li><p>标记-清除-整理算法(Mark-Sweep-Compact)</p>
</li>
</ul>
<h4 id="GC收集器"><a href="#GC收集器" class="headerlink" title="GC收集器"></a>GC收集器</h4><h5 id="串行GC-Serial-GC"><a href="#串行GC-Serial-GC" class="headerlink" title="串行GC(Serial GC)"></a>串行GC(Serial GC)</h5><ul>
<li><code>-XX:+UseSerialGC</code>：配置使用串行化GC</li>
<li>串行 GC 对年轻代使用 mark-copy（标记-复制） 算法，对老年代使用 mark-sweep-compact （标记-清除-整理）算法</li>
<li>两者都是单线程的垃圾收集器，不能进行并行处理，所以都会触发全线暂停（STW），停止所有的应用线程</li>
<li>因此这种GC算法不能充分利用多核 CPU。不管有多少CPU 内核，JVM 在垃圾收集时都只能使用单个核心</li>
<li>CPU 利用率高，暂停时间长。简单粗暴，就像老式的电脑，动不动就卡死</li>
<li>只适合几百 MB 堆内存的 JVM，而且是单核 CPU 时比较有用</li>
<li><code>-XX:+UseParNewGC</code>改进版本的Serial GC,配置CMS使用</li>
</ul>
<h5 id="并行GC-Parallel-GC"><a href="#并行GC-Parallel-GC" class="headerlink" title="并行GC(Parallel GC)"></a>并行GC(Parallel GC)</h5><ul>
<li>使用命令<ul>
<li>-XX:+UseParallelGC</li>
<li>-XX:+UseParallelOldGC</li>
<li>-XX:+UseParallelGC -XX:+UseParallelOldGC</li>
</ul>
</li>
<li>年轻代和老年代的垃圾回收都会触发 STW 事件</li>
<li>在年轻代使用 标记-复制（mark-copy）算法，在老年代使用 标记-清除-整理（mark-sweepcompact）算法</li>
<li><code>-XX:ParallelGCThreads=N</code>来指定GC线程数，默认CPU核心数</li>
<li>并行垃圾收集器适用于多核服务器，主要目标是<code>增加吞吐量</code>。因为对系统资源的有效使用，能达到 更高的吞吐量<ul>
<li>在 GC 期间，所有 CPU 内核都在并行清理垃圾，所以总暂停时间更短</li>
<li>在两次 GC 周期的间隔期，没有 GC 线程在运行，不会消耗任何系统资源</li>
</ul>
</li>
</ul>
<h5 id="CMS-GC"><a href="#CMS-GC" class="headerlink" title="CMS GC"></a>CMS GC</h5><ul>
<li><code>-XX:+UseConcMarkSweepGC</code></li>
<li>其对年轻代采用并行 STW 方式的 mark-copy (标记-复制)算法，对老年代主要使用并发 marksweep (标记-清除)算法</li>
<li>CMS GC 的设计目标是避免在老年代垃圾收集时出现长时间的卡顿<ul>
<li>不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收</li>
<li>在 mark-and-sweep （标记-清除） 阶段的大部分工作和应用线程一起并发执行</li>
</ul>
</li>
<li>如果服务器是多核 CPU，并且主要调优目标是<code>降低 GC 停顿导致的系统延迟</code>，那么使用 CMS 是 个很明智的选择。进行老年代的并发回收时，可能会伴随着多次年轻代的 minor GC</li>
<li>CMS GC六个阶段<ul>
<li>Initial Mark（初始标记）<ul>
<li>这个阶段伴随着 STW 暂停。初始标记的目标是标记所有的根对象，包括根对象直接引用的对象，以及被年轻代中 所有存活对象所引用的对象（老年代单独回收）。</li>
</ul>
</li>
<li>Concurrent Mark（并发标记）<ul>
<li>在此阶段，CMS GC 遍历老年代，标记所有的存活对象， 从前一阶段 “Initial Mark” 找到的根对象开始算起。 “并 发标记”阶段，就是与应用程序同时运行，不用暂停的阶段</li>
</ul>
</li>
<li>Concurrent Preclean（并发预清理）<ul>
<li>此阶段同样是与应用线程并发执行的，不需要停止应用线 程。 因为前一阶段【并发标记】与程序并发运行，可能 有一些引用关系已经发生了改变。如果在并发标记过程中 引用关系发生了变化，JVM 会通过“Card（卡片）”的方 式将发生了改变的区域标记为“脏”区，这就是所谓的 卡片 标记（Card Marking）</li>
</ul>
</li>
<li>Final Remark（最终标记）<ul>
<li>最终标记阶段是此次 GC 事件中的第二次（也是最后一 次）STW 停顿。本阶段的目标是完成老年代中所有存活 对象的标记. 因为之前的预清理阶段是并发执行的，有可 能 GC 线程跟不上应用程序的修改速度。所以需要一次 STW 暂停来处理各种复杂的情况。 通常 CMS 会尝试在年轻代尽可能空的情况下执行 Final  Remark 阶段，以免连续触发多次 STW 事件</li>
</ul>
</li>
<li>Concurrent Sweep（并发清除）<ul>
<li>此阶段与应用程序并发执行，不需要 STW 停顿。JVM 在此 阶段删除不再使用的对象，并回收他们占用的内存空间</li>
</ul>
</li>
<li>Concurrent Reset（并发重置）<ul>
<li>此阶段与应用程序并发执行，重置 CMS 算法相关的内部 数据，为下一次 GC 循环做准备</li>
</ul>
</li>
</ul>
</li>
<li>CMS 垃圾收集器在减少停顿时间上做了很多复杂而有用的工作，用于垃圾回收的并发线程执 行的同时，并不需要暂停应用线程。 当然， CMS 也有一些缺点，其中最大的问题就是老年代内存碎片问题（因为不压缩），在某些情况 下 GC 会造成不可预测的暂停时间，特别是堆 内存较大的情况下</li>
</ul>
<h5 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h5><ul>
<li><p><code>-XX:+UseG1GC</code></p>
</li>
<li><p>G1 的全称是 Garbage -First，意为垃圾优先，哪 一块的垃圾最多就优先清理它</p>
</li>
<li><p>G1 GC 最主要的设计目标是：将 STW 停顿的时间 和分布，变成可预期且可配置的</p>
</li>
<li><p>G1 GC 是一款软实时垃圾收集器，可以为 其设置某项特定的性能指标。为了达成可预期停顿 时间的指标，G1 GC 有一些独特的实现</p>
<ul>
<li>堆不再分成年轻代和老年代，而是划分为多 个（通常是 2048 个）可以存放对象的 小块堆区域 (smaller heap regions)</li>
<li>每个小块，可能一会被 定义成 Eden 区，一会被指定为 Survivor区或者 Old 区</li>
<li>所有的 Eden 区和 Survivor 区合起来就是年轻代，所有的 Old 区拼在一起那 就是老年代</li>
<li>这样划分之后，使得 G1 不必每次都去收集整 个堆空间，而是以增量的方式来进行处理:  每 次只处理一部分内存块，称为此次 GC 的回收 集(collection set)。每次 GC 暂停都会收集所 有年轻代的内存块，但一般只包含部分老年代 的内存块</li>
</ul>
</li>
<li><p>G1 的另一项创新是，在并发阶段估算每个小 堆块存活对象的总数。构建回收集的原则是： 垃圾最多的小块会被优先收集。这也是 G1  名 称的由来</p>
</li>
<li><p>G1 GC –配置参数</p>
<ul>
<li><code>-XX:+UseG1GC</code>：启用 G1 GC； </li>
<li><code>-XX:G1NewSizePercent</code>：初始年轻代占整个 Java Heap 的大小，默认值为 5%； </li>
<li><code>-XX:G1MaxNewSizePercent</code>：最大年轻代占整个 Java Heap 的大小，默认值为 60%； </li>
<li><code>-XX:G1HeapRegionSize</code>：设置每个 Region 的大小，单位 MB，需要为 1，2，4，8，16，32 中的某个值，默 认是堆内存的 1&#x2F;2000。如果这个值设置比较大，那么大对象就可以进入 Region 了。 </li>
<li><code>-XX:ConcGCThreads</code>：与 Java 应用一起执行的 GC 线程数量，默认是 Java 线程的 1&#x2F;4，减少这个参数的数值可 能会提升并行回收的效率，提高系统内部吞吐量。如果这个数值过低，参与回收垃圾的线程不足，也会导致并行回 收机制耗时加长。 </li>
<li><code>-XX:+InitiatingHeapOccupancyPercent</code>（简称 IHOP）：G1 内部并行回收循环启动的阈值，默认为 Java Heap 的 45%。这个可以理解为老年代使用大于等于 45% 的时候，JVM 会启动垃圾回收。这个值非常重要，它决定了在 什么时间启动老年代的并行回收。 </li>
<li><code>-XX:G1HeapWastePercent</code>：G1停止回收的最小内存大小，默认是堆大小的 5%。GC 会收集所有的 Region 中 的对象，但是如果下降到了 5%，就会停下来不再收集了。就是说，不必每次回收就把所有的垃圾都处理完，可以 遗留少量的下次处理，这样也降低了单次消耗的时间。 </li>
<li><code>-XX:G1MixedGCCountTarget</code>：设置并行循环之后需要有多少个混合 GC 启动，默认值是 8 个。老年代 Region的回收时间通常比年轻代的收集时间要长一些，所以如果混合收集器比较多，可以允许G1延长老年代的收集时间</li>
<li><code>-XX:+G1PrintRegionLivenessInfo</code>：这个参数需要和 <code>-XX:+UnlockDiagnosticVMOptions</code> 配合启动，打印 JVM 的调试信 息，每个 Region 里的对象存活信息。 </li>
<li><code>-XX:G1ReservePercent</code>：G1 为了保留一些空间用于年代之间的提升，默认值是堆空间的 10%。因为大量执行回收的地方在 年轻代（存活时间较短），所以如果你的应用里面有比较大的堆内存空间、比较多的大对象存活，这里需要保留一些内存。</li>
<li><code>-XX:+G1SummarizeRSetStats</code>：这也是一个 VM 的调试信息。如果启用，会在 VM 退出的时候打印出 Rsets 的详细总结信 息。如果启用 </li>
<li><code>-XX:G1SummaryRSetStatsPeriod</code>： 参数，就会阶段性地打印 Rsets 信息。 </li>
<li><code>-XX:+G1TraceConcRefinement</code>：这个也是一个 VM 的调试信息，如果启用，并行回收阶段的日志就会被详细打印出来。 </li>
<li><code>-XX:+GCTimeRatio</code>：这个参数就是计算花在 Java 应用线程上和花在 GC 线程上的时间比率，默认是 9，跟新生代内存的分 配比例一致。这个参数主要的目的是让用户可以控制花在应用上的时间，G1 的计算公式是 100&#x2F;（1+GCTimeRatio）。这样 如果参数设置为 9，则最多 10% 的时间会花在 GC 工作上面。Parallel GC 的默认值是 99，表示 1% 的时间被用在 GC 上面， 这是因为 Parallel GC 贯穿整个 GC，而 G1 则根据 Region 来进行划分，不需要全局性扫描整个内存堆。 </li>
<li><code>-XX:+UseStringDeduplication</code>：手动开启 Java String 对象的去重工作，这个是 JDK8u20 版本之后新增的参数，主要用于 相同 String 避免重复申请内存，节约 Region 的使用。 -XX：MaxGCPauseMills：预期 G1 每次执行 GC 操作的暂停时间，单位是毫秒，默认值是 200 毫秒，G1 会尽量保证控制在 这个范围内</li>
</ul>
</li>
<li><p>G1 GC的处理步骤</p>
<ul>
<li><p>年轻代模式转移暂停（Evacuation Pause）</p>
<ul>
<li>G1 GC 会通过前面一段时间的运行情况来不断的调整自己的回收策略和行为，以此来比较稳定地控制 暂停时间。在应用程序刚启动时，G1 还没有采集到什么足够的信息，这时候就处于初始的 fullyyoung 模式。当年轻代空间用满后，应用线程会被暂停，年轻代内存块中的存活对象被拷贝到存活 区。如果还没有存活区，则任意选择一部分空闲的内存块作为存活区</li>
</ul>
</li>
<li><p>并发标记（Concurrent Marking）</p>
<ul>
<li><p>G1 并发标记的过程与 CMS 基本上是一样的。G1 的并发标记通过 Snapshot-At-The-Beginning（起始 快照）的方式，在标记阶段开始时记下所有的存活对象。即使在标记的同时又有一些变成了垃圾。通过 对象的存活信息，可以构建出每个小堆块的存活状态，以便回收集能高效地进行选择，这些信息在接下来的阶段会用来执行老年代区域的垃圾收集</p>
</li>
<li><p>有两种情况时可以并发执行</p>
<ul>
<li>如果在标记阶段确定某个小堆块中没有存活对象，只包含垃圾</li>
<li>在 STW 转移暂停期间，同时包含垃圾和存活对象的老年代小堆块</li>
</ul>
</li>
<li><p>处理</p>
<ul>
<li>Initial Mark（初始标记）<ul>
<li>此阶段标记所有从 GC 根对象直接可达的对象</li>
</ul>
</li>
<li>Root Region Scan（Root区扫描）<ul>
<li>此阶段标记所有从 “根区域” 可达的存活对象。根区域包括：非空的区域，以及在标记过程中不得不收集的区域</li>
</ul>
</li>
<li>Concurrent Mark（并发标记）<ul>
<li>此阶段和 CMS 的并发标记阶段非常类似：只遍历对象图，并在一个特殊的位图中标记能访问到的对象</li>
</ul>
</li>
<li>Remark（再次标记）<ul>
<li>这是一次 STW 停顿(因为不是并发的阶段)，以完成标记过程。 G1 收集器会短暂地停止应用线程， 停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标记开始时未被标记的存活对象</li>
</ul>
</li>
<li>Cleanup（清理）<ul>
<li>清理阶段为即将到来的转移阶段做准备，统计小堆块中所有存活的对象，并将小堆块进行排序，以提升 GC 的效率，维护并发标记的内部状态。 所有不包含存活对象的小堆块在此阶段都被回收了。有一部分任务是并发 的：例如空堆区的回收，还有大部分的存活率计算。此阶段也需要一个短暂的 STW 暂停</li>
</ul>
</li>
</ul>
</li>
<li><p>转移暂停: 混合模式（Evacuation Pause (mixed)）</p>
<ul>
<li><p>并发标记完成之后，G1将执行一次混合收集（mixed collection），就是不只清理年轻代，还将一部 分老年代区域也加入到 回收集 中。混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历 史数据会影响混合模式的启动时机。比如，假若在老年代中可以并发地腾出很多的小堆块，就没有必 要启动混合模式</p>
<p>因此，在并发标记与混合转移暂停之间，很可能会存在多次 young 模式的转移暂停</p>
<p>具体添加到回收集的老年代小堆块的大小及顺序，也是基于许多规则来判定的。其中包括指定的软实 时性能指标，存活性，以及在并发标记期间收集的 GC 效率等数据，外加一些可配置的 JVM 选项。混 合收集的过程，很大程度上和前面的 fully-young gc 是一样的</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>G1 GC 注意事项</p>
<ul>
<li><p>某些情况下 G1 触发了 Full GC，这时 G1 会退化使用 Serial 收集器来完成垃圾的清理工作， 它仅仅使用单线程来完成 GC 工作，GC 暂停时间将达到秒级别的</p>
<ul>
<li><p>并发模式失败</p>
<p>G1 启动标记周期，但在 Mix GC 之前，老年代就被填满，这时候 G1 会放弃标记周期。解决办法：增加堆大小，或者调整周期（例如增加线程数<code>-XX:ConcGCThreads</code>）</p>
</li>
<li><p>晋升失败</p>
<p>没有足够的内存供存活对象或晋升对象使用，由此触发了 Full GC(to-space exhausted&#x2F;to-space overflow）</p>
<ul>
<li>解决方法<ol>
<li>增加 <code>–XX:G1ReservePercent</code> 选项的值（并相应增加总的堆大小）增加预留内存量</li>
<li>通过减少 <code>–XX:InitiatingHeapOccupancyPercent</code> 提前启动标记周期</li>
<li>也可以通过增加 <code>–XX:ConcGCThreads</code> 选项的值来增加并行标记线程的数目</li>
</ol>
</li>
</ul>
</li>
<li><p>巨型对象分配失败</p>
<p>当巨型对象找不到合适的空间进行分配时，就会启动 Full GC，来释放空间</p>
<ul>
<li>解决方法：增加内存或者增大 <code>-XX:G1HeapRegionSize</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="各个GC对比图"><a href="#各个GC对比图" class="headerlink" title="各个GC对比图"></a>各个GC对比图</h5><p>​	<img src="/2022/05/21/jvm-xue-xi/image-20220521230335965.png" class="asset-class" title="image-20220521230335965"></p>
<h5 id="常用GC组合"><a href="#常用GC组合" class="headerlink" title="常用GC组合"></a>常用GC组合</h5><ul>
<li>Serial+Serial Old 实现单线程的低延迟 垃圾回收机制</li>
<li>ParNew+CMS，实现多线程的低延迟垃 圾回收机制</li>
<li>Parallel Scavenge和Parallel  Scavenge Old，实现多线程的高吞吐量垃圾 回收机制</li>
</ul>
<h5 id="如何选择正确GC"><a href="#如何选择正确GC" class="headerlink" title="如何选择正确GC"></a>如何选择正确GC</h5><ul>
<li>如果系统考虑吞吐优先，CPU 资源都用来最大程度处理业务，用 Parallel GC</li>
<li>如果系统考虑低延迟有限，每次 GC 时间尽量短，用 CMS GC</li>
<li>如果系统内存堆较大，同时希望整体来看平均 GC 时间可控，使用 G1 GC<ul>
<li>一般 4G 以上，算是比较大，用 G1 的性价比较高</li>
<li>一般超过 8G，比如 16G-64G 内存，非常推荐使用 G1 GC</li>
</ul>
</li>
</ul>
<h5 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h5><ul>
<li>JDK11之后支持</li>
<li><code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx16g</code></li>
<li>ZGC主要特点<ul>
<li>GC 最大停顿时间不超过 10ms</li>
<li>堆内存支持范围广，小至几百 MB 的堆空间，大至 4TB 的超大堆 内存（JDK13 升至 16TB）</li>
<li>与 G1 相比，应用吞吐量下降不超过 15%</li>
<li>通过着色指针和读屏障，实现几乎全部的并发执行，几毫 秒级别的延迟，线性可扩展</li>
</ul>
</li>
</ul>
<h5 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h5><ul>
<li><code>-XX:+UnlockExperimentalVMOptions - XX:+UseShenandoahGC -Xmx16g</code></li>
</ul>
<p>可以看出 GC 算法和实现的演进路线</p>
<ol>
<li>串行 -&gt; 并行: 重复利用多核 CPU 的优势，大幅降低 GC 暂停时间，提升吞吐量</li>
<li>并行 -&gt; 并发： 不只开多个 GC 线程并行回收，还将GC操作拆分为多个步骤，让很多繁重的任务和应用线程一起并 发执行，减少了单次 GC 暂停持续的时间，这能有效降低业务系统的延迟</li>
<li>CMS -&gt; G1： G1 可以说是在 CMS 基础上进行迭代和优化开发出来的，划分为多个小堆块进行增量回收，这样就更 进一步地降低了单次 GC 暂停的时间</li>
<li>G1 -&gt; ZGC:：ZGC 号称无停顿垃圾收集器，这又是一次极大的改进。ZGC 和 G1 有一些相似的地方，但是底层的算法 和思想又有了全新的突破</li>
</ol>
<h3 id="Parallel-GC、CMS-GC、G1-GC"><a href="#Parallel-GC、CMS-GC、G1-GC" class="headerlink" title="Parallel GC、CMS GC、G1 GC"></a>Parallel GC、CMS GC、G1 GC</h3><img src="/2022/05/21/jvm-xue-xi/image-20220521231711959.png" class="asset-class" title="image-20220521231711959">

<h3 id="GC日志查看命令"><a href="#GC日志查看命令" class="headerlink" title="GC日志查看命令"></a>GC日志查看命令</h3><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><pre><code class="prettyprint">package com.rocpenghua.gc;

import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.LongAdder;

/**
 * Describe:
 * 演示GC日志生成
 *
 * @author RocPengHua
 * @date 2022/5/22.
 */
public class GCLogAnalysis &#123;
    private static Random random = new Random();

    public static void main(String[] args) &#123;
        //当前毫秒时间戳
        long startMillis = System.currentTimeMillis();
        //持续运行毫秒数
        long timeOutMillis = TimeUnit.SECONDS.toMillis(1);
        //结束时间戳
        long endMillis = startMillis + timeOutMillis;

        LongAdder counter = new LongAdder();
        System.out.println(&quot;正在执行&quot;);
        //缓存一部分对象；进入老年代
        int cacheSize = 2000;
        Object[] cachedGarbage = new Object[cacheSize];
        //在此时间范围内持续循环
        while (System.currentTimeMillis() &lt; endMillis) &#123;
            //生成垃圾对象
            Object garbage = generateGarbage(100 * 1024);
            counter.increment();
            int randomIndex = random.nextInt(2 * cacheSize);
            if (randomIndex &lt; cacheSize) &#123;
                cachedGarbage[randomIndex] = garbage;
            &#125;
        &#125;
        System.out.println(&quot;执行结束！共生成对象次数：&quot; + counter.longValue());
    &#125;

    private static Object generateGarbage(int max) &#123;
        int randomSize = random.nextInt(max);
        int type = randomSize % 4;
        Object result = null;
        switch (type) &#123;
            case 0:
                result = new int[randomSize];
                break;
            case 1:
                result = new byte[randomSize];
                break;
            case 2:
                result = new double[randomSize];
            default:
                StringBuilder builder = new StringBuilder();
                String randomString = &quot;randomString-Anything&quot;;
                while (builder.length() &lt; randomSize) &#123;
                    builder.append(randomString);
                    builder.append(max);
                    builder.append(randomSize);
                &#125;
                result = builder.toString();
                break;

        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<ul>
<li><p><code>java -XX:+PrintGCDetails com.rocpenghua.gc.GCLogAnalysis</code>：打印GC详细信息</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220522105901086.png" class="asset-class" title="image-20220522105901086">
</li>
<li><p><code>java -XX:+PrintGC com.rocpenghua.gc.GCLogAnalysis</code>：打印GC信息</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220522110044459.png" class="asset-class" title="image-20220522110044459">
</li>
<li><p><code>java -Xloggc:com.rocpenghua.gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps com.rocpenghua.gc.GCLogAnalysis</code>：GC信息保存到日志</p>
</li>
<li><p><code>java -Xmx128m -XX:+PrintGCDetails com.rocpenghua.gc.GCLogAnalysis</code>：指定最大堆</p>
<ul>
<li><p>堆内存太小GC次数变多</p>
<p>​	1.<img src="/2022/05/21/jvm-xue-xi/image-20220522110158184.png" class="asset-class" title="image-20220522110158184"></p>
<p>​	2.<img src="/2022/05/21/jvm-xue-xi/image-20220522110213797.png" class="asset-class" title="image-20220522110213797"></p>
<p>​	3.<img src="/2022/05/21/jvm-xue-xi/image-20220522110228153.png" class="asset-class" title="image-20220522110228153"></p>
</li>
</ul>
</li>
<li><p><code>java -XX:+UseSerialGC -Xms512m -Xmx512m -Xloggc:gc.UseSerialGC.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps com.rocpenghua.gc.GCLogAnalysis</code>：使用串行GC记录日志</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220522110317985.png" class="asset-class" title="image-20220522110317985">
</li>
<li><p><code>java -XX:+UseParallelGC -Xms512m -Xmx512m -XX:+PrintGCDetails -XX:+PrintGCDateStamps com.rocpenghua.gc.GCLogAnalysis</code>：使用并行GC</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220522110340790.png" class="asset-class" title="image-20220522110340790">
</li>
<li><p><code>java -XX:+UseConcMarkSweepGC -Xms512m -Xmx512m -XX:+PrintGCDetails -XX:+PrintGCDateStamps com.rocpenghua.gc.GCLogAnalysis</code>：使用CMS GC</p>
<p>1.<img src="/2022/05/21/jvm-xue-xi/image-20220522110411696.png" class="asset-class" title="image-20220522110411696"></p>
<p>​	2.<img src="/2022/05/21/jvm-xue-xi/image-20220522110436211.png" class="asset-class" title="image-20220522110436211"></p>
<p>​	3.CMS GC 六个阶段</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220522110533123.png" class="asset-class" title="image-20220522110533123">
</li>
<li><p><code>java -XX:+UseG1GC -Xms512m -Xmx512m -XX:+PrintGCDetails -XX:+PrintGCDateStamps com.rocpenghua.gc.GCLogAnalysis</code>：使用G1 GC</p>
<p>​	1.<img src="/2022/05/21/jvm-xue-xi/image-20220522110617225.png" class="asset-class" title="image-20220522110617225"></p>
<p>​	2.<img src="/2022/05/21/jvm-xue-xi/image-20220522110632399.png" class="asset-class" title="image-20220522110632399"></p>
<p>​	3.<img src="/2022/05/21/jvm-xue-xi/image-20220522110827654.png" class="asset-class" title="image-20220522110827654"></p>
<p>​	4.<img src="/2022/05/21/jvm-xue-xi/image-20220522110844810.png" class="asset-class" title="image-20220522110844810"></p>
<p>​	5.<img src="/2022/05/21/jvm-xue-xi/image-20220522110901768.png" class="asset-class" title="image-20220522110901768"></p>
</li>
<li><p><code>java -XX:+UseG1GC -Xms512m -Xmx512m -XX:+PrintGC -XX:+PrintGCDateStamps com.rocpenghua.gc.GCLogAnalysis</code>：使用G1 GC</p>
<p>​	1.<img src="/2022/05/21/jvm-xue-xi/image-20220522110926764.png" class="asset-class" title="image-20220522110926764"></p>
</li>
</ul>
<p>2.<img src="/2022/05/21/jvm-xue-xi/image-20220522110949162.png" class="asset-class" title="image-20220522110949162"></p>
<h3 id="GC配置参数"><a href="#GC配置参数" class="headerlink" title="GC配置参数"></a>GC配置参数</h3><ul>
<li><p>日志相关</p>
<ul>
<li><p><code>-XX:+PrintGC</code>：打印GC信息</p>
</li>
<li><p><code>-verbose:gc</code>：打印GC信息</p>
</li>
<li><p><code>-XX:+PrintGCDetails</code>：打印GC详细信息</p>
</li>
<li><p><code>-XX:+PrintGCDateStamps</code>：添加时间戳</p>
</li>
<li><p><code>-Xloggc:gc.UseSerialGC.log</code>：将GC记录日志文件</p>
</li>
<li><p><code>-XX:+TranceClassLoading</code>：监控类的加载情况</p>
</li>
</ul>
</li>
<li><p>堆参数分配</p>
<ul>
<li><code>-Xmx</code>：最大堆<code>-XX:MaxHeapSize</code></li>
<li><code>-Xms</code>：初始堆<code>-XX:InitialHeapSize</code></li>
<li><code>-Xmn</code>：新生代内存</li>
<li><code>-XX:NewRatio</code>：新生代和老年代的比值（默认1:2）2</li>
<li><code>-XX:SurvivorRatio</code>：年轻代和永久代（S0&#x2F;S1）的比值（默认8:1）8</li>
<li><code>-XX:NewSize</code>：年轻代的大小</li>
<li><code>-XX:MaxNewSize</code>：年轻代最大大小</li>
<li><code>-XX:OldSize</code>：老年代大小</li>
<li><code>-XX:MetaspaceSize</code>：方法区大小</li>
<li><code>-XX:MaxMetaspaceSize</code>：方法区最大大小</li>
</ul>
</li>
<li><p>GC</p>
<ul>
<li><code>-XX:+UseSerialGC</code>：串行GC</li>
<li><code>-XX:+UseParallelGC</code>：并行GC（新生代，吞吐量优先）</li>
<li><code>-XX:+UseParallelOldGC</code>：并行GC（老年代，吞吐量优先）</li>
<li><code>-XX:+UseConcMarkSweepGC</code>：CMS GC（老年代，延迟时间优先）<ul>
<li><code>-XX:ConcGCThreads</code>：CMS并非垃圾收集器使用的线程数量</li>
</ul>
</li>
<li><code>-XX:+UseG1GC</code>：G1 GC（新生代，老年代，延迟时间优先）<ul>
<li><code>-XX:G1HeapRegionSize</code>：设置每个region大小</li>
<li><code>-XX:G1HeapWastePercent</code>：允许的浪费堆空间的占比，默认10%</li>
<li><code>-XX:MaxGCPauseMillis</code>：G1最大停顿时间，默认200ms</li>
<li><code>XX:G1MixedGCLiveThresholdPercent</code>：混合垃圾回收周期中要包括的旧区域设置占用率阈值，默认65%</li>
<li><code>-XX:G1MixedGCCountTarget</code>：设置标记周期完成后，对存活数据上限为G1MixedGCLIveThresholdPercent 的旧区域执行混合垃圾回收的目标次数，默认8次</li>
<li><code>-XX:G1OldCSetRegionThresholdPercent=1</code>：描述Mixed GC时，Old Region被加入到CSet中，默认情况下，G1只把10%的Old Region加入到CSet中</li>
</ul>
</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：启动堆内存溢出打印，OOM自动生成dump文件</li>
<li><code>-XX:HeapDumpPath=heap.hprof</code>：指定堆内存溢出打印目录</li>
<li><code>-Xss</code>：设置线程的堆栈大小</li>
<li><code>-XX:MaxTenuringThreshold</code>：提升老年代的最大临界值，默认15</li>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>：启动并发GC周期时堆内存使用占比，默认45%</li>
</ul>
</li>
</ul>
<h3 id="压测工具sb"><a href="#压测工具sb" class="headerlink" title="压测工具sb"></a>压测工具<code>sb</code></h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li>管理员打开powershell</li>
<li>执行命令</li>
</ul>
<pre><code class="prettyprint">Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))
</code></pre>
<ul>
<li>执行</li>
</ul>
<pre><code class="prettyprint">choco install superbenchmarker
</code></pre>
<ul>
<li>输入<code>sb</code>查看帮助文档</li>
</ul>
<pre><code class="prettyprint">sb
</code></pre>
<ul>
<li>测试</li>
</ul>
<pre><code class="prettyprint">#20并发60秒
sb -u &#39;http://localhost:8080/api/hello&#39; -c 20 -N 60
</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>prettyprint</title>
    <url>/2022/05/28/prettyprint/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code class="prettyprint">public class PrettyPrint &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;Hello World！&quot;)
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>mysql主从配置</title>
    <url>/2022/06/03/mysql-zhu-cong-pei-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="主节点配置"><a href="#主节点配置" class="headerlink" title="主节点配置"></a>主节点配置</h3><pre><code class="prettyprint">#登录主节点
E:\tools\database\mysql-8.0.11-winx64-1\bin&gt;mysql -uroot
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 12
Server version: 8.0.11 MySQL Community Server - GPL

Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.

mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.00 sec)

mysql&gt; CREATE USER &#39;rep1&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;
Query OK, 0 rows affected (0.11 sec)
mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &#39;rep1&#39;@&#39;%&#39;;
Query OK, 0 rows affected (0.06 sec)

mysql&gt; flush privileges;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; show master status;
+---------------+----------+--------------+------------------+-------------------+
| File          | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+---------------+----------+--------------+------------------+-------------------+
| binlog.000001 |     2283 |              |                  |                   |
+---------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
</code></pre>
<h3 id="配置从节点"><a href="#配置从节点" class="headerlink" title="配置从节点"></a>配置从节点</h3><pre><code class="prettyprint">mysql&gt; CHANGE MASTER TO
         MASTER_HOST=&#39;localhost&#39;,
         MASTER_PORT=3306,
         MASTER_USER=&#39;rep1&#39;,
         MASTER_PASSWORD=&#39;123456&#39;,
         MASTER_LOG_FILE=&#39;binlog.000001&#39;,
         MASTER_LOG_POS=2283;
Query OK, 0 rows affected, 1 warning (0.28 sec)
mysql&gt; start slave;
mysql&gt; show slave status\G;
</code></pre>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>mysql事务</title>
    <url>/2022/06/03/mysql-shi-wu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h1><ul>
<li><p>原子性(Atomicity)：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。（针对于操作层面）</p>
</li>
<li><p>一致性(Consistent) ：在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性。（针对于数据层面）</p>
</li>
<li><p>隔离性(Isolation) ：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。</p>
</li>
<li><p>持久性(Durable) ：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。</p>
</li>
</ul>
<h1 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h1><ul>
<li><p>更新丢失或者脏写(Lost Update)：当两个事务或者多个事务对同一条数据做更新时，后面提交的数据会覆盖前面的写数据；</p>
</li>
<li><p>脏读（Dirty Reads）：事务A读取到了还未提交事务B的数据；</p>
</li>
<li><p>不可重复读（Non-Repeatable Reads）：事务A和事务B同时begin时，事务B先提交了，事务A读取到了事务B已提交的数据；</p>
</li>
<li><p>幻读（Phantom Reads）：事务A和事务B同时begin时，事务B先提交了，事务A读取到了事务B已提交的新增数据；</p>
</li>
</ul>
<h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><img src="/2022/06/03/mysql-shi-wu/12776164-7c040c7df6900659.png" class="asset-class" title="img">

<h1 id="MVCC机制"><a href="#MVCC机制" class="headerlink" title="MVCC机制"></a>MVCC机制</h1><p>读已提交和可重复读都是用了MVCC（Multi-Version Concurrency Control）机制；</p>
<p>首先mysql会为每一行数据，多维护trx_id（事务id，一般是自增的）和roll_pointer（回滚指针，上一个版本的指针）；再会维护一个undo日志，每当数据有更新时，先把历史版本数据写入undo日志，便于以后回滚；</p>
<img src="/2022/06/03/mysql-shi-wu/12776164-9399ca1bbd0143fe.png" class="asset-class" title="img">

<p><code>undo日志结构</code></p>
<p>MVCC机制：在事务开启后，第一个查询语句执行之前，会把当前数据库存在的未提交事务放在一个readView集合中，获取一个当前数据库最大的事务id（max_id）；再从readView中选出最小的事务id（min_id）;因为事务是自增的；所以当事务开启后，查询到的数据</p>
<ul>
<li><p>如果trx_id的版本号小于min_id则说明当前这个版本号肯定是在我这个事务开启前已提交的，则是可见的，可以查询出来的数据；</p>
</li>
<li><p>如果大于min_id且小于max_id，则需要去看是否在readView集合中，如果在该集合中，则该事务未提交，则是不可见的，需要根据roll_pointer去查找上个版本的数据，直到查找到复核规则的数据；</p>
</li>
<li><p>如果是大于max_id，因为事务id是自增的，则该事务肯定是我查询之后才插入的数据，所以该数据是不可见的，则需要查找上个版本数据，直到查找到复核规则的数据；</p>
</li>
</ul>
<p>mysql默认使用可重复读（RR）级别，是上述规则；当使用读已提交，区别在于，每次查询语句都会生成一个当前的readView；</p>
<p>链接：<a href="https://www.jianshu.com/p/142e7ee32b86">https://www.jianshu.com/p/142e7ee32b86</a></p>
]]></content>
      <categories>
        <category>数据</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发</title>
    <url>/2022/05/28/java-bing-fa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="synchronized特性"><a href="#synchronized特性" class="headerlink" title="synchronized特性"></a>synchronized特性</h3><ul>
<li><p>对普通方法加锁，锁是当前实例对象</p>
<pre><code class="prettyprint">public synchronized void test(Object obj)&#123;
   //TODO 
&#125;
</code></pre>
</li>
<li><p>对静态方法加锁，锁是当前类实例，因为类数据存在永久代&#x2F;元空间，因此静态方法锁就是该类的全局锁</p>
<pre><code class="prettyprint">public static synchronized void test(Object obj)&#123;
   //TODO 
&#125;
</code></pre>
</li>
<li><p>对对象加锁，锁是<code>synchronized</code>括号里的对象实例</p>
<pre><code class="prettyprint">synchronized(Object o) &#123;
    //TODO
&#125;
</code></pre>
</li>
</ul>
<h3 id="synchronized的同步实现"><a href="#synchronized的同步实现" class="headerlink" title="synchronized的同步实现"></a>synchronized的同步实现</h3><ul>
<li><p><code>synchronized</code>的锁的实现是基于JVM进入和退出monitor对象来实现的。</p>
</li>
<li><p>monitor对象有2个关键指令monitorenter和monitorexit,具体就是在编译过程中把monitorenter指令插入到同步代码块开始位置，把monitorexit指令插入退出或异常的位置。</p>
</li>
<li><p>线程执行同步代码块的时首先需要获取锁，即尝试获取monitor对象的所有权，具体过程如下</p>
<p>​		首先线程执行指令monitorenter指令尝试获取monitor的所有权，如果monitor的进入数为0，则线程进入进入monitor，并且把进入修改为1，当前线程就持有了锁；如果线程进入monitor时，发现进入数大于0，则会判断monitor的持有者是否为当前线程，如果是当前线程则表示只是重新进入，则对monitor的进入数+1；如果monitor的所有权不是被当前线程持有，线程进入阻塞状态，直到monitor的进入数等于0，再次重新获取monitor的所有权。</p>
</li>
</ul>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>每个对象分为三块区域:<em>对象头、实例数据和对齐填充</em>。</p>
<ul>
<li>对象头包含两部分，第一部分是Mark Word，用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等，这一部分占一个字节。第二部分是Klass Pointer（类型指针），是对象指向它的类元数据的指针，<em>虚拟机通过这个指针来确定这个对象是哪个类的实例</em>，这部分也占一个字节。(<em>如果对象是数组类型的，则需要3个字节来存储对象头，因为还需要一个字节存储数组的长度</em>)</li>
<li>实例数据存放的是类属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，<em>这部分内存按4字节对齐</em>。</li>
<li>填充数据是因为虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</li>
</ul>
<p>对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机 中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码(HashCode)，4Bits用于存储对象分代年龄，2Bits用于存储锁标志 位，1Bit固定为0，在其他状态(轻量级锁定、重量级锁定、GC标记、可偏向)下对象的存储内容如下表所示</p>
<img src="/2022/05/28/java-bing-fa/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70.png" class="asset-class" title="对象头存储结构">

<p>从对象头的存储内容可以看出<strong>锁的状态都保存在对象头</strong>中，Synchronized也不例外，当其从轻量级锁膨胀为重量级锁时，锁标识位为10，其中<em>指针指向的是monitor对象</em>(也称为管程或监视器锁)的起始地址。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提升程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。<br>但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p>
<ul>
<li>获取锁</li>
</ul>
<ol>
<li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li>
<li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤(5)，否则执行步骤(3)；</li>
<li>如果线程ID不为当前线程ID，则<strong>通过CAS操作竞争锁</strong>，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程(4)；</li>
<li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li>
<li>执行同步代码块</li>
</ol>
<ul>
<li>释放锁</li>
</ul>
<p>偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）</p>
<ol>
<li>暂停拥有偏向锁的线程，判断锁对象是否还处于被锁定状态；</li>
<li>撤销偏向锁，恢复到无锁状态(01)或者轻量级锁的状态；</li>
</ol>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>引入轻量级锁的主要原因是，对绝大部分的锁，在整个同步周期内都不存在竞争，可能是交替获取锁然后执行。(<strong>与偏向锁的区别是，引入偏向锁是假设同一个锁都是由同一线程多次获得，而轻量级锁是假设同一个锁是由n个线程交替获得；相同点是都是假设不存在多线程竞争</strong>)<br>引入轻量级锁的主要目的是，在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗(多指时间消耗)。<br>触发轻量级锁的条件是当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，此时Mark Word的结构也变为轻量级锁的结构。<strong>如果存在多个线程同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁</strong>。</p>
<ul>
<li>获取锁<ol>
<li>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的<em>栈帧</em>中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</li>
<li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li>
<li>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li>
</ol>
</li>
<li>释放锁<ol>
<li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li>
<li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li>
<li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li>
</ol>
</li>
</ul>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p>
<p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。如果自旋之后依然没有获取到锁，也就只能升级为重量级锁了。</p>
<ol>
<li>当一个线程(假设叫A线程)想要获得锁时，首先检查对象头中的锁标志，如果是偏向锁，则跳转到2,如果是无锁状态，则跳转到3</li>
<li>检查对象头中的偏向线程id是否指向A线程，是,则直接执行同步代码块,不是则3。</li>
<li>使用cas操作将替换对象头中的偏向线程id,成功，则直接执行同步代码块。失败则说明其他的线程(假设叫B线程)已经拥有偏向锁了,那么进行偏向锁的撤销(因为这里有竞争了)，此时执行4。</li>
<li>B线程运行到全局安全点后，暂停该线程，检查它的状态,如果处于不活动或者已经退出同步代码块则原持有偏向锁的线程释放锁，然后A再次执行3。如果仍处于活动状态，则需要升级为轻量级锁，此时执行5。</li>
<li>在B线程的栈中分配锁记录，拷贝对象头中的MarkWord到锁记录中，然后将MarkWord改为指向B线程，同时将对象头中的锁标志信息改为轻量级锁的00,然后唤醒B线程，也就是从安全点处继续执行。</li>
<li>由于锁升级为轻量级锁, A线程也进行相同的操作，即，在A线程的栈中分配锁记录，拷贝对象头中的Mark Word到锁记录中，然后使用cas操作替换MarkWord,因为此时B线程拥有锁，因此, A线程自旋。如果自旋一定次数内成功获得锁，那么A线程获得轻量级锁，执行同步代码块。若自旋后仍未获得锁，A升级为重量级锁，将对象头中的锁标志信息改为重量级的10，同时阻塞,此时请看7。</li>
<li>B线程在释放锁的时候，使用cas将MarkWord中的信息替换，成功，则表示无竞争(这个时候还是轻量级锁, A线程可能正在自旋中)直接释放。失败(因为这个时候锁已经膨胀)，那么释放之 后唤醒被挂起的线程(在这个例子中，也就是A)。</li>
</ol>
<h3 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h3><ul>
<li><p>自旋与自适应自旋</p>
<p>如果持有锁的线程能在很短时间内释放锁资源，就可以让线程执行一个忙循环（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。但是线程自旋需要消耗cpu的资源，如果一直得不到锁就会浪费cpu资源。因此在jdk1.6引入了自适应自旋锁，自旋等待的时候不固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
</li>
<li><p>锁消除</p>
<p>锁消除是指虚拟机即时编译器在运行时，对于一些代码上要求同步但是被检测不可能存在共享数据竞争的锁进行消除。例如String类型的连接操作，String是一个不可变对象，字符串的连接操作总是通过生成新的String对象来进行的，Javac编译器会对String连接做自动优化，在JDK1.5的版本中使用的是StringBuffer对象的append操作，StringBuffer的append方法是同步方法，这段代码在经过即时编译器编译之后就会忽略掉所有的同步直接执行。在JDK1.5之后是使用的StringBuilder对象的append操作来优化字符串连接的。</p>
</li>
<li><p>锁粗化</p>
<p>将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。例如每次调用StringBuffer.append方法都需要加锁，如果虚拟机检测到有一系列的连续操作都是对同一个对象反复加锁和解锁，就会将其合并成一个更大范围的加锁和解锁操作。</p>
</li>
</ul>
<h3 id="synchronized-方式的问题"><a href="#synchronized-方式的问题" class="headerlink" title="synchronized 方式的问题"></a>synchronized 方式的问题</h3><ul>
<li>同步块的阻塞无法中断（不能 Interruptibly）</li>
<li>同步块的阻塞无法控制超时（无法自动解锁）</li>
<li>同步块无法异步处理锁（即不能立即知道是否可以拿到锁）</li>
<li>同步块无法根据条件灵活的加锁解锁（即只能跟同步块范围一致）</li>
</ul>
<h2 id="juc"><a href="#juc" class="headerlink" title="juc"></a>juc</h2><h3 id="锁机制类"><a href="#锁机制类" class="headerlink" title="锁机制类"></a>锁机制类</h3><h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><ul>
<li><p>使用方式灵活可控</p>
</li>
<li><p>性能开销较小</p>
</li>
<li><p>接口设计</p>
<ul>
<li><p><code>void lock();</code>获取锁</p>
</li>
<li><p><code>void lockInterruptibly() throws InterruptedException;</code>获取锁; 允许打断;</p>
</li>
<li><p><code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</code>尝试获取锁; 成功则返回 true; 超时则退出</p>
</li>
<li><p><code>boolean tryLock();</code>尝试【无等待】获取锁; 成功则返回 true</p>
</li>
<li><p><code>void unlock</code>解锁；要求当前线程已获得锁; 类比同步块结束</p>
</li>
<li><p><code>Condition newCondition();</code>新增一个绑定到当前Lock的条件； </p>
<pre><code class="prettyprint">//示例: （类比: Object monitor） 
final Lock lock = new ReentrantLock(); 
final Condition notFull = lock.newCondition(); 
final Condition notEmpty = lock.newCondition();
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><ul>
<li><p>代码示例</p>
<ul>
<li><p><code>Count</code>类定义<code>ReentrantLock</code>的读写方法</p>
<pre><code class="prettyprint">public class Count &#123;

    final ReentrantLock lock = new ReentrantLock();

    public void get() &#123;
        try &#123;
            lock.lock();
            System.out.println(Thread.currentThread().getName() + &quot; get begin&quot;);
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + &quot; get end&quot;);
            lock.unlock();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public void put() &#123;
        try &#123;
            lock.lock();
            System.out.println(Thread.currentThread().getName() + &quot; put begin&quot;);
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + &quot; put end&quot;);
            lock.unlock();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p><code>ReentrantLockDemo</code>测试类</p>
<pre><code class="prettyprint">public class ReentrantLockDemo &#123;

    public static void main(String[] args) &#123;
        final Count count = new Count();

        for (int i = 0; i &lt; 2; i++) &#123;
            new Thread(count::get).start();
        &#125;

        for (int i = 0; i &lt; 2; i++) &#123;
            new Thread(count::put).start();
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>测试结果</p>
<img src="/2022/05/28/java-bing-fa/image-20220528215049400.png" class="asset-class" title="image-20220528215049400"></li>
</ul>
<h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><ul>
<li><p>ReadWriteLock 管理一组锁，一个读锁，一个写锁。</p>
</li>
<li><p>读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。</p>
</li>
<li><p>所有读写锁的实现必须确保写操作对读操作的内存影响。每次只能有一个写线程，但是 同时可以有多个线程并发地读数据。ReadWriteLock 适用于读多写少的并发情况。</p>
</li>
<li><p>代码示例</p>
<ul>
<li><p><code>Count2</code>类定义<code>ReentrantReadWriteLock</code>的读写方法</p>
<pre><code class="prettyprint">public class Count2 &#123;

    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();

    public void get() &#123;
        rwLock.readLock().lock();
        try &#123;
            System.out.println(Thread.currentThread().getName() + &quot; get begin&quot;);
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + &quot; get end&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            rwLock.readLock().unlock();
        &#125;
    &#125;

    public void put() &#123;
        rwLock.writeLock().lock();
        try &#123;
            System.out.println(Thread.currentThread().getName() + &quot; put begin&quot;);
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + &quot; put end&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            rwLock.writeLock().unlock();
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p><code>ReentrantReadWriteLockDemo</code> 测试类</p>
<pre><code class="prettyprint">public class ReentrantReadWriteLockDemo &#123;

    public static void main(String[] args) &#123;
        final Count2 count = new Count2();

        for (int i = 0; i &lt; 5; i++) &#123;
            new Thread(() -&gt; count.get()).start();
        &#125;

        for (int i = 0; i &lt; 5; i++) &#123;
            new Thread(() -&gt; count.put()).start();
        &#125;
    &#125;
    // 读锁不互斥、写锁互斥
&#125;
</code></pre>
</li>
<li><p>运行结果</p>
<img src="/2022/05/28/java-bing-fa/image-20220528223705002.png" class="asset-class" title="image-20220528223705002"></li>
</ul>
</li>
</ul>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>通过 lock.newCondition()创建。 可以看做是 Lock 对象上的信号。类似于 wait&#x2F;notify。</p>
<ul>
<li><code>void await() throws  InterruptedException;</code> 等待信号; 类比 Object#wait() </li>
<li><code>void awaitUninterruptibly();</code> 等待信号;  </li>
<li><code>boolean await(long time, TimeUnit unit) throws InterruptedException;</code> 等待信号; 超时则返回 false </li>
<li><code>boolean awaitUntil(Date deadline) throws InterruptedException;</code> 等待信号; 超时则返回 false </li>
<li><code>void signal();</code>给一个等待线程发送唤醒信号; 类比 Object#notify () </li>
<li><code>void signalAll();</code> 给所有等待线程发送唤醒信号; 类比 Object#notifyAll()</li>
</ul>
<p>测试</p>
<pre><code class="prettyprint">class ConditionDemo &#123;
    final Lock lock = new ReentrantLock();
    final Condition notFull  = lock.newCondition();
    final Condition notEmpty = lock.newCondition();
    
    final Object[] items = new Object[10];
    int putptr, takeptr, count;
    
    public void put(Object x) throws InterruptedException &#123;
        lock.lock();
        try &#123;
            // 当count等于数组的大小时，当前线程等待，直到notFull通知，再进行生产
            while (count == items.length)
                notFull.await();
            items[putptr] = x;
            if (++putptr == items.length) putptr = 0;
            ++count;
            notEmpty.signal();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
    
    public Object take() throws InterruptedException &#123;
        lock.lock();
        try &#123;
            // 当count为0，进入等待，直到notEmpty通知，进行消费。
            while (count == 0)
                notEmpty.await();
            Object x = items[takeptr];
            if (++takeptr == items.length) takeptr = 0;
            --count;
            notFull.signal();
            return x;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="LockSupport–锁当前线程"><a href="#LockSupport–锁当前线程" class="headerlink" title="LockSupport–锁当前线程"></a>LockSupport–锁当前线程</h4><p>LockSupport 类似于 Thread 类的静态方法，专门处理（执行这个代码的）本线程的</p>
<p>为什么 unpark 需要加一个线程作为参数？ 因为一个 park 的线程，无法自己唤醒自己，所以需要其他线程来唤醒。</p>
<ul>
<li><code>public static void park(Object blocker)</code> 暂停当前线程</li>
<li><code>public static void parkNanos(Object blocker, long nanos)</code> 暂停当前线程，有超时时间的限制</li>
<li><code>public static void parkUntil(Object blocker, long deadline)</code> 暂定当前线程，直到某个时间</li>
<li><code>public static void park()</code> 无期限暂停当前线程</li>
<li><code>public static void parkNanos(long nanos)</code> 暂停当前线程，有超时时间限制</li>
<li><code>public static void parkUntil(long deadline)</code> 暂定当前线程，直到某个时间</li>
<li><code>public static void unpark(Thread thread)</code>恢复当前线程</li>
<li><code>public static Object getBlocker(Thread t)</code></li>
</ul>
<p>测试</p>
<pre><code class="prettyprint">public class LockSupportDemo &#123;
    
    public static Object u = new Object();
    static ChangeObjectThread t1 = new ChangeObjectThread(&quot;t1&quot;);
    static ChangeObjectThread t2 = new ChangeObjectThread(&quot;t2&quot;);
    
    public static class ChangeObjectThread extends Thread &#123;
        public ChangeObjectThread(String name) &#123;
            super(name);
        &#125;
        @Override public void run() &#123;
            synchronized (u) &#123;
                System.out.println(&quot;in &quot; + getName());
                LockSupport.park();
                if (Thread.currentThread().isInterrupted()) &#123;
                    System.out.println(Thread.currentThread().getName() + &quot;被中断了&quot;);
                &#125;
                System.out.println(Thread.currentThread().getName() + &quot;继续执行&quot;);
            &#125;
        &#125;
    &#125;
    
    public static void main(String[] args) throws InterruptedException &#123;
        t1.start();
        Thread.sleep(1000L);
        t2.start();
        Thread.sleep(3000L);
        t1.interrupt();
        LockSupport.unpark(t2);
        t1.join();
        t2.join();
    &#125;
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220528224817320.png" class="asset-class" title="image-20220528224817320">

<h3 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h3><h4 id="java-util-concurrent-atomic"><a href="#java-util-concurrent-atomic" class="headerlink" title="java.util.concurrent.atomic"></a>java.util.concurrent.atomic</h4><img src="/2022/05/28/java-bing-fa/image-20220528225129911.png" class="asset-class" title="image-20220528225129911">

<h4 id="无锁技术的底层实现原理"><a href="#无锁技术的底层实现原理" class="headerlink" title="无锁技术的底层实现原理"></a>无锁技术的底层实现原理</h4><ul>
<li><p>Unsafe API - Compare-And-Swap</p>
</li>
<li><p>CPU 硬件指令支持: CAS 指令</p>
</li>
<li><p>核心实现原理：</p>
<ul>
<li><p>volatile 保证读写操作都可见（注意不保证原子）； </p>
<img src="/2022/05/28/java-bing-fa/image-20220528225929218.png" class="asset-class" title="image-20220528225929218">
</li>
<li><p>使用 CAS 指令，作为乐观锁实现，通过自旋重试保证写入</p>
<img src="/2022/05/28/java-bing-fa/image-20220528230009442.png" class="asset-class" title="image-20220528230009442">

<img src="/2022/05/28/java-bing-fa/image-20220528230022453.png" class="asset-class" title="image-20220528230022453">

<img src="/2022/05/28/java-bing-fa/image-20220528230039040.png" class="asset-class" title="image-20220528230039040"></li>
</ul>
</li>
</ul>
<h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>CAS 本质上没有使用锁。 并发压力跟锁性能的关系： </p>
<ul>
<li>压力非常小，性能本身要求就不高； </li>
<li>压力一般的情况下，无锁更快，大部分都一次写入；</li>
<li>压力非常大时，自旋导致重试过多，资源消耗很大。</li>
</ul>
<p>代码示例</p>
<ul>
<li><p><code>Count</code>增加获取工具类，无锁，非同步</p>
<pre><code class="prettyprint">public class Count &#123;

    private int num = 0;

    public int add() &#123;
        return num++;
    &#125;

    public int getNum() &#123;
        return num;
    &#125;
&#125;
</code></pre>
</li>
<li><p><code>SyncCount</code>增加和获取工具类，同步</p>
</li>
<li><p><code>AtomicCount</code>增加和获取工具类，原子类</p>
<pre><code class="prettyprint">public class AtomicCount &#123;

    private AtomicInteger num = new AtomicInteger();

    public int add() &#123;
        return num.getAndIncrement();
    &#125;

    public int getNum() &#123;
        return num.get();
    &#125;
&#125;
</code></pre>
</li>
<li><p>测试类</p>
<pre><code class="prettyprint">public class AtomicMain &#123;

    public static void main(String[] args) &#123;
//        final Count count = new Count(); // &lt;1000000
//        final SyncCount count = new SyncCount(); // 1000000
        final AtomicCount count = new AtomicCount(); // 1000000
        for (int i = 0; i &lt; 100; i++) &#123;
            new Thread(() -&gt; &#123;
                for (int j = 0; j &lt; 10000; j++) &#123;
                    count.add();
                &#125;
            &#125;).start();
        &#125;

        try &#123;
            Thread.sleep(5000L);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        System.out.println(&quot;num=&quot; + count.getNum());
    &#125;

&#125;
</code></pre>
<h4 id="LongAdder-对-AtomicLong-的改进"><a href="#LongAdder-对-AtomicLong-的改进" class="headerlink" title="LongAdder 对 AtomicLong 的改进"></a>LongAdder 对 AtomicLong 的改进</h4><pre><code class="prettyprint">LongAdder 的改进思路：
1、AtomicInteger 和 AtomicLong 里的 value 是所有
线程竞争读写的热点数据；
2、将单个 value 拆分成跟线程一样多的数组 Cell[]；
3、每个线程写自己的 Cell[i]++，最后对数组求和。
</code></pre>
</li>
</ul>
<h3 id="线程池相关类"><a href="#线程池相关类" class="headerlink" title="线程池相关类"></a>线程池相关类</h3><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><ul>
<li>单个线程&#x2F;任务的执行结果</li>
</ul>
<pre><code class="prettyprint">public class FutureDemo &#123;
    public static void main(String[] args) &#123;
        ExecutorService executor = Executors.newCachedThreadPool();
        Future&lt;Integer&gt; result = executor.submit(new Callable&lt;Integer&gt;() &#123;
            public Integer call() throws Exception &#123;
                return new Random().nextInt();
            &#125;
        &#125;);
        executor.shutdown();
        try &#123;
            System.out.println(&quot;result:&quot; + result.get());
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; catch (ExecutionException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><ul>
<li>单个线程&#x2F;任务的执行结果</li>
</ul>
<pre><code class="prettyprint">public class FutureTask &#123;
    public static void main(String[] args) &#123;
        //第一种方式
        FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123;
            @Override
            public Integer call() throws Exception &#123;
                return new Random().nextInt();
            &#125;
        &#125;);
        new Thread(task).start();
        //第二种方方式
//        ExecutorService executor = Executors.newSingleThreadExecutor();
//        FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123;
//            @Override
//            public Integer call() throws Exception &#123;
//                return new Random().nextInt();
//            &#125;
//        &#125;);
//        executor.submit(task);
        
        try &#123;
            System.out.println(&quot;result: &quot; + task.get());
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; catch (ExecutionException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    
&#125;
</code></pre>
<h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><ul>
<li>异步，回调，组合, 功能强大</li>
</ul>
<pre><code class="prettyprint">public class CompletableFutureDemo &#123;
    
    public static void main(String[] args)&#123;
        // 1.变换结果
        System.out.println(&quot;=====&gt;1.变换结果&quot;);
        String result1 = CompletableFuture.supplyAsync(()-&gt;&#123;
            return &quot;Hello &quot;;
        &#125;).thenApplyAsync(v -&gt; v + &quot;world&quot;)
                .join();
        System.out.println(result1);
        // 2.消费
        CompletableFuture.supplyAsync(()-&gt;&#123;return &quot;Hello &quot;;&#125;)
                .thenAccept(v -&gt; &#123;
                    System.out.println(&quot;=====&gt;2.消费&quot;);
                    System.out.println(&quot;consumer: &quot; + v);
                &#125;);
        
        // 3.组合
        System.out.println(&quot;=====&gt;3.组合&quot;);
        String result3 = CompletableFuture.supplyAsync(()-&gt;&#123;
            try &#123;
                Thread.sleep(1000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            return &quot;Hello&quot;;
        &#125;).thenCombine(CompletableFuture.supplyAsync(()-&gt;&#123;         
            try &#123;
                Thread.sleep(2000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            return &quot;world&quot;;
        &#125;),(s1,s2)-&gt;&#123;return s1 + &quot; &quot; + s2;&#125;).join();
        System.out.println(&quot;thenCombine:&quot;+result3);
    
        CompletableFuture.supplyAsync(() -&gt; &quot;Hello, java course.&quot;)
                .thenApply(String::toUpperCase).thenCompose(s -&gt; CompletableFuture.supplyAsync(s::toLowerCase))
                .thenAccept(v -&gt; &#123; System.out.println(&quot;thenCompose:&quot;+v);&#125;);
        // 4.竞争
        System.out.println(&quot;=====&gt;4.竞争&quot;);
        String result4 = CompletableFuture.supplyAsync(()-&gt;&#123;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            return &quot;Hi Boy&quot;;
        &#125;).applyToEither(CompletableFuture.supplyAsync(()-&gt;&#123;
            try &#123;
                Thread.sleep(300);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            return &quot;Hi Girl&quot;;
        &#125;),(s)-&gt;&#123;return s;&#125;).join();
        System.out.println(result4);
        // 5.补偿异常
        System.out.println(&quot;=====&gt;5.补偿异常&quot;);
        String result5 = CompletableFuture.supplyAsync(()-&gt;&#123;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            if(true) &#123;
                throw new RuntimeException(&quot;exception test!&quot;);
            &#125;
            return &quot;Hi Boy&quot;;
        &#125;).exceptionally(e-&gt;&#123;                // Fluent API      
            System.out.println(e.getMessage());
            return &quot;Hello world!&quot;;
        &#125;).join();
        System.out.println(result5); 
    &#125;   
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220528234046204.png" class="asset-class" title="image-20220528234046204">

<h3 id="信号量三种工具类"><a href="#信号量三种工具类" class="headerlink" title="信号量三种工具类"></a>信号量三种工具类</h3><h4 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore - 信号量"></a>Semaphore - 信号量</h4><ul>
<li>准入数量为N</li>
<li>N&#x3D;1时则等价于独占锁</li>
<li>使用场景，同一时间控制并发线程数</li>
</ul>
<pre><code class="prettyprint">public Semaphore(int permits) &#123;          //参数permits表示许可数目，即同时可以允许多少线程进行访问
    sync = new NonfairSync(permits);
&#125;
public Semaphore(int permits, boolean fair) &#123;    //这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可
    sync = (fair)? new FairSync(permits) : new NonfairSync(permits);
&#125;
public void acquire() throws InterruptedException &#123;  &#125;     //获取一个许可
public void acquire(int permits) throws InterruptedException &#123; &#125;    //获取permits个许可
public void release() &#123; &#125;          //释放一个许可
public void release(int permits) &#123; &#125;    //释放permits个许可
</code></pre>
<p>代码示例<code>SemaphoreDemo</code></p>
<pre><code class="prettyprint">public class SemaphoreDemo &#123;
    
    public static void main(String[] args) &#123;
        int N = 8;            //工人数
        Semaphore semaphore = new Semaphore(2); //机器数目
        for (int i = 0; i &lt; N; i++)
            new Worker(i, semaphore).start();
    &#125;
    static class Worker extends Thread &#123;
        private int num;
        private Semaphore semaphore;
        public Worker(int num, Semaphore semaphore) &#123;
            this.num = num;
            this.semaphore = semaphore;
        &#125;
        @Override
        public void run() &#123;
            try &#123;
                semaphore.acquire();  // 在子线程里控制资源占用
                System.out.println(&quot;工人&quot; + this.num + &quot;占用一个机器在生产...&quot;);
                Thread.sleep(2000);
                System.out.println(&quot;工人&quot; + this.num + &quot;释放出机器&quot;);
                semaphore.release();   // 在子线程里控制释放资源占用
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220528231859010.png" class="asset-class" title="image-20220528231859010">

<p>代码示例<code>SemaphoreDemo2</code>获取多个许可</p>
<pre><code class="prettyprint">public class SemaphoreDemo2 &#123;
    private final static int threadCount = 20;
    public static void main(String[] args) throws Exception &#123;
        ExecutorService exec = Executors.newCachedThreadPool();
        final Semaphore semaphore = new Semaphore(7);
        for (int i = 0; i &lt; threadCount; i++) &#123;
            final int threadNum = i;
            exec.execute(() -&gt; &#123;
                try &#123;
                    semaphore.acquire(3); // 获取全部许可，退化成串行执行
                    test(threadNum);
                    semaphore.release(3); // 释放多个许可
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;);
        &#125;
        exec.shutdown();
    &#125;
    private static void test(int threadNum) throws Exception &#123;
        System.out.println(&quot;id:&quot; + threadNum + &quot;,&quot; + Thread.currentThread().getName());
        Thread.sleep(1000);
    &#125;
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220528232146316.png" class="asset-class" title="image-20220528232146316">

<h4 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h4><p>Master 线程等待 Worker 线程把任务执行完（做减号，只能使用一次,在主线程await()）</p>
<pre><code class="prettyprint">public CountDownLatch(int count) &#123;  &#125;;  //参数count为计数值
public void await() throws InterruptedException &#123; &#125;;//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;;  //和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行
public void countDown() &#123; &#125;;  //将count值减1
</code></pre>
<p>代码示例<code>CountDownLatchDemo</code></p>
<pre><code class="prettyprint">public class CountDownLatchDemo &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        CountDownLatch countDownLatch = new CountDownLatch(5);
        for(int i=0;i&lt;5;i++)&#123;
            new Thread(new readNum(i,countDownLatch)).start();
        &#125;
        countDownLatch.await(); // 注意跟CyclicBarrier不同，这里在主线程await
        System.out.println(&quot;==&gt;各个子线程执行结束。。。。&quot;);
        System.out.println(&quot;==&gt;主线程执行结束。。。。&quot;);
    &#125;
    static class readNum  implements Runnable&#123;
        private int id;
        private CountDownLatch latch;
        public readNum(int id,CountDownLatch latch)&#123;
            this.id = id;
            this.latch = latch;
        &#125;
        @Override
        public void run() &#123;
            synchronized (this)&#123;
                System.out.println(&quot;id:&quot;+id+&quot;,&quot;+Thread.currentThread().getName());
                //latch.countDown();
                System.out.println(&quot;线程组任务&quot;+id+&quot;结束，其他任务继续&quot;);
                latch.countDown();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220528232409607.png" class="asset-class" title="image-20220528232409607">

<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>任务执行到一定阶段, 等待其他任务对齐(做加号，可再次使用,在子线程await()通过回调判断)</p>
<pre><code class="prettyprint">public CyclicBarrier(int parties, Runnable barrierAction) &#123;&#125;//parties：让多少个线程或者任务等待至barrier状态，barrierAction：parties线程结束的回调
public CyclicBarrier(int parties) &#123;&#125;//parties：让多少个线程或者任务等待至barrier状态
public int await() throws InterruptedException, BrokenBarrierException &#123; &#125;;//来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务；
public int await(long timeout, TimeUnit unit)throws InterruptedException,BrokenBarrierException,TimeoutException &#123; &#125;;//这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务
</code></pre>
<p>代码示例<code>CyclicBarrierDemo</code></p>
<pre><code class="prettyprint">public class CyclicBarrierDemo &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        CyclicBarrier cyclicBarrier = new CyclicBarrier(5, new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;回调&gt;&gt;&quot;+Thread.currentThread().getName());
                System.out.println(&quot;回调&gt;&gt;线程组执行结束&quot;);
                System.out.println(&quot;==&gt;各个子线程执行结束。。。。&quot;);
            &#125;
        &#125;);
        for (int i = 0; i &lt; 5; i++) &#123;
            new Thread(new readNum(i,cyclicBarrier)).start();
        &#125;
        
        System.out.println(&quot;==&gt;主线程执行结束。。。。&quot;);
        
        //CyclicBarrier 可以重复利用，
        // 这个是CountDownLatch做不到的
//        for (int i = 11; i &lt; 16; i++) &#123;
//            new Thread(new readNum(i,cyclicBarrier)).start();
//        &#125;
    &#125;
    static class readNum  implements Runnable&#123;
        private int id;
        private CyclicBarrier cyc;
        public readNum(int id,CyclicBarrier cyc)&#123;
            this.id = id;
            this.cyc = cyc;
        &#125;
        @Override
        public void run() &#123;
            synchronized (this)&#123;
                System.out.println(&quot;id:&quot;+id+&quot;,&quot;+Thread.currentThread().getName());
                try &#123;
                    cyc.await();
                    System.out.println(&quot;线程组任务&quot; + id + &quot;结束，其他任务继续&quot;);
//                    cyc.await();   // 注意跟CountDownLatch不同，这里在子线程await
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220528232738351.png" class="asset-class" title="image-20220528232738351">

<p>代码示例<code>CyclicBarrierDemo2</code></p>
<pre><code class="prettyprint">public class CyclicBarrierDemo2 &#123;
    public static void main(String[] args) &#123;
        int N = 4;
        CyclicBarrier barrier  = new CyclicBarrier(N);
        for(int i=0;i&lt;N;i++) &#123;
            new Writer(barrier).start();
        &#125;
        try &#123;
            Thread.sleep(10000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;====&gt;  CyclicBarrier重用&quot;);
        
        for(int i=0;i&lt;N;i++) &#123;
            new Writer(barrier).start();
        &#125;
    &#125;
    static class Writer extends Thread&#123;
        private CyclicBarrier cyclicBarrier;
        public Writer(CyclicBarrier cyclicBarrier) &#123;
            this.cyclicBarrier = cyclicBarrier;
        &#125;
        @Override
        public void run() &#123;
            System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;正在写入数据...&quot;);
            try &#123;
                Thread.sleep(3000);      //以睡眠来模拟写入数据操作
                System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);
                
                cyclicBarrier.await();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;catch(BrokenBarrierException e)&#123;
                e.printStackTrace();
            &#125;
            System.out.println(Thread.currentThread().getName()+&quot;所有线程写入完毕，继续处理其他任务...&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220528232836700.png" class="asset-class" title="image-20220528232836700">

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><img src="/2022/05/28/java-bing-fa/image-20220528232908736.png" class="asset-class" title="image-20220528232908736">

<ul>
<li>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：	<ul>
<li>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；</li>
<li>而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</li>
</ul>
</li>
</ul>
<p>　　　　另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。</p>
<ul>
<li>Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</li>
</ul>
<h3 id="并发集合类"><a href="#并发集合类" class="headerlink" title="并发集合类"></a>并发集合类</h3><h4 id="List线程安全"><a href="#List线程安全" class="headerlink" title="List线程安全"></a>List线程安全</h4><p>既然线程安全是写冲突和读写冲突导致的 最简单办法就是，读写都加锁</p>
<ul>
<li><p>ArrayList 的方法都加上 synchronized -&gt; Vector</p>
</li>
<li><p>Collections.synchronizedList，强制将 List 的操作加上同步</p>
</li>
<li><p>Arrays.asList，不允许添加删除，但是可以 set 替换元素</p>
</li>
<li><p>Collections.unmodifiableList，不允许修改内容，包括添加删除和 set</p>
</li>
</ul>
<pre><code class="prettyprint">public class SyncListDemo &#123;
    public static void main(String[] args) &#123;
        List list0 = Arrays.asList(1,2,3,4,5,6,7,8,8);
        list0.set(8,9);        // 可以修改内容，不能变动元素数量
        // list0.add(10)  will throw an error
        
        List list = new ArrayList(); // 正常List，可以操作
        list.addAll(list0);
        List list1 = Collections.synchronizedList(list);
        // 多线程操作
        // to do something
        System.out.println(Arrays.toString(list1.toArray()));
        
        Collections.shuffle(list1);
        System.out.println(Arrays.toString(list1.toArray()));
        
        // 假如不再修改
        List list2 = Collections.unmodifiableList(list1);
        System.out.println(list2.getClass());
        
        list2.set(8,10);
        System.out.println(Arrays.toString(list2.toArray()));
        
        list2.add(11);
        System.out.println(Arrays.toString(list2.toArray()));
    &#125; 
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220528234607137.png" class="asset-class" title="image-20220528234607137">

<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><ul>
<li><p>写加锁，保证不会写混乱</p>
</li>
<li><p>写在一个 Copy 副本上，而不是原始数据上(读写分离，最终一致)</p>
</li>
<li><p><code>add</code> 插入元素时，在新副本操作，不影响旧引用</p>
<pre><code class="prettyprint">public boolean add(E e) &#123;
    final ReentrantLock lock = this.lock;
    lock.lock();
    try &#123;
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    &#125; finally &#123;
        lock.unlock();
    &#125;
&#125;
</code></pre>
</li>
<li><p><code>remove</code> 删除末尾元素，直接 使用前 N-1 个元素创建 一个新数组；删除其他位置元素， 创建新数组，将剩余元素 复制到新数组</p>
<pre><code class="prettyprint">public E remove(int index) &#123;
    final ReentrantLock lock = this.lock;
    lock.lock();
    try &#123;
        Object[] elements = getArray();
        int len = elements.length;
        E oldValue = get(elements, index);
        int numMoved = len - index - 1;
        if (numMoved == 0)
            setArray(Arrays.copyOf(elements, len - 1));
        else &#123;
            Object[] newElements = new Object[len - 1];
            System.arraycopy(elements, 0, newElements, 0, index);
            System.arraycopy(elements, index + 1, newElements, index,
                             numMoved);
            setArray(newElements);
        &#125;
        return oldValue;
    &#125; finally &#123;
        lock.unlock();
    &#125;
&#125;
</code></pre>
</li>
<li><p><code>get</code> 读取无需加锁</p>
<pre><code class="prettyprint">private E get(Object[] a, int index) &#123;
    return (E) a[index];
&#125;

/**
     * &#123;@inheritDoc&#125;
     *
     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;
     */
public E get(int index) &#123;
    return get(getArray(), index);
&#125;
</code></pre>
</li>
<li><p><code>COWIterator</code> 使用迭代器，直接拿当前的数组对象做 一个快照，此后的 List 元素变动，就跟这次迭代 没关系了</p>
<ul>
<li><p>获取迭代器</p>
<pre><code class="prettyprint"> public Iterator&lt;E&gt; iterator() &#123;
     return new COWIterator&lt;E&gt;(getArray(), 0);
 &#125;

/**
     * &#123;@inheritDoc&#125;
     *
     * &lt;p&gt;The returned iterator provides a snapshot of the state of the list
     * when the iterator was constructed. No synchronization is needed while
     * traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the
     * &#123;@code remove&#125;, &#123;@code set&#125; or &#123;@code add&#125; methods.
     */
public ListIterator&lt;E&gt; listIterator() &#123;
    return new COWIterator&lt;E&gt;(getArray(), 0);
&#125;
</code></pre>
</li>
</ul>
<p><code>COWIterator</code></p>
<pre><code class="prettyprint">static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;
    /** Snapshot of the array 快照*/
    private final Object[] snapshot; 
    /** Index of element to be returned by subsequent call to next.  */
    private int cursor;

    private COWIterator(Object[] elements, int initialCursor) &#123;
        cursor = initialCursor;
        snapshot = elements;
    &#125;

    public boolean hasNext() &#123;
        return cursor &lt; snapshot.length;
    &#125;

    public boolean hasPrevious() &#123;
        return cursor &gt; 0;
    &#125;

    @SuppressWarnings(&quot;unchecked&quot;)
    public E next() &#123;
        if (! hasNext())
            throw new NoSuchElementException();
        return (E) snapshot[cursor++];
    &#125;

    @SuppressWarnings(&quot;unchecked&quot;)
    public E previous() &#123;
        if (! hasPrevious())
            throw new NoSuchElementException();
        return (E) snapshot[--cursor];
    &#125;

    public int nextIndex() &#123;
        return cursor;
    &#125;

    public int previousIndex() &#123;
        return cursor-1;
    &#125;

    /**
         * Not supported. Always throws UnsupportedOperationException.
         * @throws UnsupportedOperationException always; &#123;@code remove&#125;
         *         is not supported by this iterator.
         */
    public void remove() &#123;
        throw new UnsupportedOperationException();
    &#125;

    /**
         * Not supported. Always throws UnsupportedOperationException.
         * @throws UnsupportedOperationException always; &#123;@code set&#125;
         *         is not supported by this iterator.
         */
    public void set(E e) &#123;
        throw new UnsupportedOperationException();
    &#125;

    /**
         * Not supported. Always throws UnsupportedOperationException.
         * @throws UnsupportedOperationException always; &#123;@code add&#125;
         *         is not supported by this iterator.
         */
    public void add(E e) &#123;
        throw new UnsupportedOperationException();
    &#125;

    @Override
    public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;
        Objects.requireNonNull(action);
        Object[] elements = snapshot;
        final int size = elements.length;
        for (int i = cursor; i &lt; size; i++) &#123;
            @SuppressWarnings(&quot;unchecked&quot;) E e = (E) elements[i];
            action.accept(e);
        &#125;
        cursor = size;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><h5 id="Java7-分段锁"><a href="#Java7-分段锁" class="headerlink" title="Java7 分段锁"></a>Java7 分段锁</h5><ul>
<li>默认16个Segment，降低锁粒度。 concurrentLevel &#x3D; 16</li>
</ul>
<img src="/2022/05/28/java-bing-fa/image-20220528235452123.png" class="asset-class" title="image-20220528235452123">

<h5 id="Java8-自旋"><a href="#Java8-自旋" class="headerlink" title="Java8-自旋"></a>Java8-自旋</h5><img src="/2022/05/28/java-bing-fa/image-20220528235602891.png" class="asset-class" title="image-20220528235602891">

<pre><code class="prettyprint">public class ConcurrentHashMapDemo &#123;
    
    public static void main(String[] args) &#123;
        demo1();
    &#125;
    public static void demo1() &#123;
        final Map&lt;String, AtomicInteger&gt; count = new ConcurrentHashMap&lt;&gt;();
        final CountDownLatch endLatch = new CountDownLatch(2);
        Runnable task = new Runnable() &#123;
            @Override
            public void run() &#123;
                AtomicInteger oldValue;
                for (int i = 0; i &lt; 5; i++) &#123;
                    oldValue = count.get(&quot;a&quot;);
                    if (null == oldValue) &#123;
                        AtomicInteger zeroValue = new AtomicInteger(0);
                        oldValue = count.putIfAbsent(&quot;a&quot;, zeroValue);
                        if (null == oldValue) &#123;
                            oldValue = zeroValue;
                        &#125;
                    &#125;
                    oldValue.incrementAndGet();
                &#125;
                endLatch.countDown();
            &#125;
        &#125;;
        new Thread(task).start();
        new Thread(task).start();
        try &#123;
            endLatch.await();
            System.out.println(count);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><ul>
<li><p>常用方法</p>
<ul>
<li><p><code>public ThreadLocal()</code>构造方法 </p>
</li>
<li><p><code>protected T initialValue()</code> 覆写-设置初始默认值 </p>
</li>
<li><p><code>void set(T value)</code> 设置本线程对应的值 </p>
</li>
<li><p><code>void remove()</code> 清理本线程对应的值 </p>
</li>
<li><p><code>T get()</code> 获取本线程对应的值</p>
</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li>线程本地变量 </li>
<li>场景: 每个线程一个副本 </li>
<li>不改方法签名静默传参 </li>
<li>及时进行清理</li>
</ul>
</li>
<li><p>可以看做是 Context 模式，减少显式传递参数</p>
</li>
</ul>
<pre><code class="prettyprint">public class ThreadLocalDemo &#123;
    
    private static ThreadLocal&lt;Integer&gt; seqNum = new ThreadLocal&lt;Integer&gt;() &#123;
        public Integer initialValue() &#123;
            return 0;
        &#125;
    &#125;;
    public ThreadLocal&lt;Integer&gt; getThreadLocal() &#123;
        return seqNum;
    &#125;
    public int getNextNum() &#123;
        seqNum.set(seqNum.get() + 1);
        return seqNum.get();
    &#125;
    public static void main(String[] args) &#123;
        ThreadLocalDemo threadLocalMain = new ThreadLocalDemo();
    
        SnThread client1 = new SnThread(threadLocalMain);
        SnThread client2 = new SnThread(threadLocalMain);
        SnThread client3 = new SnThread(threadLocalMain);
        
        client1.start();
        client2.start();
        client3.start();
    &#125;
    private static class SnThread extends Thread &#123;
        private ThreadLocalDemo sn;
        public SnThread(ThreadLocalDemo sn) &#123;
            this.sn = sn;
        &#125;
        public void run() &#123;
            for (int i = 0; i &lt; 3; i++) &#123;
                System.out.println(&quot;thread[&quot; + Thread.currentThread().getName() + &quot;] ---&gt; sn [&quot; + sn.getNextNum() + &quot;]&quot;);
            &#125;
            sn.getThreadLocal().remove();
        &#125;
    &#125;
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220529000224433.png" class="asset-class" title="image-20220529000224433">

<h2 id="并行Stream"><a href="#并行Stream" class="headerlink" title="并行Stream"></a>并行Stream</h2><pre><code class="prettyprint">public class StreamParallelDemo &#123;
    public static void main(String[] args) &#123;
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        IntStream.range(1, 10000).forEach(i -&gt; list.add(i));
        BlockingQueue&lt;Long&gt; blockingQueue = new LinkedBlockingQueue(10000);
        List&lt;Long&gt; longList = list.stream().parallel()
                .map(i -&gt; i.longValue())
                .sorted()
                .collect(Collectors.toList());
//      // 串行，单线程
//      longList.stream().forEach(
        // 并行，默认使用CPU * 2个线程
        longList.stream().parallel().forEach(
                i -&gt; &#123;
            try &#123;
                blockingQueue.put(i);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;);
        System.out.println(&quot;blockingQueue:&quot; + blockingQueue.toString());
    &#125;   
&#125;
</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql索引</title>
    <url>/2022/06/03/mysql-suo-yin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="何为索引？有什么作用？"><a href="#何为索引？有什么作用？" class="headerlink" title="何为索引？有什么作用？"></a>何为索引？有什么作用？</h1><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong><br> 索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<h1 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h1><p><strong>优点</strong> ：</p>
<ul>
<li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p>
<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>
<h1 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h1><h2 id="Hash表-amp-B-树"><a href="#Hash表-amp-B-树" class="headerlink" title="Hash表 &amp; B+树"></a>Hash表 &amp; B+树</h2><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p>
<p><strong>为何能够通过 key 快速取出 value呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 value 对应的 index，找到了 index 也就找到了对应的 value。</p>
<pre><code class="prettyprint">hash = hashfunc(key)
index = hash % array_size
</code></pre>
<img src="/2022/06/03/mysql-suo-yin/webp-165425733052856.webp" class="asset-class" title="img">

<p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了红黑树。</p>
<img src="/2022/06/03/mysql-suo-yin/webp-165425731577354.webp" class="asset-class" title="img">

<p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。<br> 既然哈希表这么快，<strong>为什么MySQL 没有使用其作为索引的数据结构呢？</strong><br> <strong>1.Hash 冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。<br> <strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p>
<p>试想一种情况:</p>
<pre><code class="prettyprint">SELECT * FROM tb1 WHERE id &lt; 500;Copy to clipboardErrorCopied
</code></pre>
<p>在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。</p>
<h2 id="B-树-amp-B-树"><a href="#B-树-amp-B-树" class="headerlink" title="B 树&amp; B+树"></a>B 树&amp; B+树</h2><p>B 树全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p>
<p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p>
<p><strong>B 树&amp; B+树两者有何异同呢？</strong></p>
<ul>
<li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
<img src="/2022/06/03/mysql-suo-yin/webp-165425730431552.webp" class="asset-class" title="img">

<p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p>
<p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p>
<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<h1 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h1><h2 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h2><p>数据表的主键列使用的就是主键索引。<br> 一张数据表有只能有一个主键，并且主键不能为 null，不能重复。<br> 在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p>
<h2 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h2><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong><br> 唯一索引，普通索引，前缀索引等索引属于二级索引。<br> <strong>PS:不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</strong></p>
<ol>
<li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li>
<li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li>
<li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>
</ol>
<p>二级索引: </p>
<img src="/2022/06/03/mysql-suo-yin/webp-165425728778950.webp" class="asset-class" title="img">

<h1 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h1><h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p>
<p>在 Mysql 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<h3 id="聚集索引的优点"><a href="#聚集索引的优点" class="headerlink" title="聚集索引的优点"></a>聚集索引的优点</h3><p>聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>
<h3 id="聚集索引的缺点"><a href="#聚集索引的缺点" class="headerlink" title="聚集索引的缺点"></a>聚集索引的缺点</h3><ol>
<li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ol>
<h2 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h2><p><strong>非聚集索引即索引结构和数据分开存放的索引。</strong></p>
<p><strong>二级索引属于非聚集索引。</strong></p>
<blockquote>
<p>MYISAM 引擎的表的.MYI 文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。</p>
<p><strong>非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p>
</blockquote>
<h3 id="非聚集索引的优点"><a href="#非聚集索引的优点" class="headerlink" title="非聚集索引的优点"></a>非聚集索引的优点</h3><p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>
<h3 id="非聚集索引的缺点"><a href="#非聚集索引的缺点" class="headerlink" title="非聚集索引的缺点"></a>非聚集索引的缺点</h3><ol>
<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ol>
<p>这是 MySQL 的表的文件截图:</p>
<img src="/2022/06/03/mysql-suo-yin/webp-165425727549748.webp" class="asset-class" title="img">

<p>聚集索引和非聚集索引:</p>
<img src="/2022/06/03/mysql-suo-yin/webp-165425725894946.webp" class="asset-class" title="img">

<h2 id="非聚集索引一定回表查询吗-覆盖索引"><a href="#非聚集索引一定回表查询吗-覆盖索引" class="headerlink" title="非聚集索引一定回表查询吗(覆盖索引)?"></a>非聚集索引一定回表查询吗(覆盖索引)?</h2><p><strong>非聚集索引不一定回表查询。</strong></p>
<blockquote>
<p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p>
</blockquote>
<pre><code class="prettyprint"> SELECT name FROM table WHERE name=&#39;guang19&#39;;
</code></pre>
<blockquote>
<p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p>
</blockquote>
<p><strong>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表， 因为它的主键索引的叶子节点存放的是指针。但是如果 SQL 查的就是主键呢?</strong></p>
<pre><code class="prettyprint">SELECT id FROM table WHERE id=1;
</code></pre>
<p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p>
<h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。</strong></p>
<blockquote>
<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p>
</blockquote>
<p>覆盖索引: </p>
<img src="/2022/06/03/mysql-suo-yin/webp-165425722617344.webp" class="asset-class" title="img">

<h1 id="创建索引的注意事项"><a href="#创建索引的注意事项" class="headerlink" title="创建索引的注意事项"></a>创建索引的注意事项</h1><p><strong>1.选择合适的字段创建索引：</strong></p>
<ul>
<li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>
<li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li>
<li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>
<li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>
</ul>
<p><strong>2.被频繁更新的字段应该慎重建立索引。</strong></p>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<p><strong>3.尽可能的考虑建立联合索引而不是单列索引。</strong></p>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<p><strong>4.注意避免冗余索引</strong> 。</p>
<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<h1 id="使用索引的一些建议"><a href="#使用索引的一些建议" class="headerlink" title="使用索引的一些建议"></a>使用索引的一些建议</h1><ul>
<li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li>
<li>避免 where 子句中对字段施加函数，这会造成无法命中索引。</li>
<li>在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li>
<li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</li>
<li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li>
</ul>
<h1 id="MySQL-如何为表字段添加索引？"><a href="#MySQL-如何为表字段添加索引？" class="headerlink" title="MySQL 如何为表字段添加索引？"></a>MySQL 如何为表字段添加索引？</h1><p>1.添加 PRIMARY KEY（主键索引）</p>
<pre><code class="prettyprint">ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` )
</code></pre>
<p>2.添加 UNIQUE(唯一索引)</p>
<pre><code class="prettyprint">ALTER TABLE `table_name` ADD UNIQUE ( `column` )
</code></pre>
<p>3.添加 INDEX(普通索引)</p>
<pre><code class="prettyprint">ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
</code></pre>
<p>4.添加 FULLTEXT(全文索引)</p>
<pre><code class="prettyprint">ALTER TABLE `table_name` ADD FULLTEXT ( `column`)
</code></pre>
<p>5.添加多列索引</p>
<pre><code class="prettyprint">ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
</code></pre>
<p>链接：<a href="https://www.jianshu.com/p/e54074fe91d8">https://www.jianshu.com/p/e54074fe91d8</a></p>
]]></content>
      <categories>
        <category>数据</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql锁机制</title>
    <url>/2022/06/03/mysql-suo-ji-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="表级锁、行级锁、页级锁"><a href="#表级锁、行级锁、页级锁" class="headerlink" title="表级锁、行级锁、页级锁"></a>表级锁、行级锁、页级锁</h2><p>数据库锁定机制简单来说，就是<strong>数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则</strong>。</p>
<p>MySQL数据库由于其自身架构的特点，存在多种数据存储引擎，每种存储引擎的锁定机制都是为各自所面对的特定场景而优化设计，所以各存储引擎的锁定机制也有较大区别。</p>
<p>MySQL各存储引擎使用了三种类型（级别）的锁定机制：<code>表级锁定</code>，<code>行级锁定</code>和<code>页级锁定</code>。</p>
<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。</p>
<p>当然，<strong>锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发度大打折扣</strong>。</p>
<p>使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。</p>
<h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><p>行级锁定最大的特点就是<strong>锁定对象的颗粒度很小</strong>，由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。</p>
<p>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。</p>
<p><strong>由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁</strong>。</p>
<p><code>使用行级锁定的主要是InnoDB存储引擎</code>。</p>
<h4 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h4><p>页级锁定是MySQL中比较独特的一种锁定级别。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。</p>
<p>使用页级锁定的主要是BerkeleyDB存储引擎。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总的来说，MySQL这3种锁的特性可大致归纳如下：</p>
<p><code>表级锁</code>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；<br><code>行级锁</code>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；<br><code>页面锁</code>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>
<h2 id="共享锁、排它锁"><a href="#共享锁、排它锁" class="headerlink" title="共享锁、排它锁"></a>共享锁、排它锁</h2><p>InnoDB 实现了标准的<strong>行级锁</strong>，包括两种：<strong>共享锁</strong>（简称 s 锁）、<strong>排它锁</strong>（简称 x 锁）。</p>
<p>对于共享锁而言，对当前行加<strong>共享锁</strong>，不会阻塞其他事务对同一行的读请求，但会阻塞对同一行的写请求。只有当读锁释放后，才会执行其它事物的写操作。</p>
<p>对于排它锁而言，会阻塞其他事务对同一行的读和写操作，只有当写锁释放后，才会执行其它事务的读写操作。</p>
<img src="/2022/06/03/mysql-suo-ji-zhi/webp-165424398243024.webp" class="asset-class" title="img">

<p>简而言之，就是<code>读锁会阻塞写(X)，但是不会堵塞读(S)。而写锁则会把读(S)和写(X)都堵塞</code></p>
<p>对于InnoDB 在RR(MySQL默认隔离级别) 而言，对于 update、delete 和 insert 语句， 会自动给涉及数据集加排它锁（X）；</p>
<p>对于普通 select 语句，innodb 不会加任何锁。如果想在select操作的时候加上 S锁 或者 X锁，需要我们手动加锁。</p>
<pre><code class="prettyprint">-- 加共享锁（S）
select * from table_name where ... lock in share mode

-- 加排它锁（X)
select * from table_name where ... for update
</code></pre>
<p>用 <strong>select… in share mode</strong> 获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行 update 或者 delete 操作。</p>
<p>但是如果当前事务也需要对该记录进行更新操作,则有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用 <strong>select… for update</strong> 方式获得排他锁。</p>
<h2 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h2><h4 id="记录锁（Record-Locks）"><a href="#记录锁（Record-Locks）" class="headerlink" title="记录锁（Record Locks）"></a>记录锁（Record Locks）</h4><p>记录锁其实很好理解，对表中的记录加锁，叫做记录锁，简称行锁。比如</p>
<pre><code class="prettyprint">SELECT * FROM `test` WHERE `id`=1 FOR UPDATE;
</code></pre>
<p>它会在 id&#x3D;1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id&#x3D;1 这一行。</p>
<p>需要注意的是：</p>
<ul>
<li><strong>id 列必须为唯一索引列或主键列</strong>，否则上述语句加的锁就会变成临键锁(有关临键锁下面会讲)。</li>
<li><strong>同时查询语句必须为精准匹配（&#x3D;）</strong>，不能为 &gt;、&lt;、like等，否则也会退化成临键锁。</li>
</ul>
<p>其他实现</p>
<p>在通过 <strong>主键索引</strong> 与 <strong>唯一索引</strong> 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：</p>
<pre><code class="prettyprint">-- id 列为主键列或唯一索引列 
UPDATE SET age = 50 WHERE id = 1;
</code></pre>
<p><strong>记录锁是锁住记录，锁住索引记录，而不是真正的数据记录</strong>.</p>
<p>如果要锁的列没有索引，进行全表记录加锁</p>
<p><code>记录锁也是排它(X)锁</code>,所以会阻塞其他事务对其<strong>插入、更新、删除</strong>。</p>
<h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><h4 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h4><p>间隙锁 是 <strong>Innodb 在 RR(可重复读) 隔离级别</strong> 下为了解决<code>幻读问题</code>时引入的锁机制。<strong>间隙锁是innodb中行锁的一种</strong>。</p>
<p>请务必牢记：<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据</strong>。</p>
<p>举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101，下面的SQL：</p>
<pre><code class="prettyprint">  SELECT * FROM emp WHERE empid &gt; 100 FOR UPDATE
</code></pre>
<p>当我们用条件检索数据，并请求共享或排他锁时，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p>
<p>这个时候如果你插入empid等于102的数据的，如果那边事物还没有提交，那你就会处于等待状态，无法插入数据。</p>
<h2 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h2><h4 id="临键锁（Next-Key-Locks）"><a href="#临键锁（Next-Key-Locks）" class="headerlink" title="临键锁（Next-Key Locks）"></a>临键锁（Next-Key Locks）</h4><p><strong>Next-key锁是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁</strong>。</p>
<p>也可以理解为一种特殊的<strong>间隙锁</strong>。通过<strong>临建锁</strong>可以解决<code>幻读</code>的问题。 每个数据行上的<strong>非唯一索引列</strong>上都会存在一把<strong>临键锁</strong>，当某个事务持有该数据行的<strong>临键锁</strong>时，会锁住一段<strong>左开右闭区间</strong>的数据。需要强调的一点是，InnoDB 中<strong>行级锁</strong>是基于索引实现的，<strong>临键锁</strong>只与<strong>非唯一索引列</strong>有关，在<code>唯一索引列（包括主键列）上不存在临键锁</code>。</p>
<p>假设有如下表：</p>
<p><strong>InnoDB</strong>，<strong>RR隔离级别</strong>：id主键, age 普通索引</p>
<img src="/2022/06/03/mysql-suo-ji-zhi/webp-165424396374222.webp" class="asset-class" title="img">

<p>该表中 age 列潜在的临键锁有：<br> (-∞, 10],<br> (10, 24],<br> (24, 32],<br> (32, 45],<br> (45, +∞],<br> 在事务 A 中执行如下命令：</p>
<pre><code class="prettyprint">-- 根据非唯一索引列 UPDATE 某条记录 
UPDATE table SET name = Vladimir WHERE age = 24; 
-- 或根据非唯一索引列 锁住某条记录 
SELECT * FROM table WHERE age = 24 FOR UPDATE; 
</code></pre>
<p>不管执行了上述 SQL 中的哪一句，之后如果在事务 B 中执行以下命令，则该命令会被阻塞：</p>
<pre><code class="prettyprint">INSERT INTO table VALUES(100, 26, &#39;tianqi&#39;); 
</code></pre>
<p>很明显，事务 A 在对 age 为 24 的列进行 UPDATE 操作的同时，也获取了 (24, 32] 这个区间内的临键锁。</p>
<p><code>总结</code></p>
<p>这里对 <strong>记录锁</strong>、<strong>间隙锁</strong>、<strong>临键锁</strong> 做一个总结</p>
<ul>
<li><strong>InnoDB</strong> 中的<strong>行锁</strong>的实现依赖于<strong>索引</strong>，一旦某个加锁操作没有使用到索引，那么该锁就会退化为<code>表锁</code>。</li>
<li><strong>记录锁</strong>存在于包括<strong>主键索引</strong>在内的<strong>唯一索引</strong>中，锁定单条索引记录。</li>
<li><strong>间隙锁</strong>存在于<strong>非唯一索引</strong>中，锁定<strong>开区间</strong>范围内的一段间隔，它是基于<strong>临键锁</strong>实现的。</li>
<li><strong>临键锁</strong>存在于<strong>非唯一索引</strong>中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的<strong>间隙锁</strong>，锁定一段<strong>左开右闭</strong>的索引区间。</li>
</ul>
<h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><h4 id="意向锁-1"><a href="#意向锁-1" class="headerlink" title="意向锁"></a>意向锁</h4><p>意向锁又分为 <code>意向共享锁（IS）</code>和 <code>意向排他锁（IX）</code></p>
<ul>
<li><strong>意向共享(IS)锁</strong>：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</li>
</ul>
<pre><code class="prettyprint">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 
SELECT column FROM table ... LOCK IN SHARE MODE;
</code></pre>
<ul>
<li><strong>意向排他(IX)锁</strong>：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</li>
</ul>
<pre><code class="prettyprint"> -- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
 SELECT column FROM table ... FOR UPDATE;
</code></pre>
<p>首先我们要明白四点</p>
<ul>
<li>意向共享锁（IS）和 意向排他锁（IX）都是<strong>表锁</strong>。</li>
<li>意向锁是一种 <strong>不与行级锁冲突的表级锁</strong>，这一点非常重要。</li>
<li>意向锁是 InnoDB 自动加的， 不需用户干预。</li>
<li>意向锁是在 InnoDB 下存在的内部锁，对于MyISAM 而言 没有意向锁之说。</li>
</ul>
<p>这里就会有疑惑，既然前面已经有了共享锁（S锁）、排它锁（X锁）。那么为什么需要引入意向锁呢？它能解决什么问题呢？</p>
<p>我们可以理解 意向锁 存在的目的就是 为了让 <code>InnoDB 中的行锁和表锁更高效的共存</code>。</p>
<p>为什么这么说，我们来举一个例子。</p>
<p>下面有一张表 <strong>InnoDB RR隔离级别 id是主键</strong></p>
<img src="/2022/06/03/mysql-suo-ji-zhi/webp-165424393096220.webp" class="asset-class" title="img">

<p>事务 A 获取了<strong>某一行的排他锁</strong>，并未提交：</p>
<pre><code class="prettyprint">SELECT * FROM users WHERE id = 6 FOR UPDATE; 
</code></pre>
<p>事务 B 想要获取users表的<strong>表锁</strong>：</p>
<pre><code class="prettyprint">LOCK TABLES users READ; 
</code></pre>
<p>因为共享锁与排他锁互斥，所以事务 B 在视图对 users 表加共享锁的时候，必须保证：</p>
<ul>
<li>当前没有其他事务持有 users 表的排他锁。</li>
<li>当前没有其他事务持有 users 表中任意一行的排他锁 。</li>
</ul>
<p>为了检测是否满足第二个条件，事务 B 必须在确保users表不存在任何<strong>排他锁</strong>的前提下，去检测表中的<strong>每一行是否存在排他锁</strong>。很明显这是一个效率很差的做法，但是有了<strong>意向锁</strong>之后，情况就不一样了：事务B只要看表上有没有意向共享锁，有则说明表中有些行被<strong>共享行锁</strong>锁住了，因此，事务B申请表的写锁会被阻塞。这样是不是就高效多了。</p>
<p>这也解释就应该清楚，为什么有意向锁这个东西存在了。</p>
<p>我们可以举个生活中的例子，再来理解下为什么需要存在意向锁。</p>
<p>打个比方，就像有个游乐场，很多小朋友进去玩，看门大爷如果要下班锁游乐场的门(<strong>加表锁</strong>)，他必须确保每个角落都要去检查一遍，确保每个小朋友都离开了(<strong>释放行锁</strong>)，才可以锁门。</p>
<p>假设锁门是件频繁发生的事情，大爷就会非常崩溃。那大爷想了一个办法，每个小朋友进入，就把自己的名字写在本子上，小朋友离开，就把自己的名字划掉，那大爷就能方便掌握有没有小朋友在游乐场里，不必每个角落都去寻找一遍。例子中的“小本子”，就是<strong>意向锁</strong>，他记录的信息并不精细，他只是提醒大爷，有人在屋里。</p>
<p>这里我们再来看下 共享(S)锁、排他(X)锁、意向共享锁（IS）、意向排他锁（IX）的兼容性</p>
<img src="/2022/06/03/mysql-suo-ji-zhi/webp-165424391917018.webp" class="asset-class" title="img">

<p>可以看出 <strong>意向锁之间是互相兼容的</strong>.那你存在的意义是啥？</p>
<p>意向锁不会为难意向锁。也不会为难行级排他(X)&#x2F;共享(X)锁,它的存在是为难<code>表级</code>排他(X)&#x2F;共享(X)锁。</p>
<img src="/2022/06/03/mysql-suo-ji-zhi/webp-165424390759316.webp" class="asset-class" title="img">

<p><code>注意</code><strong>这里的排他(X)&#x2F;共享(S)锁指的都是表锁！意向锁不会与行级的共享&#x2F;排他锁互斥！</strong> 行级别的X和S按照上面的兼容性规则即可。</p>
<p>意向锁与意向锁之间永远是兼容的，因为当你不论加行级的X锁或S锁，都会自动获取表级的IX锁或者IS锁。也就是你有10个事务，对不同的10行加了行级X锁，那么这个时候就存在10个IX锁。</p>
<p>这10个IX存在的目的是啥呢，就是假如这个时候有个事务，想对整个表加排它X锁,那它不需要遍历每一行是否存在S或X锁，而是看有没有存在意向锁，只要存在一个意向锁，那这个事务就加不了表级排它X锁，要等上面10个IX全部释放才行。</p>
<h2 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h2><h4 id="插入意向锁-1"><a href="#插入意向锁-1" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>在讲解插入意向锁之前，先来思考一个问题</p>
<p>下面有张表 id主键，age普通索引</p>
<p>首先<strong>事务 A</strong> 插入了一行数据，并且没有 <strong>commit</strong>：</p>
<img src="/2022/06/03/mysql-suo-ji-zhi/webp-165424389093414.webp" class="asset-class" title="img">

<pre><code class="prettyprint">INSERT INTO users SELECT 4, &#39;Bill&#39;, 15; 
</code></pre>
<p>随后<strong>事务 B</strong> 试图插入一行数据：</p>
<pre><code class="prettyprint">INSERT INTO users SELECT 5, &#39;Louis&#39;, 16; 
</code></pre>
<p>请问：</p>
<p>1、事务A使用了什么锁？</p>
<p>2、 <strong>事务 B</strong> 是否会被<strong>事务 A</strong> 阻塞？</p>
<p><strong>插入意向锁</strong>是在插入一条记录行前，由 <strong>INSERT</strong> 操作产生的一种<code>间隙锁</code>。</p>
<p>该锁用以表示插入<strong>意向</strong>，当多个事务在<strong>同一区间</strong>（gap）插入<strong>位置不同</strong>的多条数据时，事务之间<strong>不需要互相等待</strong>。</p>
<p>假设存在两条值分别为 4 和 7 的记录，两个不同的事务分别试图插入值为 5 和 6 的两条记录，每个事务在获取插入行上独占的（排他）锁前，都会获取（4，7）之间的<strong>间隙锁</strong>，但是因为数据行之间并不冲突，所以两个事务之间并<strong>不会产生冲突</strong>（阻塞等待）。</p>
<p>总结来说，<strong>插入意向锁</strong> 的特性可以分成两部分：</p>
<ul>
<li>插入意向锁是一种特殊的<strong>间隙锁</strong> —— 间隙锁可以锁定<strong>开区间</strong>内的部分记录。</li>
<li>插入意向锁之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身（<strong>主键</strong>、<strong>唯一索引</strong>）不冲突，那么事务之间就不会出现<strong>冲突等待</strong>。</li>
</ul>
<p>需要强调的是，虽然<strong>插入意向锁</strong>中含有<strong>意向锁</strong>三个字，但是它并不属于<strong>意向锁</strong>而属于<strong>间隙锁</strong>，因为<strong>意向锁</strong>是<strong>表锁</strong>而<code>插入意向锁是行锁</code>。</p>
<p>现在我们可以回答开头的问题了：</p>
<p>1、 使用<strong>插入意向锁</strong>与<strong>记录锁</strong>。<br> 2、<strong>事务 A</strong> 不会阻塞<strong>事务 B</strong>。</p>
<p>为什么不用间隙锁</p>
<p>如果只是使用普通的<strong>间隙锁</strong>会怎么样呢？我们在看事务A,其实它一共获取了3把锁</p>
<ul>
<li>id 为 4 的记录行的<strong>记录锁</strong>。</li>
<li>age 区间在（10，15）的<strong>间隙锁</strong>。</li>
<li>age 区间在（15，20）的<strong>间隙锁</strong>。</li>
</ul>
<p>最终，<strong>事务 A</strong> 插入了该行数据，并锁住了（10，20）这个区间。</p>
<p>随后<strong>事务 B</strong> 试图插入一行数据：</p>
<pre><code class="prettyprint">INSERT INTO users SELECT 5, &#39;Louis&#39;, 16; 
</code></pre>
<p>因为 16 位于（15，20）区间内，而该区间内又存在一把<strong>间隙锁</strong>，所以<strong>事务 B</strong> 别说想申请自己的<strong>间隙锁</strong>了，它甚至不能获取该行的<strong>记录锁</strong>，自然只能乖乖的等待 <strong>事务 A</strong>结束，才能执行插入操作。<br> 很明显，这样做事务之间将会频发陷入<strong>阻塞等待</strong>，<strong>插入的并发性</strong>非常之差。这时如果我们再去回想我们刚刚讲过的<strong>插入意向锁</strong>，就不难发现它是如何优雅的解决了<strong>并发插入</strong>的问题。</p>
<p><code>总结</code></p>
<ul>
<li><p>InnoDB在RR的事务隔离级别下，使用插入意向锁来<strong>控制和解决并发插入</strong>。</p>
</li>
<li><p>插入意向锁是一种特殊的<strong>间隙锁</strong>。</p>
</li>
<li><p>插入意向锁在锁定区间相同但记录行本身不冲突的情况下<strong>互不排斥</strong>。</p>
<p>链接：<a href="https://www.jianshu.com/p/478bc84a7721">https://www.jianshu.com/p/478bc84a7721</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>锁机制</tag>
      </tags>
  </entry>
  <entry>
    <title>win10安装两个mysql</title>
    <url>/2022/06/03/win10-an-zhuang-liang-ge-mysql/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><a href="https://downloads.mysql.com/archives/community/">MySQL :: Download MySQL Community Server (Archived Versions)</a></p>
<blockquote>
<p>下载免安装版本，解压至两个文件夹</p>
</blockquote>
<ul>
<li><p>mysql-8.0.11-winx64-1</p>
</li>
<li><p>mysql-8.0.11-winx64-2</p>
</li>
</ul>
<blockquote>
<p>分别在两个文件夹下新建<code>my.ini</code>文件</p>
</blockquote>
<ul>
<li>mysql-8.0.11-winx64-1&#x2F;my.ini</li>
</ul>
<pre><code class="prettyprint">[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8mb4
#---------分割线----------
[mysqld]
# 设置3306端口
port=3306
#服务id
server-id=1
# 设置mysql的安装目录
basedir=E:\\tools\\database\\mysql-8.0.11-winx64-1
# 设置mysql数据库的数据的存放目录
datadir=E:\\tools\\database\\mysql-8.0.11-winx64-1\\data
# 允许最大连接数
max_connections=200
# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统
max_connect_errors=10
# 服务端使用的字符集默认为 UTF8 More Byte 4
character-set-server=utf8mb4
# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
# 默认使用“mysql_native_password”插件认证
default_authentication_plugin=mysql_native_password
#不区分大小写
lower_case_table_names = 1
#数据库过大导入问题
max_allowed_packet=500M
wait_timeout=288000
interactive_timeout = 288000
#---------分割线----------
[client]
# 设置mysql客户端连接服务端时默认使用的端口
port=3306
default-character-set=utf8mb4
</code></pre>
<ul>
<li>mysql-8.0.11-winx64-2&#x2F;my.ini</li>
</ul>
<pre><code class="prettyprint">[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8mb4
#---------分割线----------
[mysqld]
# 设置3306端口
port=3316
#服务id
server-id=2
# 设置mysql的安装目录
basedir=E:\\tools\\database\\mysql-8.0.11-winx64-2
# 设置mysql数据库的数据的存放目录
datadir=E:\\tools\\database\\mysql-8.0.11-winx64-2\\data
# 允许最大连接数
max_connections=200
# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统
max_connect_errors=10
# 服务端使用的字符集默认为 UTF8 More Byte 4
character-set-server=utf8mb4
# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
# 默认使用“mysql_native_password”插件认证
default_authentication_plugin=mysql_native_password
#不区分大小写
lower_case_table_names = 1
#数据库过大导入问题
max_allowed_packet=500M
wait_timeout=288000
interactive_timeout = 288000
#---------分割线----------
[client]
# 设置mysql客户端连接服务端时默认使用的端口
port=3316
default-character-set=utf8mb4
</code></pre>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用管理员身份打开cmd</p>
<p>进入到mysql免安装bin目录下</p>
<h4 id="无密码模式"><a href="#无密码模式" class="headerlink" title="无密码模式"></a>无密码模式</h4><ul>
<li>在mysql-1下执行脚本</li>
</ul>
<pre><code class="prettyprint">mysqld install mysql1
mysqld --initialize-insecure --console
net start mysql1
#如有安装失败需要先删除data文件夹再安装
#进入mysql
mysql -uroot
</code></pre>
<ul>
<li>在mysql-1下执行脚本</li>
</ul>
<pre><code class="prettyprint">mysqld install mysql2
mysqld --initialize-insecure --console
net start mysql2
#如有安装失败需要先删除data文件夹再安装
#进入mysql
mysql -P3316 -uroot
</code></pre>
<h4 id="带密码安装"><a href="#带密码安装" class="headerlink" title="带密码安装"></a>带密码安装</h4><ul>
<li>在mysql-1下执行脚本</li>
</ul>
<pre><code class="prettyprint">mysqld install mysql1
#默认root，user可以不用指定，打印密码需要记住
mysqld --initialize --user=root --console
net start mysql1
#如有安装失败需要先删除data文件夹再安装
#进入mysql
mysql -uroot -p
#输入密码
**************
ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;;
create user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;root&#39;;
grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; with grant option;
flush privileges;
</code></pre>
<ul>
<li>在mysql-1下执行脚本</li>
</ul>
<pre><code class="prettyprint">mysqld install mysql2
#默认root，user可以不用指定，打印密码需要记住
mysqld --initialize --user=root --console
net start mysql2
#如有安装失败需要先删除data文件夹再安装
#进入mysql
mysql -uroot -p
#输入密码
**************
ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;;
create user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;root&#39;;
grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; with grant option;
flush privileges;
</code></pre>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>git clone Filename too long</title>
    <url>/2022/06/04/git-clone-filename-too-long/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题（windows）"><a href="#问题（windows）" class="headerlink" title="问题（windows）"></a>问题（windows）</h3><pre><code class="prettyprint">error: unable to create file examples/shardingsphere-jdbc-example/mixed-feature-example/sharding-readwrite-splitting-example/sharding-readwrite-splitting-raw-jdbc-example/src/main/java/org/apache/shardingsphere/example/sharding/readwrite/splitting/raw/ShardingReadwriteSplittingRawJavaConfigurationExample.java: Filename too long
error: unable to create file examples/shardingsphere-jdbc-example/mixed-feature-example/sharding-readwrite-splitting-example/sharding-readwrite-splitting-raw-jdbc-example/src/main/java/org/apache/shardingsphere/example/sharding/readwrite/splitting/raw/ShardingReadwriteSplittingRawJavaRangeConfigurationExample.java: Filename too long
error: unable to create file examples/shardingsphere-jdbc-example/mixed-feature-example/sharding-readwrite-splitting-example/sharding-readwrite-splitting-raw-jdbc-example/src/main/java/org/apache/shardingsphere/example/sharding/readwrite/splitting/raw/ShardingReadwriteSplittingRawYamlConfigurationExample.java: Filename too long
error: unable to create file examples/shardingsphere-jdbc-example/mixed-feature-example/sharding-readwrite-splitting-example/sharding-readwrite-splitting-raw-jdbc-example/src/main/java/org/apache/shardingsphere/example/sharding/readwrite/splitting/raw/ShardingReadwriteSplittingRawYamlRangeConfigurationExample.java: Filename too long
fatal: cannot create directory at &#39;examples/shardingsphere-jdbc-example/mixed-feature-example/sharding-readwrite-splitting-example/sharding-readwrite-splitting-raw-jdbc-example/src/main/java/org/apache/shardingsphere/example/sharding/readwrite/splitting/raw/config&#39;: Filename too long
</code></pre>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><blockquote>
<p>管理员打开<code>cmd</code></p>
</blockquote>
<pre><code> git config --system core.longpaths true
</code></pre>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux定时git pull</title>
    <url>/2022/06/05/linux-ding-shi-git-pull/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="编辑git-pull脚本"><a href="#编辑git-pull脚本" class="headerlink" title="编辑git pull脚本"></a>编辑git pull脚本</h3><pre><code class="prettyprint">#!/bin/bash

cd /usr/local/nginx/html/RocPengHua
git pull
</code></pre>
<h3 id="给脚本权限"><a href="#给脚本权限" class="headerlink" title="给脚本权限"></a>给脚本权限</h3><pre><code class="prettyprint">chmod 777 task.sh
</code></pre>
<h3 id="编辑crontab定时任务"><a href="#编辑crontab定时任务" class="headerlink" title="编辑crontab定时任务"></a>编辑crontab定时任务</h3><pre><code class="prettyprint">#新建
crontab -e
#查看
crontab -l
</code></pre>
<h4 id="编辑定时任务内容"><a href="#编辑定时任务内容" class="headerlink" title="编辑定时任务内容"></a>编辑定时任务内容</h4><pre><code class="prettyprint">#每隔两分钟，7点到23点执行
*/2 7-23 * * * sh /usr/local/nginx/html/task.sh
</code></pre>
<h3 id="重启定时任务"><a href="#重启定时任务" class="headerlink" title="重启定时任务"></a>重启定时任务</h3><pre><code class="prettyprint">systemctl restart crond #重启定时任务
systemctl reload crond #重新加载
</code></pre>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><pre><code class="prettyprint">tailf /val/log/cron
</code></pre>
<ul>
<li>日志记录</li>
</ul>
<blockquote>
<p>Jun  5 10:50:01 iZm5e198ia3o66a6om8gf3Z CROND[31499]: (root) CMD (sh &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;task.sh)<br>Jun  5 10:50:01 iZm5e198ia3o66a6om8gf3Z CROND[31497]: (root) MAIL (mailed 69 bytes of output but got status 0x004b#012)<br>Jun  5 10:52:01 iZm5e198ia3o66a6om8gf3Z CROND[31607]: (root) CMD (sh &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;task.sh)<br>Jun  5 10:52:01 iZm5e198ia3o66a6om8gf3Z CROND[31606]: (root) MAIL (mailed 69 bytes of output but got status 0x004b#012)<br>Jun  5 10:54:01 iZm5e198ia3o66a6om8gf3Z CROND[31711]: (root) CMD (sh &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;task.sh)<br>Jun  5 10:54:01 iZm5e198ia3o66a6om8gf3Z CROND[31710]: (root) MAIL (mailed 69 bytes of output but got status 0x004b#012)<br>Jun  5 10:56:01 iZm5e198ia3o66a6om8gf3Z CROND[31818]: (root) CMD (sh &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;task.sh)<br>Jun  5 10:56:01 iZm5e198ia3o66a6om8gf3Z CROND[31817]: (root) MAIL (mailed 69 bytes of output but got status 0x004b#012)</p>
</blockquote>
<h4 id="mailed-69-bytes-of-output-but-got-status-0x004b-012"><a href="#mailed-69-bytes-of-output-but-got-status-0x004b-012" class="headerlink" title="mailed 69 bytes of output but got status 0x004b#012"></a>mailed 69 bytes of output but got status 0x004b#012</h4><ul>
<li><p>问题修改</p>
<ul>
<li>修改 &#x2F;etc&#x2F;postfix&#x2F;main.cf 文件</li>
</ul>
<pre><code class="prettyprint">#打开all
inet_interfaces = all
#inet_interfaces = $myhostname
#inet_interfaces = $myhostname, localhost
#注释localhost
#inet_interfaces = localhost
</code></pre>
<ul>
<li><code>service postfix start</code></li>
</ul>
</li>
</ul>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><pre><code class="prettyprint">#查看服务状态
systemctl status crond
#启动
systemctl start crond
#停止
systemctl stop crond
#重启
systemctl restart crond
#重新加载
systemctl reload crond
#开机启动crontab服务
systemctl start crond
</code></pre>
<h3 id="cron说明"><a href="#cron说明" class="headerlink" title="cron说明"></a>cron说明</h3><blockquote>
<p>第一列：分minute (0 - 59)<br>第二列：时hour (0 - 23)<br>第三列：日day of month (1 - 31)<br>第四列：月month (1 - 12)<br>第五列：周day of week (0 - 6)<br>第六列：要执行的任务命令或程序</p>
</blockquote>
<ul>
<li><p>表示的 每或每一 的意思<br> <code>00 23 * * * sh /usr/local/nginx/html/task.sh</code> 每天23点00分执行任务</p>
</li>
<li><p>连续区间 1-10</p>
<ul>
<li><code>00 8-23 * * * sh /usr/local/nginx/html/task.sh</code> 每天8点至23点，每小时执行任务</li>
<li><code>00 1,2,3,4,8 * * * sh /usr/local/nginx/html/task.sh</code> 每天1点、2点、3点、4点、8点执行任务</li>
<li><code>*/10 *  * * * sh /usr/local/nginx/html/task.sh </code>每隔10分钟执行一次任务</li>
<li><code>30 */6 * * * sh /usr/local/nginx/html/task.sh </code>每隔6小时的30分执行任务</li>
<li><code>30 8-12/2 * * * sh /usr/local/nginx/html/task.sh</code> 每天8点至12点，每隔2小时的30分执行任务</li>
<li><code>45 4 1,10,22 * * sh /usr/local/nginx/html/task.sh </code>每月1号、10号、22号4点45分执行任务</li>
<li><code>10 1 * * 6,0 sh /usr/local/nginx/html/task.sh </code>每周六周日1点10执行任务</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>雪花算法（SnowFlake）</title>
    <url>/2022/06/03/xue-hua-suan-fa-snowflake/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p>SnowFlake算法生成id的结果是一个64bit大小的整数，它的结构如下图：</p>
</blockquote>
<img src="/2022/06/03/xue-hua-suan-fa-snowflake/webp.webp" class="asset-class" title="img">

<ul>
<li><p>1bit，不用，因为二进制中最高位是符号位，1表示负数，0表示正数。生成的id一般都是用整数，所以最高位固定为0。</p>
</li>
<li><p>41bit时间戳，毫秒级。可以表示的数值范围是 （2^41-1），转换成单位年则是69年。</p>
</li>
<li><p>10bit工作机器ID，用来表示工作机器的ID，包括5位<code>datacenterId</code>(机房id)和5位<code>workerId</code>(机器id)。</p>
</li>
<li><p>12bit序列号，用来记录同毫秒内产生的不同id，12位可以表示的最大整数为4095，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号。</p>
</li>
</ul>
<blockquote>
<p>由于在Java中64bit的整数是long类型，所以在Java中SnowFlake算法生成的id就是long来存储的。</p>
</blockquote>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><pre><code class="prettyprint">package dataStructure;

/**
 * @author RocPengHua
 * @program algorithmic-problems
 * @description 雪花算法
 * @date 2022年06月03日 20:46
 */

public class IdWorker &#123;

    //因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。

    /**
     * 机器ID  2进制5位  32位减掉1位 31个
     */
    private long workerId;
    /**
     * 机房ID 2进制5位  32位减掉1位 31个
     */
    private long datacenterId;

    /**
     * 代表一毫秒内生成的多个id的最新序号  12位 4096 -1 = 4095 个
     */
    private long sequence;
    /**
     * 设置一个时间初始值    2^41 - 1   差不多可以用69年
     */
    private long twepoch = 1585644268888L;
    /**
     * 5位的机器id
     */
    private long workerIdBits = 5L;
    /**
     * 5位的机房id
     */
    private long datacenterIdBits = 5L;
    /**
     * 每毫秒内产生的id数 2 的 12次方
     */
    private long sequenceBits = 12L;
    /**
     * 这个是二进制运算，就是5 bit最多只能有31个数字，也就是说机器id最多只能是32以内
     * -1L ^ (-1L &lt;&lt; workerIdBits);
     */
    private long maxWorkerId = ~(-1L &lt;&lt; workerIdBits);
    /**
     * 这个是一个意思，就是5 bit最多只能有31个数字，机房id最多只能是32以内
     * -1L ^ (-1L &lt;&lt; datacenterIdBits);
     */
    private long maxDatacenterId = ~(-1L &lt;&lt; datacenterIdBits);

    private long workerIdShift = sequenceBits;
    private long datacenterIdShift = sequenceBits + workerIdBits;
    private long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;
    /**
     * -1L ^ (-1L &lt;&lt; sequenceBits);
     */
    private long sequenceMask = ~(-1L &lt;&lt; sequenceBits);
    /**
     * 记录产生时间毫秒数，判断是否是同1毫秒
     */
    private long lastTimestamp = -1L;

    public long getWorkerId() &#123;
        return workerId;
    &#125;

    public long getDatacenterId() &#123;
        return datacenterId;
    &#125;

    public long getTimestamp() &#123;
        return System.currentTimeMillis();
    &#125;


    public IdWorker(long workerId, long datacenterId, long sequence) &#123;

        // 检查机房id和机器id是否超过31 不能小于0
        if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123;
            throw new IllegalArgumentException(
                    String.format(&quot;worker Id can&#39;t be greater than %d or less than 0&quot;, maxWorkerId));
        &#125;

        if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123;

            throw new IllegalArgumentException(
                    String.format(&quot;datacenter Id can&#39;t be greater than %d or less than 0&quot;, maxDatacenterId));
        &#125;
        this.workerId = workerId;
        this.datacenterId = datacenterId;
        this.sequence = sequence;
    &#125;

    // 这个是核心方法，通过调用nextId()方法，让当前这台机器上的snowflake算法程序生成一个全局唯一的id
    public synchronized long nextId() &#123;
        // 这儿就是获取当前时间戳，单位是毫秒
        long timestamp = timeGen();
        if (timestamp &lt; lastTimestamp) &#123;

            System.err.printf(
                    &quot;clock is moving backwards. Rejecting requests until %d.&quot;, lastTimestamp);
            throw new RuntimeException(
                    String.format(&quot;Clock moved backwards. Refusing to generate id for %d milliseconds&quot;,
                            lastTimestamp - timestamp));
        &#125;

        // 下面是说假设在同一个毫秒内，又发送了一个请求生成一个id
        // 这个时候就得把seqence序号给递增1，最多就是4096
        if (lastTimestamp == timestamp) &#123;

            // 这个意思是说一个毫秒内最多只能有4096个数字，无论你传递多少进来，
            //这个位运算保证始终就是在4096这个范围内，避免你自己传递个sequence超过了4096这个范围
            sequence = (sequence + 1) &amp; sequenceMask;
            //当某一毫秒的时间，产生的id数 超过4095，系统会进入等待，直到下一毫秒，系统继续产生ID
            if (sequence == 0) &#123;
                timestamp = tilNextMillis(lastTimestamp);
            &#125;

        &#125; else &#123;
            sequence = 0;
        &#125;
        // 这儿记录一下最近一次生成id的时间戳，单位是毫秒
        lastTimestamp = timestamp;
        // 这儿就是最核心的二进制位运算操作，生成一个64bit的id
        // 先将当前时间戳左移，放到41 bit那儿；将机房id左移放到5 bit那儿；将机器id左移放到5 bit那儿；将序号放最后12 bit
        // 最后拼接起来成一个64 bit的二进制数字，转换成10进制就是个long型
        return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) |
                (datacenterId &lt;&lt; datacenterIdShift) |
                (workerId &lt;&lt; workerIdShift) | sequence;
    &#125;

    /**
     * 当某一毫秒的时间，产生的id数 超过4095，系统会进入等待，直到下一毫秒，系统继续产生ID
     *
     * @param lastTimestamp
     * @return
     */
    private long tilNextMillis(long lastTimestamp) &#123;

        long timestamp = timeGen();

        while (timestamp &lt;= lastTimestamp) &#123;
            timestamp = timeGen();
        &#125;
        return timestamp;
    &#125;

    //获取当前时间戳
    private long timeGen() &#123;
        return System.currentTimeMillis();
    &#125;

    /**
     * main 测试类
     *
     * @param args
     */
    public static void main(String[] args) &#123;
        System.out.println(1 &amp; 4596);
        System.out.println(2 &amp; 4596);
        System.out.println(6 &amp; 4596);
        System.out.println(6 &amp; 4596);
        System.out.println(6 &amp; 4596);
        System.out.println(6 &amp; 4596);
        IdWorker worker = new IdWorker(1, 1, 1);
        for (int i = 0; i &lt; 22; i++) &#123;
            System.out.println(worker.nextId());
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>SnowFlake算法的优点：</p>
</blockquote>
<ul>
<li><p>高性能高可用：生成时不依赖于数据库，完全在内存中生成。</p>
</li>
<li><p>容量大：每秒中能生成数百万的自增ID。</p>
</li>
<li><p>ID自增：存入数据库中，索引效率高。</p>
</li>
</ul>
<blockquote>
<p> SnowFlake算法的缺点：</p>
</blockquote>
<p>依赖与系统时间的一致性，如果系统时间被回调，或者改变，可能会造成id冲突或者重复。</p>
<p>实际中我们的机房并没有那么多，我们可以改进改算法，将10bit的机器id优化，成业务表或者和我们系统相关的业务。</p>
<h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><p>雪花算法产生的长整数的精度可能超过javascript能表达的精度，这会导致js获取的id与雪花算法算出来的id不一致，如雪花算法得到的是36594866121080832，但是因为javascript丢失精度后只获取到36594866121080830， 这会导致对数据的所有操作都失效。</p>
<p>解决办法：后端的语言获取到雪花算法的id后将其转换为String类型，这样js也会当做字符串来处理，就不会丢失精度了。</p>
<p>链接：<a href="http://events.jianshu.io/p/5769966ff5fc">http://events.jianshu.io/p/5769966ff5fc</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>redis淘汰算法及策略</title>
    <url>/2022/06/07/redis-tao-tai-suan-fa-ji-ce-lue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><blockquote>
<p>创建一个定时器，当key设置有过期时间且过期时间到达时，由定时器任务立即执行对键的删除操作</p>
<p>优点：节省内存，快速释放</p>
<p>缺点：cpu压力大，删除操作会影响redis响应时间和吞吐量</p>
</blockquote>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><blockquote>
<p>redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的 key</p>
<p>默认每100ms扫描一次，但是不会遍历所有的key，使用贪心策略</p>
</blockquote>
<ul>
<li>从过期字典中随机20gekey</li>
<li>删除者20个key中已经过期了的key</li>
<li>如果过期比例超过1&#x2F;4，重复步骤1</li>
</ul>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><blockquote>
<p>客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西</p>
<p>定期删除可能会导致很多过期key到了时间并没有被删除掉。所以就有了惰性删除</p>
</blockquote>
<p><strong>定期删除是集中处理，惰性删除是零散处理</strong></p>
<h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><ul>
<li><p><code>noeviction</code>：当内存使用超过配置的时候会返回错误，不会驱逐任何键</p>
</li>
<li><p><code>allkeys-lru</code>：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键</p>
</li>
<li><p><code>volatile-lru</code>：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键</p>
</li>
<li><p><code>allkeys-random</code>：加入键的时候如果过限，从所有key随机删除</p>
</li>
<li><p><code>volatile-random</code>：加入键的时候如果过限，从过期键的集合中随机驱逐</p>
</li>
<li><p><code>volatile-ttl</code>：从配置了过期时间的键中驱逐马上就要过期的键</p>
</li>
<li><p><code>volatile-lfu</code>：从所有配置了过期时间的键中驱逐使用频率最少的键</p>
</li>
<li><p><code>allkeys-lfu</code>：从所有键中驱逐使用频率最少的键</p>
</li>
</ul>
<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><img src="/2022/06/07/redis-tao-tai-suan-fa-ji-ce-lue/v2-9374e1c1ef6c7c8d14491b4092d79f80_720w.jpg" class="asset-class" title="img">

<ul>
<li>新增key value的时候首先在链表结尾添加Node节点，如果超过LRU设置的阈值就淘汰队头的节点并删除掉HashMap中对应的节点。</li>
<li>修改key对应的值的时候先修改对应的Node中的值，然后把Node节点移动队尾。</li>
<li>访问key对应的值的时候把访问的Node节点移动到队尾即可。</li>
</ul>
<pre><code class="prettyprint">package LRU;

import java.util.HashMap;

/**
 * @author RocPengHua
 * @program CLRS
 * @description LRU(最近最少使用)缓存机制
 * @date 2022年06月07日 21:03
 */
public class LRUCache &#123;
    private HashMap&lt;Integer,LinkedNode&gt; cache = new HashMap&lt;&gt;();
    int size;
    int capacity;
    private LinkedNode head,tail;
    class LinkedNode &#123;
        int key;
        int value;
        LinkedNode pre;
        LinkedNode next;
    &#125;

    public LRUCache(int capacity) &#123;
        this.size = 0;
        this.capacity = capacity;
        head = new LinkedNode();
        tail = new LinkedNode();
        head.next = tail;
        tail.pre = head;
    &#125;

    /**
     * 写入数据
     * @param key
     * @param value
     */
    public void put(int key, int value)&#123;
        LinkedNode node = cache.get(key);

        /**
         * 存在
         */
        if(node != null)&#123;
            //更新数据
            node.value = value;
            moveToHead(node);
        &#125;else&#123;
            LinkedNode newNode = new LinkedNode();
            newNode.key = key;
            newNode.value = value;
            //更新map
            cache.put(key,newNode);
            //添加节点到头部
            addNode(newNode);
            //更新节点数
            size++;
            //如果节点数目大于容量，删除最后一个节点
            if(size &gt; capacity) &#123;
                //获取最后一个节点
                LinkedNode tailPre = tail.pre;
                //从map中删除
                cache.remove(tailPre.key);
                //删除节点
                removeNode(tailPre);
                size--;
            &#125;
        &#125;
    &#125;

    public int get(int key)&#123;
        LinkedNode node = cache.get(key);
        if(node != null)&#123;
            moveToHead(node);
        &#125;else&#123;
            return -1;
        &#125;
        return node.value;
    &#125;
    /**
     * 将节点移到头部
     * @param node
     */
    private void moveToHead(LinkedNode node) &#123;
        removeNode(node);
        addNode(node);
    &#125;

    /**
     * 添加到头部
     * @param node
     */
    private void addNode(LinkedNode node) &#123;
        node.pre = head;
        node.next = head.next;
        head.next.pre = node;
        head.next = node;
    &#125;

    /**
     * 删除节点
     * @param node
     */
    private void removeNode(LinkedNode node) &#123;
        LinkedNode preNode = node.pre;
        LinkedNode nextNode = node.next;
        preNode.next = nextNode;
        nextNode.pre = preNode;

    &#125;

    public static void main(String[] args) &#123;
        LRUCache cache = new LRUCache(2);
        cache.put(1,1);
        cache.put(2,2);
        System.out.println(cache.get(1));
        cache.put(3,3);
        System.out.println(cache.get(2));
        cache.put(4,4);
        cache.put(5,5);
        cache.put(6,6);
        System.out.println(cache.get(4));
        System.out.println(cache.get(5));
        System.out.println(cache.get(6));
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存穿透、击穿、雪崩</title>
    <url>/2022/06/08/huan-cun-chuan-tou-ji-chuan-xue-beng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><blockquote>
<p>大量并发查询不存在的KEY，导致都直接将压力透传到数据库</p>
</blockquote>
<p><strong>解决方法</strong></p>
<ul>
<li>缓存空值的KEY，这样第一次不存在也会被加载会记录，下次拿到有这个KEY</li>
<li>Bloom过滤或RoaringBitmap 判断KEY是否存</li>
<li>完全以缓存为准，使用 延迟异步加载 的策略</li>
</ul>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><blockquote>
<p>某个KEY失效的时候，正好有大量并发请求访问这个KEY</p>
</blockquote>
<p><strong>解决方法</strong></p>
<ul>
<li>KEY的更新操作添加全局互斥锁(异步双删)</li>
<li>完全以缓存为准，使用 延迟异步加载 的策略</li>
</ul>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><blockquote>
<p>当某一时刻发生大规模的缓存失效的情况，会有大量的请求进来直接打到数据库，导致数 据库压力过大升值宕机</p>
</blockquote>
<p><strong>解决方法</strong></p>
<ul>
<li>更新策略在时间上做到比较均匀</li>
<li>使用的热数据尽量分散到不同的机器上</li>
<li>多台机器做主从复制或者多副本，实现高可用</li>
<li>实现熔断限流机制，对系统进行负载能力控制</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置学习</title>
    <url>/2022/06/05/nginx-pei-zhi-xue-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>Nginx</code> 是开源、高性能、高可靠的 <code>Web</code> 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，即使运行几个月也不需要重新启动，还能在不间断服务的情况下对软件版本进行热更新。性能是 <code>Nginx</code> 最重要的考量，其占用内存少、并发能力强、能支持高达 5w 个并发连接数，最重要的是， <code>Nginx</code> 是免费的并可以商业化，配置使用也比较简单。</p>
<p><strong>Nginx 特点</strong></p>
<ul>
<li>高并发、高性能；</li>
<li>模块化架构使得它的扩展性非常好；</li>
<li>异步非阻塞的事件驱动模型这点和 <code>Node.js</code> 相似；</li>
<li>相对于其它服务器来说它可以连续几个月甚至更长而不需要重启服务器使得它具有高可靠性；</li>
<li>热部署、平滑升级；</li>
<li>完全开源，生态繁荣；</li>
</ul>
<h1 id="Nginx-作用"><a href="#Nginx-作用" class="headerlink" title="Nginx 作用"></a>Nginx 作用</h1><p>Nginx 的最重要的几个使用场景：</p>
<ol>
<li>静态资源服务，通过本地文件系统提供服务；</li>
<li>反向代理服务，延伸出包括缓存、负载均衡等；</li>
<li><code>API</code> 服务， <code>OpenResty</code> ；</li>
</ol>
<p>对于前端来说 <code>Node.js</code> 并不陌生， <code>Nginx</code> 和 <code>Node.js</code> 的很多理念类似， <code>HTTP</code> 服务器、事件驱动、异步非阻塞等，且 <code>Nginx</code> 的大部分功能使用 <code>Node.js</code> 也可以实现，但 <code>Nginx</code> 和<code>Node.js</code> 并不冲突，都有自己擅长的领域。<code>Nginx</code> 擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等）， <code>Node.js</code> 更擅长上层具体业务逻辑的处理，两者可以完美组合。</p>
<p>用一张图表示：</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640.png" class="asset-class" title="图片">

<p><strong>Nginx 安装</strong></p>
<p>本文演示的是 <code>Linux</code> <code>centOS 7.x</code> 的操作系统上安装 <code>Nginx</code> ，至于在其它操作系统上进行安装可以网上自行搜索，都非常简单的。</p>
<p>使用 <code>yum</code> 安装 <code>Nginx</code> ：</p>
<pre><code>yum install nginx -y
</code></pre>
<p>安装完成后，通过 <code>rpm \-ql nginx</code> 命令查看 <code>Nginx</code> 的安装信息：</p>
<pre><code># Nginx配置文件
/etc/nginx/nginx.conf # nginx 主配置文件
/etc/nginx/nginx.conf.default

# 可执行程序文件
/usr/bin/nginx-upgrade
/usr/sbin/nginx

# nginx库文件
/usr/lib/systemd/system/nginx.service # 用于配置系统守护进程
/usr/lib64/nginx/modules # Nginx模块目录

# 帮助文档
/usr/share/doc/nginx-1.16.1
/usr/share/doc/nginx-1.16.1/CHANGES
/usr/share/doc/nginx-1.16.1/README
/usr/share/doc/nginx-1.16.1/README.dynamic
/usr/share/doc/nginx-1.16.1/UPGRADE-NOTES-1.6-to-1.10

# 静态资源目录
/usr/share/nginx/html/404.html
/usr/share/nginx/html/50x.html
/usr/share/nginx/html/index.html

# 存放Nginx日志文件
/var/log/nginx
</code></pre>
<p>主要关注的文件夹有两个：</p>
<p><code>1. /etc/nginx/conf.d/</code> 是子配置项存放处， <code>/etc/nginx/nginx.conf</code> 主配置文件会默认把这个文件夹中所有子配置项都引入；</p>
<p><code>2. /usr/share/nginx/html/</code> 静态文件都放在这个文件夹，也可以根据你自己的习惯放在其他地方；</p>
<p><strong>Nginx 常用命令</strong></p>
<p><code>systemctl</code> 系统命令：</p>
<pre><code># 开机配置
systemctl enable nginx # 开机自动启动
systemctl disable nginx # 关闭开机自动启动

# 启动Nginx
systemctl start nginx # 启动Nginx成功后，可以直接访问主机IP，此时会展示Nginx默认页面

# 停止Nginx
systemctl stop nginx

# 重启Nginx
systemctl restart nginx

# 重新加载Nginx
systemctl reload nginx

# 查看 Nginx 运行状态
systemctl status nginx

# 查看Nginx进程
ps -ef | grep nginx

# 杀死Nginx进程
kill -9 pid # 根据上面查看到的Nginx进程号，杀死Nginx进程，-9 表示强制结束进程
</code></pre>
<p><code>Nginx</code> 应用程序命令：</p>
<pre><code>nginx -s reload # 向主进程发送信号，重新加载配置文件，热重启
nginx -s reopen # 重启 Nginx
nginx -s stop # 快速关闭
nginx -s quit # 等待工作进程处理完成后关闭
nginx -T # 查看当前 Nginx 最终的配置
nginx -t # 检查配置是否有问题
</code></pre>
<h1 id="Nginx-核心配置"><a href="#Nginx-核心配置" class="headerlink" title="Nginx 核心配置"></a>Nginx 核心配置</h1><h2 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h2><p><code>Nginx</code> 的典型配置示例：</p>
<pre><code># main段配置信息
user  nginx; # 运行用户，默认即是nginx，可以不进行设置
worker_processes  auto; # Nginx 进程数，一般设置为和 CPU 核数一样
error_log  /var/log/nginx/error.log warn; # Nginx 的错误日志存放目录
pid        /var/run/nginx.pid; # Nginx 服务启动时的 pid 存放位置

# events段配置信息
events &#123;
    use epoll; # 使用epoll的I/O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的)
    worker_connections 1024; # 每个进程允许最大并发数
&#125;

# http段配置信息
# 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置
http &#123; 
    # 设置日志模式
    log_format  main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

    access_log  /var/log/nginx/access.log main; # Nginx访问日志存放位置

    sendfile            on; # 开启高效传输模式
    tcp_nopush          on; # 减少网络报文段的数量
    tcp_nodelay         on;
    keepalive_timeout   65; # 保持连接的时间，也叫超时时间，单位秒
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types; # 文件扩展名与类型映射表
    default_type        application/octet-stream; # 默认文件类型

    include /etc/nginx/conf.d/*.conf; # 加载子配置项
    
    # server段配置信息
    server &#123;
     listen       80; # 配置监听的端口
     server_name  localhost; # 配置的域名
      
     # location段配置信息
     location / &#123;
      root   /usr/share/nginx/html; # 网站根目录
      index  index.html index.htm; # 默认首页文件
      deny 172.168.22.11; # 禁止访问的ip地址，可以为all
      allow 172.168.33.44；# 允许访问的ip地址，可以为all
     &#125;
     
     error_page 500 502 503 504 /50x.html; # 默认50x对应的访问页面
     error_page 400 404 error.html; # 同上
    &#125;
&#125;
</code></pre>
<ul>
<li>全局配置，对全局生效；</li>
<li><code>events</code> 配置影响 <code>Nginx</code> 服务器与用户的网络连接；</li>
<li><code>http</code> 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置；</li>
<li><code>server</code> 配置虚拟主机的相关参数，一个 <code>http</code> 块中可以有多个 <code>server</code> 块；</li>
<li><code>location</code> 用于配置匹配的 <code>uri</code> ；</li>
<li><code>upstream</code> 配置后端服务器具体地址，负载均衡配置不可或缺的部分；</li>
</ul>
<p>用一张图清晰的展示它的层级结构：</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550491.png" class="asset-class" title="图片">

<h2 id="配置文件-main-段核心参数"><a href="#配置文件-main-段核心参数" class="headerlink" title="配置文件 main 段核心参数"></a>配置文件 main 段核心参数</h2><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>指定运行 <code>Nginx</code> 的 <code>woker</code> 子进程的属主和属组，其中组可以不指定。</p>
<pre><code>user USERNAME [GROUP]

user nginx lion; # 用户是nginx;组是lion
</code></pre>
<p><strong>pid</strong></p>
<p>指定运行 <code>Nginx</code> <code>master</code> 主进程的 <code>pid</code> 文件存放路径。</p>
<pre><code>pid /opt/nginx/logs/nginx.pid # master主进程的的pid存放在nginx.pid的文件
</code></pre>
<h3 id="worker-rlimit-nofile-number"><a href="#worker-rlimit-nofile-number" class="headerlink" title="worker_rlimit_nofile_number"></a>worker_rlimit_nofile_number</h3><p>指定 <code>worker</code> 子进程可以打开的最大文件句柄数。</p>
<pre><code>worker_rlimit_nofile 20480; # 可以理解成每个worker子进程的最大连接数量。
</code></pre>
<p><strong>worker_rlimit_core</strong></p>
<p>指定 <code>worker</code> 子进程异常终止后的 <code>core</code> 文件，用于记录分析问题。</p>
<pre><code>worker_rlimit_core 50M; # 存放大小限制
working_directory /opt/nginx/tmp; # 存放目录
</code></pre>
<h3 id="worker-processes-number"><a href="#worker-processes-number" class="headerlink" title="worker_processes_number"></a>worker_processes_number</h3><p>指定 <code>Nginx</code> 启动的 <code>worker</code> 子进程数量。</p>
<pre><code>worker_processes 4; # 指定具体子进程数量
worker_processes auto; # 与当前cpu物理核心数一致
</code></pre>
<h3 id="worker-cpu-affinity"><a href="#worker-cpu-affinity" class="headerlink" title="worker_cpu_affinity"></a>worker_cpu_affinity</h3><p>将每个 <code>worker</code> 子进程与我们的 <code>cpu</code> 物理核心绑定。</p>
<pre><code>worker_cpu_affinity 0001 0010 0100 1000; # 4个物理核心，4个worker子进程
</code></pre>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550492.png" class="asset-class" title="图片">



<p>将每个 <code>worker</code> 子进程与特定 <code>CPU</code> 物理核心绑定，优势在于，避免同一个 <code>worker</code> 子进程在不同的 <code>CPU</code> 核心上切换，缓存失效，降低性能。但其并不能真正的避免进程切换。</p>
<p><strong>worker_priority</strong></p>
<p>指定 <code>worker</code> 子进程的 <code>nice</code> 值，以调整运行 <code>Nginx</code> 的优先级，通常设定为负值，以优先调用<code>Nginx</code> 。</p>
<pre><code>worker_priority -10; # 120-10=110，110就是最终的优先级
</code></pre>
<p><code>Linux</code> 默认进程的优先级值是120，值越小越优先；<code>nice</code> 定范围为 <code>-20</code> 到 <code>+19</code> 。</p>
<p>[备注] 应用的默认优先级值是120加上 <code>nice</code> 值等于它最终的值，这个值越小，优先级越高。</p>
<h3 id="worker-shutdown-timeout"><a href="#worker-shutdown-timeout" class="headerlink" title="worker_shutdown_timeout"></a>worker_shutdown_timeout</h3><p>指定 <code>worker</code> 子进程优雅退出时的超时时间。</p>
<pre><code>worker_shutdown_timeout 5s;
</code></pre>
<h3 id="timer-resolution"><a href="#timer-resolution" class="headerlink" title="timer_resolution"></a>timer_resolution</h3><p><code>worker</code> 子进程内部使用的计时器精度，调整时间间隔越大，系统调用越少，有利于性能提升；反之，系统调用越多，性能下降。</p>
<pre><code>timer_resolution 100ms;
</code></pre>
<p>在 <code>Linux</code> 系统中，用户需要获取计时器时需要向操作系统内核发送请求，有请求就必然会有开销，因此这个间隔越大开销就越小。</p>
<p><strong>daemon</strong></p>
<p>指定 <code>Nginx</code> 的运行方式，前台还是后台，前台用于调试，后台用于生产。</p>
<pre><code>daemon off; # 默认是on，后台运行模式
</code></pre>
<h2 id="配置文件-events-段核心参数"><a href="#配置文件-events-段核心参数" class="headerlink" title="配置文件 events 段核心参数"></a>配置文件 events 段核心参数</h2><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p><code>Nginx</code> 使用何种事件驱动模型。</p>
<pre><code>use method; # 不推荐配置它，让nginx自己选择

method 可选值为：select、poll、kqueue、epoll、/dev/poll、eventport
</code></pre>
<h3 id="worker-connections"><a href="#worker-connections" class="headerlink" title="worker_connections"></a>worker_connections</h3><p><code>worker</code> 子进程能够处理的最大并发连接数。</p>
<pre><code>worker_connections 1024 # 每个子进程的最大连接数为1024
</code></pre>
<p><strong>accept_mutex</strong></p>
<p>是否打开负载均衡互斥锁。</p>
<pre><code>accept_mutex on # 默认是off关闭的，这里推荐打开
</code></pre>
<p><strong>server_name 指令</strong></p>
<p>指定虚拟主机域名。</p>
<pre><code>server_name name1 name2 name3

# 示例：
server_name www.nginx.com;
</code></pre>
<p>域名匹配的四种写法：</p>
<ul>
<li>精确匹配：<code>server_name www.nginx.com</code> ;</li>
<li>左侧通配：<code>server_name *.nginx.com</code> ;</li>
<li>右侧统配：<code>server_name www.nginx.*</code> ;</li>
<li>正则匹配：<code>server_name ~^www\.nginx\.*$</code> ;</li>
</ul>
<p>匹配优先级：<strong>精确匹配 &gt; 左侧通配符匹配 &gt; 右侧通配符匹配 &gt; 正则表达式匹配</strong></p>
<p><code>server_name</code> 配置实例：</p>
<p>1、配置本地 <code>DNS</code> 解析 <code>vim /etc/hosts</code> （ <code>macOS</code> 系统）</p>
<pre><code># 添加如下内容，其中 121.42.11.34 是阿里云服务器IP地址
121.42.11.34 www.nginx-test.com
121.42.11.34 mail.nginx-test.com
121.42.11.34 www.nginx-test.org
121.42.11.34 doc.nginx-test.com
121.42.11.34 www.nginx-test.cn
121.42.11.34 fe.nginx-test.club
</code></pre>
<p>[注意] 这里使用的是虚拟域名进行测试，因此需要配置本地 <code>DNS</code> 解析，如果使用阿里云上购买的域名，则需要在阿里云上设置好域名解析。</p>
<p>2、配置阿里云 <code>Nginx</code> ，<code>vim /etc/nginx/nginx.conf</code></p>
<pre><code># 这里只列举了http端中的sever端配置

# 左匹配
server &#123;
 listen 80;
 server_name *.nginx-test.com;
 root /usr/share/nginx/html/nginx-test/left-match/;
 location / &#123;
  index index.html;
 &#125;
&#125;

# 正则匹配
server &#123;
 listen 80;
 server_name ~^.*\.nginx-test\..*$;
 root /usr/share/nginx/html/nginx-test/reg-match/;
 location / &#123;
  index index.html;
 &#125;
&#125;

# 右匹配
server &#123;
 listen 80;
 server_name www.nginx-test.*;
 root /usr/share/nginx/html/nginx-test/right-match/;
 location / &#123;
  index index.html;
 &#125;
&#125;

# 完全匹配
server &#123;
 listen 80;
 server_name www.nginx-test.com;
 root /usr/share/nginx/html/nginx-test/all-match/;
 location / &#123;
  index index.html;
 &#125;
&#125;
</code></pre>
<p>3、访问分析</p>
<ul>
<li>当访问 <code>www.nginx-test.com</code> 时，都可以被匹配上，因此选择优先级最高的“完全匹配”；</li>
<li>当访问 <code>mail.nginx-test.com</code> 时，会进行“左匹配”；</li>
<li>当访问 <code>www.nginx-test.org</code> 时，会进行“右匹配”；</li>
<li>当访问 <code>doc.nginx-test.com</code> 时，会进行“左匹配”；</li>
<li>当访问 <code>www.nginx-test.cn</code> 时，会进行“右匹配”；</li>
<li>当访问 <code>fe.nginx-test.club</code> 时，会进行“正则匹配”；</li>
</ul>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>指定静态资源目录位置，它可以写在 <code>http</code> 、 <code>server</code> 、 <code>location</code> 等配置中。</p>
<pre><code>root path

例如：
location /image &#123;
 root /opt/nginx/static;
&#125;

当用户访问 www.test.com/image/1.png 时，实际在服务器找的路径是 /opt/nginx/static/image/1.png
</code></pre>
<p>[注意] <code>root</code> 会将定义路径与 <code>URI</code> 叠加， <code>alias</code> 则只取定义路径。</p>
<h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>它也是指定静态资源目录位置，它只能写在 <code>location</code> 中。</p>
<pre><code>location /image &#123;
 alias /opt/nginx/static/image/;
&#125;

当用户访问 www.test.com/image/1.png 时，实际在服务器找的路径是 /opt/nginx/static/image/1.png
</code></pre>
<p>[注意] 使用 alias 末尾一定要添加 <code>/</code> ，并且它只能位于 <code>location</code> 中。</p>
<p><strong>location</strong></p>
<p>配置路径。</p>
<pre><code>location [ = | ~ | ~* | ^~ ] uri &#123;
 ...
&#125;
</code></pre>
<p>匹配规则：</p>
<ul>
<li><code>=</code> 精确匹配；</li>
<li><code>~</code> 正则匹配，区分大小写；</li>
<li><code>~*</code> 正则匹配，不区分大小写；</li>
<li><code>^~</code> 匹配到即停止搜索；</li>
</ul>
<p>匹配优先级：<code>=</code> &gt; <code>^~</code> &gt; <code>~</code> &gt; <code>~*</code> &gt; 不带任何字符。</p>
<p>实例：</p>
<pre><code>server &#123;
  listen 80;
  server_name www.nginx-test.com;
  
  # 只有当访问 www.nginx-test.com/match_all/ 时才会匹配到/usr/share/nginx/html/match_all/index.html
  location = /match_all/ &#123;
      root /usr/share/nginx/html
      index index.html
  &#125;
  
  # 当访问 www.nginx-test.com/1.jpg 等路径时会去 /usr/share/nginx/images/1.jpg 找对应的资源
  location ~ \.(jpeg|jpg|png|svg)$ &#123;
   root /usr/share/nginx/images;
  &#125;
  
  # 当访问 www.nginx-test.com/bbs/ 时会匹配上 /usr/share/nginx/html/bbs/index.html
  location ^~ /bbs/ &#123;
   root /usr/share/nginx/html;
    index index.html index.htm;
  &#125;
&#125;
</code></pre>
<p><strong>location 中的反斜线</strong></p>
<pre><code>location /test &#123;
 ...
&#125;

location /test/ &#123;
 ...
&#125;
</code></pre>
<ul>
<li>不带 <code>/</code> 当访问 <code>www.nginx-test.com/test</code> 时， <code>Nginx</code> 先找是否有 <code>test</code> 目录，如果有则找<code>test</code> 目录下的 <code>index.html</code> ；如果没有 <code>test</code> 目录， <code>nginx</code> 则会找是否有 <code>test</code> 文件。</li>
<li>带 <code>/</code> 当访问 <code>www.nginx-test.com/test</code> 时， <code>Nginx</code> 先找是否有 <code>test</code> 目录，如果有则找<code>test</code> 目录下的 <code>index.html</code> ，如果没有它也不会去找是否存在 <code>test</code> 文件。</li>
</ul>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>停止处理请求，直接返回响应码或重定向到其他 <code>URL</code> ；执行 <code>return</code> 指令后， <code>location</code> 中后续指令将不会被执行。</p>
<pre><code>return code [text];
return code URL;
return URL;

例如：
location / &#123;
 return 404; # 直接返回状态码
&#125;

location / &#123;
 return 404 &quot;pages not found&quot;; # 返回状态码 + 一段文本
&#125;

location / &#123;
 return 302 /bbs ; # 返回状态码 + 重定向地址
&#125;

location / &#123;
 return https://www.baidu.com ; # 返回重定向地址
&#125;
</code></pre>
<h2 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h2><p>根据指定正则表达式匹配规则，重写 <code>URL</code> 。</p>
<pre><code>语法：rewrite 正则表达式 要替换的内容 [flag];

上下文：server、location、if

示例：rewirte /images/(.*\.jpg)$ /pic/$1; # $1是前面括号(.*\.jpg)的反向引用
</code></pre>
<p><code>flag</code> 可选值的含义：</p>
<ul>
<li><code>last</code> 重写后的 <code>URL</code> 发起新请求，再次进入 <code>server</code> 段，重试 <code>location</code> 的中的匹配；</li>
<li><code>break</code> 直接使用重写后的 <code>URL</code> ，不再匹配其它 <code>location</code> 中语句；</li>
<li><code>redirect</code> 返回302临时重定向；</li>
<li><code>permanent</code> 返回301永久重定向；</li>
</ul>
<pre><code>server&#123;
  listen 80;
  server_name fe.lion.club; # 要在本地hosts文件进行配置
  root html;
  location /search &#123;
   rewrite ^/(.*) https://www.baidu.com redirect;
  &#125;
  
  location /images &#123;
   rewrite /images/(.*) /pics/$1;
  &#125;
  
  location /pics &#123;
   rewrite /pics/(.*) /photos/$1;
  &#125;
  
  location /photos &#123;
  
  &#125;
&#125;
</code></pre>
<p>按照这个配置我们来分析：</p>
<ul>
<li>当访问 <code>fe.lion.club/search</code> 时，会自动帮我们重定向到 <code>https://www.baidu.com</code>。</li>
<li>当访问 <code>fe.lion.club/images/1.jpg</code> 时，第一步重写 <code>URL</code> 为 <code>fe.lion.club/pics/1.jpg</code> ，找到 <code>pics</code> 的 <code>location</code> ，继续重写 <code>URL</code> 为 <code>fe.lion.club/photos/1.jpg</code> ，找到 <code>/photos</code> 的<code>location</code> 后，去 <code>html/photos</code> 目录下寻找 <code>1.jpg</code> 静态资源。</li>
</ul>
<h2 id="if-指令"><a href="#if-指令" class="headerlink" title="if 指令"></a>if 指令</h2><pre><code>语法：if (condition) &#123;...&#125;

上下文：server、location

示例：
if($http_user_agent ~ Chrome)&#123;
  rewrite /(.*)/browser/$1 break;
&#125;
</code></pre>
<p><code>condition</code> 判断条件：</p>
<ul>
<li><code>$variable</code> 仅为变量时，值为空或以0开头字符串都会被当做 <code>false</code> 处理；</li>
<li><code>=</code> 或 <code>!=</code> 相等或不等；</li>
<li><code>~</code> 正则匹配；</li>
<li><code>! ~</code> 非正则匹配；</li>
<li><code>~*</code> 正则匹配，不区分大小写；</li>
<li><code>-f</code> 或 <code>! -f</code> 检测文件存在或不存在；</li>
<li><code>-d</code> 或 <code>! -d</code> 检测目录存在或不存在；</li>
<li><code>-e</code> 或 <code>! -e</code> 检测文件、目录、符号链接等存在或不存在；</li>
<li><code>-x</code> 或 <code>! -x</code> 检测文件可以执行或不可执行；</li>
</ul>
<p>实例：</p>
<pre><code>server &#123;
  listen 8080;
  server_name localhost;
  root html;
  
  location / &#123;
   if ( $uri = &quot;/images/&quot; )&#123;
     rewrite (.*) /pics/ break;
    &#125;
  &#125;
&#125;
</code></pre>
<p>当访问 <code>localhost:8080/images/</code> 时，会进入 <code>if</code> 判断里面执行 <code>rewrite</code> 命令。</p>
<p><strong>autoindex</strong></p>
<p>用户请求以 <code>/</code> 结尾时，列出目录结构，可以用于快速搭建静态资源下载网站。</p>
<p><code>autoindex.conf</code> 配置信息：</p>
<pre><code>server &#123;
  listen 80;
  server_name fe.lion-test.club;
  
  location /download/ &#123;
    root /opt/source;
    
    autoindex on; # 打开 autoindex，，可选参数有 on | off
    autoindex_exact_size on; # 修改为off，以KB、MB、GB显示文件大小，默认为on，以bytes显示出⽂件的确切⼤⼩
    autoindex_format html; # 以html的方式进行格式化，可选参数有 html | json | xml
    autoindex_localtime off; # 显示的⽂件时间为⽂件的服务器时间。默认为off，显示的⽂件时间为GMT时间
  &#125;
&#125;
</code></pre>
<p>当访问 <code>fe.lion.com/download/</code> 时，会把服务器 <code>/opt/source/download/</code> 路径下的文件展示出来，如下图所示：</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550493.png" class="asset-class" title="图片">


<p><strong>变量</strong></p>
<p><code>Nginx</code> 提供给使用者的变量非常多，但是终究是一个完整的请求过程所产生数据， <code>Nginx</code> 将这些数据以变量的形式提供给使用者。</p>
<p>下面列举些项目中常用的变量：</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550504.png" class="asset-class" title="图片">

<p>实例演示 <code>var.conf</code> ：</p>
<pre><code>server&#123;
 listen 8081;
 server_name var.lion-test.club;
 root /usr/share/nginx/html;
 location / &#123;
  return 200 &quot;
remote_addr: $remote_addr
remote_port: $remote_port
server_addr: $server_addr
server_port: $server_port
server_protocol: $server_protocol
binary_remote_addr: $binary_remote_addr
connection: $connection
uri: $uri
request_uri: $request_uri
scheme: $scheme
request_method: $request_method
request_length: $request_length
args: $args
arg_pid: $arg_pid
is_args: $is_args
query_string: $query_string
host: $host
http_user_agent: $http_user_agent
http_referer: $http_referer
http_via: $http_via
request_time: $request_time
https: $https
request_filename: $request_filename
document_root: $document_root
&quot;;
 &#125;
&#125;
</code></pre>
<p>当我们访问 <code>http://var.lion-test.club:8081/test?pid=121414&amp;cid=sadasd</code> 时，由于 <code>Nginx</code>中写了 <code>return</code> 方法，因此 <code>chrome</code> 浏览器会默认为我们下载一个文件，下面展示的就是下载的文件内容：</p>
<pre><code>remote_addr: 27.16.220.84
remote_port: 56838
server_addr: 172.17.0.2
server_port: 8081
server_protocol: HTTP/1.1
binary_remote_addr: 茉
connection: 126
uri: /test/
request_uri: /test/?pid=121414&amp;cid=sadasd
scheme: http
request_method: GET
request_length: 518
args: pid=121414&amp;cid=sadasd
arg_pid: 121414
is_args: ?
query_string: pid=121414&amp;cid=sadasd
host: var.lion-test.club
http_user_agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36
http_referer: 
http_via: 
request_time: 0.000
https: 
request_filename: /usr/share/nginx/html/test/
document_root: /usr/share/nginx/html
</code></pre>
<p><code>Nginx</code> 的配置还有非常多，以上只是罗列了一些常用的配置，在实际项目中还是要学会查阅文档。</p>
<p><strong>Nginx 应用核心概念</strong></p>
<p>代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。</p>
<p>不管是正向代理还是反向代理，实现的都是上面的功能。</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550505.png" class="asset-class" title="图片">

<p><strong>正向代理</strong></p>
<blockquote>
<p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>
</blockquote>
<p>正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。</p>
<p>正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。</p>
<p><strong>反向代理</strong></p>
<blockquote>
<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
</blockquote>
<p>反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。</p>
<p>反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。</p>
<p>反向代理的优势：</p>
<ul>
<li>隐藏真实服务器；</li>
<li>负载均衡便于横向扩充后端动态服务；</li>
<li>动静分离，提升系统健壮性；</li>
</ul>
<p>那么“动静分离”是什么？负载均衡又是什么？</p>
<p><strong>动静分离</strong></p>
<p>动静分离是指在 <code>web</code> 服务器架构中，将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提示整个服务的访问性和可维护性。</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550506.png" class="asset-class" title="图片">


<p>一般来说，都需要将动态资源和静态资源分开，由于 <code>Nginx</code> 的高并发和静态资源缓存等特性，经常将静态资源部署在 <code>Nginx</code> 上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是动态资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。</p>
<p>使用前后端分离后，可以很大程度提升静态资源的访问速度，即使动态服务不可用，静态资源的访问也不会受到影响。</p>
<p><strong>负载均衡</strong></p>
<p>一般情况下，客户端发送多个请求到服务器，服务器处理请求，其中一部分可能要操作一些资源比如数据库、静态资源等，服务器处理完毕后，再将结果返回给客户端。</p>
<p>这种模式对于早期的系统来说，功能要求不复杂，且并发请求相对较少的情况下还能胜任，成本也低。随着信息数量不断增长，访问量和数据量飞速增长，以及系统业务复杂度持续增加，这种做法已无法满足要求，并发量特别大时，服务器容易崩。</p>
<p>很明显这是由于服务器性能的瓶颈造成的问题，除了堆机器之外，最重要的做法就是负载均衡。</p>
<p>请求爆发式增长的情况下，单个机器性能再强劲也无法满足要求了，这个时候集群的概念产生了，单个服务器解决不了的问题，可以使用多个服务器，然后将请求分发到各个服务器上，将负载分发到不同的服务器，这就是负载均衡，核心是「分摊压力」。<code>Nginx</code> 实现负载均衡，一般来说指的是将请求转发给服务器集群。</p>
<p>举个具体的例子，晚高峰乘坐地铁的时候，入站口经常会有地铁工作人员大喇叭“请走 <code>B</code> 口， <code>B</code>口人少车空….”，这个工作人员的作用就是负载均衡。</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550507.png" class="asset-class" title="图片">

<p><code>Nginx</code> 实现负载均衡的策略：</p>
<ul>
<li>轮询策略：默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</li>
<li>最小连接数策略：将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。</li>
<li>最快响应时间策略：优先分配给响应时间最短的服务器。</li>
<li>客户端 <code>ip</code> 绑定策略：来自同一个 <code>ip</code> 的请求永远只分配一台服务器，有效解决了动态网页存在的 <code>session</code> 共享问题。</li>
</ul>
<p><strong>Nginx 实战配置</strong></p>
<p>在配置反向代理和负载均衡等等功能之前，有两个核心模块是我们必须要掌握的，这两个模块应该说是 <code>Nginx</code> 应用配置中的核心，它们分别是：<code>upstream</code> 、<code>proxy_pass</code> 。</p>
<p><strong>upstream</strong></p>
<p>用于定义上游服务器（指的就是后台提供的应用服务器）的相关信息。</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550508.png" class="asset-class" title="图片">

<pre><code>语法：upstream name &#123;
 ...
&#125;

上下文：http

示例：
upstream back_end_server&#123;
  server 192.168.100.33:8081
&#125;
</code></pre>
<p>在 <code>upstream</code> 内可使用的指令：</p>
<ul>
<li><code>server</code> 定义上游服务器地址；</li>
<li><code>zone</code> 定义共享内存，用于跨 <code>worker</code> 子进程；</li>
<li><code>keepalive</code> 对上游服务启用长连接；</li>
<li><code>keepalive_requests</code> 一个长连接最多请求 <code>HTTP</code> 的个数；</li>
<li><code>keepalive_timeout</code> 空闲情形下，一个长连接的超时时长；</li>
<li><code>hash</code> 哈希负载均衡算法；</li>
<li><code>ip_hash</code> 依据 <code>IP</code> 进行哈希计算的负载均衡算法；</li>
<li><code>least_conn</code> 最少连接数负载均衡算法；</li>
<li><code>least_time</code> 最短响应时间负载均衡算法；</li>
<li><code>random</code> 随机负载均衡算法；</li>
</ul>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>定义上游服务器地址。</p>
<pre><code>语法：server address [parameters]

上下文：upstream
</code></pre>
<p><code>parameters</code> 可选值：</p>
<ul>
<li><code>weight=number</code> 权重值，默认为1；</li>
<li><code>max_conns=number</code> 上游服务器的最大并发连接数；</li>
<li><code>fail_timeout=time</code> 服务器不可用的判定时间；</li>
<li><code>max_fails=numer</code> 服务器不可用的检查次数；</li>
<li><code>backup</code> 备份服务器，仅当其他服务器都不可用时才会启用；</li>
<li><code>down</code> 标记服务器长期不可用，离线维护；</li>
</ul>
<h3 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h3><p>限制每个 <code>worker</code> 子进程与上游服务器空闲长连接的最大数量。</p>
<pre><code>keepalive connections;

上下文：upstream

示例：keepalive 16;
</code></pre>
<h3 id="keepalive-requests"><a href="#keepalive-requests" class="headerlink" title="keepalive_requests"></a>keepalive_requests</h3><p>单个长连接可以处理的最多 <code>HTTP</code> 请求个数。</p>
<pre><code>语法：keepalive_requests number;

默认值：keepalive_requests 100;

上下文：upstream
</code></pre>
<p><strong>keepalive_timeout</strong></p>
<p>空闲长连接的最长保持时间。</p>
<pre><code>语法：keepalive_timeout time;

默认值：keepalive_timeout 60s;

上下文：upstream
</code></pre>
<h3 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h3><pre><code>upstream back_end&#123;
 server 127.0.0.1:8081 weight=3 max_conns=1000 fail_timeout=10s max_fails=2;
  keepalive 32;
  keepalive_requests 50;
  keepalive_timeout 30s;
&#125;
</code></pre>
<h2 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h2><p>用于配置代理服务器。</p>
<pre><code>语法：proxy_pass URL;

上下文：location、if、limit_except

示例：
proxy_pass http://127.0.0.1:8081
proxy_pass http://127.0.0.1:8081/proxy
</code></pre>
<p><code>URL</code> 参数原则</p>
<ol>
<li><p><code>URL</code> 必须以 <code>http</code> 或 <code>https</code> 开头；</p>
</li>
<li><p><code>URL</code> 中可以携带变量；</p>
</li>
<li><p><code>URL</code> 中是否带 <code>URI</code> ，会直接影响发往上游请求的 <code>URL</code> ；</p>
</li>
</ol>
<p>接下来让我们来看看两种常见的 <code>URL</code> 用法：</p>
<ol>
<li><code>proxy_pass http://192.168.100.33:8081</code></li>
<li><code>proxy_pass http://192.168.100.33:8081/</code></li>
</ol>
<p>这两种用法的区别就是带 <code>/</code> 和不带 <code>/</code> ，在配置代理时它们的区别可大了：</p>
<ul>
<li>不带 <code>/</code> 意味着 <code>Nginx</code> 不会修改用户 <code>URL</code> ，而是直接透传给上游的应用服务器；</li>
<li>带 <code>/</code> 意味着 <code>Nginx</code> 会修改用户 <code>URL</code> ，修改方法是将 <code>location</code> 后的 <code>URL</code> 从用户 <code>URL</code> 中删除；</li>
</ul>
<p>不带 <code>/</code> 的用法：</p>
<pre><code>location /bbs/&#123;
  proxy_pass http://127.0.0.1:8080;
&#125;
</code></pre>
<p>分析：</p>
<ol>
<li><p>用户请求 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
</li>
<li><p>请求到达 <code>Nginx</code> 的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
</li>
<li><p>请求到达上游应用服务器的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
</li>
</ol>
<p>带 <code>/</code> 的用法：</p>
<pre><code>location /bbs/&#123;
  proxy_pass http://127.0.0.1:8080/;
&#125;
</code></pre>
<p>分析：</p>
<ol>
<li><p>用户请求 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
</li>
<li><p>请求到达 <code>Nginx</code> 的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
</li>
<li><p>请求到达上游应用服务器的 <code>URL</code> ：<code>/abc/test.html</code></p>
</li>
</ol>
<p>并没有拼接上 <code>/bbs</code> ，这点和 <code>root</code> 与 <code>alias</code> 之间的区别是保持一致的。</p>
<p><strong>配置反向代理</strong></p>
<p>这里为了演示更加接近实际，作者准备了两台云服务器，它们的公网 <code>IP</code> 分别是：<code>121.42.11.34</code>与 <code>121.5.180.193</code> 。</p>
<p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置：</p>
<pre><code># /etc/nginx/conf.d/proxy.conf
server&#123;
  listen 8080;
  server_name localhost;
  
  location /proxy/ &#123;
    root /usr/share/nginx/html/proxy;
    index index.html;
  &#125;
&#125;

# /usr/share/nginx/html/proxy/index.html
&lt;h1&gt; 121.42.11.34 proxy html &lt;/h1&gt;
</code></pre>
<p>配置完成后重启 <code>Nginx</code> 服务器 <code>nginx \-s reload</code> 。</p>
<p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置：</p>
<pre><code># /etc/nginx/conf.d/proxy.conf
upstream back_end &#123;
  server 121.42.11.34:8080 weight=2 max_conns=1000 fail_timeout=10s max_fails=3;
  keepalive 32;
  keepalive_requests 80;
  keepalive_timeout 20s;
&#125;

server &#123;
  listen 80;
  server_name proxy.lion.club;
  location /proxy &#123;
   proxy_pass http://back_end/proxy;
  &#125;
&#125;
</code></pre>
<p>本地机器要访问 <code>proxy.lion.club</code> 域名，因此需要配置本地 <code>hosts</code> ，通过命令：<code>vim /etc/hosts</code>进入配置文件，添加如下内容：</p>
<pre><code>121.5.180.193 proxy.lion.club
</code></pre>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550509.png" class="asset-class" title="图片">

<p>分析：</p>
<p>当访问 <code>proxy.lion.club/proxy</code> 时通过 <code>upstream</code> 的配置找到 <code>121.42.11.34:8080</code> ；</p>
<p>因此访问地址变为 <code>http://121.42.11.34:8080/proxy</code> ；</p>
<p>连接到 <code>121.42.11.34</code> 服务器，找到 <code>8080</code> 端口提供的 <code>server</code> ；</p>
<p>通过 <code>server</code> 找到 <code>/usr/share/nginx/html/proxy/index.html</code> 资源，最终展示出来。</p>
<h2 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h2><p>配置负载均衡主要是要使用 <code>upstream</code> 指令。</p>
<p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置（ <code>/etc/nginx/conf.d/balance.conf</code>）：</p>
<pre><code>server&#123;
  listen 8020;
  location / &#123;
   return 200 &#39;return 8020 \n&#39;;
  &#125;
&#125;

server&#123;
  listen 8030;
  location / &#123;
   return 200 &#39;return 8030 \n&#39;;
  &#125;
&#125;

server&#123;
  listen 8040;
  location / &#123;
   return 200 &#39;return 8040 \n&#39;;
  &#125;
&#125;
</code></pre>
<p>配置完成后：</p>
<p><code>1. nginx -t</code> 检测配置是否正确；</p>
<p><code>2. nginx -s reload</code> 重启 <code>Nginx</code> 服务器；</p>
<p>\3. 执行 <code>ss -nlt</code> 命令查看端口是否被占用，从而判断 <code>Nginx</code> 服务是否正确启动。</p>
<p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置（ <code>/etc/nginx/conf.d/balance.conf</code>）：</p>
<pre><code>upstream demo_server &#123;
  server 121.42.11.34:8020;
  server 121.42.11.34:8030;
  server 121.42.11.34:8040;
&#125;

server &#123;
  listen 80;
  server_name balance.lion.club;
  
  location /balance/ &#123;
   proxy_pass http://demo_server;
  &#125;
&#125;
</code></pre>
<p>配置完成后重启 <code>Nginx</code> 服务器。并且在需要访问的客户端配置好 <code>ip</code> 和域名的映射关系。</p>
<pre><code># /etc/hosts

121.5.180.193 balance.lion.club
</code></pre>
<p>在客户端机器执行 <code>curl http://balance.lion.club/balance/</code> 命令：</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-165439725505010.png" class="asset-class" title="图片">

<p>不难看出，负载均衡的配置已经生效了，每次给我们分发的上游服务器都不一样。就是通过简单的轮询策略进行上游服务器分发。</p>
<p>接下来，我们再来了解下 <code>Nginx</code> 的其它分发策略。</p>
<p><strong>hash 算法</strong></p>
<p>通过制定关键字作为 <code>hash key</code> ，基于 <code>hash</code> 算法映射到特定的上游服务器中。关键字可以包含有变量、字符串。</p>
<pre><code>upstream demo_server &#123;
  hash $request_uri;
  server 121.42.11.34:8020;
  server 121.42.11.34:8030;
  server 121.42.11.34:8040;
&#125;

server &#123;
  listen 80;
  server_name balance.lion.club;
  
  location /balance/ &#123;
   proxy_pass http://demo_server;
  &#125;
&#125;
</code></pre>
<p><code>hash $request_uri</code> 表示使用 <code>request_uri</code> 变量作为 <code>hash</code> 的 <code>key</code> 值，只要访问的 <code>URI</code> 保持不变，就会一直分发给同一台服务器。</p>
<p><strong>ip_hash</strong></p>
<p>根据客户端的请求 <code>ip</code> 进行判断，只要 <code>ip</code> 地址不变就永远分配到同一台主机。它可以有效解决后台服务器 <code>session</code> 保持的问题。</p>
<pre><code>upstream demo_server &#123;
  ip_hash;
  server 121.42.11.34:8020;
  server 121.42.11.34:8030;
  server 121.42.11.34:8040;
&#125;

server &#123;
  listen 80;
  server_name balance.lion.club;
  
  location /balance/ &#123;
   proxy_pass http://demo_server;
  &#125;
&#125;
</code></pre>
<h3 id="最少连接数算法"><a href="#最少连接数算法" class="headerlink" title="最少连接数算法"></a>最少连接数算法</h3><p>各个 <code>worker</code> 子进程通过读取共享内存的数据，来获取后端服务器的信息。来挑选一台当前已建立连接数最少的服务器进行分配请求。</p>
<pre><code>语法：least_conn;

上下文：upstream;
</code></pre>
<p>示例：</p>
<pre><code>upstream demo_server &#123;
  zone test 10M; # zone可以设置共享内存空间的名字和大小
  least_conn;
  server 121.42.11.34:8020;
  server 121.42.11.34:8030;
  server 121.42.11.34:8040;
&#125;

server &#123;
  listen 80;
  server_name balance.lion.club;
  
  location /balance/ &#123;
   proxy_pass http://demo_server;
  &#125;
&#125;
</code></pre>
<p>最后你会发现，负载均衡的配置其实一点都不复杂。</p>
<p><strong>配置缓存</strong></p>
<p>缓存可以非常有效的提升性能，因此不论是客户端（浏览器），还是代理服务器（ <code>Nginx</code> ），乃至上游服务器都多少会涉及到缓存。可见缓存在每个环节都是非常重要的。下面让我们来学习<code>Nginx</code> 中如何设置缓存策略。</p>
<p><strong>proxy_cache</strong></p>
<p>存储一些之前被访问过、而且可能将要被再次访问的资源，使用户可以直接从代理服务器获得，从而减少上游服务器的压力，加快整个访问速度。</p>
<pre><code>语法：proxy_cache zone | off ; # zone 是共享内存的名称

默认值：proxy_cache off;

上下文：http、server、location
</code></pre>
<p><strong>proxy_cache_path</strong></p>
<p>设置缓存文件的存放路径。</p>
<pre><code>语法：proxy_cache_path path [level=levels] ...可选参数省略，下面会详细列举

默认值：proxy_cache_path off

上下文：http
</code></pre>
<p>参数含义：</p>
<ul>
<li><code>path</code> 缓存文件的存放路径；</li>
<li><code>level path</code> 的目录层级；</li>
<li><code>keys_zone</code> 设置共享内存；</li>
<li><code>inactive</code> 在指定时间内没有被访问，缓存会被清理，默认10分钟；</li>
</ul>
<h3 id="proxy-cache-key"><a href="#proxy-cache-key" class="headerlink" title="proxy_cache_key"></a>proxy_cache_key</h3><p>设置缓存文件的 <code>key</code> 。</p>
<pre><code>语法：proxy_cache_key

默认值：proxy_cache_key $scheme$proxy_host$request_uri;

上下文：http、server、location
</code></pre>
<p><strong>proxy_cache_valid</strong></p>
<p>配置什么状态码可以被缓存，以及缓存时长。</p>
<pre><code>语法：proxy_cache_valid [code...] time;

上下文：http、server、location

配置示例：proxy_cache_valid 200 304 2m;; # 说明对于状态为200和304的缓存文件的缓存时间是2分钟
</code></pre>
<h3 id="proxy-no-cache"><a href="#proxy-no-cache" class="headerlink" title="proxy_no_cache"></a>proxy_no_cache</h3><p>定义相应保存到缓存的条件，如果字符串参数的至少一个值不为空且不等于“ 0”，则将不保存该响应到缓存。</p>
<pre><code>语法：proxy_no_cache string;

上下文：http、server、location

示例：proxy_no_cache $http_pragma    $http_authorization;
</code></pre>
<h3 id="proxy-cache-bypass"><a href="#proxy-cache-bypass" class="headerlink" title="proxy_cache_bypass"></a>proxy_cache_bypass</h3><p>定义条件，在该条件下将不会从缓存中获取响应。</p>
<pre><code>语法：proxy_cache_bypass string;

上下文：http、server、location

示例：proxy_cache_bypass $http_pragma    $http_authorization;
</code></pre>
<h3 id="upstream-cache-status-变量"><a href="#upstream-cache-status-变量" class="headerlink" title="upstream_cache_status 变量"></a>upstream_cache_status 变量</h3><p>它存储了缓存是否命中的信息，会设置在响应头信息中，在调试中非常有用。</p>
<pre><code>MISS: 未命中缓存
HIT：命中缓存
EXPIRED: 缓存过期
STALE: 命中了陈旧缓存
REVALIDDATED: Nginx验证陈旧缓存依然有效
UPDATING: 内容陈旧，但正在更新
BYPASS: X响应从原始服务器获取
</code></pre>
<h3 id="配置实例-1"><a href="#配置实例-1" class="headerlink" title="配置实例"></a>配置实例</h3><p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置（ <code>/etc/nginx/conf.d/cache.conf</code>）：</p>
<pre><code>server &#123;
  listen 1010;
  root /usr/share/nginx/html/1010;
  location / &#123;
   index index.html;
  &#125;
&#125;

server &#123;
  listen 1020;
  root /usr/share/nginx/html/1020;
  location / &#123;
   index index.html;
  &#125;
&#125;
</code></pre>
<p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置（ <code>/etc/nginx/conf.d/cache.conf</code> ）：</p>
<pre><code>proxy_cache_path /etc/nginx/cache_temp levels=2:2 keys_zone=cache_zone:30m max_size=2g inactive=60m use_temp_path=off;

upstream cache_server&#123;
  server 121.42.11.34:1010;
  server 121.42.11.34:1020;
&#125;

server &#123;
  listen 80;
  server_name cache.lion.club;
  location / &#123;
    proxy_cache cache_zone; # 设置缓存内存，上面配置中已经定义好的
    proxy_cache_valid 200 5m; # 缓存状态为200的请求，缓存时长为5分钟
    proxy_cache_key $request_uri; # 缓存文件的key为请求的URI
    add_header Nginx-Cache-Status $upstream_cache_status # 把缓存状态设置为头部信息，响应给客户端
    proxy_pass http://cache_server; # 代理转发
  &#125;
&#125;
</code></pre>
<p>缓存就是这样配置，我们可以在 <code>/etc/nginx/cache_temp</code> 路径下找到相应的缓存文件。</p>
<p><strong>对于一些实时性要求非常高的页面或数据来说，就不应该去设置缓存，下面来看看如何配置不缓存的内容。</strong></p>
<pre><code>...

server &#123;
  listen 80;
  server_name cache.lion.club;
  # URI 中后缀为 .txt 或 .text 的设置变量值为 &quot;no cache&quot;
  if ($request_uri ~ \.(txt|text)$) &#123;
   set $cache_name &quot;no cache&quot;
  &#125;
  
  location / &#123;
    proxy_no_cache $cache_name; # 判断该变量是否有值，如果有值则不进行缓存，如果没有值则进行缓存
    proxy_cache cache_zone; # 设置缓存内存
    proxy_cache_valid 200 5m; # 缓存状态为200的请求，缓存时长为5分钟
    proxy_cache_key $request_uri; # 缓存文件的key为请求的URI
    add_header Nginx-Cache-Status $upstream_cache_status # 把缓存状态设置为头部信息，响应给客户端
    proxy_pass http://cache_server; # 代理转发
  &#125;
&#125;
</code></pre>
<p><strong>HTTPS</strong></p>
<p>在学习如何配置 <code>HTTPS</code> 之前，我们先来简单回顾下 <code>HTTPS</code> 的工作流程是怎么样的？它是如何进行加密保证安全的？</p>
<p><strong>HTTPS 工作流程</strong></p>
<ol>
<li><p>客户端（浏览器）访问 <code>https://www.baidu.com</code> 百度网站；</p>
</li>
<li><p>百度服务器返回 <code>HTTPS</code> 使用的 <code>CA</code> 证书；</p>
</li>
<li><p>浏览器验证 <code>CA</code> 证书是否为合法证书；</p>
</li>
<li><p>验证通过，证书合法，生成一串随机数并使用公钥（证书中提供的）进行加密；</p>
</li>
<li><p>发送公钥加密后的随机数给百度服务器；</p>
</li>
<li><p>百度服务器拿到密文，通过私钥进行解密，获取到随机数（公钥加密，私钥解密，反之也可以）；</p>
</li>
<li><p>百度服务器把要发送给浏览器的内容，使用随机数进行加密后传输给浏览器；</p>
</li>
<li><p>此时浏览器可以使用随机数进行解密，获取到服务器的真实传输内容；</p>
</li>
</ol>
<p>这就是 <code>HTTPS</code> 的基本运作原理，使用对称加密和非对称机密配合使用，保证传输内容的安全性。</p>
<p>关于HTTPS更多知识，可以查看作者的另外一篇文章《学习 HTTP 协议》。</p>
<h3 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h3><p>下载证书的压缩文件，里面有个 <code>Nginx</code> 文件夹，把 <code>xxx.crt</code> 和 <code>xxx.key</code> 文件拷贝到服务器目录，再进行如下配置：</p>
<pre><code>server &#123;
  listen 443 ssl http2 default_server; # SSL 访问端口号为 443
  server_name lion.club; # 填写绑定证书的域名(我这里是随便写的)
  ssl_certificate /etc/nginx/https/lion.club_bundle.crt; # 证书地址
  ssl_certificate_key /etc/nginx/https/lion.club.key; # 私钥地址
  ssl_session_timeout 10m;
  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 支持ssl协议版本，默认为后三个，主流版本是[TLSv1.2]
 
  location / &#123;
    root         /usr/share/nginx/html;
    index        index.html index.htm;
  &#125;
&#125;
</code></pre>
<p>如此配置后就能正常访问 <code>HTTPS</code> 版的网站了。</p>
<p><strong>配置跨域 CORS</strong></p>
<p>先简单回顾下跨域究竟是怎么回事。</p>
<p><strong>跨域的定义</strong></p>
<p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。</p>
<p><strong>同源的定义</strong></p>
<p>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</p>
<p>下面给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例:</p>
<pre><code>http://store.company.com/dir2/other.html 同源
https://store.company.com/secure.html 不同源，协议不同
http://store.company.com:81/dir/etc.html 不同源，端口不同
http://news.company.com/dir/other.html 不同源，主机不同
</code></pre>
<p>不同源会有如下限制：</p>
<ul>
<li><code>Web</code> 数据层面，同源策略限制了不同源的站点读取当前站点的 <code>Cookie</code> 、 <code>IndexDB</code> 、<code>LocalStorage</code> 等数据。</li>
<li><code>DOM</code> 层面，同源策略限制了来自不同源的 <code>JavaScript</code> 脚本对当前 <code>DOM</code> 对象读和写的操作。</li>
<li>网络层面，同源策略限制了通过 <code>XMLHttpRequest</code> 等方式将站点的数据发送给不同源的站点。</li>
</ul>
<h3 id="Nginx-解决跨域的原理"><a href="#Nginx-解决跨域的原理" class="headerlink" title="Nginx 解决跨域的原理"></a>Nginx 解决跨域的原理</h3><p>例如：</p>
<ul>
<li>前端 <code>server</code> 的域名为：<code>fe.server.com</code></li>
<li>后端服务的域名为：<code>dev.server.com</code></li>
</ul>
<p>现在我在 <code>fe.server.com</code> 对 <code>dev.server.com</code> 发起请求一定会出现跨域。</p>
<p>现在我们只需要启动一个 <code>Nginx</code> 服务器，将 <code>server_name</code> 设置为 <code>fe.server.com</code> 然后设置相应的 <code>location</code> 以拦截前端需要跨域的请求，最后将请求代理回 <code>dev.server.com</code> 。如下面的配置：</p>
<pre><code>server &#123;
 listen      80;
 server_name  fe.server.com;
 location / &#123;
  proxy_pass dev.server.com;
 &#125;
&#125;
</code></pre>
<p>这样可以完美绕过浏览器的同源策略：<code>fe.server.com</code> 访问 <code>Nginx</code> 的 <code>fe.server.com</code> 属于同源访问，而 <code>Nginx</code> 对服务端转发的请求不会触发浏览器的同源策略。</p>
<p><strong>配置开启 gzip 压缩</strong></p>
<p><code>GZIP</code> 是规定的三种标准 <code>HTTP</code> 压缩格式之一。目前绝大多数的网站都在使用 <code>GZIP</code> 传输 <code>HTML</code>、<code>CSS</code> 、 <code>JavaScript</code> 等资源文件。</p>
<p>对于文本文件， <code>GZiP</code> 的效果非常明显，开启后传输所需流量大约会降至 <code>1/4~1/3</code> 。</p>
<p>并不是每个浏览器都支持 <code>gzip</code> 的，如何知道客户端是否支持 <code>gzip</code> 呢，请求头中的 <code>Accept-Encoding</code> 来标识对压缩的支持。</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-165439725505111.png" class="asset-class" title="图片">


<p>启用 <code>gzip</code> 同时需要客户端和服务端的支持，如果客户端支持 <code>gzip</code> 的解析，那么只要服务端能够返回 <code>gzip</code> 的文件就可以启用 <code>gzip</code> 了,我们可以通过 <code>Nginx</code> 的配置来让服务端支持 <code>gzip</code> 。下面的 <code>respone</code> 中 <code>content-encoding:gzip</code> ，指服务端开启了 <code>gzip</code> 的压缩方式。</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-165439725505112.png" class="asset-class" title="图片">


<p>在 <code>/etc/nginx/conf.d/</code> 文件夹中新建配置文件 <code>gzip.conf</code> ：</p>
<pre><code># # 默认off，是否开启gzip
gzip on; 
# 要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用；
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;

# ---- 以上两个参数开启就可以支持Gzip压缩了 ---- #

# 默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容；
gzip_static on;

# 默认 off，nginx做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩；
gzip_proxied any;

# 用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩；
gzip_vary on;

# gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；
gzip_comp_level 6;

# 获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得；
gzip_buffers 16 8k;

# 允许压缩的页面最小字节数，页面字节数从header头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；
# gzip_min_length 1k;

# 默认 1.1，启用 gzip 所需的 HTTP 最低版本；
gzip_http_version 1.1;
</code></pre>
<p>其实也可以通过前端构建工具例如 <code>webpack</code> 、<code>rollup</code> 等在打生产包时就做好 <code>Gzip</code> 压缩，然后放到 <code>Nginx</code> 服务器中，这样可以减少服务器的开销，加快访问速度。</p>
<p>关于 <code>Nginx</code> 的实际应用就学习到这里，相信通过掌握了 <code>Nginx</code> 核心配置以及实战配置，之后再遇到什么需求，我们也能轻松应对。接下来，让我们再深入一点学习下 <code>Nginx</code> 的架构。</p>
<p><strong>Nginx 架构</strong></p>
<p><strong>进程结构</strong></p>
<p>多进程结构 <code>Nginx</code> 的进程模型图：</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-165439725505113.png" class="asset-class" title="图片">



<p>多进程中的 <code>Nginx</code> 进程架构如下图所示，会有一个父进程（ <code>Master Process</code> ），它会有很多子进程（ <code>Child Processes</code> ）。</p>
<ul>
<li><p><code>Master Process</code> 用来管理子进程的，其本身并不真正处理用户请求。</p>
<ul>
<li>某个子进程 <code>down</code> 掉的话，它会向 <code>Master</code> 进程发送一条消息，表明自己不可用了，此时 <code>Master</code> 进程会去新起一个子进程。</li>
<li>某个配置文件被修改了 <code>Master</code> 进程会去通知 <code>work</code> 进程获取新的配置信息，这也就是我们所说的热部署。</li>
</ul>
</li>
<li><p>子进程间是通过共享内存的方式进行通信的。</p>
</li>
</ul>
<h2 id="配置文件重载原理"><a href="#配置文件重载原理" class="headerlink" title="配置文件重载原理"></a>配置文件重载原理</h2><p><code>reload</code> 重载配置文件的流程：</p>
<ol>
<li><p>向 <code>master</code> 进程发送 <code>HUP</code> 信号（ <code>reload</code> 命令）；</p>
</li>
<li><p><code>master</code> 进程检查配置语法是否正确；</p>
</li>
<li><p><code>master</code> 进程打开监听端口；</p>
</li>
<li><p><code>master</code> 进程使用新的配置文件启动新的 <code>worker</code> 子进程；</p>
</li>
<li><p><code>master</code> 进程向老的 <code>worker</code> 子进程发送 <code>QUIT</code> 信号；</p>
</li>
<li><p>老的 <code>worker</code> 进程关闭监听句柄，处理完当前连接后关闭进程；</p>
</li>
<li><p>整个过程 <code>Nginx</code> 始终处于平稳运行中，实现了平滑升级，用户无感知；</p>
</li>
</ol>
<h2 id="Nginx-模块化管理机制"><a href="#Nginx-模块化管理机制" class="headerlink" title="Nginx 模块化管理机制"></a>Nginx 模块化管理机制</h2><p><code>Nginx</code> 的内部结构是由核心部分和一系列的功能模块所组成。这样划分是为了使得每个模块的功能相对简单，便于开发，同时也便于对系统进行功能扩展。<code>Nginx</code> 的模块是互相独立的,低耦合高内聚。</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-165439725505114.png" class="asset-class" title="图片">

<p>转载：<a href="https://juejin.cn/post/6942607113118023710">https://juejin.cn/post/6942607113118023710</a></p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>redis配置详解</title>
    <url>/2022/06/08/redis-pei-zhi-xiang-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="redis-conf"><a href="#redis-conf" class="headerlink" title="redis.conf"></a>redis.conf</h4><pre><code class="prettyprint"># 注意单位: 当需要配置内存大小时, 可能需要指定像1k,5GB,4M等常见格式
# 1k =&gt; 1000 bytes
# 1kb =&gt; 1024 bytes
# 1m =&gt; 1000000 bytes
# 1mb =&gt; 1024*1024 bytes
# 1g =&gt; 1000000000 bytes
# 1gb =&gt; 1024*1024*1024 bytes
#
# units are case insensitive so 1GB 1Gb 1gB are all the same.
# 内存配置对大小写不敏感
 
# 可以在这里包含一个或多个其他的配置文件。如果你有一个适用于所有Redis服务器的标准配置模板
# 但也需要一些每个服务器自定义的设置，这个功能将很有用。被包含的配置文件也可以包含其他配置文件，
# 所以需要谨慎的使用这个功能。
#
# 注意“inclue”选项不能被admin或Redis哨兵的&quot;CONFIG REWRITE&quot;命令重写。
# 因为Redis总是使用最后解析的配置行最为配置指令的值, 你最好在这个文件的开头配置includes来
# 避免它在运行时重写配置。
# 如果相反你想用includes的配置覆盖原来的配置，你最好在该文件的最后使用include
#
# include /path/to/local.conf
# include /path/to/other.conf
 
################################ GENERAL #####################################
 
# 默认Rdis不会作为守护进程运行。如果需要的话配置成&#39;yes&#39;
# 注意配置成守护进程后Redis会将进程号写入文件/var/run/redis.pid
daemonize no
 
# 当以守护进程方式运行时，默认Redis会把进程ID写到 /var/run/redis.pid。你可以在这里修改路径。
pidfile /var/run/redis.pid
 
# 接受连接的特定端口，默认是6379
# 如果端口设置为0，Redis就不会监听TCP套接字。
port 6379
 
# TCP listen() backlog.
#
# 在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核默默地将这个值减小
# 到/proc/sys/net/core/somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog
# 两个值来达到想要的效果。
tcp-backlog 511
 
# 默认Redis监听服务器上所有可用网络接口的连接。可以用&quot;bind&quot;配置指令跟一个或多个ip地址来实现
# 监听一个或多个网络接口
#
# 示例:
#
# bind 192.168.1.100 10.0.0.1
# bind 127.0.0.1
 
# 指定用来监听Unix套套接字的路径。没有默认值，所以在没有指定的情况下Redis不会监听Unix套接字
#
# unixsocket /tmp/redis.sock
# unixsocketperm 755
 
# 一个客户端空闲多少秒后关闭连接。(0代表禁用，永不关闭)
timeout 0
 
# TCP keepalive.
#
# 如果非零，则设置SO_KEEPALIVE选项来向空闲连接的客户端发送ACK，由于以下两个原因这是很有用的：
#
# 1）能够检测无响应的对端
# 2）让该连接中间的网络设备知道这个连接还存活
#
# 在Linux上，这个指定的值(单位：秒)就是发送ACK的时间间隔。
# 注意：要关闭这个连接需要两倍的这个时间值。
# 在其他内核上这个时间间隔由内核配置决定
#
# 这个选项的一个合理值是60秒
tcp-keepalive 0
 
# 指定服务器调试等级
# 可能值：
# debug （大量信息，对开发/测试有用）
# verbose （很多精简的有用信息，但是不像debug等级那么多）
# notice （适量的信息，基本上是你生产环境中需要的）
# warning （只有很重要/严重的信息会记录下来）
loglevel notice
 
# 指明日志文件名。也可以使用&quot;stdout&quot;来强制让Redis把日志信息写到标准输出上。
# 注意:如果Redis以守护进程方式运行，而设置日志显示到标准输出的话，日志会发送到/dev/null
logfile &quot;&quot;
 
# 要使用系统日志记录器，只要设置 &quot;syslog-enabled&quot; 为 &quot;yes&quot; 就可以了。
# 然后根据需要设置其他一些syslog参数就可以了。
# syslog-enabled no
 
# 指明syslog身份
# syslog-ident redis
 
# 指明syslog的设备。必须是user或LOCAL0 ~ LOCAL7之一。
# syslog-facility local0
 
# 设置数据库个数。默认数据库是 DB 0，
# 可以通过select &lt;dbid&gt; (0 &lt;= dbid &lt;= &#39;databases&#39; - 1 ）来为每个连接使用不同的数据库。
databases 16
 
################################ SNAPSHOTTING ################################
#
# 把数据库存到磁盘上:
#
# save &lt;seconds&gt; &lt;changes&gt;
#
# 会在指定秒数和数据变化次数之后把数据库写到磁盘上。
#
# 下面的例子将会进行把数据写入磁盘的操作:
# 900秒（15分钟）之后，且至少1次变更
# 300秒（5分钟）之后，且至少10次变更
# 60秒之后，且至少10000次变更
#
# 注意：你要想不写磁盘的话就把所有 &quot;save&quot; 设置注释掉就行了。
#
# 通过添加一条带空字符串参数的save指令也能移除之前所有配置的save指令
# 像下面的例子：
# save &quot;&quot;
 
save 900 1
save 300 10
save 60 10000
 
# 默认如果开启RDB快照(至少一条save指令)并且最新的后台保存失败，Redis将会停止接受写操作
# 这将使用户知道数据没有正确的持久化到硬盘，否则可能没人注意到并且造成一些灾难。
#
# 如果后台保存进程能重新开始工作，Redis将自动允许写操作
#
# 然而如果你已经部署了适当的Redis服务器和持久化的监控，你可能想关掉这个功能以便于即使是
# 硬盘，权限等出问题了Redis也能够像平时一样正常工作，
stop-writes-on-bgsave-error yes
 
# 当导出到 .rdb 数据库时是否用LZF压缩字符串对象？
# 默认设置为 &quot;yes&quot;，因为几乎在任何情况下它都是不错的。
# 如果你想节省CPU的话你可以把这个设置为 &quot;no&quot;，但是如果你有可压缩的key和value的话，
# 那数据文件就会更大了。
rdbcompression yes
 
# 因为版本5的RDB有一个CRC64算法的校验和放在了文件的最后。这将使文件格式更加可靠但在
# 生产和加载RDB文件时，这有一个性能消耗(大约10%)，所以你可以关掉它来获取最好的性能。
#
# 生成的关闭校验的RDB文件有一个0的校验和，它将告诉加载代码跳过检查
rdbchecksum yes
 
# 持久化数据库的文件名
dbfilename dump.rdb
 
# 工作目录
#
# 数据库会写到这个目录下，文件名就是上面的 &quot;dbfilename&quot; 的值。
#
# 累加文件也放这里。
#
# 注意你这里指定的必须是目录，不是文件名。
dir ./
 
################################# REPLICATION #################################
# 主从同步。通过 slaveof 指令来实现Redis实例的备份。
# 注意，这里是本地从远端复制数据。也就是说，本地可以有不同的数据库文件、绑定不同的IP、监听
# 不同的端口。
#
# slaveof &lt;masterip&gt; &lt;masterport&gt;
 
# 如果master设置了密码保护（通过 &quot;requirepass&quot; 选项来配置），那么slave在开始同步之前必须
# 进行身份验证，否则它的同步请求会被拒绝。
#
# masterauth &lt;master-password&gt;
 
# 当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能：
#
# 1) 如果 slave-serve-stale-data 设置为 &quot;yes&quot; (默认值)，slave会继续响应客户端请求，
# 可能是正常数据，也可能是还没获得值的空数据。
# 2) 如果 slave-serve-stale-data 设置为 &quot;no&quot;，slave会回复&quot;正在从master同步
# （SYNC with master in progress）&quot;来处理各种请求，除了 INFO 和 SLAVEOF 命令。
#
slave-serve-stale-data yes
 
# 你可以配置salve实例是否接受写操作。可写的slave实例可能对存储临时数据比较有用(因为写入salve
# 的数据在同master同步之后将很容被删除)，但是如果客户端由于配置错误在写入时也可能产生一些问题。
#
# 从Redis2.6默认所有的slave为只读
#
# 注意:只读的slave不是为了暴露给互联网上不可信的客户端而设计的。它只是一个防止实例误用的保护层。
# 一个只读的slave支持所有的管理命令比如config,debug等。为了限制你可以用&#39;rename-command&#39;来
# 隐藏所有的管理和危险命令来增强只读slave的安全性
slave-read-only yes
 
# slave根据指定的时间间隔向master发送ping请求。
# 时间间隔可以通过 repl_ping_slave_period 来设置。
# 默认10秒。
#
# repl-ping-slave-period 10
 
# 以下选项设置同步的超时时间
#
# 1）slave在与master SYNC期间有大量数据传输，造成超时
# 2）在slave角度，master超时，包括数据、ping等
# 3）在master角度，slave超时，当master发送REPLCONF ACK pings
#
# 确保这个值大于指定的repl-ping-slave-period，否则在主从间流量不高时每次都会检测到超时
#
# repl-timeout 60
 
# 是否在slave套接字发送SYNC之后禁用 TCP_NODELAY ？
#
# 如果你选择“yes”Redis将使用更少的TCP包和带宽来向slaves发送数据。但是这将使数据传输到slave
# 上有延迟，Linux内核的默认配置会达到40毫秒
#
# 如果你选择了 &quot;no&quot; 数据传输到salve的延迟将会减少但要使用更多的带宽
#
# 默认我们会为低延迟做优化，但高流量情况或主从之间的跳数过多时，把这个选项设置为“yes”
# 是个不错的选择。
repl-disable-tcp-nodelay no
 
# 设置数据备份的backlog大小。backlog是一个slave在一段时间内断开连接时记录salve数据的缓冲，
# 所以一个slave在重新连接时，不必要全量的同步，而是一个增量同步就足够了，将在断开连接的这段
# 时间内slave丢失的部分数据传送给它。
#
# 同步的backlog越大，slave能够进行增量同步并且允许断开连接的时间就越长。
#
# backlog只分配一次并且至少需要一个slave连接
#
# repl-backlog-size 1mb
 
# 当master在一段时间内不再与任何slave连接，backlog将会释放。以下选项配置了从最后一个
# slave断开开始计时多少秒后，backlog缓冲将会释放。
#
# 0表示永不释放backlog
#
# repl-backlog-ttl 3600
 
# slave的优先级是一个整数展示在Redis的Info输出中。如果master不再正常工作了，哨兵将用它来
# 选择一个slave提升=升为master。
#
# 优先级数字小的salve会优先考虑提升为master，所以例如有三个slave优先级分别为10，100，25，
# 哨兵将挑选优先级最小数字为10的slave。
#
# 0作为一个特殊的优先级，标识这个slave不能作为master，所以一个优先级为0的slave永远不会被
# 哨兵挑选提升为master
#
# 默认优先级为100
slave-priority 100
 
# 如果master少于N个延时小于等于M秒的已连接slave，就可以停止接收写操作。
#
# N个slave需要是“oneline”状态
#
# 延时是以秒为单位，并且必须小于等于指定值，是从最后一个从slave接收到的ping（通常每秒发送）
# 开始计数。
#
# This option does not GUARANTEES that N replicas will accept the write, but
# will limit the window of exposure for lost writes in case not enough slaves
# are available, to the specified number of seconds.
#
# 例如至少需要3个延时小于等于10秒的slave用下面的指令：
#
# min-slaves-to-write 3
# min-slaves-max-lag 10
#
# 两者之一设置为0将禁用这个功能。
#
# 默认 min-slaves-to-write 值是0（该功能禁用）并且 min-slaves-max-lag 值是10。
 
################################## SECURITY ###################################
 
# 要求客户端在处理任何命令时都要验证身份和密码。
# 这个功能在有你不信任的其它客户端能够访问redis服务器的环境里非常有用。
#
 
# 为了向后兼容的话这段应该注释掉。而且大多数人不需要身份验证(例如:它们运行在自己的服务器上)
#
# 警告：因为Redis太快了，所以外面的人可以尝试每秒150k的密码来试图破解密码。这意味着你需要
# 一个高强度的密码，否则破解太容易了。
#
# requirepass foobared
 
# 命令重命名
#
# 在共享环境下，可以为危险命令改变名字。比如，你可以为 CONFIG 改个其他不太容易猜到的名字，
# 这样内部的工具仍然可以使用，而普通的客户端将不行。
#
# 例如：
#
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#
# 也可以通过改名为空字符串来完全禁用一个命令
#
# rename-command CONFIG &quot;&quot;
#
# 请注意：改变命令名字被记录到AOF文件或被传送到从服务器可能产生问题。
 
################################### LIMITS ####################################
 
# 设置最多同时连接的客户端数量。默认这个限制是10000个客户端，然而如果Redis服务器不能配置
# 处理文件的限制数来满足指定的值，那么最大的客户端连接数就被设置成当前文件限制数减32（因
# 为Redis服务器保留了一些文件描述符作为内部使用）
#
# 一旦达到这个限制，Redis会关闭所有新连接并发送错误&#39;max number of clients reached&#39;
#
# maxclients 10000
 
# 不要用比设置的上限更多的内存。一旦内存使用达到上限，Redis会根据选定的回收策略（参见：
# maxmemmory-policy）删除key
#
# 如果因为删除策略Redis无法删除key，或者策略设置为 &quot;noeviction&quot;，Redis会回复需要更
# 多内存的错误信息给命令。例如，SET,LPUSH等等，但是会继续响应像Get这样的只读命令。
#
# 在使用Redis作为LRU缓存，或者为实例设置了硬性内存限制的时候（使用 &quot;noeviction&quot; 策略）
# 的时候，这个选项通常事很有用的。
#
# 警告：当有多个slave连上达到内存上限的实例时，master为同步slave的输出缓冲区所需
# 内存不计算在使用内存中。这样当驱逐key时，就不会因网络问题 / 重新同步事件触发驱逐key
# 的循环，反过来slaves的输出缓冲区充满了key被驱逐的DEL命令，这将触发删除更多的key，
# 直到这个数据库完全被清空为止
#
# 总之...如果你需要附加多个slave，建议你设置一个稍小maxmemory限制，这样系统就会有空闲
# 的内存作为slave的输出缓存区(但是如果最大内存策略设置为&quot;noeviction&quot;的话就没必要了)
#
# maxmemory &lt;bytes&gt;
 
# 最大内存策略：如果达到内存限制了，Redis如何选择删除key。你可以在下面五个行为里选：
#
# volatile-lru -&gt; 根据LRU算法生成的过期时间来删除。
# allkeys-lru -&gt; 根据LRU算法删除任何key。
# volatile-random -&gt; 根据过期设置来随机删除key。
# allkeys-&gt;random -&gt; 无差别随机删。
# volatile-ttl -&gt; 根据最近过期时间来删除（辅以TTL）
# noeviction -&gt; 谁也不删，直接在写操作时返回错误。
#
# 注意：对所有策略来说，如果Redis找不到合适的可以删除的key都会在写操作时返回一个错误。
#
 
# 目前为止涉及的命令：set setnx setex append
# incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
# sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
# zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
# getset mset msetnx exec sort
#
 
# 默认值如下：
#
# maxmemory-policy volatile-lru
 
# LRU和最小TTL算法的实现都不是很精确，但是很接近（为了省内存），所以你可以用样本量做检测。
# 例如：默认Redis会检查3个key然后取最旧的那个，你可以通过下面的配置指令来设置样本的个数。
#
# maxmemory-samples 3
 
############################## APPEND ONLY MODE ###############################
 
# 默认情况下，Redis是异步的把数据导出到磁盘上。这种模式在很多应用里已经足够好，但Redis进程
# 出问题或断电时可能造成一段时间的写操作丢失(这取决于配置的save指令)。
#
# AOF是一种提供了更可靠的替代持久化模式，例如使用默认的数据写入文件策略（参见后面的配置）
# 在遇到像服务器断电或单写情况下Redis自身进程出问题但操作系统仍正常运行等突发事件时，Redis
# 能只丢失1秒的写操作。
#
# AOF和RDB持久化能同时启动并且不会有问题。
# 如果AOF开启，那么在启动时Redis将加载AOF文件，它更能保证数据的可靠性。
#
# 请查看 http://redis.io/topics/persistence 来获取更多信息.
 
appendonly no
 
# 纯累加文件名字（默认：&quot;appendonly.aof&quot;）
 
appendfilename &quot;appendonly.aof&quot;
 
# fsync() 系统调用告诉操作系统把数据写到磁盘上，而不是等更多的数据进入输出缓冲区。
# 有些操作系统会真的把数据马上刷到磁盘上；有些则会尽快去尝试这么做。
#
# Redis支持三种不同的模式：
#
# no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。
# always：每次写操作都立刻写入到aof文件。慢，但是最安全。
# everysec：每秒写一次。折中方案。
#
# 默认的 &quot;everysec&quot; 通常来说能在速度和数据安全性之间取得比较好的平衡。根据你的理解来
# 决定，如果你能放宽该配置为&quot;no&quot; 来获取更好的性能(但如果你能忍受一些数据丢失，可以考虑使用
# 默认的快照持久化模式)，或者相反，用“always”会比较慢但比everysec要更安全。
#
# 请查看下面的文章来获取更多的细节
# http://antirez.com/post/redis-persistence-demystified.html
#
# 如果不能确定，就用 &quot;everysec&quot;
 
# appendfsync always
appendfsync everysec
# appendfsync no
 
# 如果AOF的同步策略设置成 &quot;always&quot; 或者 &quot;everysec&quot;，并且后台的存储进程（后台存储或写入AOF
# 日志）会产生很多磁盘I/O开销。某些Linux的配置下会使Redis因为 fsync()系统调用而阻塞很久。
# 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们同步的write(2)调用。
#
# 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止fsync()。
#
# 这就意味着如果有子进程在进行保存操作，那么Redis就处于&quot;不可同步&quot;的状态。
# 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。（默认Linux设定）
#
# 如果把这个设置成&quot;yes&quot;带来了延迟问题，就保持&quot;no&quot;，这是保存持久数据的最安全的方式。
 
no-appendfsync-on-rewrite no
 
# 自动重写AOF文件
# 如果AOF日志文件增大到指定百分比，Redis能够通过 BGREWRITEAOF 自动重写AOF日志文件。
#
# 工作原理：Redis记住上次重写时AOF文件的大小（如果重启后还没有写操作，就直接用启动时的AOF大小）
#
# 这个基准大小和当前大小做比较。如果当前大小超过指定比例，就会触发重写操作。你还需要指定被重写
# 日志的最小尺寸，这样避免了达到指定百分比但尺寸仍然很小的情况还要重写。
#
# 指定百分比为0会禁用AOF自动重写特性。
 
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb```
 
################################ LUA SCRIPTING ###############################
 
# Lua 脚本的最大执行时间，毫秒为单位
#
# 如果达到了最大的执行时间，Redis将要记录在达到最大允许时间之后一个脚本仍然在执行，并且将
# 开始对查询进行错误响应。
#
# 当一个长时间运行的脚本超过了最大执行时间，只有 SCRIPT KILL 和 SHUTDOWN NOSAVE 两个
# 命令可用。第一个可以用于停止一个还没有调用写命名的脚本。第二个是关闭服务器唯一方式，当
# 写命令已经通过脚本开始执行，并且用户不想等到脚本的自然终止。
#
# 设置成0或者负值表示不限制执行时间并且没有任何警告
lua-time-limit 5000
 
################################## SLOW LOG ###################################
 
# Redis慢查询日志可以记录超过指定时间的查询。运行时间不包括各种I/O时间，例如：连接客户端，
# 发送响应数据等，而只计算命令执行的实际时间（这只是线程阻塞而无法同时为其他请求服务的命令执
# 行阶段）
#
# 你可以为慢查询日志配置两个参数:一个指明Redis的超时时间(单位为微秒)来记录超过这个时间的命令
# 另一个是慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录从队列中移除。
#
# 下面的时间单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录
# 所有命令。
slowlog-log-slower-than 10000
 
# 这个长度没有限制。只是要主要会消耗内存。你可以通过 SLOWLOG RESET 来回收内存。
slowlog-max-len 128
 
############################# Event notification ##############################
 
# Redis 能通知 Pub/Sub 客户端关于键空间发生的事件
# 这个功能文档位于http://redis.io/topics/keyspace-events
#
# 例如：如果键空间事件通知被开启，并且客户端对 0 号数据库的键 foo 执行 DEL 命令时，将通过
# Pub/Sub发布两条消息：
# PUBLISH __keyspace@0__:foo del
# PUBLISH __keyevent@0__:del foo
#
# 可以在下表中选择Redis要通知的事件类型。事件类型由单个字符来标识：
#
# K 键空间通知，以__keyspace@&lt;db&gt;__为前缀
# E 键事件通知，以__keysevent@&lt;db&gt;__为前缀
# g DEL , EXPIRE , RENAME 等类型无关的通用命令的通知, ...
# $ String命令
# l List命令
# s Set命令
# h Hash命令
# z 有序集合命令
# x 过期事件（每次key过期时生成）
# e 驱逐事件（当key在内存满了被清除时生成）
# A g$lshzxe的别名，因此”AKE”意味着所有的事件
#
# notify-keyspace-events 带一个由0到多个字符组成的字符串参数。空字符串意思是通知被禁用。
#
# 例子：启用List和通用事件通知：
# notify-keyspace-events Elg
#
# 例子2：为了获取过期key的通知订阅名字为 __keyevent@__:expired 的频道，用以下配置
# notify-keyspace-events Ex
#
# 默认所用的通知被禁用，因为用户通常不需要该特性，并且该特性会有性能损耗。
# 注意如果你不指定至少K或E之一，不会发送任何事件。
notify-keyspace-events &quot;&quot;
 
############################### ADVANCED CONFIG ###############################
 
# 当hash只有少量的entry时，并且最大的entry所占空间没有超过指定的限制时，会用一种节省内存的
# 数据结构来编码。可以通过下面的指令来设定限制
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
 
# 与hash似，数据元素较少的list，可以用另一种方式来编码从而节省大量空间。
# 这种特殊的方式只有在符合下面限制时才可以用：
list-max-ziplist-entries 512
list-max-ziplist-value 64
 
# set有一种特殊编码的情况：当set数据全是十进制64位有符号整型数字构成的字符串时。
# 下面这个配置项就是用来设置set使用这种编码来节省内存的最大长度。
set-max-intset-entries 512
 
# 与hash和list相似，有序集合也可以用一种特别的编码方式来节省大量空间。
# 这种编码只适合长度和元素都小于下面限制的有序集合：
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
 
# HyperLogLog sparse representation bytes limit. The limit includes the
# 16 bytes header. When an HyperLogLog using the sparse representation crosses
# this limit, it is converted into the dense representation.
#
# A value greater than 16000 is totally useless, since at that point the
# dense representation is more memory efficient.
#
# The suggested value is ~ 3000 in order to have the benefits of
# the space efficient encoding without slowing down too much PFADD,
# which is O(N) with the sparse encoding. The value can be raised to
# ~ 10000 when CPU is not a concern, but space is, and the data set is
# composed of many HyperLogLogs with cardinality in the 0 - 15000 range.
hll-sparse-max-bytes 3000
 
# 启用哈希刷新，每100个CPU毫秒会拿出1个毫秒来刷新Redis的主哈希表（顶级键值映射表）。
# redis所用的哈希表实现（见dict.c）采用延迟哈希刷新机制：你对一个哈希表操作越多，哈希刷新
# 操作就越频繁；反之，如果服务器是空闲的，那么哈希刷新就不会完成，哈希表就会占用更多的一些
# 内存而已。
#
# 默认是每秒钟进行10次哈希表刷新，用来刷新字典，然后尽快释放内存。
#
# 建议：
# 如果你对延迟比较在意，不能够接受Redis时不时的对请求有2毫秒的延迟的话，就用
# &quot;activerehashing no&quot;，如果不太在意延迟而希望尽快释放内存就设置&quot;activerehashing yes&quot;
activerehashing yes
 
# 客户端的输出缓冲区的限制，可用于强制断开那些因为某种原因从服务器读取数据的速度不够快的客户端，
# （一个常见的原因是一个发布/订阅客户端消费消息的速度无法赶上生产它们的速度）
#
# 可以对三种不同的客户端设置不同的限制：
# normal -&gt; 正常客户端
# slave -&gt; slave和 MONITOR 客户端
# pubsub -&gt; 至少订阅了一个pubsub channel或pattern的客户端
#
# 下面是每个client-output-buffer-limit语法:
# client-output-buffer-limit &lt;class&gt;&lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;
 
# 一旦达到硬限制客户端会立即被断开，或者达到软限制并持续达到指定的秒数（连续的）。
# 例如，如果硬限制为32兆字节和软限制为16兆字节/10秒，客户端将会立即断开
# 如果输出缓冲区的大小达到32兆字节，或客户端达到16兆字节并连续超过了限制10秒，就将断开连接。
#
# 默认normal客户端不做限制，因为他们在不主动请求时不接收数据（以推的方式），只有异步客户端
# 可能会出现请求数据的速度比它可以读取的速度快的场景。
#
# pubsub和slave客户端会有一个默认值，因为订阅者和slaves以推的方式来接收数据
#
# 把硬限制和软限制都设置为0来禁用该功能
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
 
# Redis调用内部函数来执行许多后台任务，如关闭客户端超时的连接，清除未被请求过的过期Key等等。
#
# 不是所有的任务都以相同的频率执行，但Redis依照指定的“hz”值来执行检查任务。
#
# 默认情况下，“hz”的被设定为10。提高该值将在Redis空闲时使用更多的CPU时，但同时当有多个key
# 同时到期会使Redis的反应更灵敏，以及超时可以更精确地处理。
#
# 范围是1到500之间，但是值超过100通常不是一个好主意。
# 大多数用户应该使用10这个默认值，只有在非常低的延迟要求时有必要提高到100。
hz 10
 
# 当一个子进程重写AOF文件时，如果启用下面的选项，则文件每生成32M数据会被同步。为了增量式的
# 写入硬盘并且避免大的延迟高峰这个指令是非常有用的
aof-rewrite-incremental-fsync yes
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7安装redis6及哨兵</title>
    <url>/2022/06/09/centos7-an-zhuang-redis6-ji-shao-bing/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h3><pre><code class="prettyprint">#创建一个专门存放软件的目录
mkdir /opt/software
cd /opt/software
#下载
wget https://download.redis.io/releases/redis-6.2.6.tar.gz
#解压
tar -zxvf redis-6.2.6.tar.gz
#进入src目录安装
cd redis-6.2.6/src
#指定安装到目录
make PREFIX=/usr/local/redis install
#测试是否成功
cd /usr/local/redis/bin
#启动
./redis-server 
#访问
./redis-cli
</code></pre>
<blockquote>
<p>ps：&#x2F;bin&#x2F;sh: cc: command not found</p>
<p>yum install gcc gcc-c++ libstdc++-devel</p>
</blockquote>
<h4 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h4><p><a href="https://rocpenghua.gitee.io/2022/06/08/redis-pei-zhi-xiang-jie/">redis配置详解 | 小鹏驿站 (gitee.io)</a></p>
<h5 id="建议修改配置"><a href="#建议修改配置" class="headerlink" title="建议修改配置"></a>建议修改配置</h5><pre><code class="prettyprint"># 后台启动
daemonize yes
# rdb文件存放
dbfilename dump6379.rdb
</code></pre>
<h5 id="创建redis-server软链"><a href="#创建redis-server软链" class="headerlink" title="创建redis-server软链"></a>创建<code>redis-server</code>软链</h5><pre><code class="prettyprint">ln -s /usr/local/redis/bin/redis-server /usr/local/bin/redis-server
ln -s /usr/local/redis/bin/redis-cli /usr/local/bin/redis-cli
</code></pre>
<h4 id="开机启动配置"><a href="#开机启动配置" class="headerlink" title="开机启动配置"></a>开机启动配置</h4><pre><code class="prettyprint">vim /etc/systemd/system/redis-server.service
</code></pre>
<p>粘贴内容</p>
<pre><code class="prettyprint">[Unit]
Description=The redis-server Process Manager
After=syslog.target network.target


[Service]
Type=simple
PIDFile=/var/run/redis_6379.pid
ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/redis.conf
ExecReload=/bin/kill -USR2 $MAINPID
ExecStop=/bin/kill -SIGINT $MAINPID


[Install]
WantedBy=multi-user.target
</code></pre>
<p>设置启动命令</p>
<pre><code class="prettyprint">systemctl daemon-reload 
systemctl start redis-server.service 
systemctl enable redis-server.servic
systemctl status redis-server.service 
</code></pre>
<h3 id="哨兵配置"><a href="#哨兵配置" class="headerlink" title="哨兵配置"></a>哨兵配置</h3><h4 id="准备三份配置文件"><a href="#准备三份配置文件" class="headerlink" title="准备三份配置文件"></a>准备三份配置文件</h4><pre><code class="prettyprint">cd /opt/software
mkdir redis-sentinel
cd redis-sentinel
#-r 包含目录复制
cp -r /opt/software/redis-6.2.6/ .
mv redis-6.2.6 redis-6.2.6-6380
cp -r redis-6.2.6-6380 redis-6.2.6-6381
cp -r redis-6.2.6-6380 redis-6.2.6-6382
</code></pre>
<h3 id="修改主节点配置"><a href="#修改主节点配置" class="headerlink" title="修改主节点配置"></a>修改主节点配置</h3><pre><code class="prettyprint">vim /opt/software/redis-sentinel/redis-6.2.6-6380/redis.conf
</code></pre>
<p>修改<code>redis.conf</code></p>
<pre><code class="prettyprint">#只需要修改端口
port 6380
</code></pre>
<p>修改<code>sentinel.conf</code></p>
<pre><code class="prettyprint">#修改port
port 26380
#开启守护线程
daemonize yes 
#sentinel monitor &lt;master-group-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;
#master-group-name是集群名称 quorum是需要同意主节点不可用的Sentinel的数量
sentinel monitor mymaster 192.168.101.123 6380 2
#主节点密码，如果有
#sentinel auth-pass &lt;master-name&gt; &lt;password&gt;
</code></pre>
<h4 id="修改两个从节点"><a href="#修改两个从节点" class="headerlink" title="修改两个从节点"></a>修改两个从节点</h4><pre><code class="prettyprint">vim /opt/software/redis-sentinel/redis-6.2.6-6381/redis.conf
</code></pre>
<p>修改<code>redis.conf</code></p>
<pre><code class="prettyprint">#修改port（一个为6381，另一个为6382）
port 6381
#主从复制 replicaof &lt;masterip&gt; &lt;masterport&gt;
replicaof 192.168.101.123 6380
#主节点密码 masterauth &lt;master-password&gt;
#masterauth 主节点密码
</code></pre>
<p>修改<code>sentinel.conf</code></p>
<pre><code class="prettyprint">#修改port（一个为26381，另一个为26382）
port 26381
#开启守护线程
daemonize yes 
#sentinel monitor &lt;master-group-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;
sentinel monitor mymaster 192.168.101.123 6380 2
#主节点密码
#sentinel auth-pass mymaster 主节点密码
</code></pre>
<h3 id="启动哨兵模式"><a href="#启动哨兵模式" class="headerlink" title="启动哨兵模式"></a>启动哨兵模式</h3><h4 id="maste和slave启动"><a href="#maste和slave启动" class="headerlink" title="maste和slave启动"></a>maste和slave启动</h4><pre><code class="prettyprint">cd /usr/local/redis/bin
# &amp; 后台启动
./redis-server /opt/software/redis-sentinel/redis-6.2.6-6380/redis.conf &amp;
./redis-server /opt/software/redis-sentinel/redis-6.2.6-6381/redis.conf &amp;
./redis-server /opt/software/redis-sentinel/redis-6.2.6-6382/redis.conf &amp;
</code></pre>
<h4 id="sentinel启动"><a href="#sentinel启动" class="headerlink" title="sentinel启动"></a>sentinel启动</h4><pre><code class="prettyprint">cd /usr/local/redis/bin

./redis-sentinel /opt/software/redis-sentinel/redis-6.2.6-6380/sentinel.conf
./redis-sentinel /opt/software/redis-sentinel/redis-6.2.6-6381/sentinel.conf
./redis-sentinel /opt/software/redis-sentinel/redis-6.2.6-6382/sentinel.conf
</code></pre>
<h4 id="测试哨兵模式"><a href="#测试哨兵模式" class="headerlink" title="测试哨兵模式"></a>测试哨兵模式</h4><blockquote>
<p>分别连接</p>
</blockquote>
<pre><code class="prettyprint">./redis-cli -p 6380
./redis-cli -p 6381
./redis-cli -p 6382
</code></pre>
<blockquote>
<p>查看角色信息</p>
</blockquote>
<pre><code class="prettyprint">192.168.101.123:6380&gt;info
#role:master
192.168.101.123:6381&gt;info
#role:slave
192.168.101.123:6382&gt;info
#role:slave
</code></pre>
<blockquote>
<p>测试master切换，手动shutdown主服务器,过一会重新启动6380</p>
</blockquote>
<pre><code>./redis-cli -p 6380 shutdown
./redis-server /opt/software/redis-sentinel/redis-6.2.6-6380/redis.conf &amp;
</code></pre>
<blockquote>
<p>再次查看角色信息</p>
</blockquote>
<pre><code class="prettyprint">192.168.101.123:6380&gt;info
#role:slave
192.168.101.123:6381&gt;info
#role:master
192.168.101.123:6382&gt;info
#role:slave
</code></pre>
<blockquote>
<p> 注意：</p>
<p>如果开始配置哨兵模式使用的ip是127.0.0.1,外部客户端无法连接，需要使用机器ip</p>
<p>修改redis.conf sentinel.conf中使用的ip之前停掉redis sentinel</p>
<p>.&#x2F;redis-cli -p 6380 shutdown</p>
<p>.&#x2F;redis-cli -p 6381 shutdown</p>
<p>.&#x2F;redis-cli -p 6382 shutdown</p>
<p>.&#x2F;redis-cli -p 26380 shutdown</p>
<p>.&#x2F;redis-cli -p 26382 shutdown</p>
<p>.&#x2F;redis-cli -p 26382 shutdown</p>
</blockquote>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>redis</tag>
        <tag>哨兵</tag>
      </tags>
  </entry>
  <entry>
    <title>redis脑裂</title>
    <url>/2022/06/09/redis-nao-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="redis脑裂发生"><a href="#redis脑裂发生" class="headerlink" title="redis脑裂发生"></a>redis脑裂发生</h3><ul>
<li>假如有三台redis服务器</li>
<li>当master服务器出现网络问题，两个slave服务器无法和master服务器通信，然而客户端是可以的</li>
<li>那么sentine就会从两台slave服务器选取一个作为主服务器来处理客户端请求</li>
<li>此时就存在两个master了</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><blockquote>
<p>修改conf配置</p>
</blockquote>
<pre><code class="prettyprint">min-slaves-to-write 1 #要求至少有一个slave。

min-slaves-max-lag 10 #主从数据同步超时时间，10秒。
</code></pre>
<p>以上要求无法满足拒绝客户端请求，可以将master通信异常的数据丢失控制在10s</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat源码环境搭建</title>
    <url>/2022/06/10/tomcat-yuan-ma-huan-jing-da-jian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><p><a href="https://links.jianshu.com/go?to=https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.50/src/">https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.50/src/</a></p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>解压源码</li>
<li>新建<code>source</code>文件夹用来存放配置文件和页面文件，将<code>conf</code>和<code>webapps</code>目录移动到<code>source</code>目录下</li>
<li>在根目录下新建<code>pom.xml</code>导入依赖</li>
</ul>
<pre><code class="prettyprint">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;
    &lt;artifactId&gt;apache-tomcat-8.5.50-src&lt;/artifactId&gt;
    &lt;name&gt;Tomcat8.5&lt;/name&gt;
    &lt;version&gt;8.5&lt;/version&gt;
    &lt;build&gt;
        &lt;!--指定源目录--&gt;
        &lt;finalName&gt;Tomcat8.5&lt;/finalName&gt;
        &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;java&lt;/directory&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
        &lt;plugins&gt;
            &lt;!--引入编译插件--&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.1&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                    &lt;source&gt;8&lt;/source&gt;
                    &lt;target&gt;8&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
    &lt;!--tomcat依赖的基础包--&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.easymock&lt;/groupId&gt;
            &lt;artifactId&gt;easymock&lt;/artifactId&gt;
            &lt;version&gt;3.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ant&lt;/groupId&gt;
            &lt;artifactId&gt;ant&lt;/artifactId&gt;
            &lt;version&gt;1.7.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;wsdl4j&lt;/groupId&gt;
            &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt;
            &lt;version&gt;1.6.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.xml&lt;/groupId&gt;
            &lt;artifactId&gt;jaxrpc&lt;/artifactId&gt;
            &lt;version&gt;1.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt;
            &lt;artifactId&gt;ecj&lt;/artifactId&gt;
            &lt;version&gt;4.5.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.xml.soap&lt;/groupId&gt;
            &lt;artifactId&gt;javax.xml.soap-api&lt;/artifactId&gt;
            &lt;version&gt;1.4.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<ul>
<li>导入idea工具</li>
</ul>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ul>
<li>找到<code>org.apache.catalina.startup.Bootstrap#main</code>执行启动，如果有找不到包等问题可以直接用idea提示修改</li>
<li>配置VM.options</li>
</ul>
<pre><code class="prettyprint">-Dcatalina.home=E:/Download/apache-tomcat-8.5.50-src/source
-Dcatalina.base=E:/Download/apache-tomcat-8.5.50-src/source
-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager
-Djava.util.logging.config.file=E:/Download/apache-tomcat-8.5.50-src/source/conf/logging.properties
</code></pre>
<ul>
<li>初始化jsp解析引擎jasper,<code>org.apache.catalina.startup.ContextConfig#configureStart</code></li>
</ul>
<pre><code>context.addServletContainerInitializer(new JasperInitializer(), null);
</code></pre>
<img src="/2022/06/10/tomcat-yuan-ma-huan-jing-da-jian/1654832343643.png" class="asset-class" width="1654832343643">

<h3 id="中文乱码解决"><a href="#中文乱码解决" class="headerlink" title="中文乱码解决"></a>中文乱码解决</h3><ul>
<li><code>org.apache.tomcat.util.res.StringManager#getString(java.lang.String, java.lang.Object...)</code></li>
</ul>
<pre><code class="prettyprint">//RocPengHua
value = new String(value.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);
</code></pre>
<ul>
<li><code>org.apache.jasper.compiler.Localizer#getMessage(java.lang.String)</code></li>
</ul>
<pre><code class="prettyprint">//RocPengHua
errMsg = new String(errMsg.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);
</code></pre>
<ul>
<li><code>org.apache.jasper.compiler.Localizer#getMessage(java.lang.String, java.lang.Object...)</code></li>
</ul>
<pre><code class="prettyprint">errMsg = new String(errMsg.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);
</code></pre>
<blockquote>
<p>源码分析地址：</p>
<p><a href="https://www.jianshu.com/p/7c9401b85704?utm_campaign=haruki&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">一万字深度剖析Tomcat源码 - 简书 (jianshu.com)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7安装pulsar</title>
    <url>/2022/06/12/centos7-an-zhuang-pulsar/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="download"><a href="#download" class="headerlink" title="download"></a>download</h3><p><a href="https://pulsar.apache.org/zh-CN/download/">Apache Pulsar</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>直接解压</li>
</ul>
<pre><code class="prettyprint">tar -zxvf apache-pulsar-2.3.0-bin.tar.gz
</code></pre>
<ul>
<li>启动验证</li>
</ul>
<pre><code class="prettyprint">#启动
./pulsar standalone
#消费者监听
./pulsar-client consume topic1 -s &quot;first-subscription&quot;
#发送
./pulsar-client produce topic1 --messages &quot;hello-pulsa
</code></pre>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>pulsar</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7搭建kafka集群</title>
    <url>/2022/07/19/centos7-da-jian-kafka-ji-qun/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="单机安装"><a href="#单机安装" class="headerlink" title="单机安装"></a>单机安装</h3><p><a href="https://rocpenghua.gitee.io/2022/04/26/centos7-an-zhuang-kafka/">centos7安装kafka | 小鹏驿站 (gitee.io)</a></p>
<h3 id="集群配置-一台服务器"><a href="#集群配置-一台服务器" class="headerlink" title="集群配置(一台服务器)"></a>集群配置(一台服务器)</h3><ul>
<li><code>kafka9001.properties</code>配置</li>
</ul>
<pre><code class="prettyprint">#修改配置
broker.id=1
host.name=192.168.101.143
listeners=PLAINTEXT://192.168.101.143:9001
advertised.listeners=PLAINTEXT://192.168.101.143:9001
log.dirs=/opt/module/kafka/datas-logs1
</code></pre>
<ul>
<li><code>kafka9002.properties</code>配置</li>
</ul>
<pre><code class="prettyprint">#修改配置
broker.id=2
host.name=192.168.101.143
listeners=PLAINTEXT://192.168.101.143:9002
advertised.listeners=PLAINTEXT://192.168.101.143:9002
log.dirs=/opt/module/kafka/datas-logs2
</code></pre>
<ul>
<li><code>kafka9003.properties</code>配置</li>
</ul>
<pre><code class="prettyprint">#修改配置
broker.id=3
host.name=192.168.101.143
listeners=PLAINTEXT://192.168.101.143:9003
advertised.listeners=PLAINTEXT://192.168.101.143:9003
log.dirs=/opt/module/kafka/datas-logs3
</code></pre>
<blockquote>
<p> 启动</p>
</blockquote>
<pre><code class="prettyprint">./kafka-server-start.sh ../config/kafka9001.properties &amp;
./kafka-server-start.sh ../config/kafka9002.properties &amp;
./kafka-server-start.sh ../config/kafka9003.properties &amp;
</code></pre>
<blockquote>
<p>启动脚本</p>
</blockquote>
<pre><code class="prettyprint">#!/bin/bash

case $1 in
&quot;start&quot;)&#123;
    for i in 9001 9002 9003
    do
        echo  ------------- kafka $i 启动 ------------
        &quot;source /etc/profile;nohup /opt/module/kafka/bin/kafka-server-start.sh -daemon /opt/module/kafka/config/kafka$i.properties&quot;
    done
&#125;
;;
&quot;stop&quot;)&#123;
    echo  ------------- kafka  停止 ------------
    &quot;/opt/module/kafka/bin/kafka-server-stop.sh &quot;
&#125;
;;
esac
</code></pre>
<h3 id="集群配置-三台服务器"><a href="#集群配置-三台服务器" class="headerlink" title="集群配置(三台服务器)"></a>集群配置(三台服务器)</h3><ul>
<li><p>准备三台服务器<code>node2</code>,<code>node3</code>,<code>node4</code></p>
</li>
<li><p>修改<code>node2</code>配置文件<code>config/server.properties</code></p>
</li>
</ul>
<pre><code class="prettyprint"># broker 的全局唯一编号，不能重复，只能是数字。
broker.id=0
# kafka 运行日志(数据)存放的路径，路径不需要提前创建，kafka 自动帮你创建，可以配置多个磁盘路径，路径与路径之间可以用&quot;，&quot;分隔
log.dirs=/opt/module/kafka/datas
# 配置连接 Zookeeper 集群地址（在 zk 根目录下创建/kafka，方便管理）
zookeeper.connect=node2:2181,node3:2181,node4:2181/kafka
</code></pre>
<ul>
<li>分发安装包</li>
</ul>
<blockquote>
<p>xsync配置<a href="https://rocpenghua.gitee.io/2022/07/12/linux-jiao-ben/">linux脚本 | 小鹏驿站 (gitee.io)</a></p>
</blockquote>
<pre><code class="prettyprint">cd /opt/module
xsync kafka/
</code></pre>
<ul>
<li>修改<code>node3</code>,<code>node4</code>下面<code>config/server.properties</code></li>
</ul>
<pre><code class="prettyprint"># node3 broker 的全局唯一编号，不能重复，只能是数字。
broker.id=1
# node4 broker 的全局唯一编号，不能重复，只能是数字。
broker.id=2
</code></pre>
<ul>
<li>环境变量增加<code>kafka</code>配置（node2,node3,node4）</li>
</ul>
<pre><code class="prettyprint">vim /etc/profile
</code></pre>
<p>添加内容</p>
<pre><code class="prettyprint">#KAFKA_HOME
export KAFKA_HOME=/opt/module/kafka
export PATH=$PATH:$KAFKA_HOME/bin
</code></pre>
<p>刷新环境变量脚本</p>
<pre><code class="prettyprint">source /etc/profile
</code></pre>
<ul>
<li>zk启动脚本，kafka启动脚本编写</li>
</ul>
<p><a href="https://rocpenghua.gitee.io/2022/07/12/linux-jiao-ben/">linux脚本 | 小鹏驿站 (gitee.io)</a></p>
<pre><code class="prettyprint"># 先启动zk
./zk.sh start
# 再启动kafka
./kf.sh start
</code></pre>
<h3 id="集群配置kraft"><a href="#集群配置kraft" class="headerlink" title="集群配置kraft"></a>集群配置<code>kraft</code></h3><ul>
<li><p>准备三台服务器<code>node2</code>,<code>node3</code>,<code>node4</code></p>
</li>
<li><p>修改<code>node2</code>配置文件<code>config/kraft/server.properties</code></p>
</li>
</ul>
<pre><code class="prettyprint"># 节点 id
node.id=2
#全 Controller 列表
controller.quorum.voters=2@node2:9093,3@node3:9093,4@node4:9093
#broker 对外暴露的地址
advertised.Listeners=PLAINTEXT://node2:9092
#kafka 数据存储目录
log.dirs=/opt/module/kafka/data
</code></pre>
<ul>
<li>分发安装包</li>
</ul>
<blockquote>
<p>xsync配置<a href="https://rocpenghua.gitee.io/2022/07/12/linux-jiao-ben/">linux脚本 | 小鹏驿站 (gitee.io)</a></p>
</blockquote>
<pre><code class="prettyprint">cd /opt/module
xsync kafka/
</code></pre>
<ul>
<li>修改<code>node3</code>,<code>node4</code>下面<code>config/server.properties</code></li>
</ul>
<pre><code class="prettyprint"># 节点 id
node.id=3
# broker 对外暴露的地址
advertised.Listeners=PLAINTEXT://node3:9092


# 节点 id
node.id=4
# broker 对外暴露的地址
advertised.Listeners=PLAINTEXT://node4:9092
</code></pre>
<ul>
<li>环境变量增加<code>kafka</code>配置（node2,node3,node4）</li>
</ul>
<pre><code class="prettyprint">vim /etc/profile
</code></pre>
<p>添加内容</p>
<pre><code class="prettyprint">#KAFKA_HOME
export KAFKA_HOME=/opt/module/kafka
export PATH=$PATH:$KAFKA_HOME/bin
</code></pre>
<p>刷新环境变量脚本</p>
<pre><code class="prettyprint">source /etc/profile
</code></pre>
<ul>
<li>初始化集群数据目录</li>
</ul>
<pre><code class="prettyprint"># 生成存储目录唯一ID
[root@node2 ~]# cd /opt/module/kafka/bin
[root@node2 bin]# ./kafka-storage.sh random-uuid
MBJ8mVoITCC3hDl886zuyA
# node2
[root@node2 bin]# ./kafka-storage.sh format -t MBJ8mVoITCC3hDl886zuyA -c /opt/module/kafka/config/kraft/server.properties 
Formatting /opt/module/kafka/data

# node3
[root@node3 bin]# ./kafka-storage.sh format -t MBJ8mVoITCC3hDl886zuyA -c /opt/module/kafka/config/kraft/server.properties 
Formatting /opt/module/kafka/data

# node4
[root@node4 bin]# ./kafka-storage.sh format -t MBJ8mVoITCC3hDl886zuyA -c /opt/module/kafka/config/kraft/server.properties 
Formatting /opt/module/kafka/data
</code></pre>
<ul>
<li>启动</li>
</ul>
<pre><code class="prettyprint">[root@node2 bin]# ./kafka-server-start.sh -daemon ../config/kraft/server.properties

[root@node3 bin]# ./kafka-server-start.sh -daemon ../config/kraft/server.properties

[root@node4 bin]# ./kafka-server-start.sh -daemon ../config/kraft/server.properties
</code></pre>
<ul>
<li>启动脚本</li>
</ul>
<pre><code class="prettyprint">#!/bin/bash

case $1 in
&quot;start&quot;)&#123;
    for i in node2 node3 node4
    do
        echo  ------------- kafka $i 启动 ------------
        ssh $i &quot;source /etc/profile;nohup /opt/module/kafka/bin/kafka-server-start.sh -daemon /opt/module/kafka/config/kraft/server.properties&quot;
    done
&#125;
;;
&quot;stop&quot;)&#123;
    for i in node2 node3 node4
    do
        echo  ------------- kafka $i 停止 ------------
        ssh $i &quot;/opt/module/kafka/bin/kafka-server-stop.sh &quot;
    done
&#125;
;;
esac
</code></pre>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="prettyprint">#创建
./kafka-topics.sh --create --topic &quot;first32&quot; --bootstrap-server 192.168.101.143:9001,192.168.101.143:9002,192.168.101.143:9003 --partitions 3 --replication-factor 2
#查看描述
./kafka-topics.sh --describe --topic &quot;first32&quot; --bootstrap-server 192.168.101.143:9001,192.168.101.143:9002,192.168.101.143:9003
</code></pre>
<ul>
<li>3个partitions 2个副本</li>
</ul>


<ul>
<li>3个partitions 3个副本</li>
</ul>


<ul>
<li><code>kafka-console-consumer.sh</code></li>
</ul>
<pre><code class="prettyprint"># from-beginning 从头开始
./kafka-console-consumer.sh --bootstrap-server 192.168.101.143:9001,192.168.101.143:9002,192.168.101.143:9003 --from-beginning --topic first33
</code></pre>
<ul>
<li><code>kafka-console-producer.sh</code></li>
</ul>
<pre><code class="prettyprint">./kafka-console-producer.sh --bootstrap-server 192.168.101.143:9001,192.168.101.143:9002,192.168.101.143:9003 --topic first33
</code></pre>
<h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><h5 id="kafka-producer-perf-test-sh"><a href="#kafka-producer-perf-test-sh" class="headerlink" title="kafka-producer-perf-test.sh"></a><code>kafka-producer-perf-test.sh</code></h5><pre><code class="prettyprint">#生产数量100万个 每个数据1000字节 每秒两千个
[root@rocketmq-nameserver1 bin]# ./kafka-producer-perf-test.sh --topic test --record-size 1024 --num-records 1000000 --throughput 10000 --producer-props bootstrap.servers=192.168.101.143:9001,192.168.101.143:9002,192.168.101.143:9003 batch.size=16384 linger.ms=0
</code></pre>
<blockquote>
<p>参数说明</p>
<ul>
<li>record-size 是一条信息有多大，单位是字节，本次测试设置为 1k</li>
<li>num-records 是总共发送多少条信息，本次测试设置为 100 万条</li>
<li>throughput 是每秒多少条信息，设成-1，表示不限流，尽可能快的生产数据，可测出生产者最大吞吐量。本次实验设置为每秒钟 1 万条</li>
<li>producer-props 后面可以配置生产者相关参数，batch.size 配置为 16k</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th>压测结果（机器不同效率也有影响）</th>
</tr>
</thead>
<tbody><tr>
<td>batch.size&#x3D;16384 linger.ms&#x3D;0</td>
<td>1000000 records sent, 6565.384666 records&#x2F;sec (6.41 MB&#x2F;sec), 4552.62 ms avg latency, 11020.00 ms max latency, 4028 ms 50th, 8530 ms 95th, 10529 ms 99th, 10988 ms 99.9th.</td>
</tr>
<tr>
<td>batch.size&#x3D;32768 linger.ms&#x3D;0</td>
<td>1000000 records sent, 9996.101520 records&#x2F;sec (9.76 MB&#x2F;sec), 1187.20 ms avg latency, 4831.00 ms max latency, 374 ms 50th, 4008 ms 95th, 4556 ms 99th, 4731 ms 99.9th.</td>
</tr>
<tr>
<td>batch.size&#x3D;4096 linger.ms&#x3D;0</td>
<td>1000000 records sent, 3801.052892 records&#x2F;sec (3.71 MB&#x2F;sec), 6347.24 ms avg latency, 16980.00 ms max latency, 7125 ms 50th, 13355 ms 95th, 16519 ms 99th, 16904 ms 99.9th.</td>
</tr>
<tr>
<td>batch.size&#x3D;4096 linger.ms&#x3D;50</td>
<td>1000000 records sent, 4139.569733 records&#x2F;sec (4.04 MB&#x2F;sec), 5786.82 ms avg latency, 17962.00 ms max latency, 3667 ms 50th, 16259 ms 95th, 17789 ms 99th, 17923 ms 99.9th</td>
</tr>
<tr>
<td>batch.size&#x3D;32768 linger.ms&#x3D;0 compression.type&#x3D;snappy</td>
<td>1000000 records sent, 9997.600576 records&#x2F;sec (9.76 MB&#x2F;sec), 1865.76 ms avg latency, 5883.00 ms max latency, 1455 ms 50th, 4909 ms 95th, 5438 ms 99th, 5801 ms 99.9th.</td>
</tr>
<tr>
<td>batch.size&#x3D;32768 linger.ms&#x3D;50 compression.type&#x3D;gzip</td>
<td>1000000 records sent, 9998.300289 records&#x2F;sec (9.76 MB&#x2F;sec), 37.91 ms avg latency, 739.00 ms max latency, 6 ms 50th, 199 ms 95th, 562 ms 99th, 639 ms 99.9th.</td>
</tr>
<tr>
<td>batch.size&#x3D;16384 linger.ms&#x3D;50 compression.type&#x3D;gzip buffer.memory&#x3D;67108864</td>
<td>1000000 records sent, 9998.400256 records&#x2F;sec (9.76 MB&#x2F;sec), 45.36 ms avg latency, 1219.00 ms max latency, 4 ms 50th, 260 ms 95th, 945 ms 99th, 1161 ms 99.9th</td>
</tr>
</tbody></table>
<h5 id="kafka-consumer-perf-test-sh"><a href="#kafka-consumer-perf-test-sh" class="headerlink" title="kafka-consumer-perf-test.sh"></a><code>kafka-consumer-perf-test.sh</code></h5><pre><code class="prettyprint">#消费数量10万个
./kafka-consumer-perf-test.sh --bootstrap-server 192.168.101.143:9001,192.168.101.143:9002,192.168.101.143:9003 --topic test --messages 1000000 --consumer.config ../config/consumer.properties
</code></pre>
<blockquote>
<ul>
<li>–bootstrap-server 指定 Kafka 集群地址</li>
<li>–topic 指定 topic 的名称</li>
<li>–messages 总共要消费的消息个数。本次实验 100 万条。</li>
</ul>
<p>修改配置consumer.properties</p>
<p>max.poll.records&#x3D;500：一次 poll 拉取数据返回消息的最大条数</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th>结果start.time, end.time, data.consumed.in.MB, MB.sec, data.consumed.in.nMsg, nMsg.sec, rebalance.time.ms, fetch.time.ms, fetch.MB.sec, fetch.nMsg.sec</th>
</tr>
</thead>
<tbody><tr>
<td>max.poll.records&#x3D;500 fetch.max.bytes&#x3D;52428800</td>
<td>2022-07-21 20:39:56:913, 2022-07-21 20:40:07:561, 976.7051, <strong>91.7266</strong>, 1000146, 93928.0616, 1531, 9117, 107.1301, 109701.2175</td>
</tr>
<tr>
<td>max.poll.records&#x3D;2000 fetch.max.bytes&#x3D;52428800</td>
<td>2022-07-21 20:41:14:571, 2022-07-21 20:41:19:923, 976.9424, <strong>182.5378</strong>, 1000389, 186918.7220, 641, 4711, 207.3747, 212351.7300</td>
</tr>
<tr>
<td>max.poll.records&#x3D;2000 fetch.max.bytes&#x3D;104857600</td>
<td>2022-07-21 20:42:24:476, 2022-07-21 20:42:29:266, 977.1650, <strong>204.0011</strong>, 1000617, 208897.0772, 509, 4281, 228.2563, 233734.4078</td>
</tr>
</tbody></table>
<h3 id="服役新节点"><a href="#服役新节点" class="headerlink" title="服役新节点"></a>服役新节点</h3><ul>
<li>新增配置文件<code>kafka9004.properties</code></li>
</ul>
<pre><code class="prettyprint">cp kafka9001.properties kafka9004.properties
</code></pre>
<ul>
<li>修改内容</li>
</ul>
<pre><code class="prettyprint">#修改配置
broker.id=4
host.name=192.168.101.143
listeners=PLAINTEXT://192.168.101.143:9004
advertised.listeners=PLAINTEXT://192.168.101.143:9004
log.dirs=/opt/module/kafka/datas-logs4
</code></pre>
<ul>
<li>启动新节点</li>
</ul>
<pre><code class="prettyprint">./kafka-server-start.sh ../config/kafka9004.properties &amp;
</code></pre>
<ul>
<li>创建一个需要负载均衡的主题<code>topics-to-move.json</code></li>
</ul>
<pre><code class="prettyprint"># 可以传多个主题
&#123;
    &quot;topics&quot;: [
        &#123;&quot;topic&quot;: &quot;first&quot;&#125;
    ],
    &quot;version&quot;: 1
&#125;
</code></pre>
<ul>
<li>生成负载均衡计划</li>
</ul>
<pre><code class="prettyprint">bin/kafka-reassign-partitions.sh --bootstrap-server 192.168.101.143:9001 --topics-to-move-json-file topics-to-move.json --broker-list &quot;1,2,3,4&quot; --generate
</code></pre>
<blockquote>
<p>执行结果</p>
</blockquote>
<pre><code class="prettyprint">Current partition replica assignment
&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[1,3],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[2,1],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[3,2],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;]&#125;

Proposed partition reassignment configuration
# 需要执行的存储计划json
&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[1,2],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[2,3],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[3,4],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;]&#125;
</code></pre>
<ul>
<li>创建副本存储计划<code>increase-replication.json</code></li>
</ul>
<pre><code class="prettyprint">&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[1,2],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[2,3],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[3,4],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;]&#125;
</code></pre>
<ul>
<li>执行副本存储计划</li>
</ul>
<pre><code class="prettyprint">bin/kafka-reassign-partitions.sh --bootstrap-server 192.168.101.143:9001 --reassignment-json-file increase-replication.json --execute
</code></pre>
<blockquote>
<p>执行结果</p>
</blockquote>
<pre><code class="prettyprint">Current partition replica assignment

&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[1,3],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[2,1],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[3,2],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;]&#125;

Save this to use as the --reassignment-json-file option during rollback
Successfully started partition reassignments for first-0,first-1,first-2
</code></pre>
<ul>
<li>验证副本存储计划</li>
</ul>
<pre><code class="prettyprint">bin/kafka-reassign-partitions.sh --bootstrap-server 192.168.101.143:9001 --reassignment-json-file increase-replication.json --verify
</code></pre>
<blockquote>
<p>执行结果</p>
</blockquote>
<pre><code class="prettyprint">Status of partition reassignment:
Reassignment of partition first-0 is complete.
Reassignment of partition first-1 is complete.
Reassignment of partition first-2 is complete.

Clearing broker-level throttles on brokers 1,2,3,4
Clearing topic-level throttles on topic first
</code></pre>
<h3 id="退役旧结点"><a href="#退役旧结点" class="headerlink" title="退役旧结点"></a>退役旧结点</h3><ul>
<li>创建一个需要负载均衡的主题<code>topics-to-move.json</code></li>
</ul>
<pre><code class="prettyprint">&#123;
    &quot;topics&quot;: [
        &#123;&quot;topic&quot;: &quot;first&quot;&#125;
    ],
    &quot;version&quot;: 1
&#125;
</code></pre>
<ul>
<li>创建执行计划</li>
</ul>
<pre><code class="prettyprint">bin/kafka-reassign-partitions.sh --bootstrap-server 192.168.101.143:9001 --topics-to-move-json-file topics-to-move.json --broker-list &quot;1,2,3&quot; --generate
</code></pre>
<blockquote>
<p>执行结果</p>
</blockquote>
<pre><code class="prettyprint">Current partition replica assignment
&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[1,3],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[2,1],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[3,2],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;]&#125;

Proposed partition reassignment configuration
&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[3,2],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[1,3],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[2,1],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;]&#125;
</code></pre>
<ul>
<li>创建副本存储计划<code>decrease-replication.json</code></li>
</ul>
<pre><code class="prettyprint">&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[3,2],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[1,3],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[2,1],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;]&#125;
</code></pre>
<ul>
<li>执行副本存储计划</li>
</ul>
<pre><code class="prettyprint">bin/kafka-reassign-partitions.sh --bootstrap-server 192.168.101.143:9001 --reassignment-json-file decrease-replication.json --execute
</code></pre>
<blockquote>
<p>执行结果</p>
</blockquote>
<pre><code class="prettyprint">Current partition replica assignment

&#123;&quot;version&quot;:1,&quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[1,2],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[2,3],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;,&#123;&quot;topic&quot;:&quot;first&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[3,4],&quot;log_dirs&quot;:[&quot;any&quot;,&quot;any&quot;]&#125;]&#125;

Save this to use as the --reassignment-json-file option during rollback
Successfully started partition reassignments for first-0,first-1,first-2
</code></pre>
<ul>
<li>验证副本存储计划</li>
</ul>
<pre><code class="prettyprint">bin/kafka-reassign-partitions.sh --bootstrap-server 192.168.101.143:9001 --reassignment-json-file decrease-replication.json --verify
</code></pre>
<blockquote>
<p>执行结果</p>
</blockquote>
<pre><code class="prettyprint">Status of partition reassignment:
Reassignment of partition first-0 is complete.
Reassignment of partition first-1 is complete.
Reassignment of partition first-2 is complete.

Clearing broker-level throttles on brokers 1,2,3,4
Clearing topic-level throttles on topic first
</code></pre>
<h3 id="指定分区副本"><a href="#指定分区副本" class="headerlink" title="指定分区副本"></a>指定分区副本</h3><ul>
<li>创建分区主题</li>
</ul>
<pre><code class="prettyprint"># 4分区 2 副本
./kafka-topics.sh --create --topic &quot;rocpenghua3&quot; --bootstrap-server 192.168.101.143:9001 --partitions 4 --replication-factor 2
</code></pre>
<ul>
<li>创建分区配置<code>assign-replication-factor.json</code></li>
</ul>
<pre><code class="prettyprint">&#123;
    &quot;version&quot;:1,
    &quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;rocpenghua3&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[1,2]&#125;,
        &#123;&quot;topic&quot;:&quot;rocpenghua3&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[1,2]&#125;,
        &#123;&quot;topic&quot;:&quot;rocpenghua3&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[2,1]&#125;,
        &#123;&quot;topic&quot;:&quot;rocpenghua3&quot;,&quot;partition&quot;:3,&quot;replicas&quot;:[2,1]&#125;]
&#125;
</code></pre>
<ul>
<li>执行副本存储计划</li>
</ul>
<pre><code class="prettyprint">./kafka-reassign-partitions.sh --bootstrap-server 192.168.101.143:9001 --reassignment-json-file ../assign-replication-factor.json --execute
</code></pre>
<ul>
<li>验证副本存储计划</li>
</ul>
<pre><code class="prettyprint">./kafka-reassign-partitions.sh --bootstrap-server 192.168.101.143:9001 --reassignment-json-file ../assign-replication-factor.json --verify
</code></pre>
<ul>
<li>查看主题信息</li>
</ul>
<pre><code class="prettyprint">bin/kafka-topics.sh --bootstrap-server 192.168.101.143:9001 --describe --topic &quot;rocpenghua3&quot;
</code></pre>
<blockquote>
<p>结果信息</p>
</blockquote>
<pre><code class="prettyprint">Topic: rocpenghua3	TopicId: e7ZcYefrQ_ekcjzbEX4fbw	PartitionCount: 4	ReplicationFactor: 2	Configs: segment.bytes=1073741824
    Topic: rocpenghua3	Partition: 0	Leader: 2	Replicas: 1,2	Isr: 2,1
    Topic: rocpenghua3	Partition: 1	Leader: 1	Replicas: 1,2	Isr: 2,1
    Topic: rocpenghua3	Partition: 2	Leader: 2	Replicas: 2,1	Isr: 1,2
    Topic: rocpenghua3	Partition: 3	Leader: 1	Replicas: 2,1	Isr: 1,2
</code></pre>
<h3 id="增加分区副本"><a href="#增加分区副本" class="headerlink" title="增加分区副本"></a>增加分区副本</h3><ul>
<li>创建主题</li>
</ul>
<pre><code class="prettyprint"># 3分区 1 副本
./kafka-topics.sh --create --topic &quot;rocpenghua4&quot; --bootstrap-server 192.168.101.143:9001 --partitions 3 --replication-factor 1
</code></pre>
<ul>
<li>创建分区配置<code>increase-replication-factor.json</code></li>
</ul>
<pre><code class="prettyprint">&#123;
    &quot;version&quot;:1,
    &quot;partitions&quot;:[&#123;&quot;topic&quot;:&quot;rocpenghua4&quot;,&quot;partition&quot;:0,&quot;replicas&quot;:[1,2,3]&#125;,
    &#123;&quot;topic&quot;:&quot;rocpenghua4&quot;,&quot;partition&quot;:1,&quot;replicas&quot;:[1,2,3]&#125;,
    &#123;&quot;topic&quot;:&quot;rocpenghua4&quot;,&quot;partition&quot;:2,&quot;replicas&quot;:[1,2,3]&#125;]
&#125;
</code></pre>
<ul>
<li>执行副本存储计划</li>
</ul>
<pre><code class="prettyprint">./kafka-reassign-partitions.sh --bootstrap-server 192.168.101.143:9001 --reassignment-json-file ../increase-replication-factor.json --execute
</code></pre>
<ul>
<li>验证副本存储计划</li>
</ul>
<pre><code class="prettyprint">./kafka-reassign-partitions.sh --bootstrap-server 192.168.101.143:9001 --reassignment-json-file ../increase-replication-factor.json --verify
</code></pre>
<ul>
<li>查看主题信息</li>
</ul>
<pre><code class="prettyprint">bin/kafka-topics.sh --bootstrap-server 192.168.101.143:9001 --describe --topic &quot;rocpenghua4&quot;
</code></pre>
<h3 id="核心参数配置"><a href="#核心参数配置" class="headerlink" title="核心参数配置"></a>核心参数配置</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><ul>
<li><p><code>bootstrap.servers</code>：生 产 者 连 接 集 群 所 需 的 broker 地 址 清 单 。 例 如<br>192.168.101.143:9001,192.168.101.143:9002，可以设置 1 个或者多个，中间用逗号隔开，并非所有的broker</p>
</li>
<li><p><code>key.serializer</code> 和<code>value.serializer</code>：指定发送消息的 key 和 value 的序列化类型。一定要写<br>全类名</p>
</li>
<li><p><code>buffer.memory</code>：RecordAccumulator 缓冲区总大小，<strong>默认 32m</strong>。</p>
</li>
<li><p><code>batch.size</code>：缓冲区一批数据最大值，<strong>默认 16k</strong>。适当增加该值，可以提高吞吐量，但是如果该值设置太大，会导致数据传输延迟增加。</p>
</li>
<li><p><code>linger.ms</code>：如果数据迟迟未达到 batch.size，sender 等待 linger.time之后就会发送数据。单位 ms，<strong>默认值是 0ms</strong>，表示没有延迟。生产环境建议该值大小为 5-100ms 之间</p>
</li>
<li><p><code>acks</code>：<strong>默认值是-1</strong></p>
<ul>
<li>0：生产者发送过来的数据，不需要等数据落盘应答。</li>
<li>1：生产者发送过来的数据，Leader 收到数据后应答。</li>
<li>-1（all）：生产者发送过来的数据，Leader+和 isr 队列里面的所有节点收齐数据后应答。</li>
</ul>
</li>
<li><p><code>max.in.flight.requests.per.connection</code>：允许最多没有返回 ack 的次数，<strong>默认为 5</strong>，开启幂等性要保证该值是 1-5 的数字</p>
</li>
<li><p><code>retries</code>：当消息发送出现错误的时候，系统会重发消息。retries表示重试次数。<strong>默认是 int 最大值</strong>,2147483647。如果设置了重试，还想保证消息的有序性，需要设置MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION&#x3D;1否则在重试此失败消息的时候，其他的消息可能发送成功了</p>
</li>
<li><p><code>retry.backoff.ms</code>：两次重试之间的时间间隔，<strong>默认是 100ms</strong>。</p>
</li>
<li><p><code>enable.idempotence</code>：是否开启幂等性，<strong>默认 true</strong>，开启幂等性</p>
</li>
<li><p><code>compression.type</code>：生产者发送的所有数据的压缩方式。<strong>默认是 none</strong>，也就是不压缩。支持压缩类型：none、gzip、snappy、lz4 和 zstd</p>
</li>
<li><p><code>partitioner.class</code>：分区器</p>
<ul>
<li><p>默认：<code>org.apache.kafka.clients.producer.internals.DefaultPartitioner</code></p>
</li>
<li><p>自定义：<code>properties.put(ProducerConfig.PARTITIONER_CLASS_CONFIG,&quot;com.rocpenghua.kafka.producer.MyPartitioner&quot;);</code></p>
<pre><code class="prettyprint">public class MyPartitioner implements Partitioner &#123;
    @Override
    public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) &#123;
        // 获取数据 
        String msgValues = value.toString();
        int partition;

        if (msgValues.contains(&quot;rocpenghua&quot;))&#123;
            partition = 2;
        &#125;else &#123;
            partition = 1;
        &#125;
        return partition;
    &#125;
    @Override
    public void close() &#123;

    &#125;
    @Override
    public void configure(Map&lt;String, ?&gt; configs) &#123;

    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>事务开启</p>
<ul>
<li><pre><code class="prettyprint">public class CustomProducerTranactions &#123;
    public static void main(String[] args) &#123;
        // 0 配置
        Properties properties = new Properties();
        // 连接集群 bootstrap.servers
        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;192.168.101.143:9001,192.168.101.143:9002,192.168.101.143:9003&quot;);
        // 指定对应的key和value的序列化类型 key.serializer
        properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
        properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());
        // 指定事务id
        properties.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, &quot;tranactional_id_01&quot;);
        // 1 创建kafka生产者对象
        KafkaProducer&lt;String, String&gt; kafkaProducer = new KafkaProducer&lt;&gt;(properties);
        //初始化事务
        kafkaProducer.initTransactions();
        //开启事务
        kafkaProducer.beginTransaction();
        try &#123;
            // 2 发送数据
            for (int i = 0; i &lt; 5; i++) &#123;
                kafkaProducer.send(new ProducerRecord&lt;&gt;(&quot;first&quot;, &quot;rocpenghua&quot; + i));
            &#125;
            int i = 1 / 0;
            //提交事务
            kafkaProducer.commitTransaction();
        &#125; catch (Exception e) &#123;
            //放弃事务
            kafkaProducer.abortTransaction();
        &#125; finally &#123;
            // 3 关闭资源
            kafkaProducer.close();
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<blockquote>
<p>提高吞吐量配置</p>
<ul>
<li>buffer.memory：缓冲区大小 默认 32m</li>
<li>batch.size：缓冲区一批数据最大值 默认 16k</li>
<li>linger.ms：默认值是 0ms，表示没有延迟</li>
<li>compression.type：默认是 none</li>
</ul>
<p>数据可靠性</p>
<ul>
<li>acks：默认值是-1</li>
</ul>
<p>数据去重</p>
<ul>
<li>enable.idempotence：开启幂等性，默认 true</li>
</ul>
<p>数据乱序</p>
<ul>
<li>enable.idempotence：开启幂等性，默认 true</li>
<li>max.in.flight.requests.per.connection：允许最多没有返回 ack 的次数，默认为 5，开启幂等性要保证该值是 1-5 的数字</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><ul>
<li><p><code>bootstrap.servers</code>：向 Kafka 集群建立初始连接用到的 host&#x2F;port 列表。</p>
</li>
<li><p><code>key.deserializer</code> 和 <code>value.deserializer</code>：指定接收消息的 key 和 value 的反序列化类型</p>
</li>
<li><p><code>group.id</code>：标记消费者所属的消费者组。命令默认生成。</p>
</li>
<li><p><code>enable.auto.commit</code>：<strong>默认值为 true</strong>，消费者会自动周期性地向服务器提交偏移量</p>
</li>
<li><p><code>auto.commit.interval.ms</code>：如果设置了 enable.auto.commit 的值为 true， 则该值定义了消费者偏移量向 Kafka 提交的频率，<strong>默认 5s</strong>。</p>
</li>
<li><p><code>auto.offset.reset</code>：当 Kafka 中没有初始偏移量或当前偏移量在服务器中不存在（如，数据被删除了），该如何处理？ </p>
<ul>
<li>earliest：自动重置偏移量到最早的偏移量。</li>
<li>latest：<strong>默认，自动重置偏移量为最新的偏移量</strong>。 </li>
<li>none：如果消费组原来的（previous）偏移量不存在，则向消费者抛异常。 </li>
<li>anything：向消费者抛异常</li>
</ul>
</li>
<li><p><code>offsets.topic.num.partitions</code>：__consumer_offsets 的分区数，<strong>默认是 50 个分区</strong>。</p>
</li>
<li><p><code>heartbeat.interval.ms</code>：Kafka 消费者和 coordinator 之间的心跳时间，<strong>默认 3s</strong>。该条目的值必须小于 session.timeout.ms ，也不应该高于session.timeout.ms 的 1&#x2F;3。</p>
</li>
<li><p><code>session.timeout.ms</code>：Kafka 消费者和 coordinator 之间连接超时时间，<strong>默认 45s</strong>。超过该值，该消费者被移除，消费者组执行再平衡。</p>
</li>
<li><p><code>max.poll.interval.ms</code>：消费者处理消息的最大时长，<strong>默认是 5 分钟</strong>。超过该值，该消费者被移除，消费者组执行再平衡。</p>
</li>
<li><p><code>fetch.min.bytes</code>：<strong>默认 1 个字节</strong>。消费者获取服务器端一批消息最小的字节数。</p>
</li>
<li><p><code>fetch.max.wait.ms</code>：<strong>默认 500ms</strong>。如果没有从服务器端获取到一批数据的最小字节数。该时间到，仍然会返回数据。</p>
</li>
<li><p><code>fetch.max.bytes</code>：<strong>默认 Default: 52428800（50 m）</strong>。消费者获取服务器端一批消息最大的字节数。如果服务器端一批次的数据大于该值（50m）仍然可以拉取回来这批数据，因此，这不是一个绝对最大值。一批次的大小受 message.max.bytes （broker config）or max.message.bytes （topic config）影响。</p>
</li>
<li><p><code>max.poll.records</code>：一次 poll 拉取数据返回消息的最大条数，<strong>默认是 500 条</strong>。</p>
</li>
<li><p><code>partition.assignment.strategy</code>：分区策略,默认<code>org.apache.kafka.clients.consumer.RangeAssignor</code> <code>org.apache.kafka.clients.consumer.CooperativeStickyAssignor</code></p>
<ul>
<li><p><code>org.apache.kafka.clients.consumer.RangeAssignor</code>‎：基于每个主题分配分区。‎</p>
</li>
<li><p><code>org.apache.kafka.clients.consumer.RoundRobinAssignor</code>‎：以轮循机制方式将分区分配给使用者。‎</p>
</li>
<li><p><code>org.apache.kafka.clients.consumer.StickyAssignor</code>‎：保证分配的最大平衡，同时保留尽可能多的现有分区分配。‎</p>
</li>
<li><p><code>org.apache.kafka.clients.consumer.CooperativeStickyAssignor</code>‎：遵循相同的粘性Assignor逻辑，但允许合作再平衡。‎</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>消费者再平衡</p>
<ul>
<li>heartbeat.interval.ms：默认 3s，小于 session.timeout.ms，也不应该高于session.timeout.ms 的 1&#x2F;3</li>
<li>session.timeout.ms：默认 45s</li>
<li>max.poll.interval.ms：默认是 5 分钟</li>
<li>partition.assignment.strategy：默 认 策 略 是Range +CooperativeSticky</li>
</ul>
<p>消费者提高吞吐量</p>
<ul>
<li>fetch.max.bytes：Default: 52428800（50 m）</li>
<li>max.poll.records：一次 poll 拉取数据返回消息的最大条数，默认是 500 条</li>
</ul>
</blockquote>
<h4 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h4><ul>
<li><p><code>replica.lag.time.max.ms</code>：ISR 中，如果 Follower 长时间未向 Leader 发送通信请求或同步数据，则该 Follower 将被踢出 ISR。该时间阈值，<strong>默认 30s</strong>。</p>
</li>
<li><p><code>auto.leader.rebalance.enable</code>：<strong>默认是 true</strong>。 自动 Leader Partition 平衡。</p>
</li>
<li><p><code>leader.imbalance.per.broker.percentage</code>：**默认是 10%**。每个 broker 允许的不平衡的 leader的比率。如果每个 broker 超过了这个值，控制器会触发 leader 的平衡。</p>
</li>
<li><p><code>leader.imbalance.check.interval.seconds </code>：<strong>默认值 300 秒</strong>。检查 leader 负载是否平衡的间隔时间</p>
</li>
<li><p><code>log.segment.bytes</code>：Kafka 中 log 日志是分成一块块存储的，此配置是指 log 日志划分 成块的大小，<strong>默认值 1G</strong>。</p>
</li>
<li><p><code>log.index.interval.bytes</code>：<strong>默认 4kb</strong>，kafka 里面每当写入了 4kb 大小的日志（.log），然后就往 index 文件里面记录一个索引。</p>
</li>
<li><p><code>log.retention.hours</code>：Kafka 中数据保存的时间，<strong>默认 7 天</strong>。</p>
</li>
<li><p><code>log.retention.minutes</code>：Kafka 中数据保存的时间，分钟级别，<strong>默认关闭</strong>。</p>
</li>
<li><p><code>log.retention.ms</code>：Kafka 中数据保存的时间，毫秒级别，<strong>默认关闭</strong>。</p>
</li>
<li><p><code>log.retention.check.interval.ms</code>：检查数据是否保存超时的间隔，<strong>默认是 5 分钟</strong></p>
</li>
<li><p><code>log.retention.bytes</code>：<strong>默认等于-1</strong>，表示无穷大。超过设置的所有日志总大小，删除最早的 segment。</p>
</li>
<li><p><code>log.cleanup.policy</code>：<strong>默认是 delete</strong>，表示所有数据启用删除策略；如果设置值为 compact，表示所有数据启用压缩策略。</p>
</li>
<li><p><code>num.io.threads</code>：<strong>默认是 8</strong>。负责写磁盘的线程数。整个参数值要占总核数的 50%。</p>
</li>
<li><p><code>num.replica.fetchers</code>：副本拉取线程数，这个参数占总核数的 50%的 1&#x2F;3</p>
</li>
<li><p><code>num.network.threads</code>：<strong>默认是 3</strong>。数据传输线程数，这个参数占总核数的50%的 2&#x2F;3 。</p>
</li>
<li><p><code>log.flush.interval.messages</code>：强制页缓存刷写到磁盘的条数，<strong>默认是 long 的最大值</strong>，9223372036854775807。<strong>一般不建议修改</strong>，交给系统自己管理</p>
</li>
<li><p><code>log.flush.interval.ms</code>：每隔多久，刷数据到磁盘，默认是 null。<strong>一般不建议修改</strong>，交给系统自己管理。</p>
</li>
</ul>
<blockquote>
<p>Partition负载平衡</p>
<ul>
<li>auto.leader.rebalance.enable：建议设置为 false 关闭。</li>
<li>leader.imbalance.per.broker.percentage：默认是 10%。每个 broker 允许的不平衡的 leader的比率</li>
<li>leader.imbalance.check.interval.seconds：默认值 300 秒。检查 leader 负载是否平衡的间隔时间</li>
</ul>
<p>自动创建主题</p>
<ul>
<li>auto.create.topics.enable：默认true,生产环境改成false</li>
</ul>
<p>单条日志大于1m</p>
<ul>
<li>message.max.bytes：默认 1m，broker 端接收每个批次消息最大值</li>
<li>max.request.size：默认 1m，生产者发往 broker 每个请求消息最大值</li>
<li>replica.fetch.max.bytes：默认 1m，副本同步数据，每个批次消息最大值</li>
<li>fetch.max.bytes：默认 Default: 52428800（50 m）</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化缓存定制</title>
    <url>/2022/06/15/xu-lie-hua-huan-cun-ding-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="prettyprint">@Configuration
public class RedisConfig &#123;
  /**
   * @desc 序列化缓存定制
   * @method
   */
  @Bean
  public RedisCacheManager jsonCacheManager(RedisConnectionFactory factory) &#123;
    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                    //使用GenericJackson2JsonRedisSerializer可以同时支持多种不同类型的domain对象
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));
    return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .build();
  &#125;
&#125;
</code></pre>
<h3 id="序列化问题"><a href="#序列化问题" class="headerlink" title="序列化问题"></a>序列化问题</h3><p>要把<code>对象</code>做为<code>key-value</code>对保存在redis中，就必须要解决对象的序列化问题。Spring Data Redis给我们提供了一些现成的方案：</p>
<ul>
<li><p><code>JdkSerializationRedisSerializer</code>. 使用JDK提供的序列化功能。 优点是反序列化时不需要提供类型信息(class)，但缺点是序列化后的结果非常庞大，是JSON格式的5倍左右，这样就会消耗redis服务器的大量内存。</p>
</li>
<li><p><code>Jackson2JsonRedisSerializer</code>. 使用Jackson库将对象序列化为JSON字符串。优点是速度快，序列化后的字符串短小精悍。但缺点也非常致命，那就是此类的构造函数中有一个类型参数，必须提供要序列化对象的类型信息(.class对象)。 通过查看源代码，发现其只在反序列化过程中用到了类型信息。</p>
</li>
<li><p><code>GenericJackson2JsonRedisSerializer</code>. 和 <code>Jackson2JsonRedisSerializer</code> 类似。但是它不需要提供序列化对象的类型信息。</p>
</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果用方案一，就必须付出缓存多占用4倍内存的代价，实在承受不起。  </p>
<p>如果用方案二，则必须给每一种domain对象都配置一个Serializer，即如果我的应用里有100种domain对象，那就必须在spring配置文件中配置100个Jackson2JsonRedisSerializer，这显然也是不现实的。</p>
<p>如果用方案三，就是为了解决Jackson必须提供类型信息的问题，可以同时支持多种不同类型的domain对象。</p>
<h3 id="Jackson2JsonRedisSerializer和GenericJackson2JsonRedisSerializer的区别"><a href="#Jackson2JsonRedisSerializer和GenericJackson2JsonRedisSerializer的区别" class="headerlink" title="Jackson2JsonRedisSerializer和GenericJackson2JsonRedisSerializer的区别"></a>Jackson2JsonRedisSerializer和GenericJackson2JsonRedisSerializer的区别</h3><h4 id="一、使用Jackson2JsonRedisSerializer序列化反序列化带泛型的List数据"><a href="#一、使用Jackson2JsonRedisSerializer序列化反序列化带泛型的List数据" class="headerlink" title="一、使用Jackson2JsonRedisSerializer序列化反序列化带泛型的List数据"></a>一、使用Jackson2JsonRedisSerializer序列化反序列化带泛型的List数据</h4><p>1、使用Jackson2JsonRedisSerializer序列化value的代码</p>
<pre><code class="prettyprint">redisTemplate.setKeySerializer(new StringRedisSerializer());
redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer(Object.class));
</code></pre>
<pre><code class="prettyprint">User user = new User();
user.setUserId(1);
user.setUsername(&quot;张三&quot;);
List&lt;User&gt; userList = new ArrayList&lt;&gt;();
userList.add(user);
//不能直接将对象存储进redis中否则在进行反序列化的时候会报
// java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to com.lx.entity.User错误
//可以先转为json字符串再进行存储
String value = JSON.toJSONString(userList);
redisTemplate.opsForValue().set(&quot;jackson2JsonRedisSerializer&quot;, value, 5,
        TimeUnit.MINUTES);
</code></pre>
<p>2、使用Jackson2JsonRedisSerializer序列化后的数据形式</p>
<pre><code class="prettyprint">[
  &#123;
    &quot;userId&quot;:1,
    &quot;username&quot;:&quot;张三&quot;
  &#125;
]
</code></pre>
<p>3、使用Jackson2JsonRedisSerializer反序列化时报错</p>
<pre><code class="prettyprint">List&lt;User&gt; userListRedis = redisTemplate.opsForValue().get(&quot;jackson2JsonRedisSerializer&quot;);
userListRedis.forEach(u -&gt; System.out.println(JSON.toJSONString(u)));
</code></pre>
<p>错误信息</p>
<pre><code>java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to com.lx.entity.User
</code></pre>
<ul>
<li>原因: <strong>序列化带泛型的数据时，会以map的结构进行存储，反序列化时不能将map解析成对象。</strong></li>
</ul>
<p>4、解决方案：序列化存储时，转成JSON字符串<br>使用<code>jackson</code>或者<code>fastjson</code>都可以，我这里使用的是<code>fastjson</code>,<br>需要的依赖</p>
<pre><code class="prettyprint">&lt;dependency&gt;
  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
  &lt;version&gt;1.2.47&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="prettyprint">User user = new User();
user.setUserId(1);
user.setUsername(&quot;张三&quot;);
List&lt;User&gt; userList = new ArrayList&lt;&gt;();
userList.add(user);

redisTemplate.opsForValue().set(&quot;jackson2JsonRedisSerializer&quot;, JSON.toJSONString(userList), 5, TimeUnit.MINUTES);

String res = (String) redisTemplate.opsForValue().get(&quot;jackson2JsonRedisSerializer&quot;);
JSON.parseArray(res, User.class).forEach(u -&gt; System.out.println(JSON.toJSONString(u)));
</code></pre>
<h4 id="二、使用GenericJackson2JsonRedisSerializer序列化反序列化带泛型的List数据"><a href="#二、使用GenericJackson2JsonRedisSerializer序列化反序列化带泛型的List数据" class="headerlink" title="二、使用GenericJackson2JsonRedisSerializer序列化反序列化带泛型的List数据"></a>二、使用GenericJackson2JsonRedisSerializer序列化反序列化带泛型的List数据</h4><p>1、使用GenericJackson2JsonRedisSerializer序列化value的代码</p>
<pre><code class="prettyprint">redisTemplate.setKeySerializer(new StringRedisSerializer());
redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
</code></pre>
<pre><code class="prettyprint">User user = new User();
user.setUserId(1);
user.setUsername(&quot;李四&quot;);
List&lt;User&gt; userList = new ArrayList&lt;&gt;();
userList.add(user);
redisTemplate.opsForValue().set(&quot;genericJackson2JsonRedisSerializer&quot;,userList,5,TimeUnit.MINUTES);
</code></pre>
<p>2、使用GenericJackson2JsonRedisSerializer序列化后的数据形式</p>
<pre><code class="prettyprint">[
    &quot;java.util.ArrayList&quot;,
    [
        &#123;
            &quot;@class&quot;: &quot;com.lx.entity.User&quot;,
            &quot;userId&quot;: 1,
            &quot;username&quot;: &quot;李四&quot;
        &#125;
    ]
]
</code></pre>
<p>3、使用GenericJackson2JsonRedisSerializer可以正常反序列化</p>
<pre><code class="prettyprint">List&lt;User&gt; userListRedis = (List&lt;User&gt;) redisTemplate.opsForValue().get(&quot;genericJackson2JsonRedisSerializer&quot;);
userListRedis.forEach(u -&gt; System.out.println(JSON.toJSONString(u)));
</code></pre>
<p>4、可以正常反序列化的原因<br>使用<code>GenericJackson2JsonRedisSerializer</code>序列化时，会保存序列化的对象的包名和类名，反序列化时以这个作为标示就可以反序列化成指定的对象。</p>
<p>5、也可以以JSON字符串保存</p>
<pre><code class="prettyprint">redisTemplate.opsForValue().set(&quot;genericJackson2JsonRedisSerializer&quot;,JSON.toJSONString(userList),5,TimeUnit.MINUTES);

List&lt;User&gt; userListRedis = (List&lt;User&gt;) redisTemplate.opsForValue().get(&quot;genericJackson2JsonRedisSerializer&quot;);
userListRedis.forEach(u -&gt; System.out.println(JSON.toJSONString(u)));
</code></pre>
<h4 id="四、GenericJackson2JsonRedisSerializer和Jackson2JsonRedisSerializerdo效率"><a href="#四、GenericJackson2JsonRedisSerializer和Jackson2JsonRedisSerializerdo效率" class="headerlink" title="四、GenericJackson2JsonRedisSerializer和Jackson2JsonRedisSerializerdo效率"></a>四、GenericJackson2JsonRedisSerializer和Jackson2JsonRedisSerializerdo效率</h4><pre><code class="prettyprint"> 
</code></pre>
<p>测试后:</p>
<pre><code>jackson2JsonRedisSerializer序列化需要的时间:687
genericJackson2JsonRedisSerializer序列化需要的时间:22
</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>使用<code>Jackson2JsonRedisSerializer</code>需要指明序列化的类Class，可以使用<code>Obejct.class</code></p>
</li>
<li><p>使用<code>GenericJackson2JsonRedisSerializer</code>和<code>Jackson2JsonRedisSerializerdo</code>都可以正常序列化非泛型数组对象。<code>GenericJackson2JsonRedisSerializer</code>也可以正常反序列化非泛型数组对象，但是<code>Jackson2JsonRedisSerializerdo</code>因为“序列化带泛型的数据时，会以map的结构进行存储，反序列化时不能将map解析成对象”，所以不能反序列化，解决办法: 存储以JSON字符串存储</p>
</li>
<li><p>使用<code>GenericJacksonRedisSerializer</code>比<code>Jackson2JsonRedisSerializer</code>效率高</p>
</li>
<li><p><code>GenericJacksonRedisSerializer</code>和<code>Jackson2JsonRedisSerializer</code>都是以JSON格式去存储数据，都可以作为Redis的序列化方式</p>
</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP-字符串匹配</title>
    <url>/2022/06/16/kmp-zi-fu-chuan-pi-pei/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h4><ul>
<li>如果当前字符匹配成功（即 str1[i] &#x3D;&#x3D; str2[j]），则 i++，j++，继续匹配下一个字符</li>
<li>如果失配（即 str1[i]! &#x3D; str2[j]），令 i &#x3D; i - (j - 1)，j &#x3D; 0。相当于每次匹配失败时，i 回溯，j 被置为 0。</li>
<li>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)</li>
</ul>
<pre><code class="prettyprint">public class ViolenceMatch &#123;
    public static void main(String[] args) &#123;
        //测试暴力匹配算法
        String str1 = &quot;哇哈哈哈娃娃 哇哈哇哈 哈哇哈哈哈哈&quot;;
        String str2 = &quot;哈哇哈哈哈&quot;;
        int index = violenceMatch(str1, str2);
        System.out.println(&quot;index=&quot; + index);
    &#125;
    // 暴力匹配算法实现
    public static int violenceMatch(String str1, String str2) &#123;
        char[] s1 = str1.toCharArray();
        char[] s2 = str2.toCharArray();
        int s1Len = s1.length;
        int s2Len = s2.length;
        int i = 0; // i索引指向s1
        int j = 0; // j索引指向s2
        while (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123;// 保证匹配时，不越界
            if(s1[i] == s2[j]) &#123;//匹配ok
                i++;
                j++;
            &#125; else &#123; //没有匹配成功
                //如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。
                i = i - (j - 1);
                j = 0;
            &#125;
        &#125;
        //判断是否匹配成功
        if(j == s2Len) &#123;
            return i - j;
        &#125; else &#123;
            return -1;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><p><a href="https://blog.csdn.net/weixin_52622200/article/details/110563434">什么是KMP算法（详解)</a></p>
<pre><code class="prettyprint">public class KMPAlgorithm &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        String str1 = &quot;BBC ABCDAB ABCDABCDABDE&quot;;
        String str2 = &quot;ABCDABD&quot;;
        //String str2 = &quot;BBC&quot;;
        
        int[] next = kmpNext(str2); //[0, 1, 2, 0]
        System.out.println(&quot;next=&quot; + Arrays.toString(next));
        
        int index = kmpSearch(str1, str2, next);
        System.out.println(&quot;index=&quot; + index); // 15了
        
        
    &#125;
    
    //写出我们的kmp搜索算法
    /**
     * 
     * @param str1 源字符串
     * @param str2 子串
     * @param next 部分匹配表, 是子串对应的部分匹配表
     * @return 如果是-1就是没有匹配到，否则返回第一个匹配的位置
     */
    public static int kmpSearch(String str1, String str2, int[] next) &#123;
        
        //遍历  j标识头部用于对对比下标 i标识字符串遍历下标
        for(int i = 0, j = 0; i &lt; str1.length(); i++) &#123;
            
            //需要处理 str1.charAt(i) ！= str2.charAt(j), 去调整j的大小
            //KMP算法核心点, 可以验证...
            while( j &gt; 0 &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;
                //next[j-1] 表示前面有n个数匹配了和开头匹配了，直接从下标n开始
                j = next[j-1]; 
            &#125;
            
            if(str1.charAt(i) == str2.charAt(j)) &#123;
                j++;
            &#125;			
            if(j == str2.length()) &#123;//找到了 // j = 3 i 
                return i - j + 1;
            &#125;
        &#125;
        return  -1;
    &#125;

    //获取到一个字符串(子串) 的部分匹配值表
    public static  int[] kmpNext(String dest) &#123;
        //创建一个next 数组保存部分匹配值
        int[] next = new int[dest.length()];
        next[0] = 0; //如果字符串是长度为1 部分匹配值就是0
        for(int i = 1, j = 0; i &lt; dest.length(); i++) &#123;
            //当dest.charAt(i) != dest.charAt(j) ，我们需要从next[j-1]获取新的j
            //直到我们发现 有  dest.charAt(i) == dest.charAt(j)成立才退出
            //这时kmp算法的核心点
            while(j &gt; 0 &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;
                j = next[j-1];
            &#125;
            
            //当dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就是+1
            if(dest.charAt(i) == dest.charAt(j)) &#123;
                j++;
            &#125;
            next[i] = j;
        &#125;
        return next;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>fastdfs安装</title>
    <url>/2022/06/17/fastdfs-an-zhuang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="组件准备"><a href="#组件准备" class="headerlink" title="组件准备"></a>组件准备</h3><ul>
<li><p><code>libfastcommon</code>-1.0.5：<a href="https://github.com/happyfish100/libfastcommon.git">https://github.com/happyfish100/libfastcommon.git</a></p>
</li>
<li><p><code>fastdfs</code>-6.0.7： <a href="https://github.com/happyfish100/fastdfs.git">https://github.com/happyfish100/fastdfs.git</a></p>
</li>
<li><p><code>fastdfs-nginx-module</code>-1.22：<a href="https://github.com/happyfish100/fastdfs-nginx-module.git">https://github.com/happyfish100/fastdfs-nginx-module.git</a></p>
</li>
<li><p><code>nginx</code>-1.20.2：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p>
<ul>
<li><a href="https://rocpenghua.gitee.io/2022/06/05/nginx-pei-zhi-xue-xi/">nginx配置学习 | 小鹏驿站 (gitee.io)</a></li>
</ul>
</li>
</ul>
<img src="/2022/06/17/fastdfs-an-zhuang/image-20220617223712983.png" class="asset-class" title="image-20220617223712983">

<h3 id="安装libfastcommon"><a href="#安装libfastcommon" class="headerlink" title="安装libfastcommon"></a>安装<code>libfastcommon</code></h3><pre><code class="prettyprint">cd /opt/software/fastdfs
tar -zxvf libfastcommon-1.0.50.tar.gz
cd libfastcommon-1.0.50
./make.sh
./make.sh install
</code></pre>
<h3 id="安装fastdfs"><a href="#安装fastdfs" class="headerlink" title="安装fastdfs"></a>安装<code>fastdfs</code></h3><pre><code class="prettyprint">cd /opt/software/fastdfs
tar -zxvf fastdfs-6.07.tar.gz
cd fastdfs-6.07
./make.sh &amp;&amp; ./make.sh install
</code></pre>
<h3 id="创建文件和日志存储文件夹tracker和storage"><a href="#创建文件和日志存储文件夹tracker和storage" class="headerlink" title="创建文件和日志存储文件夹tracker和storage"></a>创建文件和日志存储文件夹<code>tracker</code>和<code>storage</code></h3><blockquote>
<p>FastDFS服务有三个⻆⾊:跟踪服务器(tracker server)、存储服务器(storage server)和客户端(client) </p>
</blockquote>
<h4 id="配置tracker"><a href="#配置tracker" class="headerlink" title="配置tracker"></a>配置<code>tracker</code></h4><pre><code class="prettyprint"># 创建tracker的存储日志和数据的根目录
mkdir -p /opt/software/fastdfs/tracker
# 修改tracker配置
cd /etc/fdfs
cp tracker.conf.sample tracker.conf
vim tracker.conf
</code></pre>
<p>修改<code>tracker.conf</code>配置</p>
<pre><code class="prettyprint"># is this config file disabled
# false for enabled
# true for disabled
# 使用默认
disabled = false
# the tracker server port
# 使用默认
port = 22122
# the base path to store data and log files
#配置前面新建的tracker根目录
base_path = /opt/software/fastdfs/tracker
</code></pre>
<h4 id="配置storage"><a href="#配置storage" class="headerlink" title="配置storage"></a>配置<code>storage</code></h4><pre><code class="prettyprint"># 创建tracker的存储日志和数据的根目录
mkdir -p /opt/software/fastdfs/storage
# 修改tracker配置
cd /etc/fdfs
cp storage.conf.sample storage.conf
vim storage.conf
</code></pre>
<p>修改<code>tracker.conf</code>配置</p>
<pre><code class="prettyprint"># 启⽤配置⽂件（默认为 false，表示启⽤配置⽂件）
disabled=false
# Storage 服务端⼝（默认为 23000）
port=23000
# 数据和⽇志⽂件存储根⽬录
base_path=/opt/software/fastdfs/storage
# 存储路径，访问时路径为 M00
# store_path1 则为 M01，以此递增到 M99（如果配置了多个存储⽬录的话，这⾥只指定 1 个）
store_path0=/opt/software/fastdfs/storage
# Tracker 服务器 IP 地址和端⼝，单机搭建时也不要写 127.0.0.1
# tracker_server 可以多次出现，如果有多个，则配置多个
tracker_server=192.168.101.123:22122
# 设置 HTTP 访问⽂件的端⼝。这个配置已经不⽤配置了，配置了也没什么⽤
# 这也是为何 Storage 服务器需要 Nginx 来提供 HTTP 访问的原因
http.server_port=8888
</code></pre>
<h4 id="启动tracker和storage"><a href="#启动tracker和storage" class="headerlink" title="启动tracker和storage"></a>启动<code>tracker</code>和<code>storage</code></h4><pre><code class="prettyprint"># 启动tracker 
# 其余命令 start、stop、restart、reload、status
/etc/init.d/fdfs_trackerd start
#启动storage 
# 其余命令 start、stop、restart、reload、status
/etc/init.d/fdfs_storaged start
# 查看状态
# ACTIVE表示成功
/usr/bin/fdfs_monitor /etc/fdfs/storage.conf
</code></pre>
<h4 id="测试文件上传client"><a href="#测试文件上传client" class="headerlink" title="测试文件上传client"></a>测试文件上传<code>client</code></h4><pre><code class="prettyprint"># 修改client配置文件
cp /etc/fdfs/client.conf.sample /etc/fdfs/client.conf
vim /etc/fdfs/client.conf
</code></pre>
<p>修改<code>client.conf</code>中base_path和tracker的ip:port</p>
<pre><code class="prettyprint"># the base path to store log files
base_path = /opt/software/fastdfs/tracker

# tracker_server can ocur more than once for multi tracker servers.
tracker_server = 192.168.101.123:22122
</code></pre>
<ul>
<li>测试文件上传</li>
</ul>
<pre><code class="prettyprint"># /root/soft.txt 测试的文件
/usr/bin/fdfs_upload_file /etc/fdfs/client.conf /root/soft.txt
</code></pre>
<p>返回文件ID：<code>group1/M00/00/00/wKhle2KsilWACukrAAAAW5T75rI594.txt</code>表示上传成功</p>
<p>文件查看：<code>cd /opt/software/fastdfs/storage/data/00/00/</code></p>
<ul>
<li>测试下载</li>
</ul>
<pre><code class="prettyprint">/usr/bin/fdfs_download_file /etc/fdfs/client.conf group1/M00/00/00/wKhle2KsilWACukrAAAAW5T75rI594.txt
</code></pre>
<ul>
<li>测试删除</li>
</ul>
<pre><code class="prettyprint">/usr/bin/fdfs_delete_file /etc/fdfs/client.conf group1/M00/00/00/wKhle2KsilWACukrAAAAW5T75rI594.txt
</code></pre>
<h3 id="安装fastdfs-nginx-module"><a href="#安装fastdfs-nginx-module" class="headerlink" title="安装fastdfs-nginx-module"></a>安装<code>fastdfs-nginx-module</code></h3><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><pre><code class="prettyprint">cd /opt/software/fastdfs
tar -zxvf fastdfs-nginx-module-1.22.tar.gz
cd fastdfs-nginx-module-1.22/src
pwd
#/opt/software/fastdfs/fastdfs-nginx-module-1.22/src
</code></pre>
<h4 id="安装编译nginx"><a href="#安装编译nginx" class="headerlink" title="安装编译nginx"></a>安装编译nginx</h4><pre><code class="prettyprint">cd /opt/software/fastdfs
tar -zxvf nginx-1.20.2.tar.gz
cd nginx-1.20.2
#将fastdfs-nginx-module-1.22/src添加
./configure --add-module=/opt/software/fastdfs/fastdfs-nginx-module-1.22/src
</code></pre>
<blockquote>
<p>生产objs&#x2F;Makefile 表示编译成功</p>
</blockquote>
<h4 id="给objs-Makefile文件增加头文件目录"><a href="#给objs-Makefile文件增加头文件目录" class="headerlink" title="给objs/Makefile文件增加头文件目录"></a>给<code>objs/Makefile</code>文件增加头文件目录</h4><pre><code class="prettyprint"># 增加以下两行配置
# -I /usr/include/fastdfs \
# -I /usr/include/fastcommon \
ALL_INCS = -I src/core \
    -I /usr/include/fastdfs \
    -I /usr/include/fastcommon \
    -I src/event \
    -I src/event/modules \
    -I src/os/unix \
    -I objs \
    -I src/http \
    -I src/http/modules \
    -I /usr/local/include
</code></pre>
<h4 id="编译及安装nginx"><a href="#编译及安装nginx" class="headerlink" title="编译及安装nginx"></a>编译及安装nginx</h4><pre><code class="prettyprint">cd /opt/software/fastdfs/nginx-1.20.2
make
make install
</code></pre>
<h4 id="配置fastdfs-nginx-module"><a href="#配置fastdfs-nginx-module" class="headerlink" title="配置fastdfs-nginx-module"></a>配置<code>fastdfs-nginx-module</code></h4><ul>
<li>拷贝配置文件到<code>/etc/fdfs</code>目录下</li>
</ul>
<pre><code class="prettyprint">cd /opt/software/fastdfs/fastdfs-nginx-module-1.22/src
# 查看目录下文件
ls
# common.c  common.h  config  mod_fastdfs.conf  ngx_http_fastdfs_module.c
</code></pre>
<ul>
<li>拷贝配置</li>
</ul>
<pre><code class="prettyprint">cp /opt/software/fastdfs/fastdfs-nginx-module-1.22/src/mod_fastdfs.conf /etc/fdfs/
cp /opt/software/fastdfs/fastdfs-6.07/conf/http.conf /etc/fdfs/
cp /opt/software/fastdfs/fastdfs-6.07/conf/mime.types /etc/fdfs/
</code></pre>
<ul>
<li>修改<code>/etc/fdfs/mod_fastdfs.conf</code></li>
</ul>
<pre><code class="prettyprint"># Tracker 服务器IP和端⼝修改
tracker_server=192.168.101.123:22122
# url 中是否包含 group 名称，改为 true，包含 group
url_have_group_name = true
# 配置 Storage 信息，修改 store_path0 的信息
store_path0=/opt/software/fastdfs/storage
# 其它的⼀般默认即可，例如
base_path=/tmp
group_name=group1
storage_server_port=23000
store_path_count=1
</code></pre>
<h4 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置<code>nginx</code></h4><p>修改配置文件 <code>vim /usr/local/nginx/conf/nginx.conf</code></p>
<pre><code class="prettyprint">
#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events &#123;
    worker_connections  1024;
&#125;


http &#123;
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    server &#123;
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / &#123;
            root   html;
            index  index.html index.htm;
        &#125;
        
        # 增加配置正则匹配
        location ~/group([0-9])/M([0-9])([0-9]) &#123;
            ngx_fastdfs_module;
        &#125;

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html &#123;
            root   html;
        &#125;

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ &#123;
        #    proxy_pass   http://127.0.0.1;
        #&#125;

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ &#123;
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #&#125;

        # deny access to .htaccess files, if Apache&#39;s document root
        # concurs with nginx&#39;s one
        #
        #location ~ /\.ht &#123;
        #    deny  all;
        #&#125;
    &#125;


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server &#123;
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / &#123;
    #        root   html;
    #        index  index.html index.htm;
    #    &#125;
    #&#125;


    # HTTPS server
    #
    #server &#123;
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / &#123;
    #        root   html;
    #        index  index.html index.htm;
    #    &#125;
    #&#125;

&#125;
</code></pre>
<p>启动<code>nginx</code></p>
<blockquote>
<p>第一次启动 <code>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</code></p>
<p>重启 <code>/usr/local/nginx/sbin/nginx -s reload</code></p>
</blockquote>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><a href="http://192.168.101.123/group1/M00/00/00/wKhle2KsilWACukrAAAAW5T75rI594.txt">192.168.101.123&#x2F;group1&#x2F;M00&#x2F;00&#x2F;00&#x2F;wKhle2KsilWACukrAAAAW5T75rI594.txt</a></p>
<img src="/2022/06/17/fastdfs-an-zhuang/image-20220617231602933.png" class="asset-class" title="image-20220617231602933">

<blockquote>
<p>代码测试路径<a href="https://gitee.com/RocPengHua/springboot-integrate.git">https://gitee.com/RocPengHua/springboot-integrate.git</a></p>
</blockquote>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>fastdfs</tag>
        <tag>文件存储</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法-集合覆盖</title>
    <url>/2022/06/17/tan-xin-suan-fa-ji-he-fu-gai/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><blockquote>
<p> 贪心算法是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法</p>
<p>贪心算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</p>
</blockquote>
<h4 id="集合覆盖"><a href="#集合覆盖" class="headerlink" title="集合覆盖"></a>集合覆盖</h4><ul>
<li>目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合</li>
<li>遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系）</li>
<li>将这个电台加入到一个集合中(比如 ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉</li>
<li>重复第 1 步直到覆盖了全部的地区</li>
</ul>
<pre><code class="prettyprint">public class GreedyAlgorithm &#123;

    public static void main(String[] args) &#123;
        //创建广播电台,放入到Map
        HashMap&lt;String,HashSet&lt;String&gt;&gt; broadcasts = new HashMap&lt;String, HashSet&lt;String&gt;&gt;();
        //将各个电台放入到broadcasts
        HashSet&lt;String&gt; hashSet1 = new HashSet&lt;String&gt;();
        hashSet1.add(&quot;北京&quot;);
        hashSet1.add(&quot;上海&quot;);
        hashSet1.add(&quot;天津&quot;);
        
        HashSet&lt;String&gt; hashSet2 = new HashSet&lt;String&gt;();
        hashSet2.add(&quot;广州&quot;);
        hashSet2.add(&quot;北京&quot;);
        hashSet2.add(&quot;深圳&quot;);
        
        HashSet&lt;String&gt; hashSet3 = new HashSet&lt;String&gt;();
        hashSet3.add(&quot;成都&quot;);
        hashSet3.add(&quot;上海&quot;);
        hashSet3.add(&quot;杭州&quot;);
        
        
        HashSet&lt;String&gt; hashSet4 = new HashSet&lt;String&gt;();
        hashSet4.add(&quot;上海&quot;);
        hashSet4.add(&quot;天津&quot;);
        
        HashSet&lt;String&gt; hashSet5 = new HashSet&lt;String&gt;();
        hashSet5.add(&quot;杭州&quot;);
        hashSet5.add(&quot;大连&quot;);
    
        //加入到map
        broadcasts.put(&quot;K1&quot;, hashSet1);
        broadcasts.put(&quot;K2&quot;, hashSet2);
        broadcasts.put(&quot;K3&quot;, hashSet3);
        broadcasts.put(&quot;K4&quot;, hashSet4);
        broadcasts.put(&quot;K5&quot;, hashSet5);
        
        //allAreas 存放所有的地区
        HashSet&lt;String&gt; allAreas = new HashSet&lt;String&gt;();
        allAreas.add(&quot;北京&quot;);
        allAreas.add(&quot;上海&quot;);
        allAreas.add(&quot;天津&quot;);
        allAreas.add(&quot;广州&quot;);
        allAreas.add(&quot;深圳&quot;);
        allAreas.add(&quot;成都&quot;);
        allAreas.add(&quot;杭州&quot;);
        allAreas.add(&quot;大连&quot;);
        
        //创建ArrayList, 存放选择的电台集合
        ArrayList&lt;String&gt; selects = new ArrayList&lt;String&gt;();
        
        //定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集
        HashSet&lt;String&gt; tempSet = new HashSet&lt;String&gt;();
        
        //定义给maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key
        //如果maxKey 不为null , 则会加入到 selects
        String maxKey = null;
        while(allAreas.size() != 0) &#123; // 如果allAreas 不为0, 则表示还没有覆盖到所有的地区
            //每进行一次while,需要
            maxKey = null;
            
            //遍历 broadcasts, 取出对应key
            for(String key : broadcasts.keySet()) &#123;
                //每进行一次for
                tempSet.clear();
                //当前这个key能够覆盖的地区
                HashSet&lt;String&gt; areas = broadcasts.get(key);
                tempSet.addAll(areas);
                //求出tempSet 和   allAreas 集合的交集, 交集会赋给 tempSet
                tempSet.retainAll(allAreas);
                //如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多
                //就需要重置maxKey
                // tempSet.size() &gt;broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的
                if(tempSet.size() &gt; 0 &amp;&amp; 
                        (maxKey == null || tempSet.size() &gt;broadcasts.get(maxKey).size()))&#123;
                    maxKey = key;
                &#125;
            &#125;
            //maxKey != null, 就应该将maxKey 加入selects
            if(maxKey != null) &#123;
                selects.add(maxKey);
                //将maxKey指向的广播电台覆盖的地区，从 allAreas 去掉
                allAreas.removeAll(broadcasts.get(maxKey));
            &#125;
            
        &#125;
        System.out.println(&quot;得到的选择结果是&quot; + selects);//[K1,K2,K3,K5]
        
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划-背包问题</title>
    <url>/2022/06/16/dong-tai-gui-hua-bei-bao-wen-ti/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul>
<li>动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</li>
<li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li>
<li>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 </li>
<li>动态规划可以通过填表的方式来逐步推进，得到最优解</li>
</ul>
<h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><ul>
<li><code>v[i][0]=v[0][j]=0;</code> &#x2F;&#x2F;表示 填入表 第一行和第一列是 0</li>
<li>当 <code>w[i]&gt; j</code> 时：<code>v[i][j]=v[i-1][j]</code> , 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个<br>单元格的装入策略</li>
<li>当 <code>j&gt;=w[i]</code>时： <code>v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125;</code> 当准备加入的新增的商品的容量小于等于当前背包的容量<ul>
<li><code>v[i-1][j]</code>： 就是上一个单元格的装入的最大值</li>
<li><code>v[i] </code>: 表示当前商品的价值</li>
<li><code>v[i-1][j-w[i]] </code>： 装入 i-1 商品，到剩余空间 j-w[i]的最大值</li>
<li>当<code> j&gt;=w[i]</code>时： <code>v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125; </code>:</li>
</ul>
</li>
</ul>
<pre><code class="prettyprint">public class KnapsackProblem &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub
        int[] w = &#123;1, 4, 3&#125;;//物品的重量
        int[] val = &#123;1500, 3000, 2000&#125;; //物品的价值 这里val[i] 就是前面讲的v[i]
        int m = 4; //背包的容量
        int n = val.length; //物品的个数
        
        //创建二维数组，
        //v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值
        int[][] v = new int[n+1][m+1];
        //为了记录放入商品的情况，我们定一个二维数组
        int[][] path = new int[n+1][m+1];
        
        //初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0
        for(int i = 0; i &lt; v.length; i++) &#123;
            v[i][0] = 0; //将第一列设置为0
        &#125;
        for(int i=0; i &lt; v[0].length; i++) &#123;
            v[0][i] = 0; //将第一行设置0
        &#125;
        
        
        //根据前面得到公式来动态规划处理
        for(int i = 1; i &lt; v.length; i++) &#123; //不处理第一行 i是从1开始的
            for(int j=1; j &lt; v[0].length; j++) &#123;//不处理第一列, j是从1开始的
                //公式
                if(w[i-1]&gt; j) &#123; // 因为我们程序i 是从1开始的，因此原来公式中的 w[i] 修改成 w[i-1]
                    v[i][j]=v[i-1][j];
                &#125; else &#123;
                    //说明:
                    //因为我们的i 从1开始的， 因此公式需要调整成
                    //v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);
                    //v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);
                    //为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else来体现公式
                    if(v[i - 1][j] &lt; val[i - 1] + v[i - 1][j - w[i - 1]]) &#123;
                        v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];
                        //把当前的情况记录到path
                        path[i][j] = 1;
                    &#125; else &#123;
                        v[i][j] = v[i - 1][j];
                    &#125;
                    
                &#125;
            &#125;
        &#125;
        
        //输出一下v 看看目前的情况
        for(int i =0; i &lt; v.length;i++) &#123;
            for(int j = 0; j &lt; v[i].length;j++) &#123;
                System.out.print(v[i][j] + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;
        
        System.out.println(&quot;============================&quot;);
        //输出最后我们是放入的哪些商品
        //遍历path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入
        for(int i = 0; i &lt; path.length; i++) &#123;
            for(int j=0; j &lt; path[i].length; j++) &#123;
                System.out.print(path[i][j] + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;
        
        //动脑筋
        int i = path.length - 1; //行的最大下标
        int j = path[0].length - 1;  //列的最大下标
        while(i &gt; 0 &amp;&amp; j &gt; 0 ) &#123; //从path的最后开始找
            if(path[i][j] == 1) &#123;
                System.out.printf(&quot;第%d个商品放入到背包\n&quot;, i); 
                j -= w[i-1]; //w[i-1]
            &#125;
            i--;
        &#125;
        
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>minio8.3.3启动报错</title>
    <url>/2022/06/18/minio8-3-3-qi-dong-bao-cuo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="报错日志"><a href="#报错日志" class="headerlink" title="报错日志"></a>报错日志</h4><pre><code class="prettyprint">Error starting ApplicationContext. To display the conditions report re-run your application with &#39;debug&#39; enabled.
2022-06-18 19:32:30.757 ERROR 14472 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : 

***************************
APPLICATION FAILED TO START
***************************

Description:

An attempt was made to call a method that does not exist. The attempt was made from the following location:

    io.minio.S3Base.&lt;clinit&gt;(S3Base.java:98)

The following method did not exist:

    okhttp3.RequestBody.create([BLokhttp3/MediaType;)Lokhttp3/RequestBody;

The method&#39;s class, okhttp3.RequestBody, is available from the following locations:

    jar:file:/E:/maven/maven_resp/com/squareup/okhttp3/okhttp/3.14.9/okhttp-3.14.9.jar!/okhttp3/RequestBody.class

The class hierarchy was loaded from the following locations:

    okhttp3.RequestBody: file:/E:/maven/maven_resp/com/squareup/okhttp3/okhttp/3.14.9/okhttp-3.14.9.jar


Action:

Correct the classpath of your application so that it contains a single, compatible version of okhttp3.RequestBody
</code></pre>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><blockquote>
<p>minio8.3.x版本内置okhttp3版本太低，部分代码缺失</p>
<p>修改pom.xml</p>
</blockquote>
<pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;io.minio&lt;/groupId&gt;
    &lt;artifactId&gt;minio&lt;/artifactId&gt;
    &lt;version&gt;8.3.3&lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;
            &lt;artifactId&gt;okhttp&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;
    &lt;artifactId&gt;okhttp&lt;/artifactId&gt;
    &lt;version&gt;4.8.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>minio</tag>
      </tags>
  </entry>
  <entry>
    <title>普里姆算法-修路问题</title>
    <url>/2022/06/18/pu-li-mu-suan-fa-xiu-lu-wen-ti/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="普里姆介绍"><a href="#普里姆介绍" class="headerlink" title="普里姆介绍"></a>普里姆介绍</h4><blockquote>
<p>普利姆(Prim)算法求最小生成树，也就是在包含 n 个顶点的连通图中，找出只有(n-1)条边包含所有 n 个顶点的连通子图，也就是所谓的极小连通子图</p>
</blockquote>
<ul>
<li>设 G&#x3D;(V,E)是连通网，T&#x3D;(U,D)是最小生成树，V,U 是顶点集合，E,D 是边的集合</li>
<li>若从顶点 u 开始构造最小生成树，则从集合 V 中取出顶点 u 放入集合 U 中，标记顶点 v 的 visited[u]&#x3D;1</li>
<li>若集合 U 中顶点 ui 与集合 V-U 中的顶点 vj 之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点 vj 加入集合 U 中，将边（ui,vj）加入集合 D 中，标记 visited[vj]&#x3D;1</li>
<li>重复步骤②，直到 U 与 V 相等，即所有顶点都被标记为访问过，此时 D 中有 n-1 条边</li>
</ul>
<h4 id="村庄修路"><a href="#村庄修路" class="headerlink" title="村庄修路"></a>村庄修路</h4><img src="/2022/06/18/pu-li-mu-suan-fa-xiu-lu-wen-ti/image-20220619112312344.png" class="asset-class" title="image-20220619112312344">

<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="prettyprint">public class PrimAlgorithm &#123;

    public static void main(String[] args) &#123;
        //测试看看图是否创建ok
        char[] data = new char[]&#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;&#125;;
        int verxs = data.length;
        //邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不联通
        int[][] weight = new int[][]&#123;
                &#123;10000, 5, 7, 10000, 10000, 10000, 2&#125;,
                &#123;5, 10000, 10000, 9, 10000, 10000, 3&#125;,
                &#123;7, 10000, 10000, 10000, 8, 10000, 10000&#125;,
                &#123;10000, 9, 10000, 10000, 10000, 4, 10000&#125;,
                &#123;10000, 10000, 8, 10000, 10000, 5, 4&#125;,
                &#123;10000, 10000, 10000, 4, 5, 10000, 6&#125;,
                &#123;2, 3, 10000, 10000, 4, 6, 10000&#125;,&#125;;

        //创建MGraph对象
        MGraph graph = new MGraph(verxs);
        //创建一个MinTree对象
        MinTree minTree = new MinTree();
        minTree.createGraph(graph, data, weight);
        //输出
        minTree.showGraph(graph);
        //测试普利姆算法
        minTree.prim(graph, 0);
    &#125;

&#125;

/**
 * 创建最小生成树-&gt;村庄的图
 */
class MinTree &#123;

    /**
     * @param graph  图对象
     * @param data   图的各个顶点的值
     * @param weight 图的邻接矩阵
     */
    public void createGraph(MGraph graph, char[] data, int[][] weight) &#123;
        graph.data = data;
        graph.weight = weight;
    &#125;

    /**
     *  显示图的邻接矩阵
     */
    public void showGraph(MGraph graph) &#123;
        for (int[] link : graph.weight) &#123;
            System.out.println(Arrays.toString(link));
        &#125;
    &#125;

    /**
     * @param graph 图
     * @param v     表示从图的第几个顶点开始生成&#39;A&#39;-&gt;0 &#39;B&#39;-&gt;1...
     */
    public void prim(MGraph graph, int v) &#123;
        //已访问
        List&lt;Integer&gt; v1 = new ArrayList&lt;&gt;();
        v1.add(v);
        //未访问
        List&lt;Integer&gt; v2 = IntStream.rangeClosed(0, 6).filter(item -&gt; item != v).boxed().collect(Collectors.toList());
        v2.remove((Integer)v);



        //h1 和 h2 记录两个顶点的下标
        int h1 = -1;
        int h2 = -1;
        //将 minWeight 初始成一个大数，后面在遍历过程中，会被替换
        int minWeight = 10000;
        //因为有 graph.verxs顶点，普利姆算法结束后，有 graph.verxs-1边
        for (int k = 1; k &lt; graph.verxs; k++) &#123;

            //这个是确定每一次生成的子图 ，和哪个结点的距离最近
            for (int i = 0; i &lt; v1.size(); i++) &#123;
                for (int j = 0; j &lt; v2.size(); j++) &#123;
                    if (graph.weight[v1.get(i)][v2.get(j)] &lt; minWeight) &#123;
                        //替换minWeight(寻找已经访问过的结点和未访问过的结点间的权值最小的边)
                        minWeight = graph.weight[v1.get(i)][v2.get(j)];
                        h1 = v1.get(i);
                        h2 = v2.get(j);
                    &#125;
                &#125;
            &#125;
            //找到一条边是最小
            System.out.println(&quot;边&lt;&quot; + graph.data[h1] + &quot;,&quot; + graph.data[h2] + &quot;&gt; 权值:&quot; + minWeight);

            //增加到已访问
            v1.add(h2);
            //从为访问删除
            v2.remove((Integer) h2);
            //minWeight 重新设置为最大值 10000
            minWeight = 10000;
        &#125;

    &#125;
&#125;

class MGraph &#123;
    /**
     * 表示图的节点个数
     */
    int verxs;
    /**
     * 存放结点数据
     */
    char[] data;
    /**
     * 存放边，就是我们的邻接矩阵
     */
    int[][] weight;

    public MGraph(int verxs) &#123;
        this.verxs = verxs;
        data = new char[verxs];
        weight = new int[verxs][verxs];
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>minio安装</title>
    <url>/2022/06/18/minio-an-zhuang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h4><p><a href="https://dl.minio.io/server/minio/release/linux-amd64/minio">https://dl.minio.io/server/minio/release/linux-amd64/minio</a></p>
<p>官网：<a href="https://min.io/">https://min.io/</a></p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><h5 id="目录创建"><a href="#目录创建" class="headerlink" title="目录创建"></a>目录创建</h5><pre><code class="prettyprint">mkdir -p /opt/software/minio
# 上传minio到该目录下
cd /opt/software/minio
# minio赋权
chmod +x minio
# 创建数据存放目录
mkdir data
</code></pre>
<h5 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h5><p><code>vim /etc/default/minio</code></p>
<pre><code class="prettyprint"># 账号
MINIO_ROOT_USER=&quot;minioadmin&quot;
# 密码
MINIO_ROOT_PASSWORD=&quot;minioadmin&quot;
# 数据存放
MINIO_VOLUMES=&quot;/opt/software/minio/data&quot;
# 暴露端口
MINIO_OPTS=&quot;--address 0.0.0.0:9000&quot;
# web页面端口
MINIO_OPTS1=&quot;--console-address 0.0.0.0:19001&quot;
</code></pre>
<h5 id="设置systemctl配置"><a href="#设置systemctl配置" class="headerlink" title="设置systemctl配置"></a>设置<code>systemctl</code>配置</h5><p><code>vim /etc/systemd/system/minio.service</code></p>
<pre><code class="prettyprint">[Unit]
Description=MinIO
Documentation=https://docs.min.io
Wants=network-online.target
After=network-online.target
AssertFileIsExecutable=/opt/software/minio/minio

[Service]
WorkingDirectory=/opt/software/minio
ProtectProc=invisible

EnvironmentFile=/etc/default/minio
ExecStartPre=/bin/bash -c &quot;if [ -z \&quot;$&#123;MINIO_VOLUMES&#125;\&quot; ]; then echo \&quot;Variable MINIO_VOLUMES not set in /etc/default/minio\&quot;; exit 1; fi&quot;
ExecStart=/opt/software/minio/minio server --address 0.0.0.0:9000 $MINIO_OPTS  $MINIO_OPTS1 $MINIO_VOLUMES

# Let systemd restart this service always
Restart=always

# Specifies the maximum file descriptor number that can be opened by this process
LimitNOFILE=65536

# Specifies the maximum number of threads this process can create
TasksMax=infinity

# Disable timeout logic and wait until process is stopped
TimeoutStopSec=infinity
SendSIGKILL=no

[Install]
WantedBy=multi-user.target
</code></pre>
<h4 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h4><pre><code class="prettyprint"># 重新加载 systemctl配置
systemctl daemon-reload
# 启动minio
systemctl start minio.service
# 开机自启
systemctl enable minio.service
</code></pre>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><ul>
<li><p>访问服务器路径<code>192.168.101.123：19001</code></p>
</li>
<li><p>输入前面配置的账号密码</p>
<img src="/2022/06/18/minio-an-zhuang/image-20220618170516484.png" class="asset-class" title="image-20220618170516484"></li>
</ul>
<h5 id="其他systemctl命令"><a href="#其他systemctl命令" class="headerlink" title="其他systemctl命令"></a>其他<code>systemctl</code>命令</h5><pre><code class="prettyprint">systemctl start minio.service   #启动minio服务
systemctl stop minio.service   #停止minio服务
systemctl restart minio.service   #重新启动服务
systemctl status minio.service   #查看服务当前状态
systemctl enable minio.service   #设置开机自启动
systemctl disable minio.service   #停止开机自启动
</code></pre>
<h4 id="直接启动"><a href="#直接启动" class="headerlink" title="直接启动"></a>直接启动</h4><pre><code class="prettyprint">MINIO_ROOT_USER=admin MINIO_ROOT_PASSWORD=password ./minio server /opt/software/minio/data --console-address &quot;:9001&quot;
</code></pre>
<blockquote>
<p>代码测试路径<a href="https://gitee.com/RocPengHua/springboot-integrate.git">https://gitee.com/RocPengHua/springboot-integrate.git</a></p>
</blockquote>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>文件存储</tag>
        <tag>minio</tag>
      </tags>
  </entry>
  <entry>
    <title>分治算法-汉诺塔</title>
    <url>/2022/06/16/fen-zhi-suan-fa-han-nuo-ta/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h4><blockquote>
<p>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题</p>
<p>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p>
<p>合并：将各个子问题的解合并为原问题的解。</p>
</blockquote>
<h4 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h4><ul>
<li>如果是有一个盘， A-&gt;C，如果我们有 n &gt;&#x3D; 2 情况，我们总是可以看做是两个盘 <ul>
<li>最下边的盘 </li>
<li>上面的盘</li>
</ul>
</li>
<li>先把 最上面的盘 A-&gt;B</li>
<li>把最下边的盘 A-&gt;C</li>
<li>把 B 塔的所有盘 从 B-&gt;C</li>
</ul>
<pre><code class="prettyprint">public class Hanoitower &#123;
    private static Integer times = 0;
    public static void main(String[] args) &#123;
        hanoiTower(5, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;);
    &#125;
    //汉诺塔的移动的方法
    //使用分治算法
    public static void hanoiTower(int num, char a, char b, char c) &#123;
        //如果只有一个盘
        if(num == 1) &#123;
            System.out.println(++times +&quot;----第1个盘从 &quot; + a + &quot;-&gt;&quot; + c);
        &#125; else &#123;
            //如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘
            //1. 先把 最上面的所有盘 A-&gt;B， 移动过程会使用到 c
            hanoiTower(num - 1, a, c, b);
            //2. 把最下边的盘 A-&gt;C
            System.out.println(++times + &quot;---第&quot; + num + &quot;个盘从 &quot; + a + &quot;-&gt;&quot; + c);
            //3. 把B塔的所有盘 从 B-&gt;C , 移动过程使用到 a塔  
            hanoiTower(num - 1, b, a, c);
            
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>克鲁斯卡尔-公交站问题</title>
    <url>/2022/06/19/ke-lu-si-qia-er-gong-jiao-zhan-wen-ti/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h4><blockquote>
<p>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法</p>
<p>基本思想：按照权值从小到大的顺序选择 n-1 条边，并保证这 n-1 条边不构成回路</p>
<p>具体做法：首先构造一个只含 n 个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止</p>
</blockquote>
<h4 id="公交站问题"><a href="#公交站问题" class="headerlink" title="公交站问题"></a>公交站问题</h4><img src="/2022/06/19/ke-lu-si-qia-er-gong-jiao-zhan-wen-ti/image-20220619111710523.png" class="asset-class" title="image-20220619111710523">

<img src="/2022/06/19/ke-lu-si-qia-er-gong-jiao-zhan-wen-ti/image-20220619111637614.png" class="asset-class" title="image-20220619111637614">

<ul>
<li><p>第 1 步：将边&lt;E,F&gt;加入 R 中。</p>
<ul>
<li>边&lt;E,F&gt;的权值最小，因此将它加入到最小生成树结果 R 中。</li>
</ul>
</li>
<li><p>第 2 步：将边&lt;C,D&gt;加入 R 中。</p>
<ul>
<li>上一步操作之后，边&lt;C,D&gt;的权值最小，因此将它加入到最小生成树结果 R 中。</li>
</ul>
</li>
<li><p>第 3 步：将边&lt;D,E&gt;加入 R 中。</p>
<ul>
<li>上一步操作之后，边&lt;D,E&gt;的权值最小，因此将它加入到最小生成树结果 R 中。</li>
</ul>
</li>
<li><p>第 4 步：将边&lt;B,F&gt;加入 R 中。</p>
<ul>
<li>上一步操作之后，边&lt;C,E&gt;的权值最小，但&lt;C,E&gt;会和已有的边构成回路；因此，跳过边&lt;C,E&gt;。同理，跳<br>过边&lt;C,F&gt;。将边&lt;B,F&gt;加入到最小生成树结果 R 中。</li>
</ul>
</li>
<li><p>第 5 步：将边&lt;E,G&gt;加入 R 中。</p>
<ul>
<li>上一步操作之后，边&lt;E,G&gt;的权值最小，因此将它加入到最小生成树结果 R 中。</li>
</ul>
</li>
<li><p>第 6 步：将边&lt;A,B&gt;加入 R 中。</p>
<ul>
<li>上一步操作之后，边&lt;F,G&gt;的权值最小，但&lt;F,G&gt;会和已有的边构成回路；因此，跳过边&lt;F,G&gt;。同理，跳<br>过边&lt;B,C&gt;。将边&lt;A,B&gt;加入到最小生成树结果 R 中。</li>
</ul>
</li>
<li><p>此时，最小生成树构造完成！它包括的边依次是：&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;</p>
</li>
</ul>
<blockquote>
<p>关于终点说明</p>
<p>就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是”与它连通的最大顶点”</p>
<p>因此，接下来，虽然&lt;C,E&gt;是权值最小的边。但是 C 和 E 的终点都是 F，即它们的终点相同，因此，将&lt;C,E&gt;<br>加入最小生成树的话，会形成回路。这就是判断回路的方式。也就是说，我们加入的边的两个顶点不能都指向同一个终点，否则将构成回路</p>
</blockquote>
<h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="prettyprint">public class KruskalCase &#123;

    private int edgeNum; //边的个数
    private char[] vertexs; //顶点数组
    private int[][] matrix; //邻接矩阵
    //使用 INF 表示两个顶点不能连通
    private static final int INF = Integer.MAX_VALUE;
    
    public static void main(String[] args) &#123;
        char[] vertexs = &#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;&#125;;
        //克鲁斯卡尔算法的邻接矩阵  
          int matrix[][] = &#123;
          /*A*//*B*//*C*//*D*//*E*//*F*//*G*/
    /*A*/ &#123;   0,  12, INF, INF, INF,  16,  14&#125;,
    /*B*/ &#123;  12,   0,  10, INF, INF,   7, INF&#125;,
    /*C*/ &#123; INF,  10,   0,   3,   5,   6, INF&#125;,
    /*D*/ &#123; INF, INF,   3,   0,   4, INF, INF&#125;,
    /*E*/ &#123; INF, INF,   5,   4,   0,   2,   8&#125;,
    /*F*/ &#123;  16,   7,   6, INF,   2,   0,   9&#125;,
    /*G*/ &#123;  14, INF, INF, INF,   8,   9,   0&#125;&#125;; 
          //大家可以在去测试其它的邻接矩阵，结果都可以得到最小生成树.
          
          //创建KruskalCase 对象实例
          KruskalCase kruskalCase = new KruskalCase(vertexs, matrix);
          //输出构建的
          kruskalCase.print();
          kruskalCase.kruskal();
          
    &#125;
    
    //构造器
    public KruskalCase(char[] vertexs, int[][] matrix) &#123;
        //初始化顶点数和边的个数
        int vlen = vertexs.length;
        
        //初始化顶点, 复制拷贝的方式
        this.vertexs = new char[vlen];
        for(int i = 0; i &lt; vertexs.length; i++) &#123;
            this.vertexs[i] = vertexs[i];
        &#125;
        
        //初始化边, 使用的是复制拷贝的方式
        this.matrix = new int[vlen][vlen];
        for(int i = 0; i &lt; vlen; i++) &#123;
            for(int j= 0; j &lt; vlen; j++) &#123;
                this.matrix[i][j] = matrix[i][j];
            &#125;
        &#125;
        //统计边的条数
        for(int i =0; i &lt; vlen; i++) &#123;
            for(int j = i+1; j &lt; vlen; j++) &#123;
                if(this.matrix[i][j] != INF) &#123;
                    edgeNum++;
                &#125;
            &#125;
        &#125;
        
    &#125;
    public void kruskal() &#123;
        int index = 0; //表示最后结果数组的索引
        int[] ends = new int[edgeNum]; //用于保存&quot;已有最小生成树&quot; 中的每个顶点在最小生成树中的终点
        //创建结果数组, 保存最后的最小生成树
        EData[] rets = new EData[edgeNum];
        
        //获取图中 所有的边的集合 ， 一共有12边
        EData[] edges = getEdges();
        System.out.println(&quot;图的边的集合=&quot; + Arrays.toString(edges) + &quot; 共&quot;+ edges.length); //12
        
        //按照边的权值大小进行排序(从小到大)
        sortEdges(edges);
        
        //遍历edges 数组，将边添加到最小生成树中时，判断是准备加入的边否形成了回路，如果没有，就加入 rets, 否则不能加入
        for(int i=0; i &lt; edgeNum; i++) &#123;
            //获取到第i条边的第一个顶点(起点)
            int p1 = getPosition(edges[i].start); //p1=4
            //获取到第i条边的第2个顶点
            int p2 = getPosition(edges[i].end); //p2 = 5
            
            //获取p1这个顶点在已有最小生成树中的终点
            int m = getEnd(ends, p1); //m = 4
            //获取p2这个顶点在已有最小生成树中的终点
            int n = getEnd(ends, p2); // n = 5
            //是否构成回路
            if(m != n) &#123; //没有构成回路
                ends[m] = n; // 设置m 在&quot;已有最小生成树&quot;中的终点 &lt;E,F&gt; [0,0,0,0,5,0,0,0,0,0,0,0]
                rets[index++] = edges[i]; //有一条边加入到rets数组
            &#125;
        &#125;
        //&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。
        //统计并打印 &quot;最小生成树&quot;, 输出  rets
        System.out.println(&quot;最小生成树为&quot;);
        for(int i = 0; i &lt; index; i++) &#123;
            System.out.println(rets[i]);
        &#125;
        
        
    &#125;
    
    //打印邻接矩阵
    public void print() &#123;
        System.out.println(&quot;邻接矩阵为: \n&quot;);
        for(int i = 0; i &lt; vertexs.length; i++) &#123;
            for(int j=0; j &lt; vertexs.length; j++) &#123;
                System.out.printf(&quot;%12d&quot;, matrix[i][j]);
            &#125;
            System.out.println();//换行
        &#125;
    &#125;

    /**
     * 功能：对边进行排序处理, 冒泡排序
     * @param edges 边的集合
     */
    private void sortEdges(EData[] edges) &#123;
        for(int i = 0; i &lt; edges.length - 1; i++) &#123;
            for(int j = 0; j &lt; edges.length - 1 - i; j++) &#123;
                if(edges[j].weight &gt; edges[j+1].weight) &#123;//交换
                    EData tmp = edges[j];
                    edges[j] = edges[j+1];
                    edges[j+1] = tmp;
                &#125;
            &#125;
         &#125;
    &#125;
    /**
     * 
     * @param ch 顶点的值，比如&#39;A&#39;,&#39;B&#39;
     * @return 返回ch顶点对应的下标，如果找不到，返回-1
     */
    private int getPosition(char ch) &#123;
        for(int i = 0; i &lt; vertexs.length; i++) &#123;
            if(vertexs[i] == ch) &#123;//找到
                return i;
            &#125;
        &#125;
        //找不到,返回-1
        return -1;
    &#125;
    /**
     * 功能: 获取图中边，放到EData[] 数组中，后面我们需要遍历该数组
     * 是通过matrix 邻接矩阵来获取
     * EData[] 形式 [[&#39;A&#39;,&#39;B&#39;, 12], [&#39;B&#39;,&#39;F&#39;,7], .....]
     * @return
     */
    private EData[] getEdges() &#123;
        int index = 0;
        EData[] edges = new EData[edgeNum];
        for(int i = 0; i &lt; vertexs.length; i++) &#123;
            for(int j=i+1; j &lt;vertexs.length; j++) &#123;
                if(matrix[i][j] != INF) &#123;
                    edges[index++] = new EData(vertexs[i], vertexs[j], matrix[i][j]);
                &#125;
            &#125;
        &#125;
        return edges;
    &#125;
    /**
     * 功能: 获取下标为i的顶点的终点(), 用于后面判断两个顶点的终点是否相同
     * @param ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成
     * @param i : 表示传入的顶点对应的下标
     * @return 返回的就是 下标为i的这个顶点对应的终点的下标, 一会回头还有来理解
     */
    private int getEnd(int[] ends, int i) &#123; // i = 4 [0,0,0,0,5,0,0,0,0,0,0,0]
        while(ends[i] != 0) &#123;
            i = ends[i];
        &#125;
        return i;
    &#125;
 
&#125;

//创建一个类EData ，它的对象实例就表示一条边
class EData &#123;
    char start; //边的一个点
    char end; //边的另外一个点
    int weight; //边的权值
    //构造器
    public EData(char start, char end, int weight) &#123;
        this.start = start;
        this.end = end;
        this.weight = weight;
    &#125;
    //重写toString, 便于输出边信息
    @Override
    public String toString() &#123;
        return &quot;EData [&lt;&quot; + start + &quot;, &quot; + end + &quot;&gt;= &quot; + weight + &quot;]&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯贪心-马踏棋盘</title>
    <url>/2022/06/19/hui-su-tan-xin-ma-ta-qi-pan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="马塔棋盘"><a href="#马塔棋盘" class="headerlink" title="马塔棋盘"></a>马塔棋盘</h4><blockquote>
<p>马踏棋盘问题(骑士周游问题)实际上是图的深度优先搜索(DFS)的应用</p>
<p>如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了 53 个点，如图：走到了第 53 个，坐标（1,0），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯…… </p>
<p>贪心算法优化（下个节点集合中下一个可以走的位置数量升序）</p>
</blockquote>
<h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p><strong>骑士周游问题的解决步骤和思路</strong></p>
<ul>
<li>创建棋盘 chessBoard , 是一个二维数组</li>
<li>将当前位置设置为已经访问，然后根据当前位置，计算马儿还能走哪些位置，并放入到一个集合中(ArrayList), 最多有8个位置， 每走一步，就使用step+1</li>
<li>遍历ArrayList中存放的所有位置，看看哪个可以走通 , 如果走通，就继续，走不通，就<strong>回溯</strong>.</li>
<li>判断马儿是否完成了任务，使用  step 和<strong>应该走的步数</strong>比较 ， 如果没有达到数量，则表示没有完成任务，将整个棋盘置0</li>
</ul>
<img src="/2022/06/19/hui-su-tan-xin-ma-ta-qi-pan/image-20220619202714971.png" class="asset-class" title="image-20220619202714971">

<p><strong>使用贪心算法对原来的算法优化</strong></p>
<ul>
<li>我们获取当前位置，可以走的下一个位置的集合</li>
<li>我们需要对ps 中所有的Point的下一步的所有集合的数目，进行非递减排序,就ok ,</li>
</ul>
<p>代码实现</p>
<pre><code class="prettyprint">public class HorseChessboard &#123;

    private static int X; // 棋盘的列数
    private static int Y; // 棋盘的行数
    //创建一个数组，标记棋盘的各个位置是否被访问过
    private static boolean visited[];
    //使用一个属性，标记是否棋盘的所有位置都被访问
    private static boolean finished; // 如果为true,表示成功
    
    public static void main(String[] args) &#123;
        System.out.println(&quot;骑士周游算法，开始运行~~&quot;);
        //测试骑士周游算法是否正确
        X = 8;
        Y = 8;
        int row = 1; //马儿初始位置的行，从1开始编号
        int column = 1; //马儿初始位置的列，从1开始编号
        //创建棋盘
        int[][] chessboard = new int[X][Y];
        visited = new boolean[X * Y];//初始值都是false
        //测试一下耗时
        long start = System.currentTimeMillis();
        traversalChessboard(chessboard, row - 1, column - 1, 1);
        long end = System.currentTimeMillis();
        System.out.println(&quot;共耗时: &quot; + (end - start) + &quot; 毫秒&quot;);
        
        //输出棋盘的最后情况
        for(int[] rows : chessboard) &#123;
            for(int step: rows) &#123;
                System.out.print(step + &quot;\t&quot;);
            &#125;
            System.out.println();
        &#125;
    &#125;
    
    /**
     * 完成骑士周游问题的算法
     * @param chessboard 棋盘
     * @param row 马儿当前的位置的行 从0开始 
     * @param column 马儿当前的位置的列  从0开始
     * @param step 是第几步 ,初始位置就是第1步 
     */
    public static void traversalChessboard(int[][] chessboard, int row, int column, int step) &#123;
        chessboard[row][column] = step;
        //row = 4 X = 8 column = 4 = 4 * 8 + 4 = 36
        visited[row * X + column] = true; //标记该位置已经访问
        //获取当前位置可以走的下一个位置的集合 
        ArrayList&lt;Point&gt; ps = next(new Point(column, row));
        //对ps进行排序,排序的规则就是对ps的所有的Point对象的下一步的位置的数目，进行非递减排序，为了先遍历数量少的
        sort(ps);
        //遍历 ps
        while(!ps.isEmpty()) &#123;
            Point p = ps.remove(0);//取出下一个可以走的位置
            //判断该点是否已经访问过
            if(!visited[p.y * X + p.x]) &#123;//说明还没有访问过
                traversalChessboard(chessboard, p.y, p.x, step + 1);
            &#125;
        &#125;
        //判断马儿是否完成了任务，使用   step 和应该走的步数比较 ， 
        //如果没有达到数量，则表示没有完成任务，将整个棋盘置0
        //说明: step &lt; X * Y  成立的情况有两种
        //1. 棋盘到目前位置,仍然没有走完
        //2. 棋盘处于一个回溯过程
        if(step &lt; X * Y &amp;&amp; !finished ) &#123;
            chessboard[row][column] = 0;
            visited[row * X + column] = false;
        &#125; else &#123;
            finished = true;
        &#125;
        
    &#125;
    
    /**
     * 功能： 根据当前位置(Point对象)，计算马儿还能走哪些位置(Point)，并放入到一个集合中(ArrayList), 最多有8个位置
     * @param curPoint x列  y行
     * @return
     */
    public static ArrayList&lt;Point&gt; next(Point curPoint) &#123;
        //创建一个ArrayList
        ArrayList&lt;Point&gt; ps = new ArrayList&lt;Point&gt;();
        //创建一个Point
        Point p1 = new Point();
        //表示马儿可以走5这个位置
        if((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y -1) &gt;= 0) &#123;
            ps.add(new Point(p1));
        &#125;
        //判断马儿可以走6这个位置
        if((p1.x = curPoint.x - 1) &gt;=0 &amp;&amp; (p1.y=curPoint.y-2)&gt;=0) &#123;
            ps.add(new Point(p1));
        &#125;
        //判断马儿可以走7这个位置
        if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y - 2) &gt;= 0) &#123;
            ps.add(new Point(p1));
        &#125;
        //判断马儿可以走0这个位置
        if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y - 1) &gt;= 0) &#123;
            ps.add(new Point(p1));
        &#125;
        //判断马儿可以走1这个位置
        if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) &#123;
            ps.add(new Point(p1));
        &#125;
        //判断马儿可以走2这个位置
        if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) &#123;
            ps.add(new Point(p1));
        &#125;
        //判断马儿可以走3这个位置
        if ((p1.x = curPoint.x - 1) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) &#123;
            ps.add(new Point(p1));
        &#125;
        //判断马儿可以走4这个位置
        if ((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) &#123;
            ps.add(new Point(p1));
        &#125;
        return ps;
    &#125;

    //根据当前这个一步的所有的下一步的选择位置，进行非递减排序, 减少回溯的次数
    public static void sort(ArrayList&lt;Point&gt; ps) &#123;
        ps.sort(new Comparator&lt;Point&gt;() &#123;

            @Override
            public int compare(Point o1, Point o2) &#123;
                //获取到o1的下一步的所有位置个数
                int count1 = next(o1).size();
                //获取到o2的下一步的所有位置个数
                int count2 = next(o2).size();
                if(count1 &lt; count2) &#123;
                    return -1;
                &#125; else if (count1 == count2) &#123;
                    return 0;
                &#125; else &#123;
                    return 1;
                &#125;
            &#125;
            
        &#125;);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>弗洛伊德-最短距离</title>
    <url>/2022/06/19/fu-luo-yi-de-zui-duan-ju-chi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="弗洛伊德算法介绍"><a href="#弗洛伊德算法介绍" class="headerlink" title="弗洛伊德算法介绍"></a>弗洛伊德算法介绍</h4><blockquote>
<p>和 Dijkstra 算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名</p>
<p>弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径</p>
<p>迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。</p>
<p>弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径</p>
</blockquote>
<h4 id="弗洛伊德算法图解分析"><a href="#弗洛伊德算法图解分析" class="headerlink" title="弗洛伊德算法图解分析"></a>弗洛伊德算法图解分析</h4><ul>
<li><p>设置顶点 vi 到顶点 vk 的最短路径已知为 Lik，顶点 vk 到 vj 的最短路径已知为 Lkj，顶点 vi 到 vj 的路径为 Lij，则 vi 到 vj 的最短路径为：min((Lik+Lkj),Lij)，vk 的取值为图中所有顶点，则可获得 vi 到 vj 的最短路径</p>
</li>
<li><p>至于 vi 到 vk 的最短路径 Lik 或者 vk 到 vj 的最短路径 Lkj，是以同样的方式获得</p>
</li>
</ul>
<img src="/2022/06/19/fu-luo-yi-de-zui-duan-ju-chi/image-20220619193409763.png" class="asset-class" title="image-20220619193409763">

<img src="/2022/06/19/fu-luo-yi-de-zui-duan-ju-chi/image-20220619193343714.png" class="asset-class" title="image-20220619193343714">

<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code class="prettyprint">public class FloydAlgorithm &#123;

    public static void main(String[] args) &#123;
        // 测试看看图是否创建成功
        char[] vertex = &#123; &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39; &#125;;
        //创建邻接矩阵
        int[][] matrix = new int[vertex.length][vertex.length];
        final int N = 65535;
        matrix[0] = new int[] &#123; 0, 5, 7, N, N, N, 2 &#125;;
        matrix[1] = new int[] &#123; 5, 0, N, 9, N, N, 3 &#125;;
        matrix[2] = new int[] &#123; 7, N, 0, N, 8, N, N &#125;;
        matrix[3] = new int[] &#123; N, 9, N, 0, N, 4, N &#125;;
        matrix[4] = new int[] &#123; N, N, 8, N, 0, 5, 4 &#125;;
        matrix[5] = new int[] &#123; N, N, N, 4, 5, 0, 6 &#125;;
        matrix[6] = new int[] &#123; 2, 3, N, N, 4, 6, 0 &#125;;
        
        //创建 Graph 对象
        Graph graph = new Graph(vertex.length, matrix, vertex);
        //调用弗洛伊德算法
        graph.floyd();
        graph.show();
    &#125;
&#125;
// 创建图
class Graph &#123;
    private char[] vertex; // 存放顶点的数组
    private int[][] dis; // 保存，从各个顶点出发到其它顶点的距离，最后的结果，也是保留在该数组
    private int[][] pre;// 保存到达目标顶点的前驱顶点

    /**
     * 
     * @param length 大小
     * @param matrix 邻接矩阵
     * @param vertex 顶点数组
     */
    public Graph(int length, int[][] matrix, char[] vertex) &#123;
        this.vertex = vertex;
        this.dis = matrix;
        this.pre = new int[length][length];
        // 对pre数组初始化, 注意存放的是前驱顶点的下标
        for (int i = 0; i &lt; length; i++) &#123;
            Arrays.fill(pre[i], i);
        &#125;
    &#125;

    // 显示pre数组和dis数组
    public void show() &#123;

        //为了显示便于阅读，我们优化一下输出
        for (int k = 0; k &lt; dis.length; k++) &#123;
            // 先将pre数组输出的一行
            for (int i = 0; i &lt; dis.length; i++) &#123;
                System.out.print(vertex[pre[k][i]] + &quot; &quot;);
            &#125;
            System.out.println();
            // 输出dis数组的一行数据
            for (int i = 0; i &lt; dis.length; i++) &#123;
                System.out.print(&quot;(&quot;+vertex[k]+&quot;到&quot;+vertex[i]+&quot;的最短路径是&quot; + dis[k][i] + &quot;) &quot;);
            &#125;
            System.out.println();
            System.out.println();

        &#125;

    &#125;
    
    //弗洛伊德算法, 比较容易理解，而且容易实现
    public void floyd() &#123;
        int len = 0; //变量保存距离
        //对中间顶点遍历， k 就是中间顶点的下标 [A, B, C, D, E, F, G] 
        for(int k = 0; k &lt; dis.length; k++) &#123; 
            //从i顶点开始出发 [A, B, C, D, E, F, G]
            for(int i = 0; i &lt; dis.length; i++) &#123;
                //到达j顶点 // [A, B, C, D, E, F, G]
                for(int j = 0; j &lt; dis.length; j++) &#123;
                    len = dis[i][k] + dis[k][j];// =&gt; 求出从i 顶点出发，经过 k中间顶点，到达 j 顶点距离
                    if(len &lt; dis[i][j]) &#123;//如果len小于 dis[i][j]
                        dis[i][j] = len;//更新距离
                        pre[i][j] = pre[k][j];//更新前驱顶点
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>迪杰斯特拉-送信问题</title>
    <url>/2022/06/19/di-jie-si-te-la-song-xin-wen-ti/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h4><blockquote>
<p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止</p>
</blockquote>
<ul>
<li>设置出发顶点为 v，顶点集合 V{v1,v2,vi…}，v 到 V 中各顶点的距离构成距离集合 Dis，Dis{d1,d2,di…}，Dis集合记录着 v 到图中各顶点的距离(到自身可以看作 0，v 到 vi 距离对应为 di)</li>
<li>从 Dis 中选择值最小的 di 并移出 Dis 集合，同时移出 V 集合中对应的顶点 vi，此时的 v 到 vi 即为最短路径</li>
<li>更新 Dis 集合，更新规则为：比较 v 到 V 集合中顶点的距离值，与 v 通过 vi 到 V 集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为 vi，表明是通过 vi 到达的)</li>
<li>重复执行两步骤，直到最短路径顶点为目标顶点即可结束</li>
</ul>
<h4 id="应用实践"><a href="#应用实践" class="headerlink" title="应用实践"></a>应用实践</h4><img src="/2022/06/19/di-jie-si-te-la-song-xin-wen-ti/image-20220619162939164.png" class="asset-class" title="image-20220619162939164">

<img src="/2022/06/19/di-jie-si-te-la-song-xin-wen-ti/image-20220619162002594.png" class="asset-class" title="image-20220619162002594">

<pre><code class="prettyprint">public class DijkstraAlgorithm &#123;

    public static void main(String[] args) &#123;
        char[] vertex = &#123; &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39; &#125;;
        //邻接矩阵
        int[][] matrix = new int[vertex.length][vertex.length];
        final int N = 65535;// 表示不可以连接
        matrix[0]=new int[]&#123;N,5,7,N,N,N,2&#125;;  
        matrix[1]=new int[]&#123;5,N,N,9,N,N,3&#125;;  
        matrix[2]=new int[]&#123;7,N,N,N,8,N,N&#125;;  
        matrix[3]=new int[]&#123;N,9,N,N,N,4,N&#125;;  
        matrix[4]=new int[]&#123;N,N,8,N,N,5,4&#125;;  
        matrix[5]=new int[]&#123;N,N,N,4,5,N,6&#125;;  
        matrix[6]=new int[]&#123;2,3,N,N,4,6,N&#125;;
        //创建 Graph对象
        Graph graph = new Graph(vertex, matrix);
        //测试, 看看图的邻接矩阵是否ok
        graph.showGraph();
        //测试迪杰斯特拉算法
        graph.dsj(6);//G
        graph.showDijkstra();
        
        
    &#125;

&#125;

class Graph &#123;
    private char[] vertex; // 顶点数组
    private int[][] matrix; // 邻接矩阵
    private VisitedVertex vv; //已经访问的顶点的集合

    // 构造器
    public Graph(char[] vertex, int[][] matrix) &#123;
        this.vertex = vertex;
        this.matrix = matrix;
    &#125;
    
    //显示结果
    public void showDijkstra() &#123;
        vv.show();
    &#125;

    // 显示图
    public void showGraph() &#123;
        for (int[] link : matrix) &#123;
            System.out.println(Arrays.toString(link));
        &#125;
    &#125;
    
    //迪杰斯特拉算法实现
    /**
     * 
     * @param index 表示出发顶点对应的下标
     */
    public void dsj(int index) &#123;
        vv = new VisitedVertex(vertex.length, index);
        update(index);//更新index顶点到周围顶点的距离和前驱顶点
        for(int j = 1; j &lt;vertex.length; j++) &#123;
            index = vv.updateArr();// 选择并返回新的访问顶点
            update(index); // 更新index顶点到周围顶点的距离和前驱顶点
        &#125; 
    &#125;
    
    
    
    //更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点,
    private void update(int index) &#123;
        int len = 0;
        //根据遍历我们的邻接矩阵的  matrix[index]行
        for(int j = 0; j &lt; matrix[index].length; j++) &#123;
            //访问过顶点就跳过
            if(vv.in(j) )&#123;
                continue;
            &#125;
            // len 含义是 : 出发顶点到index顶点的距离 + 从index顶点到j顶点的距离的和 ，获取下标j点到出发点的距离
            len = vv.getDis(index) + matrix[index][j];
            // 如果j顶点len 小于出发顶点到j顶点的距离，就需要更新
            if(len &lt; vv.getDis(j)) &#123;
                vv.updatePre(j, index); //更新j顶点的前驱为index顶点
                vv.updateDis(j, len); //更新出发顶点到j顶点的距离
            &#125;
        &#125;
    &#125;
&#125;

// 已访问顶点集合
class VisitedVertex &#123;
    // 记录各个顶点是否访问过 1表示访问过,0未访问,会动态更新
    public int[] alreadyArr;
    // 每个下标对应的值为前一个顶点下标, 会动态更新
    public int[] preVisited;
    // 记录出发顶点到其他所有顶点的距离,比如G为出发顶点，就会记录G到其它顶点的距离，会动态更新，求的最短距离就会存放到dis
    public int[] dis;
    
    //构造器
    /**
     * 
     * @param length :表示顶点的个数 
     * @param index: 出发顶点对应的下标, 比如G顶点，下标就是6
     */
    public VisitedVertex(int length, int index) &#123;
        this.alreadyArr = new int[length];
        this.preVisited = new int[length];
        this.dis = new int[length];
        //初始化 dis数组
        Arrays.fill(dis, 65535);
        this.alreadyArr[index] = 1; //设置出发顶点被访问过
        this.dis[index] = 0;//设置出发顶点的访问距离为0
                
    &#125;
    /**
     * 功能: 判断index顶点是否被访问过
     * @param index
     * @return 如果访问过，就返回true, 否则访问false
     */
    public boolean in(int index) &#123;
        return alreadyArr[index] == 1;
    &#125;
    
    /**
     * 功能: 更新出发顶点到index顶点的距离
     * @param index
     * @param len
     */
    public void updateDis(int index, int len) &#123;
        dis[index] = len;
    &#125;
    /**
     * 功能: 更新pre这个顶点的前驱顶点为index顶点
     * @param pre
     * @param index
     */
    public void updatePre(int pre, int index) &#123;
        preVisited[pre] = index;
    &#125;
    /**
     * 功能:返回出发顶点到index顶点的距离
     * @param index
     */
    public int getDis(int index) &#123;
        return dis[index];
    &#125;
    
    
    /**
     * 继续选择并返回新的访问顶点， 比如这里的G 完后，就是 A点作为新的访问顶点(注意不是出发顶点)
     * @return
     */
    public int updateArr() &#123;
        int min = 65535, index = 0;
        for(int i = 0; i &lt; alreadyArr.length; i++) &#123;
            //未访问过，且到起点距离最短
            if(alreadyArr[i] == 0 &amp;&amp; dis[i] &lt; min ) &#123;
                min = dis[i];
                index = i;
            &#125;
        &#125;
        //更新 index 顶点被访问过
        alreadyArr[index] = 1;
        return index;
    &#125;
    
    //显示最后的结果
    //即将三个数组的情况输出
    public void show() &#123;
        
        System.out.println(&quot;==========================&quot;);
        //输出alreadyArr
        for(int i : alreadyArr) &#123;
            System.out.print(i + &quot; &quot;);
        &#125;
        System.out.println();
        //输出preVisited
        for(int i : preVisited) &#123;
            System.out.print(i + &quot; &quot;);
        &#125;
        System.out.println();
        //输出dis
        for(int i : dis) &#123;
            System.out.print(i + &quot; &quot;);
        &#125;
        System.out.println();
        //为了好看最后的最短距离，我们处理
        char[] vertex = &#123; &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39; &#125;;
        int count = 0;
        for (int i : dis) &#123;
            if (i != 65535) &#123;
                System.out.print(vertex[count] + &quot;(&quot;+i+&quot;) &quot;);
            &#125; else &#123;
                System.out.println(&quot;N &quot;);
            &#125;
            count++;
        &#125;
        System.out.println();
        
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>window查杀进程命令</title>
    <url>/2022/06/28/window-cha-sha-jin-cheng-ming-ling/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>windows</code></p>
<pre><code class="prettyprint">netstat -ano | findstr &quot;8080&quot;
taskkill /f /t /im &quot;pid&quot;
</code></pre>
<p><code>linux</code></p>
<pre><code class="prettyprint"> ps -ef | grep &quot;java -jar&quot;| grep -v grep | awk &#39;&#123;print $2&#125;&#39;| xargs kill -9
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>centos7安装elasticsearch</title>
    <url>/2022/06/26/centos7-an-zhuang-elasticsearch/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><a href="https://www.elastic.co/cn/downloads/elasticsearch">Download Elasticsearch | Elastic</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><pre><code class="prettyprint">tar -zxvf elasticsearch-8.2.3-linux-x86_64.tar.gz /opt/modeule/
</code></pre>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h5 id="修改elasticsearch-yml"><a href="#修改elasticsearch-yml" class="headerlink" title="修改elasticsearch.yml"></a>修改<code>elasticsearch.yml</code></h5><pre><code class="prettyprint"># ======================== Elasticsearch Configuration =========================
#
# NOTE: Elasticsearch comes with reasonable defaults for most settings.
#       Before you set out to tweak and tune the configuration, make sure you
#       understand what are you trying to accomplish and the consequences.
#
# The primary way of configuring a node is via this file. This template lists
# the most important settings you may want to configure for a production cluster.
#
# Please consult the documentation for further information on configuration options:
# https://www.elastic.co/guide/en/elasticsearch/reference/index.html
#
# ---------------------------------- Cluster -----------------------------------
#
# Use a descriptive name for your cluster:
#
#cluster.name: my-es
#
# ------------------------------------ Node ------------------------------------
#
# Use a descriptive name for the node:
#
#node.name: node-1
#
# Add custom attributes to the node:
#
#node.attr.rack: r1
#
# ----------------------------------- Paths ------------------------------------
#
# Path to directory where to store the data (separate multiple locations by comma):
# 数据路径
path.data: /opt/module/elasticsearch-8.2.3/data
#
# Path to log files:
# 日志路径
path.logs: /opt/module/elasticsearch-8.2.3/logs
#
# ----------------------------------- Memory -----------------------------------
#
# Lock the memory on startup:
#
#bootstrap.memory_lock: true
#
# Make sure that the heap size is set to about half the memory available
# on the system and that the owner of the process is allowed to use this
# limit.
#
# Elasticsearch performs poorly when the system is swapping the memory.
#
# ---------------------------------- Network -----------------------------------
#
# By default Elasticsearch is only accessible on localhost. Set a different
# address here to expose this node on the network:
#
network.host: 0.0.0.0
#
# By default Elasticsearch listens for HTTP traffic on the first free port it
# finds starting at 9200. Set a specific HTTP port here:
#
http.port: 9200
#
# For more information, consult the network module documentation.
#
# --------------------------------- Discovery ----------------------------------
#
# Pass an initial list of hosts to perform discovery when this node is started:
# The default list of hosts is [&quot;127.0.0.1&quot;, &quot;[::1]&quot;]
#
#discovery.seed_hosts: [&quot;host1&quot;, &quot;host2&quot;]
#
# Bootstrap the cluster using an initial set of master-eligible nodes:
#
#cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;]
#
# For more information, consult the discovery and cluster formation module documentation.
#
# --------------------------------- Readiness ----------------------------------
#
# Enable an unauthenticated TCP readiness endpoint on localhost
#
#readiness.port: 9399
#
# ---------------------------------- Various -----------------------------------
#
# Allow wildcard deletion of indices:
#
#action.destructive_requires_name: false

#----------------------- BEGIN SECURITY AUTO CONFIGURATION -----------------------
#
# The following settings, TLS certificates, and keys have been automatically      
# generated to configure Elasticsearch security features on 26-06-2022 09:52:27
#
# --------------------------------------------------------------------------------

# Enable security features 不使用认证
xpack.security.enabled: false

xpack.security.enrollment.enabled: true

# Enable encryption for HTTP API client connections, such as Kibana, Logstash, and Agents
xpack.security.http.ssl:
  enabled: false
  keystore.path: certs/http.p12

# Enable encryption and mutual authentication between cluster nodes
xpack.security.transport.ssl:
  enabled: true
  verification_mode: certificate
  keystore.path: certs/transport.p12
  truststore.path: certs/transport.p12
# Create a new cluster with the current node only
# Additional nodes can still join the cluster later

#----------------------- END SECURITY AUTO CONFIGURATION -------------------------
</code></pre>
<h5 id="配置-etc-sysctl-conf"><a href="#配置-etc-sysctl-conf" class="headerlink" title="配置/etc/sysctl.conf"></a>配置<code>/etc/sysctl.conf</code></h5><pre><code class="prettyprint">vm.max_map_count=655360
</code></pre>
<blockquote>
<p>sysctl -p 使配置生效</p>
</blockquote>
<h5 id="配置-etc-security-limits-conf用户使用线程数"><a href="#配置-etc-security-limits-conf用户使用线程数" class="headerlink" title="配置/etc/security/limits.conf用户使用线程数"></a>配置<code>/etc/security/limits.conf</code>用户使用线程数</h5><pre><code class="prettyprint">#* 表示所有用户
* soft nofile 65536
* hard nofile 65536
* soft nproc 65536
* hard nproc 65536
# 查看 ulimit -Hn
# 查看 ulimit -Sn
</code></pre>
<h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><blockquote>
<p>elasticsearch不能使用root用户启动</p>
</blockquote>
<pre><code class="prettyprint"># 新增用户
adduser esuser
# 用户密码设置
passwd esuser
# 用户授权
chown -R esuser:esuser /opt/module/elasticsearch-8.2.3/
</code></pre>
<h4 id="选择用户启动"><a href="#选择用户启动" class="headerlink" title="选择用户启动"></a>选择用户启动</h4><pre><code class="prettyprint">su esuser
cd /opt/module/elasticsearch-8.2.3/bin
./elasticsearch -d
</code></pre>
<h4 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h4><p><a href="http://192.168.101.123:9200/">http://192.168.101.123:9200/</a></p>
<img src="/2022/06/26/centos7-an-zhuang-elasticsearch/image-20220626183843509.png" class="asset-class" title="image-20220626183843509">
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>统一异常处理</title>
    <url>/2022/07/07/tong-yi-yi-chang-chu-li/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="统一返回封装"><a href="#统一返回封装" class="headerlink" title="统一返回封装"></a>统一返回封装</h3><h4 id="自定义返回结果类"><a href="#自定义返回结果类" class="headerlink" title="自定义返回结果类"></a>自定义返回结果类</h4><pre><code class="prettyprint">@Data
public class R &#123;
    private Boolean success;

    private Integer code;

    private String message;

    private Object data;

    // 构造器私有
    private R()&#123;&#125;

    // 通用返回成功
    public static R ok() &#123;
        R r = new R();
        r.setSuccess(ResultCodeEnum.SUCCESS.getSuccess());
        r.setCode(ResultCodeEnum.SUCCESS.getCode());
        r.setMessage(ResultCodeEnum.SUCCESS.getMessage());
        return r;
    &#125;

    // 通用返回失败，未知错误
    public static R error() &#123;
        R r = new R();
        r.setSuccess(ResultCodeEnum.UNKNOWN_ERROR.getSuccess());
        r.setCode(ResultCodeEnum.UNKNOWN_ERROR.getCode());
        r.setMessage(ResultCodeEnum.UNKNOWN_ERROR.getMessage());
        return r;
    &#125;

    // 设置结果，形参为结果枚举
    public static R setResult(ResultCodeEnum result) &#123;
        R r = new R();
        r.setSuccess(result.getSuccess());
        r.setCode(result.getCode());
        r.setMessage(result.getMessage());
        return r;
    &#125;

    /**------------使用链式编程，返回类本身-----------**/

    // 自定义返回数据
    public R data(Object o) &#123;
        this.setData(o);
        return this;
    &#125;

    // 自定义状态信息
    public R message(String message) &#123;
        this.setMessage(message);
        return this;
    &#125;

    // 自定义状态码
    public R code(Integer code) &#123;
        this.setCode(code);
        return this;
    &#125;

    // 自定义返回结果
    public R success(Boolean success) &#123;
        this.setSuccess(success);
        return this;
    &#125;
&#125;
</code></pre>
<h4 id="自定义状态码"><a href="#自定义状态码" class="headerlink" title="自定义状态码"></a>自定义状态码</h4><pre><code class="prettyprint">@Getter
public enum ResultCodeEnum &#123;
    SUCCESS(true,20000,&quot;成功&quot;),
    UNKNOWN_ERROR(false,20001,&quot;未知错误&quot;),
    PARAM_ERROR(false,20002,&quot;参数错误&quot;),
    NULL_POINT(false,20003,&quot;空指针异常&quot;),
    HTTP_CLIENT_ERROR(false,20004,&quot;客户端错误&quot;),
    NOT_FOUNT(false,20005,&quot;找不到路径&quot;),
    ;

    // 响应是否成功
    private Boolean success;
    // 响应状态码
    private Integer code;
    // 响应信息
    private String message;

    ResultCodeEnum(boolean success, Integer code, String message) &#123;
        this.success = success;
        this.code = code;
        this.message = message;
    &#125;
&#125;
</code></pre>
<h3 id="统一异常返回"><a href="#统一异常返回" class="headerlink" title="统一异常返回"></a>统一异常返回</h3><ul>
<li><code>@RestControllerAdvice</code></li>
<li><code>@ExceptionHandler</code></li>
</ul>
<pre><code class="prettyprint">@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler &#123;

    /**-------- 通用异常处理方法 --------**/
    @ExceptionHandler(Exception.class)
    public R error(Exception e) &#123;
        log.error(ExceptionUtil.getMessage(e));
        return R.error().message(e.getMessage()).code(-1);
    &#125;

    /**-------- 指定异常处理方法 --------**/
    @ExceptionHandler(NullPointerException.class)
    public R error(NullPointerException e) &#123;
        log.error(ExceptionUtil.getMessage(e));
        return R.setResult(ResultCodeEnum.NULL_POINT);
    &#125;

    @ExceptionHandler(HttpClientErrorException.class)
    public R error(IndexOutOfBoundsException e) &#123;
        log.error(ExceptionUtil.getMessage(e));
        return R.setResult(ResultCodeEnum.HTTP_CLIENT_ERROR);
    &#125;
    /**-------- 自定义定异常处理方法 --------**/
    @ExceptionHandler(CustomException.class)
    public R error(CustomException e) &#123;
        log.error(ExceptionUtil.getMessage(e));
        return R.error().message(e.getMessage()).code(e.getCode());
    &#125;
&#125;
</code></pre>
<ul>
<li>自定义异常类</li>
</ul>
<pre><code class="prettyprint">@Data
public class CustomException extends RuntimeException &#123;
    private Integer code;

    public CustomException(Integer code, String message) &#123;
        super(message);
        this.code = code;
    &#125;

    public CustomException(ResultCodeEnum resultCodeEnum) &#123;
        super(resultCodeEnum.getMessage());
        this.code = resultCodeEnum.getCode();
    &#125;

    @Override
    public String toString() &#123;
        return &quot;CustomException&#123;&quot; + &quot;code=&quot; + code + &quot;, message=&quot; + this.getMessage() + &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<h3 id="ResponseBody统一返回"><a href="#ResponseBody统一返回" class="headerlink" title="ResponseBody统一返回"></a><code>ResponseBody</code>统一返回</h3><ul>
<li>@RestControllerAdvice</li>
<li><code>ResponseBodyAdvice</code></li>
</ul>
<pre><code class="prettyprint">@RestControllerAdvice
public class HandleResponseAdvice implements ResponseBodyAdvice&lt;Object&gt; &#123;
    @Autowired
    private ObjectMapper objectMapper;
    @Override
    public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123;
        //过滤swagger
        String className = returnType.getDeclaringClass().getName();
        String swaggerName = ApiResourceController.class.getName();
        String swaggerName2 = OpenApiControllerWebMvc.class.getName();
        return !swaggerName.equals(className)&amp;&amp; !swaggerName2.equals(className);
    &#125;

    @SneakyThrows
    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123;
        if (body == null) &#123;
            return R.error();
        &#125;
        //String类型需要特殊处理 手动转为json字符串
        if (body instanceof String) &#123;
            return objectMapper.writeValueAsString(R.ok().data(body));
        &#125;
        if (body instanceof R) &#123;
            return body;
        &#125;
        return R.ok().data(body);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7搭建zookeeper集群</title>
    <url>/2022/07/11/centos7-da-jian-zookeeper-ji-qun/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="download"><a href="#download" class="headerlink" title="download"></a>download</h3><p><a href="https://archive.apache.org/dist/zookeeper/">Index of &#x2F;dist&#x2F;zookeeper (apache.org)</a></p>
<img src="/2022/07/11/centos7-da-jian-zookeeper-ji-qun/image-20220711222049898.png" class="asset-class" title="image-20220711222049898">

<blockquote>
<p>本文使用3.5.7版本</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="配置host"><a href="#配置host" class="headerlink" title="配置host"></a>配置host</h4><pre><code class="prettyprint">vim /etc/hosts
#内容如下
# 192.168.101.131 node2
# 192.168.101.128 node3
# 192.168.101.130 node4
</code></pre>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><pre><code class="prettyprint">tar -zxvf /opt/software/apache-zookeeper-3.5.7-bin.tar.gz -C /opt/module/
</code></pre>
<h4 id="修改目录名称"><a href="#修改目录名称" class="headerlink" title="修改目录名称"></a>修改目录名称</h4><pre><code class="prettyprint"># 方便统一管理
cd /opt/module
mv apache-zookeeper-3.5.7-bin apache-zookeeper-3.5.7
</code></pre>
<h4 id="配置zoo-cfg"><a href="#配置zoo-cfg" class="headerlink" title="配置zoo.cfg"></a>配置<code>zoo.cfg</code></h4><pre><code class="prettyprint">cd apache-zookeeper-3.5.7/conf
# zookeeper默认使用配置
cp zoo_sample.cfg zoo.cfg
</code></pre>
<h5 id="配置内容如下"><a href="#配置内容如下" class="headerlink" title="配置内容如下"></a>配置内容如下</h5><pre><code class="prettyprint"># zookeeper服务器和客户端心跳时间，单位毫秒
tickTime=2000
# The number of ticks that the initial 
# 主从节点初始连接时间能容忍的最多心跳数
initLimit=10
# The number of ticks that can pass between 
# sending a request and getting an acknowledgement
syncLimit=5
# the directory where the snapshot is stored.
# do not use /tmp for storage, /tmp here is just 
# example sakes.
# 数据存储及日志存储
dataDir=/opt/module/apache-zookeeper-3.5.7/data
dataLogDir=/opt/module/apache-zookeeper-3.5.7/logs
# 客户端连接端口
clientPort=2181
# 集群服务
# server.A=B:C:D
# A 是一个数字，表示这个是第几号服务器。集群模式下需要在zoo.cfg中dataDir指定的目录下创建一个文件myid，这个文件里面有一个数据就是A的值，Zookeeper启动时读取此文件，拿到里面的数据与zoo.cfg里面的配置信息比较从而判断到底是哪个server。
# B 是这个服务器的地址。
# C 是这个服务器Follower与集群中的Leader服务器交换信息的端口。
# D 是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。
server.1=node2:3188:3288
server.2=node3:3188:3288
server.3=node4:3188:3288
# the maximum number of client connections.
# increase this if you need to handle more clients
#maxClientCnxns=60
#
# Be sure to read the maintenance section of the 
# administrator guide before turning on autopurge.
#
# http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance
#
# The number of snapshots to retain in dataDir
#autopurge.snapRetainCount=3
# Purge task interval in hours
# Set to &quot;0&quot; to disable auto purge feature
#autopurge.purgeInterval=1
</code></pre>
<h4 id="拷贝配置zoo-cfg到另外两个机器"><a href="#拷贝配置zoo-cfg到另外两个机器" class="headerlink" title="拷贝配置zoo.cfg到另外两个机器"></a>拷贝配置<code>zoo.cfg</code>到另外两个机器</h4><pre><code class="prettyprint">scp /opt/module/apache-zookeeper-3.5.7/conf/zoo.cfg 192.168.101.128:/opt/module/apache-zookeeper-3.5.7/conf/
scp /opt/module/apache-zookeeper-3.5.7/conf/zoo.cfg 192.168.101.130:/opt/module/apache-zookeeper-3.5.7/conf/
</code></pre>
<h4 id="在每个节点创建data和logs"><a href="#在每个节点创建data和logs" class="headerlink" title="在每个节点创建data和logs"></a>在每个节点创建<code>data</code>和<code>logs</code></h4><pre><code class="prettyprint">mkdir -p /opt/module/apache-zookeeper-3.5.7/data
mkdir -p /opt/module/apache-zookeeper-3.5.7/logs
</code></pre>
<h4 id="创建myid"><a href="#创建myid" class="headerlink" title="创建myid"></a>创建<code>myid</code></h4><pre><code class="prettyprint"># node2节点服务器
echo 1 &gt; /opt/module/apache-zookeeper-3.5.7/data/myid
# node3节点服务器
echo 2 &gt; /opt/module/apache-zookeeper-3.5.7/data/myid
# node4节点服务器
echo 3 &gt; /opt/module/apache-zookeeper-3.5.7/data/myid
</code></pre>
<h3 id="配置启动脚本"><a href="#配置启动脚本" class="headerlink" title="配置启动脚本"></a>配置启动脚本</h3><pre><code class="prettyprint">#!/bin/bash

case $1 in
&quot;start&quot;)&#123;
    for i in node2 node3 node4
    do
        echo  ------------- zookeeper $i 启动 ------------
        ssh $i &quot;/opt/module/apache-zookeeper-3.5.7/bin/zkServer.sh start&quot;
    done
&#125;
;;
&quot;stop&quot;)&#123;
    for i in node2 node3 node4
    do
        echo  ------------- zookeeper $i 停止 ------------
        ssh $i &quot;/opt/module/apache-zookeeper-3.5.7/bin/zkServer.sh stop&quot;
    done
&#125;
;;
&quot;restart&quot;)&#123;
    for i in node2 node3 node4
    do
        echo  ------------- zookeeper $i 停止 ------------
        ssh $i &quot;/opt/module/apache-zookeeper-3.5.7/bin/zkServer.sh restart&quot;
    done
&#125;
;;
&quot;status&quot;)&#123;
    for i in node2 node3 node4
    do
        echo  ------------- zookeeper $i 状态 ------------
        ssh $i &quot;/opt/module/apache-zookeeper-3.5.7/bin/zkServer.sh status&quot;
    done
&#125;
;;
esac
</code></pre>
<h4 id="启动相关命令"><a href="#启动相关命令" class="headerlink" title="启动相关命令"></a>启动相关命令</h4><pre><code class="prettyprint"># 启动
./zk.sh start
# 停止
./zk.sh stop
# 状态查看
./zk.sh status
</code></pre>
<h4 id="查看是否启动成功"><a href="#查看是否启动成功" class="headerlink" title="查看是否启动成功"></a>查看是否启动成功</h4><img src="/2022/07/11/centos7-da-jian-zookeeper-ji-qun/image-20220711222229503.png" class="asset-class" title="image-20220711222229503">

<h3 id="配置service启动"><a href="#配置service启动" class="headerlink" title="配置service启动"></a>配置service启动</h3><pre><code class="prettyprint">vim /etc/init.d/zookeeper
</code></pre>
<ul>
<li>配置内容</li>
</ul>
<pre><code class="prettyprint">#!/bin/bash
#chkconfig:2345 20 90
#description:Zookeeper Service Control Script
ZK_HOME=&#39;/opt/module/apache-zookeeper-3.5.7&#39;
case $1 in
start)
    echo &quot;---------- zookeeper 启动 ------------&quot;
    $ZK_HOME/bin/zkServer.sh start
;;
stop)
    echo &quot;---------- zookeeper 停止 ------------&quot;
    $ZK_HOME/bin/zkServer.sh stop
;;
restart)
    echo &quot;---------- zookeeper 重启 ------------&quot;
    $ZK_HOME/bin/zkServer.sh restart
;;
status)
    echo &quot;---------- zookeeper 状态 ------------&quot;
    $ZK_HOME/bin/zkServer.sh status
;;
*)
    echo &quot;Usage: $0 &#123;start|stop|restart|status&#125;&quot;
esac
</code></pre>
<h4 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h4><pre><code class="prettyprint">chmod +x /etc/init.d/zookeeper
chkconfig --add zookeeper
</code></pre>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><pre><code class="prettyprint">service zookeeper start
service zookeeper stop
service zookeeper restart
service zookeeper status
</code></pre>
<blockquote>
<p>注意事项：</p>
<ul>
<li>不要下载<code>apache-zookeeper-3.5.7.tar.gz</code>要下载<code>apache-zookeeper-3.5.7-bin.tar.gz </code></li>
<li>如果启动脚本找不到JAVA_HOME<ul>
<li>配置jdk</li>
<li>在 <code>bin/zkEnv.sh</code>添加<code>JAVA_HOME=/usr/local/java/jdk1.8</code></li>
</ul>
</li>
</ul>
</blockquote>
<img src="/2022/07/11/centos7-da-jian-zookeeper-ji-qun/image-20220711222019911.png" class="asset-class" title="image-20220711222019911">
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>linux脚本</title>
    <url>/2022/07/12/linux-jiao-ben/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="同步文件夹"><a href="#同步文件夹" class="headerlink" title="同步文件夹"></a>同步文件夹</h4><h5 id="每个服务器都要安装rsync"><a href="#每个服务器都要安装rsync" class="headerlink" title="每个服务器都要安装rsync"></a>每个服务器都要安装<code>rsync</code></h5><pre><code class="prettyprint">yum install rsync
</code></pre>
<p>在<code>/usr/local/bin</code>创建文件<code>xsync</code></p>
<pre><code class="prettyprint">#!/bin/bash

#1. 判断参数个数
if [ $# -lt 1 ]
then
    echo Not Enough Arguement!
    exit;
fi

#2. 遍历集群所有机器
for host in node2 node3 node4
do
    echo ====================  $host  ====================
    #3. 遍历所有目录，挨个发送

    for file in $@
    do
        #4. 判断文件是否存在
        if [ -e $file ]
            then
                #5. 获取父目录
                pdir=$(cd -P $(dirname $file); pwd)

                #6. 获取当前文件的名称
                fname=$(basename $file)
                ssh $host &quot;mkdir -p $pdir&quot;
                rsync -av $pdir/$fname $host:$pdir
            else
                echo $file does not exists!
        fi
    done
done
</code></pre>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><pre><code class="prettyprint">xsync kafka/
</code></pre>
<h4 id="zk启动脚本"><a href="#zk启动脚本" class="headerlink" title="zk启动脚本"></a>zk启动脚本</h4><pre><code class="prettyprint">#!/bin/bash

case $1 in
&quot;start&quot;)&#123;
    for i in node2 node3 node4
    do
        echo  ------------- zookeeper $i 启动 ------------
        ssh $i &quot;/opt/module/apache-zookeeper-3.5.7/bin/zkServer.sh start&quot;
    done
&#125;
;;
&quot;stop&quot;)&#123;
    for i in node2 node3 node4
    do
        echo  ------------- zookeeper $i 停止 ------------
        ssh $i &quot;/opt/module/apache-zookeeper-3.5.7/bin/zkServer.sh stop&quot;
    done
&#125;
;;
&quot;status&quot;)&#123;
    for i in node2 node3 node4
    do
        echo  ------------- zookeeper $i 状态 ------------
        ssh $i &quot;/opt/module/apache-zookeeper-3.5.7/bin/zkServer.sh status&quot;
    done
&#125;
;;
esac
</code></pre>
<h4 id="kafka启动脚本"><a href="#kafka启动脚本" class="headerlink" title="kafka启动脚本"></a>kafka启动脚本</h4><pre><code class="prettyprint">#!/bin/bash

case $1 in
&quot;start&quot;)&#123;
    for i in node2 node3 node4
    do
        echo  ------------- kafka $i 启动 ------------
        ssh $i &quot;source /etc/profile;nohup /opt/module/kafka/bin/kafka-server-start.sh -daemon /opt/module/kafka/config/server.properties&quot;
    done
&#125;
;;
&quot;stop&quot;)&#123;
    for i in node2 node3 node4
    do
        echo  ------------- kafka $i 停止 ------------
        ssh $i &quot;/opt/module/kafka/bin/kafka-server-stop.sh &quot;
    done
&#125;
;;
esac
</code></pre>
<h4 id="xcall查看jps"><a href="#xcall查看jps" class="headerlink" title="xcall查看jps"></a>xcall查看jps</h4><pre><code class="prettyprint"># 各服务器创建软链
ln -s /usr/local/java/jdk1.8/bin/jps /usr/local/bin/jps
</code></pre>
<p>xcall</p>
<pre><code class="prettyprint">#!/bin/bash

for host in node2 node3 node4
do
        echo =============== $host ===============
        ssh $host jps 
done
</code></pre>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器之间实现免密访问</title>
    <url>/2022/07/12/fu-wu-qi-zhi-jian-shi-xian-mian-mi-fang-wen/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="准备三台机器node2-node3-node4"><a href="#准备三台机器node2-node3-node4" class="headerlink" title="准备三台机器node2,node3,node4"></a>准备三台机器<code>node2</code>,<code>node3</code>,<code>node4</code></h4><h4 id="在每台机器执行命令生产ssh公私钥"><a href="#在每台机器执行命令生产ssh公私钥" class="headerlink" title="在每台机器执行命令生产ssh公私钥"></a>在每台机器执行命令生产ssh公私钥</h4><pre><code class="prettyprint">ssh-keygen -t rsa -P &#39;&#39; -f ~/.ssh/id_rsa
</code></pre>
<h4 id="进入-ssh目录进行授权"><a href="#进入-ssh目录进行授权" class="headerlink" title="进入.ssh目录进行授权"></a>进入<code>.ssh</code>目录进行授权</h4><pre><code class="prettyprint">[root@node2 ~]# cd ~/.ssh/
[root@node3 ~]# cd ~/.ssh/
[root@node4 ~]# cd ~/.ssh/
</code></pre>
<h5 id="创建authorized-keys"><a href="#创建authorized-keys" class="headerlink" title="创建authorized_keys"></a>创建<code>authorized_keys</code></h5><pre><code class="prettyprint"># node2
[root@node2 .ssh]# touch authorized_keys
[root@node2 .ssh]# chmod 600 authorized_keys
# node3
[root@node3 .ssh]# touch authorized_keys
[root@node3 .ssh]# chmod 600 authorized_keys
# node4
[root@node4 .ssh]# touch authorized_keys
[root@node4 .ssh]# chmod 600 authorized_keys
</code></pre>
<h5 id="公钥追加到认证"><a href="#公钥追加到认证" class="headerlink" title="公钥追加到认证"></a>公钥追加到认证</h5><pre><code class="prettyprint">#自身认证
[root@node2 .ssh]# cat id_rsa.pub &gt;&gt; authorized_keys
[root@node3 .ssh]# cat id_rsa.pub &gt;&gt; authorized_keys
[root@node4 .ssh]# cat id_rsa.pub &gt;&gt; authorized_keys
</code></pre>
<h5 id="分别将其他服务器公钥追加到认证"><a href="#分别将其他服务器公钥追加到认证" class="headerlink" title="分别将其他服务器公钥追加到认证"></a>分别将其他服务器公钥追加到认证</h5><pre><code class="prettyprint"># node2添加
[root@node3 .ssh] scp id_rsa.pub node2:/home/
[root@node2 .ssh]# cat /home/id_rsa.pub &gt;&gt; authorized_keys
[root@node4 .ssh] scp id_rsa.pub node2:/home/
[root@node2 .ssh]# cat /home/id_rsa.pub &gt;&gt; authorized_keys

# node3添加
[root@node2 .ssh] scp id_rsa.pub node3:/home/
[root@node3 .ssh]# cat /home/id_rsa.pub &gt;&gt; authorized_keys
[root@node4 .ssh] scp id_rsa.pub node3:/home/
[root@node3 .ssh]# cat /home/id_rsa.pub &gt;&gt; authorized_keys

# node4添加
[root@node2 .ssh] scp id_rsa.pub node4:/home/
[root@node4 .ssh]# cat /home/id_rsa.pub &gt;&gt; authorized_keys
[root@node3 .ssh] scp id_rsa.pub node4:/home/
[root@node4 .ssh]# cat /home/id_rsa.pub &gt;&gt; authorized_keys
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="prettyprint">/opt/module/shell/kf.sh stop
</code></pre>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>redis事务命令</title>
    <url>/2022/08/09/redis-shi-wu-ming-ling/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h4><ul>
<li><code>multi</code>：开启事务</li>
<li><code>exec</code>：执行事务</li>
<li><code>discard</code>：取消事务</li>
<li><code>watch</code>：监视Key改变，用于实现乐观锁。如果监视的Key的值改变，事务最终会执行失败</li>
<li><code>unwatch</code>：放弃监视</li>
</ul>
<blockquote>
<p>事务说明</p>
<ul>
<li><strong>事务没有隔离级别的概念</strong>：批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</li>
<li><strong>Redis不保证原子性</strong>：Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行</li>
<li>事务执行时，事务放入队列命令错误，所有命令都不会执行</li>
<li>事务执行时，事务执行错误，只有执行错误的命令不执行，其余命令依然执行</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis,事务</tag>
      </tags>
  </entry>
  <entry>
    <title>redis过期key监听</title>
    <url>/2022/08/09/redis-guo-qi-key-jian-ting/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="配置文件修改"><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h4><pre><code class="prettyprint">vim /usr/local/redis/redis.conf
</code></pre>
<blockquote>
<p> 修改字段 监听过期</p>
</blockquote>
<pre><code class="prettyprint">notify-keyspace-events Ex
</code></pre>
<h4 id="java代码事件监听"><a href="#java代码事件监听" class="headerlink" title="java代码事件监听"></a>java代码事件监听</h4><pre><code class="prettyprint">@Slf4j
@Component
public class KeyExpiredListener extends KeyExpirationEventMessageListener &#123;
    @Autowired
    private RedisTemplate&lt;String, String&gt; redisTemplate;

    public KeyExpiredListener(RedisMessageListenerContainer listenerContainer) &#123;
        super(listenerContainer);
    &#125;

    @Override
    public void onMessage(Message message, byte[] pattern) &#123;
        //获取失效key名称
        String expireKey = new String(message.getBody(), StandardCharsets.UTF_8);
        //获取key原本的value 获取不到 是null
        String expireKeyValue = redisTemplate.opsForValue().get(&quot;myKey&quot;);
        log.info(&quot;expireKey---&quot;+expireKey);
        log.info(&quot;expireKeyValue---&quot;+expireKeyValue);
        log.info(&quot;pattern----&#123;&#125;&quot;,new String(pattern));
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis集群搭建</title>
    <url>/2022/08/14/redis-ji-qun-da-jian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h4><p><a href="https://rocpenghua.gitee.io/2022/06/09/centos7-an-zhuang-redis6-ji-shao-bing/">centos7安装redis6及哨兵 | 小鹏驿站 (gitee.io)</a></p>
<h4 id="集群配置文件"><a href="#集群配置文件" class="headerlink" title="集群配置文件"></a>集群配置文件</h4><h5 id="创建配置文件及存放目录"><a href="#创建配置文件及存放目录" class="headerlink" title="创建配置文件及存放目录"></a>创建配置文件及存放目录</h5><pre><code class="prettyprint">cd /usr/local/redis
mkdir myredis
cp redis.conf myredis/
</code></pre>
<blockquote>
<p>最好修改成后台启动</p>
<p>daemonize yes</p>
</blockquote>
<h5 id="创建集群节点配置文件-6379-6380-6381-6389-6390-6391"><a href="#创建集群节点配置文件-6379-6380-6381-6389-6390-6391" class="headerlink" title="创建集群节点配置文件(6379,6380,6381,6389,6390,6391)"></a>创建集群节点配置文件(<code>6379,6380,6381,6389,6390,6391</code>)</h5><ul>
<li><code>redis6379.conf</code></li>
</ul>
<pre><code class="prettyprint">include /usr/local/redis/myredis/redis.conf
pidfile /var/run/redis_6379.pid
port 6379
dbfilename dump6379.rdb
cluster-enabled yes
cluster-config-file nodes-6379.conf
cluster-node-timeout 15000
</code></pre>
<ul>
<li>6380,6381,6389,6390,6391(配置同上修改6379为对应数字)</li>
</ul>
<h5 id="分别启动各个节点"><a href="#分别启动各个节点" class="headerlink" title="分别启动各个节点"></a>分别启动各个节点</h5><pre><code class="prettyprint">redis-server redis6379.conf
redis-server redis6380.conf
redis-server redis6381.conf
redis-server redis6389.conf
redis-server redis6390.conf
redis-server redis6391.conf
</code></pre>
<h5 id="合并集群"><a href="#合并集群" class="headerlink" title="合并集群"></a>合并集群</h5><pre><code class="prettyprint"># 进入开始解压安装目录(依赖ruby)
cd /opt/module/redis-6.2.7/src/
./redis-cli --cluster create --cluster-replicas 1 192.168.101.146:6379 192.168.101.146:6380 192.168.101.146:6381 192.168.101.146:6389 192.168.101.146:6390 192.168.101.146:6391
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="prettyprint"># 集群方式连接
redis-cli -c -p 6379
#查看集群节点信息
127.0.0.1:6379&gt; cluster nodes 
ebbb1359010776cb51e2eb6eb67e875abcfd1fec 192.168.101.146:6389@16389 slave 2aec40cbb7d21ee79a54c7b83df872b816633aa2 0 1660356353000 2 connected
c638adf60dd9ae528ca55e856aa05a6033b0197f 192.168.101.146:6391@16391 slave 664cfc95d9673a069794b0c54d79db8a99a25bbc 0 1660356352000 1 connected
2eb521f23b5fe37ef81c22a851e140232a3f1e9f 192.168.101.146:6381@16381 master - 0 1660356354675 3 connected 10923-16383
2aec40cbb7d21ee79a54c7b83df872b816633aa2 192.168.101.146:6380@16380 master - 0 1660356355705 2 connected 5461-10922
664cfc95d9673a069794b0c54d79db8a99a25bbc 192.168.101.146:6379@16379 myself,master - 0 1660356354000 1 connected 0-5460
877c1a91ccbe778d7ed70000ba27b81e5aca2940 192.168.101.146:6390@16390 slave 2eb521f23b5fe37ef81c22a851e140232a3f1e9f 0 1660356353652 3 connected
127.0.0.1:6379&gt; 
</code></pre>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>vim技巧</title>
    <url>/2022/08/14/vim-ji-qiao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>查找字符：<code>/string</code></p>
</li>
<li><p>批量替换：<code>:%s/6379/6380</code></p>
</li>
<li><p>退出保存：<code>:wq</code></p>
</li>
<li><p>退出不保存:<code>:q!</code></p>
</li>
<li><p>查看文件编码：<code>:set fileencoding</code></p>
</li>
<li><p>修改文件编码：<code>:set fileencoding=utf-8</code></p>
</li>
<li><p>查看文件系统格式：<code>:set ff</code></p>
</li>
<li><p>修改文件系统格式：<code>:set ff=unix</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>go环境开发搭建</title>
    <url>/2023/02/07/go-huan-jing-kai-fa-da-jian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="下载地址-Download-and-install-The-Go-Programming-Language"><a href="#下载地址-Download-and-install-The-Go-Programming-Language" class="headerlink" title="下载地址: Download and install - The Go Programming Language"></a>下载地址: <a href="https://go.dev/doc/install">Download and install - The Go Programming Language</a></h4><h4 id="配置系统环境变量"><a href="#配置系统环境变量" class="headerlink" title="配置系统环境变量"></a>配置系统环境变量</h4><p>新建 <code>GOROOT</code>指向安装地址</p>
<p>新建<code>GOPATH</code>执行工作目录</p>
<p>在path里面添加<code>%GOROOT%\bin</code>,<code>%GOPATH%\bin</code></p>
<img src="/2023/02/07/go-huan-jing-kai-fa-da-jian/image-20230207220257704.png" class="asset-class" title="image-20230207220257704">

<img src="/2023/02/07/go-huan-jing-kai-fa-da-jian/image-20230207220332864.png" class="asset-class" title="image-20230207220332864">
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>win10安装go-protobuf</title>
    <url>/2023/02/07/win10-an-zhuang-go-protobuf/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="GOPATH安装"><a href="#GOPATH安装" class="headerlink" title="GOPATH安装"></a>GOPATH安装</h3><h4 id="protobuf配置"><a href="#protobuf配置" class="headerlink" title="protobuf配置"></a>protobuf配置</h4><p>下载地址:<code>https://github.com/protocolbuffers/protobuf/releases/tag/v3.19.4</code></p>
<img src="/2023/02/07/win10-an-zhuang-go-protobuf/image-20230207211741969.png" class="asset-class" title="image-20230207211741969">

<p>解压到指定目录不要做变更</p>
<p>配置环境变量,添加bin目录到path中</p>
<img src="/2023/02/07/win10-an-zhuang-go-protobuf/image-20230207211919578.png" class="asset-class" title="image-20230207211919578">

<p>测试是否安装成功:<code>protoc --version</code></p>
<img src="/2023/02/07/win10-an-zhuang-go-protobuf/image-20230207212004114.png" class="asset-class" title="image-20230207212004114">

<h4 id="安装go-protocol-buffers的插件-protoc-gen-go"><a href="#安装go-protocol-buffers的插件-protoc-gen-go" class="headerlink" title="安装go protocol buffers的插件 protoc-gen-go"></a>安装go protocol buffers的插件 <strong>protoc-gen-go</strong></h4><ul>
<li>命令行输入:<code>go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</code></li>
<li>插件会自动下载到<code>GOPATH</code>的<code>bin</code>目录下<code>%GOPATH%/bin需要配置环境变量path</code></li>
</ul>
<blockquote>
<p>注意:安装失败需要配置代理</p>
<p><code>go env</code>查看</p>
<p><code>go env -w GOPROXY=https://goproxy.cn,direct</code>设置</p>
</blockquote>
<h4 id="安装grpc插件"><a href="#安装grpc插件" class="headerlink" title="安装grpc插件"></a>安装grpc插件</h4><p><code>https://gitcode.net/mirrors/grpc/grpc-go</code></p>
<p><code>go install google.golang.org/grpc@latest</code></p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><ul>
<li>创建.proto文件</li>
<li>生成.go文件命令<code>protoc --go_out=./ *.proto</code></li>
<li>protobuf-grpc命令<code>protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative *.proto</code><ul>
<li><code>--go_out=. --go_opt=paths=source_relative</code>  生成<code>*.go</code>文件,不包含服务</li>
<li><code>--go-grpc_out=. --go-grpc_opt=paths=source_relative</code> 生成<code>*_grpc.pg.go</code>包含服务</li>
</ul>
</li>
</ul>
<blockquote>
<p>执行失败:</p>
<p>在proto文件中添加<code>option go_package = &quot;../pb&quot;</code></p>
</blockquote>
<ul>
<li>生成的go文件缺失<code>google.golang.org/protobuf*</code>相关包并且无法直接下载</li>
<li>可以直接去下载放置对应的位置<code>%GOPATH%/src/google.golang.org</code>并重命名protobuf</li>
</ul>
<p><a href="https://gitcode.net/mirrors/protocolbuffers/protobuf-go?utm_source=csdn_github_accelerator">mirrors &#x2F; protocolbuffers &#x2F; protobuf-go · GitCode</a></p>
<img src="/2023/02/07/win10-an-zhuang-go-protobuf/image-20230207214826403.png" class="asset-class" title="image-20230207214826403">

<h4 id="goland配置"><a href="#goland配置" class="headerlink" title="goland配置"></a>goland配置</h4><img src="/2023/02/07/win10-an-zhuang-go-protobuf/image-20230207215246555.png" class="asset-class" title="image-20230207215246555">

<img src="/2023/02/07/win10-an-zhuang-go-protobuf/image-20230207215255065.png" class="asset-class" title="image-20230207215255065">

<img src="/2023/02/07/win10-an-zhuang-go-protobuf/image-20230207215303121.png" class="asset-class" title="image-20230207215303121">

<img src="/2023/02/07/win10-an-zhuang-go-protobuf/image-20230207215337892.png" class="asset-class" title="image-20230207215337892">

<blockquote>
<p> 缺失包</p>
<ul>
<li><p><code>https://gitcode.net/mirrors/golang/protobuf--镜像</code></p>
</li>
<li><p><code>[golang/protobuf: Go support for Google&#39;s protocol buffers (github.com)](https://github.com/golang/protobuf)</code></p>
<ul>
<li>cannot find package “github.com&#x2F;golang&#x2F;protobuf&#x2F;jsonpb”</li>
</ul>
</li>
<li><p><code>https://gitcode.net/mirrors/golang/net</code>–镜像</p>
</li>
<li><p><code>[golang/net: [mirror\] Go supplementary network libraries (github.com)](https://github.com/golang/net)</code></p>
<ul>
<li>cannot find package “golang.org&#x2F;x&#x2F;net&#x2F;http2”</li>
</ul>
</li>
<li><p><code>https://gitcode.net/mirrors/googleapis/go-genproto</code>–镜像</p>
</li>
<li><p><code>[googleapis/go-genproto: Generated code for Google Cloud client libraries. (github.com)](https://github.com/googleapis/go-genproto)</code></p>
<ul>
<li>cannot find package “google.golang.org&#x2F;genproto&#x2F;googleapis&#x2F;rpc&#x2F;status”</li>
</ul>
</li>
<li><p><code>https://gitcode.net/mirrors/golang/text</code></p>
</li>
<li><p><code>[golang/text: [mirror\] Go text processing support (github.com)](https://github.com/golang/text)</code></p>
<ul>
<li>cannot find package “golang.org&#x2F;x&#x2F;text&#x2F;secure&#x2F;bidirule”</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="MOD安装GRPC"><a href="#MOD安装GRPC" class="headerlink" title="MOD安装GRPC"></a>MOD安装GRPC</h3><blockquote>
<p><code>[Quick start | Go | gRPC](https://grpc.io/docs/languages/go/quickstart/)</code></p>
</blockquote>
<h4 id="生成go-mod文件go-mod-init-ginwork"><a href="#生成go-mod文件go-mod-init-ginwork" class="headerlink" title="生成go.mod文件go mod init ginwork"></a>生成go.mod文件<code>go mod init ginwork</code></h4><pre><code class="prettyprint">module ginwork

go 1.19
</code></pre>
<h4 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h4><pre><code class="prettyprint">go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2
go get google.golang.org/grpc
</code></pre>
<h4 id="配置执行脚本或直接执行命令"><a href="#配置执行脚本或直接执行命令" class="headerlink" title="配置执行脚本或直接执行命令"></a>配置执行脚本或直接执行命令</h4><pre><code class="shell">protoc --go_out=. --go_opt=paths=source_relative  --go-grpc_out=. --go-grpc_opt=paths=source_relative ./*.proto
#命令	      proto文件生成(不包含service)					proto-grpc文件生成(service)							当前目录下的所有proto文件
</code></pre>
<h4 id="proto文件例子"><a href="#proto文件例子" class="headerlink" title="proto文件例子"></a>proto文件例子</h4><pre><code class="prettyprint">syntax = &quot;proto3&quot;;

option go_package = &quot;./;pb&quot;;

package hello_grpc;

message Req &#123;
  string message = 1;
&#125;

message Res &#123;
  string message = 1;
&#125;

service HelloGRPC&#123;
  rpc SayHi(Req) returns (Res);
&#125;
</code></pre>
<h3 id="GRPC-GATEWAY"><a href="#GRPC-GATEWAY" class="headerlink" title="GRPC-GATEWAY"></a>GRPC-GATEWAY</h3><h4 id="安装https-grpc-ecosystem-github-io"><a href="#安装https-grpc-ecosystem-github-io" class="headerlink" title="安装https://grpc-ecosystem.github.io/"></a>安装<code>https://grpc-ecosystem.github.io/</code></h4><pre><code class="prettyprint">go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway@latest
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest #已装
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest #已装


</code></pre>
<h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><blockquote>
<pre><code class="prettyprint">import google/api/annotations.proto
</code></pre>
</blockquote>
<ul>
<li>在包目录新建 google&#x2F;api目录.下载这两个文件放入</li>
</ul>
<p><code>https://github.com/googleapis/googleapis/blob/master/google/api/http.proto</code></p>
<p><code>https://github.com/googleapis/googleapis/blob/master/google/api/annotations.proto</code></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>gin-swagger测试例子</title>
    <url>/2023/02/13/gin-swagger-ce-shi-li-zi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="安装配置地址查找"><a href="#安装配置地址查找" class="headerlink" title="安装配置地址查找"></a>安装配置地址查找</h3><p><a href="https://pkg.go.dev/">Go Packages</a></p>
<img src="/2023/02/13/gin-swagger-ce-shi-li-zi/image-20230213224739572.png" class="asset-class" title="image-20230213224739572">

<h3 id="配置安装"><a href="#配置安装" class="headerlink" title="配置安装"></a>配置安装</h3><pre><code class="prettyprint">#swag 命令安装
go install github.com/swaggo/swag/cmd/swag
#生成docs文件夹
swag init  
# 安装依赖包
go get -u github.com/swaggo/gin-swagger
go get -u github.com/swaggo/files
</code></pre>
<img src="/2023/02/13/gin-swagger-ce-shi-li-zi/image-20230213224812529.png" class="asset-class" title="image-20230213224812529">

<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><h5 id="路由引入"><a href="#路由引入" class="headerlink" title="路由引入"></a>路由引入</h5><pre><code class="prettyprint">package router

import (
    &quot;ginchat/docs&quot; //自己生成的docs
    &quot;ginchat/service&quot;
    &quot;github.com/gin-gonic/gin&quot;
    swaggerfiles &quot;github.com/swaggo/files&quot;
    ginSwagger &quot;github.com/swaggo/gin-swagger&quot;
)

func Router() *gin.Engine &#123;
    r := gin.Default()
    //swagger配置
    docs.SwaggerInfo.BasePath = &quot;&quot;
    r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerfiles.Handler))

    r.GET(&quot;/index&quot;, service.GetIndex)
    r.GET(&quot;/user/getUserList&quot;, service.GetUserList)
    r.GET(&quot;/user/createUser&quot;, service.CreateUser)
    r.GET(&quot;/user/deleteUser&quot;, service.DeleteUser)
    r.POST(&quot;/user/updateUser&quot;, service.UpdateUser)
    return r
&#125;
</code></pre>
<h5 id="接口注解"><a href="#接口注解" class="headerlink" title="接口注解"></a>接口注解</h5><pre><code class="prettyprint">// CreateUser
// @Summary 新增用户
// @Tags 用户模块
// @param name query string false &quot;用户名&quot;
// @param password query string false &quot;密码&quot;
// @param rePassword query string false &quot;确认密码&quot;
// @Success 200 &#123;string&#125; json&#123;&quot;code&quot;,&quot;message&quot;&#125;
// @Router /user/createUser [get]
func CreateUser(c *gin.Context) &#123;
    user := models.UserBasic&#123;&#125;
    user.Name = c.Query(&quot;name&quot;)
    password := c.Query(&quot;password&quot;)
    rePassword := c.Query(&quot;rePassword&quot;)
    if password != rePassword &#123;
        c.JSON(-1, gin.H&#123;
            &quot;message&quot;: &quot;两次密码不一致!&quot;,
        &#125;)
        return
    &#125;
    user.PassWord = password
    models.CreateUser(user)
    c.JSON(200, gin.H&#123;
        &quot;message&quot;: &quot;新增用户成功!&quot;,
    &#125;)
&#125;
</code></pre>
<h5 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h5><img src="/2023/02/13/gin-swagger-ce-shi-li-zi/image-20230213225229134.png" class="asset-class" title="image-20230213225229134">

<img src="/2023/02/13/gin-swagger-ce-shi-li-zi/image-20230213225248347.png" class="asset-class" title="image-20230213225248347">

<h3 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h3><p><code>http://localhost:8081/swagger/index.html</code></p>
<blockquote>
<p>写完配置注解需要执行<code>swag init</code>命令</p>
</blockquote>
<img src="/2023/02/13/gin-swagger-ce-shi-li-zi/image-20230213225419276.png" class="asset-class" title="image-20230213225419276">
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>yml文件语法说明</title>
    <url>/2023/02/25/yml-wen-jian-yu-fa-shuo-ming/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li>key: value；kv之间有空格</li>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用tab，只允许空格</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li>‘#’表示注释</li>
<li>字符串无需加引号，如果要加，’’与””表示字符串内容 会被 转义&#x2F;不转义</li>
</ul>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul>
<li>字面量：单个的、不可再分的。date、boolean、string、number、null</li>
</ul>
<pre><code class="prettyprint">k: v
</code></pre>
<ul>
<li>对象：键值对的集合。map、hash、set、object</li>
</ul>
<pre><code class="prettyprint"># 行内写法：  k: &#123;k1:v1,k2:v2,k3:v3&#125;
k: 
  k1: v1
  k2: v2
  k3: v3
</code></pre>
<ul>
<li>数组：一组按次序排列的值。array、list、queue</li>
</ul>
<pre><code class="prettyprint"># 行内写法：  k: [v1,v2,v3]
# 或者
k:
  - v1
  - v2
  - v3
</code></pre>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code class="prettyprint">@Data
public class Person &#123;
    
    private String userName;
    private Boolean boss;
    private Date birth;
    private Integer age;
    private Pet pet;
    private String[] interests;
    private List&lt;String&gt; animal;
    private Map&lt;String, Object&gt; score;
    private Set&lt;Double&gt; salarys;
    private Map&lt;String, List&lt;Pet&gt;&gt; allPets;
&#125;

@Data
public class Pet &#123;
    private String name;
    private Double weight;
&#125;
</code></pre>
<pre><code class="prettyprint">person:
  userName: zhangsan
  boss: false
  birth: 2019/12/12 20:12:33
  age: 18
  pet:
    name: tomcat
    weight: 23.4
  interests: [篮球,游泳]
  animal:
    - jerry
    - mario
  score:
    english:
      first: 30
      second: 40
      third: 50
    math: [131,140,148]
    chinese: &#123;first: 128,second: 136&#125;
  salarys: [3999,4999.98,5999.99]
  allPets:
    sick:
      - &#123;name: tom&#125;
      - &#123;name: jerry,weight: 47&#125;
    health: [&#123;name: mario,weight: 47&#125;]
</code></pre>
<h4 id="增加配置提示功能"><a href="#增加配置提示功能" class="headerlink" title="增加配置提示功能"></a>增加配置提示功能</h4><p>在pom文件添加依赖</p>
<pre><code class="prettyprint">&lt;!-- 生成json文件可以提示yaml --&gt;
&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
     &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
&lt;!-- 提升效率 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;

&lt;!-------------------------------打包排除依赖---------------------------------&gt;
&lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;excludes&gt;
                        &lt;exclude&gt;
                            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
                        &lt;/exclude&gt;
                    &lt;/excludes&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
</code></pre>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>yml</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM从入门到精通</title>
    <url>/2023/03/01/jvm-cong-ru-men-dao-jing-tong/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>笔记来源：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ">尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）</a></p>
</blockquote>
<h1 id="JVM从入门到精通"><a href="#JVM从入门到精通" class="headerlink" title="JVM从入门到精通"></a>JVM从入门到精通</h1><h2 id="JVM与java体系结构"><a href="#JVM与java体系结构" class="headerlink" title="JVM与java体系结构"></a>JVM与java体系结构</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为java工程师的你曾被伤害过吗？你是否也遇到过这些问题？</p>
<ul>
<li><p>运行着的线上系统突然卡死，系统无法访问，甚至直接OOM</p>
</li>
<li><p>想解决线上JVM GC问题，但却无从下手</p>
</li>
<li><p>新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就gg了</p>
</li>
<li><p>每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼</p>
</li>
</ul>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230301200831315.png" class="asset-class" title="image-20230301200831315">

<p>大部分java开发人员，除会在项目中使用到与java平台相关的各种高精尖技术，对于java技术的核心java虚拟机了解甚少。</p>
<h4 id="java发展的重大事件"><a href="#java发展的重大事件" class="headerlink" title="java发展的重大事件"></a>java发展的重大事件</h4><ul>
<li><p>1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为oak，后期命名为java</p>
</li>
<li><p>1995年，Sun正式发布java和HotJava产品，java首次公开亮相。</p>
</li>
<li><p>1996年1月23日，Sun Microsystems发布了JDK 1.0。</p>
</li>
<li><p>1998年，JDK1.2版本发布。同时，sun发布了JSP&#x2F;Servlet、EJB规范，以及将java分成了J2EE、J2SE和J2ME。这表明了java开始向企业、桌面应用和移动设备应用3大领域挺进。</p>
</li>
<li><p>2000年，JDK1.3发布，java HotSpot Virtual Machine正式发布，成为java的默认虚拟机。</p>
</li>
<li><p>2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。</p>
</li>
<li><p>2003年年底，java平台的Scala正式发布，同年Groovy也加入了java阵营。</p>
</li>
<li><p>2004年，JDK1.5发布。同时JDK1.5改名为javaSE5.0。</p>
</li>
<li><p>2006年，JDK6发布。同年，java开源并建立了OpenJDK。顺理成章，Hotspot虚拟机也成为了openJDK中的默认虚拟机。</p>
</li>
<li><p>2007年，java平台迎来了新伙伴Clojure。</p>
</li>
<li><p>2008年，Oracle收购了BEA，得到了JRockit虚拟机。</p>
</li>
<li><p>2009年，Twitter宣布把后台大部分程序从Ruby迁移到Scala，这是java平台的又一次大规模应用。</p>
</li>
<li><p>2010年，Oracle收购了Sun，获得java商标和最真价值的HotSpot虚拟机。此时，Oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit</p>
</li>
<li><p>2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。</p>
</li>
<li><p>2017年，JDK9发布。将G1设置为默认Gc，替代CMS</p>
</li>
<li><p>同年，IBM的J9开源，形成了现在的Open J9社区</p>
</li>
<li><p>2018年，Android的java侵权案判决，Google赔偿Oracle计88亿美元</p>
</li>
<li><p>同年，Oracle宣告javaEE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会</p>
</li>
<li><p>同年，JDK11发布，LTS版本的JDK，发布革命性的ZGC，调整JDK授权许可</p>
</li>
<li><p>2019年，JDK12发布，加入RedHat领导开发的shenandoah GC</p>
</li>
</ul>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230301201223035.png" class="asset-class" title="image-20230301201223035">

<p>在JDK11之前，OracleJDK中还会存在一些OpenJDK中没有的、闭源的功能。但在JDK11中，我们可以认为OpenJDK和OracleJDK代码实质上已经完全一致的程度。</p>
<p>不过，主流的 JDK 8 在2019年01月之后就被宣布停止更新了。另外， JDK 11 及以后的版本也不再提供免费的长期支持（LTS），而且 JDK 15 和 JDK 16 也不是一个长期支持的版本，最新的 JDK 15 只支持 6 个月时间，到 2021 年 3 月，所以千万不要把 JDK 15 等非长期支持版本用在生产。</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230301201317271.png" class="asset-class" title="image-20230301201317271">

<h4 id="虚拟机与java虚拟机"><a href="#虚拟机与java虚拟机" class="headerlink" title="虚拟机与java虚拟机"></a>虚拟机与java虚拟机</h4><h5 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h5><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为<em>系统虚拟机</em>和<em>程序虚拟机</em>。</p>
<ul>
<li><p>大名鼎鼎的Visual Box，VMware就属于系统虚拟机，<em>它们完全是对物理计算机的仿真</em>，提供了一个可运行完整操作系统的软件平台。</p>
</li>
<li><p>程序虚拟机的典型代表就是java虚拟机，它<em>专门为执行单个计算机程序而设计</em>，在java虚拟机中执行的指令我们称为java字节码指令。</p>
</li>
</ul>
<p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
<h5 id="java虚拟机"><a href="#java虚拟机" class="headerlink" title="java虚拟机"></a>java虚拟机</h5><ul>
<li><p>java虚拟机是一台执行java字节码的虚拟计算机，它拥有独立的运行机制，其运行的java字节码也未必由java语言编译而成。</p>
</li>
<li><p>JVM平台的各种语言可以共享java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</p>
</li>
<li><p>java技术的核心就是java虚拟机（JVM，java Virtual Machine），因为所有的java程序都运行在java虚拟机内部。</p>
</li>
</ul>
<blockquote>
<p> 作用</p>
<ul>
<li>java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器指令执行。每一条java指令，java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</li>
</ul>
<p>特点</p>
<ul>
<li><p>一次编译，到处运行</p>
</li>
<li><p>自动内存管理</p>
</li>
<li><p>自动垃圾回收功能</p>
</li>
</ul>
</blockquote>
<h4 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h4><img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230301201607575.png" class="asset-class" title="image-20230301201607575">

<p>JVM是运行在操作系统之上的，它与硬件没有直接的交互</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230301201630695.png" class="asset-class" title="image-20230301201630695">

<h4 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h4><img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230301201722582.png" class="asset-class" title="image-20230301201722582">

<ul>
<li><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</p>
</li>
<li><p>它采用解释器与即时编译器并存的架构。</p>
</li>
<li><p>在今天，java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++程序一较高下的地步。</p>
</li>
</ul>
<h4 id="java代码执行流程"><a href="#java代码执行流程" class="headerlink" title="java代码执行流程"></a>java代码执行流程</h4><img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230301201857182.png" class="asset-class" title="image-20230301201857182">

<h4 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h4><p>java编译器输入的指令流基本上是一种基于<em>栈的指令集架构</em>，另外一种指令集架构则是基于<em>寄存器的指令集架构</em></p>
<p><strong>基于栈式架构的特点</strong></p>
<ul>
<li><p>设计和实现更简单，适用于资源受限的系统</p>
</li>
<li><p>避开了寄存器的分配难题：使用零地址指令方式分配</p>
</li>
<li><p>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</p>
</li>
<li><p>不需要硬件支持，可移植性更好，更好实现跨平台</p>
</li>
</ul>
<p><strong>基于寄存器架构的特点</strong></p>
<ul>
<li><p>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机</p>
</li>
<li><p>指令集架构则完全依赖硬件，可移植性差</p>
</li>
<li><p>性能优秀和执行更高效</p>
</li>
<li><p>花费更少的指令去完成一项操作</p>
</li>
<li><p>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</p>
</li>
</ul>
<p><strong>举例1</strong></p>
<p>同样执行2+3这种逻辑操作，其指令分别如下：</p>
<p>基于栈的计算流程（以java虚拟机为例）:<code>反编译javap -v StackStruTest.class</code></p>
<pre><code class="prettyprint">public static void main(String[] args) &#123;
    int i = 2;
    int j = 3;
    int k = i + j;
&#125;
</code></pre>
<pre><code class="prettyprint">stack=2, locals=4, args_size=1
    0: iconst_2 //常量2入栈
    1: istore_1
    2: iconst_3 // 常量3入栈
    3: istore_2
    4: iload_1
    5: iload_2
    6: iadd //常量2/3出栈，执行相加
    7: istore_3 // 结果5入栈
    8: return
</code></pre>
<p>而基于寄存器的计算流程</p>
<pre><code class="prettyprint">mov eax,2 //将eax寄存器的值设为1
add eax,3 //使eax寄存器的值加3
</code></pre>
<p><strong>举例2</strong></p>
<pre><code class="prettyprint">public int calc()&#123;
    int a=100;
    int b=200;
    int c=300;
    return (a + b) * c;
&#125;
</code></pre>
<pre><code class="prettyprint"> Code:
      stack=2, locals=4, args_size=1
         0: bipush        100
         2: istore_1
         3: sipush        200
         6: istore_2
         7: sipush        300
        10: istore_3
        11: iload_1
        12: iload_2
        13: iadd
        14: iload_3
        15: imul
        16: ireturn
</code></pre>
<p><strong>总结</strong></p>
<p><em>由于跨平台性的设计，java的指令都是根据栈来设计的。</em>不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<h4 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h4><h5 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h5><p>java虚拟机的启动是通过引导类加载器（<code>bootstrap class loader</code>）创建一个初始类（<code>initial class</code>）来完成的，这个类是由虚拟机的具体实现指定的。</p>
<h5 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h5><ul>
<li><p>一个运行中的java虚拟机有着一个清晰的任务：执行java程序。</p>
</li>
<li><p>程序开始执行时他才运行，程序结束时他就停止。</p>
</li>
<li><p>执行一个所谓的java程序的时候，真真正正在执行的是一个叫做java虚拟机的进程。</p>
</li>
</ul>
<h5 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h5><ul>
<li><p>程序正常执行结束</p>
</li>
<li><p>程序在执行过程中遇到了异常或错误而异常终止</p>
</li>
<li><p>由于操作系统用现错误而导致java虚拟机进程终止</p>
</li>
<li><p>某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且java安全管理器也允许这次exit或halt操作。</p>
</li>
<li><p>除此之外，JNI（java Native Interface）规范描述了用JNI Invocation API来加载或卸载 java虚拟机时，java虚拟机的退出情况。</p>
</li>
</ul>
<h4 id="JVM的发展历程"><a href="#JVM的发展历程" class="headerlink" title="JVM的发展历程"></a>JVM的发展历程</h4><h5 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h5><ul>
<li><p>早在1996年java1.0版本的时候，Sun公司发布了一款名为sun classic VM的java虚拟机，它同时也是世界上第一款商用java虚拟机，JDK1.4时完全被淘汰。</p>
</li>
<li><p>这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。</p>
</li>
<li><p>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</p>
</li>
<li><p>现在hotspot内置了此虚拟机。</p>
</li>
</ul>
<h5 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h5><ul>
<li><p>为了解决上一个虚拟机问题，jdk1.2时，Sun提供了此虚拟机。</p>
</li>
<li><p>Exact Memory Management：准确式内存管理</p>
</li>
<li><ul>
<li>也可以叫Non-Conservative&#x2F;Accurate Memory Management</li>
</ul>
</li>
<li><ul>
<li>虚拟机可以知道内存中某个位置的数据具体是什么类型。</li>
</ul>
</li>
<li><p>具备现代高性能虚拟机的维形</p>
</li>
<li><ul>
<li>热点探测</li>
</ul>
</li>
<li><ul>
<li>编译器与解释器混合工作模式</li>
</ul>
</li>
<li><p>只在solaris平台短暂使用，其他平台上还是classic vm</p>
</li>
<li><ul>
<li>英雄气短，终被Hotspot虚拟机替换</li>
</ul>
</li>
</ul>
<h5 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h5><ul>
<li><p>HotSpot历史</p>
</li>
<li><ul>
<li>最初由一家名为“Longview Technologies”的小公司设计</li>
</ul>
</li>
<li><ul>
<li>1997年，此公司被sun收购；2009年，Sun公司被甲骨文收购。</li>
</ul>
</li>
<li><ul>
<li>JDK1.3时，HotSpot VM成为默认虚拟机</li>
</ul>
</li>
<li><p>目前Hotspot占有绝对的市场地位，称霸武林。</p>
</li>
<li><ul>
<li>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</li>
</ul>
</li>
<li><ul>
<li>Sun &#x2F; Oracle JDK 和 OpenJDK 的默认虚拟机</li>
</ul>
</li>
<li><ul>
<li>因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的Gc机制。（比如其他两个商用虚机都没有方法区的概念）</li>
</ul>
</li>
<li><p>从服务器、桌面到移动端、嵌入式都有应用。</p>
</li>
<li><p>名称中的HotSpot指的就是它的热点代码探测技术。</p>
</li>
<li><ul>
<li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li>
</ul>
</li>
<li><ul>
<li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li>
</ul>
</li>
</ul>
<h5 id="JRockit"><a href="#JRockit" class="headerlink" title="JRockit"></a>JRockit</h5><ul>
<li><p>专注于服务器端应用</p>
</li>
<li><ul>
<li>它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li>
</ul>
</li>
<li><p>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。</p>
</li>
<li><ul>
<li>使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</li>
</ul>
</li>
<li><p>优势：全面的java运行时解决方案组合</p>
</li>
<li><ul>
<li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</li>
</ul>
</li>
<li><ul>
<li>MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li>
</ul>
</li>
<li><p>2008年，JRockit被oracle收购。</p>
</li>
<li><p>Oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p>
</li>
<li><p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p>
</li>
</ul>
<h5 id="IBM的J9"><a href="#IBM的J9" class="headerlink" title="IBM的J9"></a>IBM的J9</h5><ul>
<li><p>全称：IBM Technology for java Virtual Machine，简称IT4J，内部代号：J9</p>
</li>
<li><p>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM</p>
</li>
<li><p>广泛用于IBM的各种java产品。</p>
</li>
<li><p>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的java虚拟机。</p>
</li>
<li><p>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给EClipse基金会管理，也称为Eclipse OpenJ9</p>
</li>
</ul>
<h5 id="KVM和CDC-x2F-CLDC-Hotspot"><a href="#KVM和CDC-x2F-CLDC-Hotspot" class="headerlink" title="KVM和CDC &#x2F; CLDC Hotspot"></a>KVM和CDC &#x2F; CLDC Hotspot</h5><ul>
<li><p>Oracle在java ME产品线上的两款虚拟机为：CDC&#x2F;CLDC HotSpot Implementation VM</p>
</li>
<li><p>KVM（Kilobyte）是CLDC-HI早期产品</p>
</li>
<li><p>目前移动领域地位尴尬，智能机被Android和iOS二分天下。</p>
</li>
<li><p>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p>
</li>
<li><ul>
<li>智能控制器、传感器</li>
</ul>
</li>
<li><ul>
<li>老人手机、经济欠发达地区的功能手机</li>
</ul>
</li>
<li><p>所有的虚拟机的原则：一次编译，到处运行。</p>
</li>
</ul>
<h5 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h5><ul>
<li><p>前面三大“高性能java虚拟机”使用在通用硬件平台上这里Azul VW和BEA Liquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机</p>
</li>
<li><ul>
<li>高性能java虚拟机中的战斗机。</li>
</ul>
</li>
<li><p>Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的java虚拟机。</p>
</li>
<li><p>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</p>
</li>
<li><p>2010年，AzulSystems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。</p>
</li>
</ul>
<h5 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h5><ul>
<li><p>高性能java虚拟机中的战斗机。</p>
</li>
<li><p>BEA公司开发的，直接运行在自家Hypervisor系统上</p>
</li>
<li><p>Liquid VM即是现在的JRockit VE（Virtual Edition），Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</p>
</li>
<li><p>随着JRockit虚拟机终止开发，Liquid vM项目也停止了。</p>
</li>
</ul>
<h5 id="Apache-Harmony"><a href="#Apache-Harmony" class="headerlink" title="Apache Harmony"></a>Apache Harmony</h5><ul>
<li><p>Apache也曾经推出过与JDK1.5和JDK1.6兼容的java运行平台Apache Harmony。</p>
</li>
<li><p>它是IBM和Intel联合开发的开源JVM，受到同样开源的OpenJDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</p>
</li>
<li><p>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的java类库代码吸纳进了Android SDK。</p>
</li>
</ul>
<h5 id="Micorsoft-JVM"><a href="#Micorsoft-JVM" class="headerlink" title="Micorsoft JVM"></a>Micorsoft JVM</h5><ul>
<li><p>微软为了在IE3浏览器中支持java Applets，开发了Microsoft JVM。</p>
</li>
<li><p>只能在Windows平台下运行。但确是当时Windows下性能最好的java VM。</p>
</li>
<li><p>1997年，Sun以侵犯商标、不正当竞争罪名指控微软成功，赔了Sun很多钱。微软WindowsXP SP3中抹掉了其VM。现在Windows上安装的jdk都是HotSpot。</p>
</li>
</ul>
<h5 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h5><ul>
<li><p>由AliJVM团队发布。阿里，国内使用java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p>
</li>
<li><p>基于OpenJDK 开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里java体系的基石。</p>
</li>
<li><p>基于OpenJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版java虚拟机。</p>
</li>
<li><ul>
<li>创新的GCIH（GC invisible heap）技术实现了off-heap，即将生命周期较长的java对象从heap中移到heap之外，并且GC不能管理GCIH内部的java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</li>
</ul>
</li>
<li><ul>
<li>GCIH中的对象还能够在多个java虚拟机进程中实现共享</li>
</ul>
</li>
<li><ul>
<li>使用crc32指令实现JVM intrinsic 降低JNI 的调用开销</li>
</ul>
</li>
<li><ul>
<li>PMU hardware 的java profiling tool 和诊断协助功能</li>
</ul>
</li>
<li><ul>
<li>针对大数据场景的ZenGc</li>
</ul>
</li>
<li><p>taobao vm应用在阿里产品上性能高，硬件严重依赖intel的cpu，损失了兼容性，但提高了性能</p>
</li>
<li><ul>
<li>目前已经在淘宝、天猫上线，把oracle官方JvM版本全部替换了。</li>
</ul>
</li>
</ul>
<h5 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h5><ul>
<li><p>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</p>
</li>
<li><p>Dalvik VM只能称作虚拟机，而不能称作“java虚拟机”，它没有遵循 java虚拟机规范，不能直接执行java的Class文件</p>
</li>
<li><p>基于寄存器架构，不是jvm的栈架构。</p>
</li>
<li><p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</p>
</li>
<li><ul>
<li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用java语法编写应用程序，可以直接使用大部分的java API等。</li>
</ul>
</li>
<li><p>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。</p>
</li>
</ul>
<h5 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h5><ul>
<li><p>2018年4月，oracle Labs公开了Graal VM，号称 “Run Programs Faster Anywhere”，野心勃勃。与1995年java的”write once，run anywhere”遥相呼应。</p>
</li>
<li><p>Graal VM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：java、Scala、Groovy、Kotlin；C、C++、javascript、Ruby、Python、R等</p>
</li>
<li><p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p>
</li>
<li><p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p>
</li>
<li><p>如果说HotSpot有一天真的被取代，Graal VM希望最大。但是java的软件生态没有丝毫变化。</p>
</li>
</ul>
<blockquote>
<p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以Oracle HotSpot VM为默认虚拟机。</p>
</blockquote>
<h2 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h2><h3 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h3><ul>
<li>class文件</li>
<li>类加载器子系统</li>
<li>运行时数据区<ul>
<li>方法区</li>
<li>堆</li>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
</li>
<li>执行引擎</li>
<li>本地方法接口</li>
<li>本地方法库</li>
</ul>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/1677722582676.png" class="asset-class" width="1677722683757">

<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/1677722683757.png" class="asset-class" width="1677722683757">

<h3 id="类加载器与类的加载过程"><a href="#类加载器与类的加载过程" class="headerlink" title="类加载器与类的加载过程"></a>类加载器与类的加载过程</h3><p><strong>类加载子系统</strong></p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/1677723779525.png" class="asset-class" width="1677723779525">

<ul>
<li>类加载器子系统负责从文件系统或网络中加载class文件，class文件再文件开头有特定的文件标识</li>
<li><code>ClassLoader</code>只负责class文件的加载，至于它是否运行，则由执行引擎 <code>Execution Engine</code> 决定</li>
<li>加载的类信息存放于方法区，除类的信息外，方法区还会存放运行时常量池信息，可能还包括字符串字面量和数字字面量（这部分常量信息是 class 文件中常量池部分的内存映射 ）</li>
</ul>
<p><strong>类加载器ClassLoader角色</strong></p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/1677724336854.png" class="asset-class" width="1677724336854">

<ul>
<li><code>class file</code>存在本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例</li>
<li><code>class file</code> 加载到JVM中，被称为DNA元数据模板，存放在方法区</li>
<li>在<code>.class</code>文件&gt;<code>JVM</code>&gt;最终成为元数据模板，此过程就要一个运输工具（类加载器<code>ClassLoader</code>）,扮演一个快递员的角色</li>
</ul>
<p><strong>类的加载过程</strong></p>
<pre><code class="prettyprint">public class HelloLoader &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;Hello World!&quot;);
    &#125;
&#125;
</code></pre>
<p>用流程图表示上述示例代码：</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/1677724634138.png" class="asset-class" width="1677724634138">

<h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/1677724652399.png" class="asset-class" width="1677724652399">

<ul>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存汇总生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<p><strong>补充：加载class文件的方式</strong></p>
<ul>
<li>从本地系统汇总直接加载</li>
<li>通过网络获取，例如：Web Applet</li>
<li>从zip压缩包中读取，成文日后jar、war格式的基础</li>
<li>运行时计算生成，动态代理技术</li>
<li>从专有数据库中提取的.class文件</li>
<li>从加密文件中获取，典型的防Class文件呗反编译的保护措施</li>
</ul>
<h4 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h4><p><strong>验证（Verify）:</strong></p>
<ul>
<li>目的在于确保<code>Class</code>文件的字节流中包含信息符合当前虚拟机要求，保证被加载的正确性，不会危害虚拟机自身安全</li>
<li>主要包括四种验证，<em>文件格式验证</em>、<em>元数据验证</em>、<em>字节码验证</em>、<em>符号引用验证</em></li>
</ul>
<p><strong>准备（Prepare）：</strong></p>
<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值</li>
<li>这里不包含用<code>final</code>修饰的<code>static</code>,因为<code>final</code>在编译的时候就会分配，准备阶段会显示初始化</li>
<li>这里不会为实例变量分配出事话，类变量会分配在方法区中，而实例变量实惠随着对象一起分配在堆中</li>
</ul>
<p><strong>解析（Resolve）:</strong></p>
<ul>
<li>将常量池内的符号引用转换为直接引用的过程</li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</li>
<li>符号引用就是一组符号来描述所引用的目标，符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中，直接引用就是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类等。对应常量池中的<code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_inf</code>、<code>CONSTANT_Methodref_info</code>等</li>
</ul>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><ul>
<li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>过程</li>
<li>此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行</li>
<li><code>&lt;clinit&gt;()</code>不同于类的构造器。（构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</li>
<li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li>
<li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法子啊多线程下呗同步加锁</li>
</ul>
<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p>JVM支持两种类型的类加载器，分别为<strong>引导类加载器（Bootstrap ClassLoader）</strong>和<strong>自定义类加载器（User-Defined ClassLoader）</strong></p>
<p>自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是java虚拟机规范却没有这么定义，而是将<strong>所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></p>
<p>无论类加载器的类型如果划分，在程序中我们最常见的类加载器始终只有3个，如下所示：</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/1677727037908.png" class="asset-class" width="1677727037908">

<p>这里的四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。</p>
<h4 id="虚拟机自带的类加载器"><a href="#虚拟机自带的类加载器" class="headerlink" title="虚拟机自带的类加载器"></a>虚拟机自带的类加载器</h4><pre><code class="prettyprint">public class ClassLoaderTest &#123;
    public static void main(String[] args) &#123;
        //获取系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2
        //获取其上层：扩展类加载器
        ClassLoader extClassLoader = systemClassLoader.getParent();
        System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@1b6d3586
        //获取其上层:获取不到引导类加载器
        ClassLoader bootstrapClassLoader = extClassLoader.getParent();
        System.out.println(bootstrapClassLoader);//null

        //对于用户自定类类型来说:默认使用系统类加载器进行加载
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2

        //String类使用引导类加载器进行加载的。-------&gt;java的核心类库都是使用引导类加载器进行加载的
        ClassLoader classLoader1 = String.class.getClassLoader();
        System.out.println(classLoader1); //null
    &#125;
&#125;
</code></pre>
<p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p>
<ul>
<li>这个类加载器使用C&#x2F;C++语言实现的，嵌套在JVM内部</li>
<li>它用来加载java的核心库（ <code>%java_HOME%\jre\lib\rt.jar</code> , <code>resources.jar</code> 或 <code>sun.boot.class.path</code> 路径下的内容），用于提供JVM自身需要的类</li>
<li>并不继承自<code>java.lang.ClassLoader</code>,没有父类加载器</li>
<li>加载扩展类加载器和应用程序类加载器，并指定为他们的父类加载器</li>
<li>出于安全考虑，<code>Bootstrap</code> 启动类加载器只加载报名为java、javax、sun等开头的类</li>
</ul>
<p><strong>扩展类加载器（Extension ClassLoader）</strong></p>
<ul>
<li>java语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现</li>
<li>派生于<code>ClassLoader</code>类</li>
<li>父类加载器为启动类加载器</li>
<li>从<code>java.ext.dirs</code> 系统属性所指定的目录中加载类库，或从JDK安装目录的<code>jre/lib/ext</code>子目录（扩展目录）下加载类库，如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li>
</ul>
<p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p>
<ul>
<li>java语言编写，有<code>sun.misc.Launcher$AppClassLoader</code>实现</li>
<li>派生于<code>ClassLoader</code>类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环节变量<code>classpath</code>或系统属性<code>java.class.path</code>指定路径下的类库</li>
<li>该类加载器是程序用默认的类加载器，一般来说，java应用的类都是由它完成加载</li>
<li>通过<code>java.lang.ClassLoader#getSystemClassLoader()</code>方法可以获取到该类加载器</li>
</ul>
<pre><code class="prettyprint">public class ClassLoaderTest1 &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;*****************启动类加载器*******************&quot;);
        //获取Bootstrap ClassLoader 能够加载的api的路径
        URL[] urLs = Launcher.getBootstrapClassPath().getURLs();
        for (URL element : urLs) &#123;
            System.out.println(element.toExternalForm());
        &#125;
        //从上面的路径中随意选择一个类，来看看他的类加载器是什么:引导类加载器
        ClassLoader classLoader = Provider.class.getClassLoader();
        System.out.println(classLoader);// null
        System.out.println(&quot;*****************扩展类加载器*******************&quot;);
        String extDirs = System.getProperty(&quot;java.ext.dirs&quot;);
        for (String path : extDirs.split(&quot;;&quot;)) &#123;
            System.out.println(path);
        &#125;
        //从上面的路径中随意选择一个类，来看看他的类加载器是什么:扩展类加载器
        ClassLoader classLoader1 = SunEC.class.getClassLoader();
        System.out.println(classLoader1);//sun.misc.Launcher$ExtClassLoader@38af3868
    &#125;
&#125;
</code></pre>
<h4 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h4><p>在java的日常应用程序开发中，类的加载几乎又虚拟机自带的类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式</p>
<p>为什么要自定义类加载器？</p>
<ul>
<li>隔离加载类</li>
<li>修改类的加载方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ul>
<p>用户自定义类加载器实现步骤</p>
<ul>
<li>开发人员可以通过继承抽象类<code>java.lang.ClassLoader</code> 类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在JDK1.2之前，在自定义类加载器时，总会继承<code>ClassLoader</code> 类并重写<code>loadClass()</code> 方法，从而实现自定义的类加载器，但是在JDK1.2之后，已不再建议用户取覆盖<code>loadClass()</code> 方法，而是建议把自定义的类加载逻辑写在<code>findClass()</code>方法中</li>
<li>在编写自定义类加载器，如果没有太过于复杂的需求，可以直接继承<code>URLClassLoader</code>类，这样就可以避免自己去编写<code>findClass()</code>方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>
</ul>
<pre><code class="prettyprint">public class CustomClassLoader extends ClassLoader&#123;
    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;
        try &#123;
            byte[] result = getClassFromCustomPath(name);
            if(result == null)&#123;
                throw new FileNotFoundException();
            &#125;else&#123;
                return defineClass(name,result,0,result.length);
            &#125;

        &#125; catch (FileNotFoundException e) &#123;
            e.printStackTrace();
        &#125;
        throw new ClassNotFoundException(name);
    &#125;

    private byte[] getClassFromCustomPath(String name) &#123;
        // 从自定义路径中加载指定类：
        // 如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作
        return null;
    &#125;
&#125;
</code></pre>
<h3 id="ClassLoader的使用说明"><a href="#ClassLoader的使用说明" class="headerlink" title="ClassLoader的使用说明"></a>ClassLoader的使用说明</h3><p><code>ClassLoader</code>类是一个抽象类，其后所有的类加载器都继承自<code>ClassLoader</code>（不包含启动类加载器）</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/1677733682107.png" class="asset-class" width="1677733682107">

<p><code>sum.misc.Launcher</code>它是java虚拟机的入口应用</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/1677733738406.png" class="asset-class" width="1677733738406">

<p><strong>获取<code>ClassLoderde</code>的方式</strong></p>
<ul>
<li><p>获取当前的<code>ClassLoader</code></p>
<pre><code class="prettyprint">clazz.getClassLoader()
</code></pre>
</li>
<li><p>获取当前线程上下文的<code>ClassLoader</code></p>
<pre><code class="prettyprint">Thread.currentThread().getContextClassLoader()
</code></pre>
</li>
<li><p>获取系统的ClassLoader</p>
<pre><code class="prettyprint">ClassLoader.getSystemClassLoader()
</code></pre>
</li>
<li><p>获取调用者的ClassLoader</p>
<pre><code class="prettyprint">DriverManager.getCallerClassLoader()
</code></pre>
</li>
</ul>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类的时候才会将他的class文件加载到内存生成class对象。而且加载某个类的class文件时，java虚拟机采用的是双亲委派模式。即把请求交由父类加载器出来，它是一种任务委派模式</p>
<p><strong>工作原理</strong></p>
<ul>
<li>如果一个类加载器收到类加载的请求，他并不会自己先去加载，而是把这个请求委托给父类加载器去执行</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终到达顶层的启动类加载器</li>
<li>如果父类加载器可以完成加载任务，就成功返回，若父类加载器无法完成此家在任务，子加载器才会尝试自己去加载</li>
</ul>
<p><strong>举例</strong></p>
<p>当我们加载<code>jdbc.jar</code> 用于实现数据库连接的时候，首先需要知道的是 <code>jdbc.jar</code> 是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从加载器加载SPI核心类，然后加载SPI接口类，接着进行反向委派，通过线程上下文类加载器进行实现类 <code>jdbc.jar</code> 的加载</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/1677734435180.png" class="asset-class" width="1677734435180">



<p><strong>优势</strong></p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改<ul>
<li>自定义类：<code>java.lang.String</code></li>
<li>自定义类：<code>java.lang.ShkStart</code>(编译报错：阻止创建 <code>java.lang </code>开头的类)</li>
</ul>
</li>
</ul>
<p><strong>沙箱安全机制</strong></p>
<p>自定义 String 类，但是在加载自定义Stirng类的时候会率先使用引导类加载器加载，而引导类加载器在加载过程中会先加载jdk自带的文件（rt.jar包中的java&#x2F;lang&#x2F;String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类，这样可以保证对java核心源代码的保护，这就是沙箱安全机制</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>如何判断两个class对象是否相同</strong></p>
<p>在JVM中标识两个class对象是否为同一个类存在两个必要条件</p>
<ul>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的<code>ClassLoader</code>（指<code>ClassLoder</code>实例对象）必须相同</li>
</ul>
<p>在JVM中，即使两个类对象（class对象）来源同一个class文件，被同一个虚拟机所加载，但只要加载她们的ClassLoader实例对象不同，那么这两个类对象也是不相同的</p>
<p><strong>对类加载器的引用</strong></p>
<p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会<strong>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>
<p><strong>类的主动使用和被动使用</strong></p>
<p>java程序对类的使用方式分为：主动使用和被动使用。</p>
<p>主动使用，又分为七种情况：</p>
<ul>
<li>创建类的实例</li>
<li>访问某个类或接口中的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（如：Class.forName(“com.rocpenghua.Test”）</li>
<li>初始化一个类的子类</li>
<li>java虚拟机启动时被标明为启动类的类</li>
<li>JDK7开始提供动态语言支持<ul>
<li><code>java.lang.invoke.MethodHandle</code> 实例的解析结果</li>
<li><code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>句柄对应的类没有初始化，则初始化</li>
</ul>
</li>
</ul>
<p>除了以上七种情况，其他使用java类的方式都被看作是对<strong>类的被动使用</strong>，都<strong>不会导致类的初始化</strong>。</p>
<h2 id="运行时数据区及程序计数器"><a href="#运行时数据区及程序计数器" class="headerlink" title="运行时数据区及程序计数器"></a>运行时数据区及程序计数器</h2><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230302200219087.png" class="asset-class" title="image-20230302200219087">

<p>当我们通过前面的：类的加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230302201258990.png" class="asset-class" title="image-20230302201258990">

<p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行，JVM内存布局规定了java在运行过程中内存申请、分配、管理的策略，保证了JVM的高校稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230302202038832.png" class="asset-class" title="image-20230302202038832">

<p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230302202519412.png" class="asset-class" title="image-20230302202519412">

<p>java虚拟机定义了若干中程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁，另外一些测试与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁</p>
<p>灰色的为单独线程私有的，红色的为多个线程共享的。</p>
<ul>
<li>每个线程：独立包括程序计数器、栈、本地栈</li>
<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>
</ul>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230302212030169.png" class="asset-class" title="image-20230302212030169">

<p>每个JVM只有一个Runtime实例。即运行时环境，相当于内存结构的中间的运行时环境</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230302212205011.png" class="asset-class" title="image-20230302212205011">

<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>线程是一个程序里的运行单元，JVM允许一个应用有多个线程并行的执行，在HotSpot JVM里，每个线程都与操作系统的本地线程直接映射</p>
<p>当一个java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。java线程执行中之后，本地线程也会回收</p>
<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用java线程中的<code>run()</code>方法</p>
<h4 id="JVM系统线程"><a href="#JVM系统线程" class="headerlink" title="JVM系统线程"></a>JVM系统线程</h4><p>如果你使用<code>jconsole</code> 或者时任何一个调试工具，都能看到后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[] args)</code>的<code>main</code>线程自己创建的线程</p>
<p>后台系统线程在HotSpot JVM里主要是以下几个：</p>
<ul>
<li><strong>虚拟机线程：</strong>这种线程的操作是需要JVM 达到安全点才会出现，这些操作必须在不同的线程中发生的原因时他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括 <code>stop-the-world</code> 的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li>
<li><strong>周期任务线程：</strong>这种线程的操作是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li>
<li><strong>GC线程：</strong>这种线程对在JVM里不同种类的垃圾收集行为提供支持</li>
<li><strong>编译线程：</strong>这种线程在运行时会将字节码编译成本地代码</li>
<li><strong>信号调度线程：</strong>这种线程接受信号并发送给JVM，在它内部通过调用适当的方法进行处理</li>
</ul>
<h3 id="程序计数器-PC寄存器"><a href="#程序计数器-PC寄存器" class="headerlink" title="程序计数器(PC寄存器)"></a>程序计数器(PC寄存器)</h3><p>JVM中的程序计数器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指定相关的现场信息。CPU只有把数据装载到寄存器才能运行。这里并非广义上所指的物理寄存器，或许将其翻译为PC计数器会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器时对物理PC寄存器的一种抽象模拟</strong></p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230302220920611.png" class="asset-class" title="image-20230302220920611">

<p><strong>作用</strong></p>
<p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码，由执行引擎读取下一条指令</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230302221030663.png" class="asset-class" title="image-20230302221030663">

<p>它是一块很小的内存空间，几乎可以忽略不计，也是<strong>运行速度最快的存储区域</strong></p>
<p>在JVM规范中，每个线程都有它自己的程序计数器，时线程私有的，生命周期和线程的生命周期保持一致</p>
<p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的java方法的JVM指令地址。或者，如果是在执行native方法，则是未指定值（undefined）</p>
<p>它是程序控制流的E指示器，分支、循环、跳转、一场处理、线程恢复等基础功能都需要依赖这个计数器来完成</p>
<p>字节码解释器工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</p>
<p>它是唯一一个在java虚拟机规范中没有规定任务OutofMemoryError情况的区域</p>
<p><strong>举例说明</strong></p>
<pre><code class="prettyprint">public int minus()&#123;
    int c = 3;
    int d = 4; 
    return c - d;
&#125;
</code></pre>
<p>字节码文件：</p>
<pre><code class="prettyprint">0: iconst_3
1: istore_1
2: iconst_4
3: istore_2
4: iload_1
5: iload_2
6: isub
7: ireturn
</code></pre>
<p><strong>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</strong></p>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p>
<p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230302221800904.png" class="asset-class" title="image-20230302221800904">

<p><strong>PC寄存器为什么被设定为私有的？</strong></p>
<p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令</p>
<p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>
<p><strong>CPU时间片</strong></p>
<p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p>
<p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p>
<p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>
<img src="2023-03-01-JVM从入门到精通/image-20230302222015842.png" alt="image-20230302222015842"  />

<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h3><h4 id="虚拟机栈出现的背景"><a href="#虚拟机栈出现的背景" class="headerlink" title="虚拟机栈出现的背景"></a>虚拟机栈出现的背景</h4><p>由于跨平台性的设计，java的指令都是根据栈来设计的，不同平台CPU架构不同，所以不能设计为基于寄存器的。</p>
<blockquote>
<p>优点：跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</p>
</blockquote>
<h4 id="初步印象"><a href="#初步印象" class="headerlink" title="初步印象"></a>初步印象</h4><p>有不少java开发人员一提到java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有java堆（<code>heap</code>）和java栈（<code>stack</code>）？为什么？</p>
<h4 id="内存中的栈与堆"><a href="#内存中的栈与堆" class="headerlink" title="内存中的栈与堆"></a>内存中的栈与堆</h4><p><strong>栈是运行时的单位，而堆是存储的单位</strong></p>
<ul>
<li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据</li>
<li>堆解决的是数据存储的问题，即数据怎么放，放的位置</li>
</ul>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/1677818499466.png" class="asset-class" width="1677818499466">

<h4 id="虚拟机栈基本内容"><a href="#虚拟机栈基本内容" class="headerlink" title="虚拟机栈基本内容"></a>虚拟机栈基本内容</h4><h5 id="java虚拟机栈是什么？"><a href="#java虚拟机栈是什么？" class="headerlink" title="java虚拟机栈是什么？"></a>java虚拟机栈是什么？</h5><p>java虚拟机栈（java Virtual Machine Stack）,早期也叫java栈，每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的java方法调用，是线程私有的</p>
<h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p>虚拟机栈的生命周期和线程一致</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>主管java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回</p>
<h5 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h5><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</p>
<p>JVM直接对java栈的操作只有两个：</p>
<ul>
<li>每个方法执行，伴随着进栈（入栈，压栈）</li>
<li>执行结束后的出栈工作</li>
</ul>
<p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p>
<h5 id="面试题：开发中遇到哪些异常？"><a href="#面试题：开发中遇到哪些异常？" class="headerlink" title="面试题：开发中遇到哪些异常？"></a>面试题：开发中遇到哪些异常？</h5><p><strong>栈中可能出现的异常</strong></p>
<p>java虚拟机规范允许<strong>java栈的大小是动态的或者是固定不变的</strong></p>
<ul>
<li>如果采用固定的大小的java虚拟机栈，那每个线程的java虚拟机栈容量可以再线程创建的时候独立选定。如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量，java虚拟机将会抛出一个<code>StackOverFlowError</code>异常**(栈溢出)**</li>
<li>如果java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者再创建新的线程时没有足够的内存区创建对应的虚拟机栈，那java虚拟机将会抛出一个<code>OutOfMemoryError</code><strong>（堆溢出）</strong></li>
</ul>
<p>模拟栈溢出：死循环</p>
<pre><code class="prettyprint">public static void main(String[] args) &#123;
    test();
&#125;
public static void test() &#123;
    test();
&#125;
//抛出异常：Exception in thread&quot;main&quot;java.lang.StackoverflowError
//程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。
</code></pre>
<p><strong>设置栈内存大小</strong></p>
<p>我们可以使用参数 <code>-Xss</code>选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p>
<pre><code class="prettyprint">public class StackDeepTest&#123; 
    private static int count=0; 
    public static void recursion()&#123;
        count++; 
        recursion(); 
    &#125;
    public static void main(String args[])&#123;
        try&#123;
            recursion();
        &#125; catch (Throwable e)&#123;
            System.out.println(&quot;deep of calling=&quot;+count); 
            e.printstackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="栈的存储单元"><a href="#栈的存储单元" class="headerlink" title="栈的存储单元"></a>栈的存储单元</h3><h4 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h4><p>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧（Stack Frame）的格式存在</strong></p>
<p>在这个线程上正在执行的每个方法都各自对应一个<strong>栈帧（Stack Frame）</strong></p>
<p>栈帧是一个内存区块，是一个数据集，维系着方法的执行过程中的各种数据信息</p>
<h4 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h4><p>JVM直接对java栈的操作只有两个，就是对 <strong>栈帧的压栈和出栈，遵循“先进后出&#x2F;后进先出原则”</strong></p>
<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>,定义这个方法的类就是<strong>当前类（Current Class）</strong></p>
<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</p>
<p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/1677832779628.png" class="asset-class" width="1677832779628">

<p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另一个线程的栈帧</p>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</p>
<p>java方法有两种返回函数的方法，<strong>一种是正常的函数返回，使用return指令；另一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出</strong></p>
<pre><code class="prettyprint">public class CurrentFrameTest&#123;
    public void methodA()&#123;
        system.out.println（&quot;当前栈帧对应的方法-&gt;methodA&quot;);
        methodB();
        system.out.println（&quot;当前栈帧对应的方法-&gt;methodA&quot;);
    &#125;
    public void methodB()&#123;
        System.out.println（&quot;当前栈帧对应的方法-&gt;methodB&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><ul>
<li><p><strong>局部变量表（Local Variables）</strong></p>
</li>
<li><p><strong>操作数栈（operand Stack）（表达式栈）</strong></p>
</li>
<li><p>动态链接（DynamicLinking）（指向运行时常量池的方法引用）</p>
</li>
<li><p>方法返回地址（Return Address）（方法正常退出或者异常退出的定义）</p>
</li>
<li><p>一些附加信息</p>
</li>
</ul>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/1677834424127.png" class="asset-class" width="1677834424127">

<p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表和操作数栈决定的</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/1677834531062.png" class="asset-class" width="1677834531062">

<h3 id="局部变量表（Local-Variables）"><a href="#局部变量表（Local-Variables）" class="headerlink" title="局部变量表（Local Variables）"></a>局部变量表（Local Variables）</h3><p>局部变量表也被称之为局部变量数组或本地变量表</p>
<ul>
<li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各种类基本数据类型、对象引用（reference），一级热土人Address类型</li>
<li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li>
<li><strong>局部变量表所需要的容量大小是在编译期确定下来的</strong>，并保证在方法的Code属性的<code>maximum local variables</code> 数据项中。在方法运行期间是不会改变局部变量表的大小的</li>
<li><strong>方法嵌套调用的次数由栈的大小决定</strong>，一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部标量越多，使得局部变量表膨胀，他的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少</li>
<li><strong>局部变量表中的变量只在当前方法调用中有效。</strong>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当前方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</li>
</ul>
<h4 id="关于Slot-变量槽"><a href="#关于Slot-变量槽" class="headerlink" title="关于Slot(变量槽)"></a>关于Slot(变量槽)</h4><ul>
<li>局部变量表，最基本的存储单元式Slot(变量槽)</li>
<li>参数值的存放总是在局部变量数组的<code>index0</code>开始，到数组长度-1的索引结束</li>
<li>局部变量表中存放编译期克制的各种基本数据类型（8种），引用类型（refrence），returnAddress类型的变量</li>
<li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot</li>
<li>byte、short、char在存储前被转换位int，boolean也被转换成int，0标识false，非0标识true</li>
<li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li>
<li>当一个实例方法被调用的时候，他的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</li>
<li>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</li>
<li>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列</li>
</ul>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/1677837174453.png" class="asset-class" width="1677837174453">

<h4 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h4><p>栈帧中的局部变量表中的槽位时可以重用的，如果以讴歌局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的</p>
<pre><code class="prettyprint">public class SlotTest &#123;
    public void localVarl() &#123;
        int a = 0;
        System.out.println(a);
        int b = 0;
    &#125;
    public void localVar2() &#123;
        &#123;
            int a = 0;
            System.out.println(a);
        &#125;
        //此时的就会复用a的槽位
        int b = 0;
    &#125;
&#125;
</code></pre>
<h4 id="静态变量和局部变量的对比"><a href="#静态变量和局部变量的对比" class="headerlink" title="静态变量和局部变量的对比"></a>静态变量和局部变量的对比</h4><p>参数表分配完毕之后，再根据方体内定义的变量的顺序和作用于分配</p>
<p>我们知道类变量表有两次初始化的机会，第一次是在 <strong>准备阶段</strong>，执行系统初始化，对类变量设置零值，另一次则是在 <strong>初始化</strong>阶段，赋予程序员在代码中定义的初始值</p>
<p>和类变量初始化不同的时，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用</p>
<pre><code class="prettyprint">public void test()&#123;
    int i;
    System. out. println(i);
&#125;
// 这样的代码是错误的，没有赋值不能使用
</code></pre>
<h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</p>
<p><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></p>
<h4 id="字节码指令解析"><a href="#字节码指令解析" class="headerlink" title="字节码指令解析"></a>字节码指令解析</h4><pre><code class="prettyprint">public class LocalVariablesTest &#123;
    private int count = 0;

    public static void main(String[] args) &#123;
        LocalVariablesTest test = new LocalVariablesTest();
        int num = 10;
        test.test1();
    &#125;
    public static void testStatic()&#123;
        LocalVariablesTest test = new LocalVariablesTest();
        Date date = new Date();
        int count = 10;
        System.out.println(count);
    &#125;
    public void test1() &#123;
        Date date = new Date();
        String name1 = &quot;rocpenghua&quot;;
        String info = test2(date, name1);
        System.out.println(date + name1);
    &#125;

    public String test2(Date datep, String name2) &#123;
        datep = null;
        name2 = &quot;rocpenghua.com&quot;;
        double weight = 130.3;
        char gender = &#39;男&#39;;
        return datep + name2;
    &#125;
    public void test3() &#123;
        count++;
    &#125;
    public void test4() &#123;
        int a = 0;
        &#123;
            int b = 0;
            b = a + 1;
        &#125;
        int c = a + 1;
    &#125;
&#125;
</code></pre>
<p>这里分析main方法：(安装idea插件<code>jclasslib</code>)</p>
<pre><code class="prettyprint"> public static void main(String[] args) &#123;
     LocalVariablesTest test = new LocalVariablesTest();
     int num = 10;
     test.test1();
 &#125;
// javap -v LocalVariablesTest
public static void main(java.lang.String[]);	// 方法名main 
    descriptor: ([Ljava/lang/String;)V		 	// 参数String数组，返回值void
    flags: ACC_PUBLIC, ACC_STATIC				// 访问标志：public static
    Code:
      stack=2, locals=3, args_size=1			// 栈的最大深度2，局部变量最大槽数3，参数个数1
         0: new           #3                  // class com/rocpenghua/java1/LocalVariablesTest
         3: dup
         4: invokespecial #4                  // Method &quot;&lt;init&gt;&quot;:()V
         7: astore_1
         8: bipush        10
        10: istore_2
        11: aload_1
        12: invokevirtual #5                  // Method test1:()V
        15: return								// 字节码长度16（0-15）
      LineNumberTable:							// 行号表：java代码行号对应字节码指令的位置
        line 14: 0								// 14: LocalVariablesTest test = new LocalVariablesTest(); -&gt; 0: new
        line 15: 8								// 15: int num = 10; -&gt; 8: bipush 10
        line 16: 11								// 16: test.test1(); -&gt; 11: aload_1
        line 17: 15
      LocalVariableTable:						// 局部变量表
        Start  Length  Slot  Name   Signature	// 起始PC(变量声明下一个位置，开始作用的位置)，变量使用长度，槽位，变量名，变量描述符
            0      16     0  args   [Ljava/lang/String; //变量开始作用位置 0: new  使用长度 16
            8       8     1  test   Lcom/rocpenghua/java1/LocalVariablesTest; //变量开始作用位置 8: new  使用长度 8
           11       5     2   num   I			//变量开始作用位置 11: new  使用长度 5
</code></pre>
<p>这里分析test4方法有代码块功能</p>
<pre><code class="prettyprint">public void test4() &#123;
    int a = 0;
    &#123;
        int b = 0;
        b = a + 1;
    &#125;
    // 变量c使用之前已经销毁的变量b的槽位
    int c = a + 1;
&#125; 
/************************************************************************/
public void test4();					// 方法名
    descriptor: ()V						// 参数空 返回值void
    flags: ACC_PUBLIC					//方法修饰符 public
    Code:
      stack=2, locals=3, args_size=1	//栈深度2，本地变量槽3
         0: iconst_0
         1: istore_1
         2: iconst_0
         3: istore_2
         4: iload_1
         5: iconst_1
         6: iadd
         7: istore_2
         8: iload_1
         9: iconst_1
        10: iadd
        11: istore_2
        12: return
      LineNumberTable:
        line 44: 0
        line 46: 2
        line 47: 4
        line 49: 8
        line 50: 12
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            4       4     2     b   I			//变量b在代码块声明没有被继续使用，卡槽占用销毁
            0      13     0  this   Lcom/rocpenghua/java1/LocalVariablesTest;
            2      11     1     a   I
           12       1     2     c   I
</code></pre>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>每个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（<code>Lost-In-First-Out</code>）的操作数栈，也可以称之为 <strong>表达式栈（<code>Expression Stack</code>）</strong></p>
<p>操作数栈，在方法执行过程中，根据字节码指令往栈中写入数据或提取数据，即入栈和出栈</p>
<ul>
<li>某些字节码指令压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li>
<li>比如：执行复制、交换、求和等操作</li>
</ul>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230305104832218.png" class="asset-class" title="image-20230305104832218">

<p>代码举例</p>
<pre><code class="prettyprint">public void testAddOperation()&#123;
    byte i = 15; 
    int j = 8; 
    int k = i + j;
&#125;
</code></pre>
<p>字节码指令信息</p>
<pre><code class="prettyprint">public void testAddOperation(); 
    Code:
    0: bipush 15
    2: istore_1 
    3: bipush 8
    5: istore_2 
    6:iload_1 
    7:iload_2 
    8:iadd
    9:istore_3 
    10:return
</code></pre>
<p>操作数栈。主要用于保护计算过程的中间结果，同时作为计算过程中变量临时的存储空间</p>
<p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之呗创建出来，这个方法的操作数栈是空的</p>
<p>每个操作数栈都会用有一个明确的栈深度用于存储数值，其所需的最大深度在编译器就定义好了，保存在方法的Code属性中，为max_stack的值</p>
<p>栈中的任何一个元素都是可以任意的java数据类型</p>
<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
<p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈从安坐来完成一次数据访问</p>
<p>如果被调用的方法带有返回值的话，其返回值将会呗压入当前栈帧的操作数栈中，并更新PC寄存器中的下一条需要执行的字节码指令</p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</p>
<p>另外，我们说java虚拟机的解释引擎时基于栈的执行引擎，其中栈指的就是操作数栈</p>
<h3 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h3><pre><code class="prettyprint">public void testAddOperation() &#123;
    byte i = 15;
    int j = 8;
    int k = i + j;
&#125;
</code></pre>
<p>使用javap 命令反编译class文件：<code>javap -v 类名.class</code></p>
<pre><code class="prettyprint">public void testAddoperation(); 
        Code:
    0: bipush 15 
    2: istore_1 
    3: bipush 8
    5: istore_2
    6: iload_1
    7: iload_2
    8: iadd
    9: istore_3
    10: return
</code></pre>
<center class="half">
    <img src="2023-03-01-JVM从入门到精通/image-20230307221031312.png" width="49%" height="250px" />
    <img src="2023-03-01-JVM从入门到精通/image-20230307221112127.png" width="49%" height="250px" />
</center>
<center class="half">
    <img src="2023-03-01-JVM从入门到精通/image-20230307221130019.png" width="49%" height="250px" />
    <img src="2023-03-01-JVM从入门到精通/image-20230307221304696.png" width="49%" height="250px" />
</center>
<center class="half">
    <img src="2023-03-01-JVM从入门到精通/image-20230307221325692.png" width="49%" height="250px" />
    <img src="2023-03-01-JVM从入门到精通/image-20230307221338832.png" width="49%" height="250px" />
</center>
<center class="half">
    <img src="2023-03-01-JVM从入门到精通/image-20230307221345546.png" width="49%" height="250px" />
    <img src="2023-03-01-JVM从入门到精通/image-20230307221412377.png" width="49%" height="250px" />
</center>

<pre><code class="prettyprint">// i++和++i的区别

public void add()&#123;
    int i1 = 10; 	// bipush 10 / istore_1
    i1++;		 	// iinc 1,1 单独++没有区别
    int i2 = 10; 	// bipush 10 / istore_2
    ++i2;		 	// iinc 2,1 单独++没有区别

    int i3 = 10; 	// bipush 10 / istore_3
    int i4 = i3++; 	//iload_3 / iinc 3,1 / istore 4 先加载数据再+1 10

    int i5 = 10;	// bipush 10 / istore 5
    int i6 = ++i4; 	// iinc  4, 1 /  iload 4 / istore 6 先+1再加载数据 11

    int i7 = 10;	// bipush 10 /istore 7
    i7 = i7++;		// iload 7 / iinc 7, 1 / istore 7 先加载数据再+1再保存在同一个局部变量表位置 10

    int i8 = 10;	// bipush 10 / istore 8
    i8 = ++i8;		// iinc 8, 1 /iload 8 /istore 8 先+1再加载数据再保存在同一个局部变量表位置 11

    int i9 = 10;	// bipush 10 / istore 9
    int i10 = i9++ + ++i9;	// iload 9 / iinc 9, 1 / iinc 9, 1 / iload 9 / iadd / istore 10 先   +1，+1再加载数据，在执行add然后保存局部变量表 10 + 12 = 22
&#125;
Code:
      stack=2, locals=11, args_size=1
         0: bipush        10
         2: istore_1
         3: iinc          1, 1
         6: bipush        10
         8: istore_2
         9: iinc          2, 1
        12: bipush        10
        14: istore_3
        15: iload_3
        16: iinc          3, 1
        19: istore        4
        21: bipush        10
        23: istore        5
        25: iinc          4, 1
        28: iload         4
        30: istore        6
        32: bipush        10
        34: istore        7
        36: iload         7
        38: iinc          7, 1
        41: istore        7
        43: bipush        10
        45: istore        8
        47: iinc          8, 1
        50: iload         8
        52: istore        8
        54: bipush        10
        56: istore        9
        58: iload         9
        60: iinc          9, 1
        63: iinc          9, 1
        66: iload         9
        68: iadd
        69: istore        10
        71: return
</code></pre>
<h3 id="栈顶缓存技术（Top-Of-Stack-Caching）"><a href="#栈顶缓存技术（Top-Of-Stack-Caching）" class="headerlink" title="栈顶缓存技术（Top Of Stack Caching）"></a>栈顶缓存技术（Top Of Stack Caching）</h3><p>基于栈式架构的虚拟机所使用的令地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着讲将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数</p>
<p>由于操作数时存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度，为了解决这个问题，HotSport JVM的设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部换存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率</strong></p>
<h3 id="动态链接（Dynamic-Linking）"><a href="#动态链接（Dynamic-Linking）" class="headerlink" title="动态链接（Dynamic Linking）"></a>动态链接（Dynamic Linking）</h3><p>动态链接、方法返回地址、附加信息：有些地方被称为帧数据区</p>
<p>每一个栈帧内部都包含一个指向<strong>运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方式的代码能够实现动态链接（Dynamic Linking）。比如：invoke dynamic指令</p>
<p>在java源文件呗编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池指向方法的符号引用来表示的，<strong>那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230308203319950.png" class="asset-class" title="image-20230308203319950">

<p>为什么需要运行时常量池？</p>
<p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p>
<h3 id="方法的调用：解析与分配"><a href="#方法的调用：解析与分配" class="headerlink" title="方法的调用：解析与分配"></a>方法的调用：解析与分配</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>当一个字节码文件被装载进JVM内部时，如果被调用的 <strong>目标方法在编译器可知，且运行期保持不变时</strong>，这种情况下降调用方法的符号引用转换为直接引用的过程，称之为静态链接</p>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>如果<strong>被调用的方法在编译器无法被确定下来，只能够在程序运行期将调用方法的符号转换为直接引用</strong>，由于这种引用转换过程具备动态性，因此也被称之为动态链接</p>
<p><strong>静态链接和动态链接不是名词，而是动词</strong></p>
<h4 id="早期绑定"><a href="#早期绑定" class="headerlink" title="早期绑定"></a>早期绑定</h4><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变，即可讲这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟时哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接饮用</p>
<h4 id="晚期绑定"><a href="#晚期绑定" class="headerlink" title="晚期绑定"></a>晚期绑定</h4><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这中绑定方式也就被称之为晚期绑定</p>
<p>随着高级语言的横空出世，类似于java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是他们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等，面向对象特性，既然这一类编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式</p>
<p>java中任何一个普通的方法其实都是具备虚函数的特征，他们相当于C语言中的虚函数。如果java程序中不希望某个方法拥有虚函数的特征，则可以受用关键字final来标记这个方案</p>
<h4 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h4><p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法</p>
<p>静态方法、似有方法、final方法、实例构造器、非类方法都是非虚方法，其他方法称为虚方法</p>
<p>在类加载的解析阶段就可以进行解析，如下时非虚方法举例：</p>
<pre><code class="prettyprint">class Father&#123;
    public static void print(String str)&#123;
        System. out. println(&quot;father &quot;+str); 
    &#125;
    private void show(String str)&#123;
        System. out. println(&quot;father&quot;+str);
    &#125;
&#125;
class Son extends Father&#123;
    public class VirtualMethodTest&#123;
        public static void main(String[] args)&#123;
            Son.print(&quot;coder&quot;);
            //Father fa=new Father();
            //fa.show(&quot;atguigu.com&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>虚拟机中提供了一下几条方法调用指令：</p>
<h5 id="普通调用指令："><a href="#普通调用指令：" class="headerlink" title="普通调用指令："></a>普通调用指令：</h5><ul>
<li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li>
<li>invokespecial：调用方法、私有及父类方案吗解析阶段确定唯一方法版本</li>
<li>invokevirtual：调用所有的虚方法</li>
<li>invokeinterface：调用借口方法</li>
</ul>
<pre><code class="prettyprint">class Father &#123;
    public Father() &#123;
        System.out.println(&quot;father的构造器&quot;);
    &#125;

    public static void showStatic(String str) &#123;
        System.out.println(&quot;father &quot; + str);
    &#125;

    public final void showFinal() &#123;
        System.out.println(&quot;father show final&quot;);
    &#125;

    public void showCommon() &#123;
        System.out.println(&quot;father 普通方法&quot;);
    &#125;
&#125;

public class Son extends Father &#123;
    public Son() &#123;
        super();
    &#125;

    public Son(int age) &#123;
        this();
    &#125;

    /**
     * 不是重写父类方法，静态方法不能不重写
     *
     * @param str
     */
    public static void showStatic(String str) &#123;
        System.out.println(&quot;son &quot; + str);
    &#125;

    private void showPrivate(String str) &#123;
        System.out.println(&quot;son private &quot; + str);
    &#125;

    public void show() &#123;
        //invokestatic
        showStatic(&quot;rocpenghua&quot;);
        //invokestatic
        super.showStatic(&quot;good&quot;);
        // invokespecial
        showPrivate(&quot;hello&quot;);
        //invokespecial
        super.showCommon();
        //invokevirtual
        /*
         * 因为此方法声明final不会被自雷重写，因此也认为此方法时非虚方法
         */
//        showFinal();
        //invokespecial
        super.showFinal();
        //invokevirtual
        showCommon();
        //invokevirtual
        info();

        MethodInterface in = null;
        //invokeinterface
        in.methodA();
    &#125;

    public void info() &#123;

    &#125;

    public void display(Father f) &#123;
        f.showCommon();
    &#125;

    public static void main(String[] args) &#123;
        Son son = new Son();
        son.show();
    &#125;
&#125;

interface MethodInterface &#123;
    public void methodA();
&#125;
</code></pre>
<h5 id="动态调用指令："><a href="#动态调用指令：" class="headerlink" title="动态调用指令："></a>动态调用指令：</h5><ul>
<li><code>invokedynamic</code>：动态解析出需要调用的方法，然后执行(lambda表达式)</li>
</ul>
<p>前四条指定固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。<strong>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰方法除外）称为虚方法</strong></p>
<p><strong>关于invokedynamic指令</strong></p>
<ul>
<li>JVM字节码指令集一直比较稳定，一直到java7中增加了一个<code>invokedynamic</code>指令，这是java为了实现【动态类型语言】支持而坐的一种改进</li>
<li>但是java7中没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生<code>invokedynamic</code>指令。知道java8的lambda表达式的出现，<code>invokedynamic</code>指令的生成，在java中才有了直接的生成方式</li>
<li>java7中增加的动态语言类型支持的本质是对java虚拟机规范的修改，而不是对java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在java平台的动态语言的编译器。</li>
</ul>
<h5 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h5><p>动态类型语言和静态类型语言两者的区别在于对类型的检查时在编译期还是在运行期，满足前者就是静态类型过语言，反之是动态类型语言</p>
<p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态原因的重要特征</p>
<h4 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h4><p><strong>java语言种方法重写的本质</strong></p>
<ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError 异常。</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.1ang.AbstractMethodsrror异常。</li>
</ol>
<p><strong>IllegalAccessError介绍</strong></p>
<p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
<h4 id="方法的调用：虚方法表"><a href="#方法的调用：虚方法表" class="headerlink" title="方法的调用：虚方法表"></a>方法的调用：虚方法表</h4><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新再类的方法元数据中搜索合适的目标的话可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法去建立一个虚方法表（非虚方法不会出现在表中）来实现。使用索引表来代替查找</p>
<p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口</p>
<blockquote>
<p>虚方法表是什么时候被创建的？</p>
<p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成后，JVM会把该类的方法表也初始化完毕</p>
</blockquote>
<p>举例1：</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230310205140006.png" class="asset-class" title="image-20230310205140006">

<p>举例2：</p>
<pre><code class="prettyprint">interface Friendly&#123;
    void sayHello();
    void sayGoodbye(); 
&#125;
class Dog&#123;
    public void sayHello()&#123;
    &#125;
    public String tostring()&#123;
        return &quot;Dog&quot;;
    &#125;
&#125;
class Cat implements Friendly &#123;
    public void eat() &#123;
    &#125;
    public void sayHello() &#123; 
    &#125; 
    public void sayGoodbye() &#123;
    &#125;
    protected void finalize() &#123;
    &#125;
&#125;
class CockerSpaniel extends Dog implements Friendly&#123;
    public void sayHello() &#123; 
        super.sayHello();
    &#125;
    public void sayGoodbye() &#123;
    &#125;
&#125;
</code></pre>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230310205231864.png" class="asset-class" title="image-20230310205231864">

<h3 id="方法返回地址（return-address）"><a href="#方法返回地址（return-address）" class="headerlink" title="方法返回地址（return address）"></a>方法返回地址（return address）</h3><p>存放调用该方法的PC寄存器的值，一个方法的结束，有两种方式：</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
<p>无论哪种方式退出，在方法退出后都返回到该方法被调用的地方。方法正常退出时，<strong>调用者的PC寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出时，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息</p>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ul>
<li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong><ul>
<li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定</li>
<li>在字节码指令中，返回指令包含<code>ireturn</code>(当返回值时boolean,byte,char,short,int类型时)，<code>lreturn</code>(Long类型)，<code>freturn</code>(Float类型)，<code>dreturn</code>(double类型)，areturn。另外还有一个return指令声明为<code>void</code>的方法，实例初始化方法，类和接口的初始化方式使用</li>
</ul>
</li>
<li>在方法执行过程中遇到一场（Exception）,并且这个异常没有在方法内进行处理，也就是只要再本方法的异常表中没有搜索到匹配的一场处理器，就会导致方法退出，简称<strong>异常完成出口</strong></li>
</ul>
<p>方法执行过程中，抛出异常时的异常处理，存储字一个异常处理表，方便在发生异常的时候找到处理异常的代码</p>
<p>本质上，方法的退出就是当前栈帧出栈的过程，此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈，设置PC寄存器值等，让调用者方法继续执行下去</p>
<p><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</strong></p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>栈帧中还允许携带与java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息</p>
<h3 id="栈的相关面试题"><a href="#栈的相关面试题" class="headerlink" title="栈的相关面试题"></a>栈的相关面试题</h3><ul>
<li>举例栈溢出的情况？（<code>StackOverflowError</code>）<ul>
<li>通过 <code>-Xss</code> 设置栈的大小</li>
</ul>
</li>
<li>调整栈的大小，就能保证不出现溢出吗?<ul>
<li>不能保证不溢出（死递归）</li>
</ul>
</li>
<li>分配的栈内存越大越好吗？<ul>
<li>不是，一定时间内降低了OOM概率，但是会挤占其他的线程空间，因为整个空间时有限的</li>
</ul>
</li>
<li>垃圾回收是否涉及打虚拟机栈？<ul>
<li>不会</li>
</ul>
</li>
<li>方法中定义的局部变量是否线程安全？<ul>
<li>具体问题具体分析，如果对象时在内部产生，并在内部消亡，没有返回到外部，那么就是线程安全的，反之则是线程不安全的</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>运行时数据区</th>
<th>是否存在Error</th>
<th>是否存在GC</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>是（StackOverflowError）</td>
<td>否</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>方法区</td>
<td>是（OutofMemoryException）</td>
<td>是</td>
</tr>
<tr>
<td>堆</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h2 id="本地方法接口和本地方法栈"><a href="#本地方法接口和本地方法栈" class="headerlink" title="本地方法接口和本地方法栈"></a>本地方法接口和本地方法栈</h2><h3 id="什么时本地方法？"><a href="#什么时本地方法？" class="headerlink" title="什么时本地方法？"></a>什么时本地方法？</h3><p><strong>一个Native Method是一个java调用非java代码的接口</strong>。一个native method是这样一个java方法：该方法的实现由非java语言实现，比如C。</p>
<p>在定义一个native method 时，并不提供实现体（有些像定义一个java interface），因为其实现体是由非java语言在外面实现的</p>
<p>本地接口的作用是融合不同的编程语言为java所用，它的初衷是融合C&#x2F;C++程序</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230310212030884.png" class="asset-class" title="image-20230310212030884">

<pre><code class="prettyprint">public class IHaveNatives&#123;
    public native void methodNative1(int x);
    public native static long methodNative2();
    private native synchronized float methodNative3(Object o);
    native void methodNative4(int[] ary) throws Exception;
&#125;
</code></pre>
<p>标识符native可以与其它java标识符连用，但是abstract除外</p>
<h3 id="为什么使用Native-Method"><a href="#为什么使用Native-Method" class="headerlink" title="为什么使用Native Method"></a>为什么使用Native Method</h3><p><strong>与java环境的交互</strong></p>
<p><strong>有时java应用需要与java外面的环境交互，这是本地方法存在的主要原因。</strong>你可以想象java需要与一些底层系统，如操作系统或某些硬件交换信息的情况。本地方法正是这样一种交流机制，它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节</p>
<p><strong>与操作系统的交互</strong></p>
<p>JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通<strong>过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的</strong>。还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p>
<p><strong>Sun&#96;s java</strong></p>
<p><strong>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。</strong>jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用java实现的，但是它实现调用的是该类里的本地方法setPriority()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setPriority() ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVw调用。</p>
<p><strong>现状</strong></p>
<p><strong>目前该方法使用的越来越少了，除非是与硬件有关的应用，</strong>比如通过java程序驱动打印机或者java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><strong>java虚拟机栈于管理java方法的调用，而本地方法栈用于管理本地方法的调用</strong></p>
<p>本地方法栈，也是线程私有的</p>
<p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，java虚拟机将会抛出一个StackOverflowError异常</li>
<li>如果本地方法栈可以动态扩展，并且尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么java虚拟机将会跑出OutOfMemoryError异常</li>
</ul>
<p>本地方法是使用C语言实现的</p>
<p>它的具体做法是Native Method Stack 中等级native方法，在Execution Engine 执行时加载本地方法库</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230310213158656.png" class="asset-class" title="image-20230310213158656">

<p><strong>当某个线程调用一个本地方法时，他就进入了一个全新的并且不再受虚拟机限制的世界，他和虚拟机拥有同样的权限</strong></p>
<ul>
<li>本地方法可以通过本地方法接口来 <strong>访问虚拟机内部的运行时数据区</strong></li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存中堆中分配任意数量的内存</li>
</ul>
<p>并不是所有的JVM都支持本地方法，因为java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈</p>
<p>在HotSpot JVM中，直接将本地方法栈和虚拟机栈合二为一</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆（heap）的核心概述"><a href="#堆（heap）的核心概述" class="headerlink" title="堆（heap）的核心概述"></a>堆（heap）的核心概述</h3><p>对针对一个JVM进程来说时唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们时共享同一堆空间。</p>
<p>一个JVM实例只存在一个堆内存，对也是java内存管理的核心区域</p>
<p>java堆区在JVM启动的时候即被创建，其空间大小也就确定了，时JVM管理的最大一块内存空间</p>
<ul>
<li>堆内存的大小是可以调节的</li>
</ul>
<p>《java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p>
<p>所有的线程共享java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer,TLAB）</p>
<p>《java虚拟机规范》中对java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（<code>The heap is the run-time data area from which memory for all class instances and arrays is allocated</code>）</p>
<p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象数组在堆中的位置。</p>
<p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾回收的时候才会被移除</p>
<p>堆时GC(Garbage Collection,垃圾收集器)执行垃圾回收的重点区域</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230311180924718.png" class="asset-class" title="image-20230311180924718">

<h4 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h4><p>java7及之前堆内存逻辑上分为三部分：新生代+老年代+<strong>永久代</strong></p>
<ul>
<li><code>Young Generation Space</code> 新生区 <code>Young/New</code> 又被划分为<code>Eden</code>区和<code>Survivor</code>区</li>
<li><code>Tenure generation space</code> 老年代<code>Old/Tenure</code></li>
<li><code>Permanent Space</code> 永久代 <code>Perm</code></li>
</ul>
<p>java8及之后对逻辑上分为三部分：新生代+老年代+<strong>元空间</strong></p>
<ul>
<li><code>Young Generation Space</code> 新生区 <code>Young/New</code> 又被划分为<code>Eden</code>区和<code>Survivor</code>区</li>
<li><code>Tenure generation space</code> 老年代<code>Old/Tenure</code></li>
<li><code>Meta Space</code> 元空间 <code>Meta</code></li>
</ul>
<h4 id="堆空间的内部结构（JDK7）"><a href="#堆空间的内部结构（JDK7）" class="headerlink" title="堆空间的内部结构（JDK7）"></a>堆空间的内部结构（JDK7）</h4><img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230311182146416.png" class="asset-class" title="image-20230311182146416">

<h4 id="堆空间和内部结构（JDK8）"><a href="#堆空间和内部结构（JDK8）" class="headerlink" title="堆空间和内部结构（JDK8）"></a>堆空间和内部结构（JDK8）</h4><img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230311182227026.png" class="asset-class" title="image-20230311182227026">

<h3 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h3><h4 id="堆空间大小的设置"><a href="#堆空间大小的设置" class="headerlink" title="堆空间大小的设置"></a>堆空间大小的设置</h4><p>java堆区用于存储java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过 <code>-Xmx</code>和 <code>-Xms</code>来设置</p>
<ul>
<li><code>-Xmx</code>：用于表示堆区的最大内存，等价于 <code>-XX:MaxHeapSize</code></li>
<li><code>-Xms</code>：用于表示堆的起始内存，等价于 <code>-XX:InitialHeapSize</code></li>
</ul>
<p>一旦堆区中的内存大小超过 <code>-Xmx</code>所指定的最大内存时，将会跑出OutOfMemoryError异常</p>
<p>通常会将<code>-Xms</code>和<code>-Xmx</code>两个参数配置相同的值，其目的是<strong>为了能够在java垃圾回收机制清理完堆区后不需要重新分割计算堆区的大小，从而提高性能</strong></p>
<blockquote>
<p>默认情况</p>
<ul>
<li>初始内存大小：物理电脑内存大小的1&#x2F; 64</li>
<li>最大内存大小：物理电脑内存大小的1&#x2F;4</li>
</ul>
</blockquote>
<h4 id="OutOfMemory举例"><a href="#OutOfMemory举例" class="headerlink" title="OutOfMemory举例"></a>OutOfMemory举例</h4><pre><code class="prettyprint">public class OOMTest &#123;
    public static void main(String[]args)&#123;
        ArrayList&lt;Picture&gt; list = new ArrayList&lt;&gt;();
        while(true)&#123;
            try &#123;
                Thread.sleep(20);
            &#125; catch (InterruptedException e)&#123;
                e.printStackTrace();
            &#125;
            list.add(new Picture(new Random().nextInt(1024*1024)));
        &#125;
    &#125;
&#125;
public class Picture &#123;
    private byte[] size;
    public Picture(int nextInt) &#123;
        this.size = new byte[nextInt];
    &#125;
&#125;
/**/
Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: java heap space
    at com.rocpenghua.java.Picture.&lt;init&gt;(Picture.java:11)
    at com.rocpenghua.java.OOMTest.main(OOMTest.java:15)
</code></pre>
<h3 id="年轻代老年代"><a href="#年轻代老年代" class="headerlink" title="年轻代老年代"></a>年轻代老年代</h3><p>存储在JVM对象可以被划分为两类</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li>
<li>另一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li>
</ul>
<p>java堆区进一步细分可以划分为年轻代我（YoungGen）和老年代（OldGen）</p>
<p>其中年轻代又可以划分为Eden区、Survivor0(s0)和Survivor1(s1)（有时也叫做from区和to区）</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230311223139143.png" class="asset-class" title="image-20230311223139143">

<p>下面者参数开发中一般不会调整：</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230311223223234.png" class="asset-class" title="image-20230311223223234">

<p>配置新生代与老年代在对结构的占比</p>
<ul>
<li>默认 <code>-XX:NewRatio=2</code>,表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3</li>
<li>可以修改 <code>-XX:NewRatio=4</code>,表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</li>
</ul>
<p>在HotSpot中Eden区和另外两个Survivor区默认占比时8:1:1</p>
<p>当然开发人员可以通过配置调整 <code>-XX:SurvivorRatio</code> 调整这个空间的比例：</p>
<p>​	<code>-XX:SurvivorRatio=8 </code>：8:1:1</p>
<p>​    <code>-XX:SurvivorRatio=4</code>：4:1:1</p>
<p>几乎所有的java对象都是在Eden区被new出来的，绝大部分的java对象的销毁都在新生代进行</p>
<p>可以使用选项 <code>-Xmn</code>设置新生代最大内存大小，这个参数一般使用默认值就可以</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230311223853295.png" class="asset-class" title="image-20230311223853295">

<h3 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h3><p>微信对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收是否会在内存空间中产生内存碎片</p>
<ol>
<li>new的对象先放Eden区，此区有大小限制</li>
<li>当Eden区的空间填满时，程序有需要创建对象，JVM的垃圾回收器将对Eden区进行垃圾回收（Minor GC）,将Eden区中的不再被其他对象所引用的对象进行销毁，再加载新的对象放到Eden区</li>
<li>然后将Eden区中的剩余对象移动到Survivor0区</li>
<li>如果再次触发垃圾回收，此时幸存下来的放到Survivor0区，如果没有回收，就会放到Survivor1区</li>
<li>如果再次经历垃圾回收，此时会重新放回Survivor0区，接着再去Survivor1区</li>
<li>什么时候可以区老年代？（可以设置次数，默认15次）<ul>
<li><strong>可以设置参数：<code>-XX:MaxTenuringThreshold=N</code></strong></li>
</ul>
</li>
<li>在老年代相对悠闲，当老年代内存不足时，再次触发GC（Major GC），进行老年代的内存清理</li>
<li>若老年代进行Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常</li>
</ol>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230312110307352.png" class="asset-class" title="image-20230312110307352">

<p><strong>流程图</strong></p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230312110334456.png" class="asset-class" title="image-20230312110334456">

<blockquote>
<p><strong>总结</strong></p>
<ul>
<li>针对s0,s1区的总结：复制之后由交换，谁空谁是to区</li>
<li>关于垃圾回收：频繁在新生代收集，很少在老年代收集，几乎不再永久代或元空间进行收集</li>
</ul>
</blockquote>
<p><strong>常用调优工具</strong></p>
<ul>
<li><p>JDK命令行</p>
</li>
<li><p>Eclipse:Memory Analyzer Tool</p>
</li>
<li><p>Jconsole</p>
</li>
<li><p>VisualVM</p>
</li>
<li><p>Jprofiler</p>
</li>
<li><p>java Flight Recorder</p>
</li>
<li><p>GCViewer</p>
</li>
<li><p>GC Easy</p>
</li>
</ul>
<h3 id="Minor-GC-Major-GC-Full-GC"><a href="#Minor-GC-Major-GC-Full-GC" class="headerlink" title="Minor GC,Major GC,Full GC"></a>Minor GC,Major GC,Full GC</h3><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代</p>
<p>针对HotSpot JVM的实现，它里面的GC按照回收区域分为两大种类型：一种是部分收集（Partial GC）,一种时整堆收集（Full GC）</p>
<ul>
<li>部分收集：不是完整收集整个java堆的垃圾收集。其中又分为：<ul>
<li>新生代收集（Minor GC &#x2F; Young GC）:只是新生代的垃圾收集</li>
<li>老年代收集（Major GC &#x2F; Old GC）：只是老年代的垃圾收集<ul>
<li>目前只有CMS GC会有单独收集老年代的行为</li>
<li>很多时候Major GC会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收</li>
</ul>
</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集<ul>
<li>目前只有G1 GC会有这种行为</li>
</ul>
</li>
<li>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集</li>
</ul>
</li>
</ul>
<h4 id="最简单的分代式GC策略的触发条件"><a href="#最简单的分代式GC策略的触发条件" class="headerlink" title="最简单的分代式GC策略的触发条件"></a>最简单的分代式GC策略的触发条件</h4><h5 id="年轻代GC（Minor-GC）触发机制"><a href="#年轻代GC（Minor-GC）触发机制" class="headerlink" title="年轻代GC（Minor GC）触发机制"></a>年轻代GC（Minor GC）触发机制</h5><ul>
<li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的时Eden区满，Survivor满不会引发GC（每次Minor GC会清理年轻代的内存）</li>
<li>因为java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，用户线程才恢复运行</li>
</ul>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230312111608133.png" class="asset-class" title="image-20230312111608133">

<h5 id="老年代GC（Major-GC-x2F-Full-GC）触发机制"><a href="#老年代GC（Major-GC-x2F-Full-GC）触发机制" class="headerlink" title="老年代GC（Major  GC &#x2F; Full GC）触发机制"></a>老年代GC（Major  GC &#x2F; Full GC）触发机制</h5><ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说 <code>Major GC</code> 或 <code>Full GC</code>发生了</li>
<li>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，Paralle 1 Scavenge 收集器的收集策略里就有直接进行Major GC的策略选择过程）<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC</li>
</ul>
</li>
<li>Major GC的速度一般比Minor GC慢10倍以上，STW的时间更长</li>
<li>如果Major GC后内存还不足，就报OOM异常</li>
</ul>
<h5 id="Full-GC触发机制："><a href="#Full-GC触发机制：" class="headerlink" title="Full GC触发机制："></a>Full GC触发机制：</h5><ul>
<li>调用System.gc()时，系统建议执行Full GC，但是不是必然执行</li>
<li>老年代空间不足时</li>
<li>方法区空间不足时</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区、s0(From)区向s1(To)区复制时，对象大小大于 To Space可用内存，则把该对象转存到老年代，切老年代的可用内存小鱼该对象大小</li>
</ul>
<p><strong>ps：Full GC是开发或调优中尽量要避免的，这样暂停时间会短一些</strong></p>
<h3 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h3><p>为什么要把java堆分代？不分代就不能正常工作了吗？</p>
<p>进研究，不同对象的生命周期不同。70%-99%的对象时临时对象</p>
<ul>
<li>新生代：有Eden、两块大小相同的Survivor（又称from&#x2F;to，s0&#x2F;s1）构成，to总为空</li>
<li>老年代：存放新生代中经历多次GC仍然存活的对象</li>
</ul>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230312112948375.png" class="asset-class" title="image-20230312112948375">

<p>其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都放在一个教师。GC的时候找到哪些对象没用，这样就会对堆的所有区域进行扫描，而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某个地方，当GC的时候先把这块存储朝生夕死对象的区域进行回收，这样就会腾出很大的空间出来</p>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230312113252543.png" class="asset-class" title="image-20230312113252543">

<h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象的年龄设为1，对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁，每个JVM每个GC都有所不同）时，就会被晋升到老年代</p>
<p>对象晋升老年代和年龄阀值，可以通过选项 <code>-XX:MaxTenuringThreshold</code> 来设置</p>
<p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li>优先分配到Eden</li>
<li>大对象直接分配到老年代（尽量避免程序汇总出现过多的多对象）</li>
<li>长期存活的对象分配到老年代</li>
<li>动态对象的年龄判断：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一般，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到<code>MaxTenuringShreold</code> 中要求的年龄</li>
<li>空间分配担保： <code>-XX:HandlePromotionFailure</code></li>
</ul>
<h3 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h3><h4 id="为什么由TLAB（Thread-Local-Allocation-Buffer）"><a href="#为什么由TLAB（Thread-Local-Allocation-Buffer）" class="headerlink" title="为什么由TLAB（Thread Local Allocation Buffer）"></a>为什么由TLAB（Thread Local Allocation Buffer）</h4><ul>
<li>堆区时线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁机制，进而影响分配速度</li>
</ul>
<h4 id="什么时TLAB"><a href="#什么时TLAB" class="headerlink" title="什么时TLAB?"></a>什么时TLAB?</h4><ul>
<li>从内存模型而不是垃圾收集的角度，堆Eden区继续进行划分，JVM为<strong>每个线程分配了一个私有缓存区域</strong>，它包含在Eden空间内</li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略</li>
</ul>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230315194821093.png" class="asset-class" title="image-20230315194821093">

<h4 id="TLAB的再说明"><a href="#TLAB的再说明" class="headerlink" title="TLAB的再说明"></a>TLAB的再说明</h4><ul>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但 <strong>JVM确实是将TLAB作为内存分配的首选</strong></li>
<li>在程序中，开发人员可以通过选项 <code>-XX:UseTLAB</code> 设置是否开启TLAB空间</li>
<li>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项 <code>-XX:TLABWasteTargetPrecent</code>设置TLAB空间所占用Eden空间的百分比大小</li>
<li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存</li>
</ul>
<img src="/2023/03/01/jvm-cong-ru-men-dao-jing-tong/image-20230315200128191.png" class="asset-class" title="image-20230315200128191">

<h3 id="堆空间的参数设置"><a href="#堆空间的参数设置" class="headerlink" title="堆空间的参数设置"></a>堆空间的参数设置</h3><p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p>
<pre><code class="prettyprint">-XX:+PrintFlagsInitial  //查看所有的参数的默认初始值
-XX:+PrintFlagsFinal  //查看所有的参数的最终值（可能会存在修改，不再是初始值）
-Xms  //初始堆空间内存（默认为物理内存的1/64）
-Xmx  //最大堆空间内存（默认为物理内存的1/4）
-Xmn  //设置新生代的大小。（初始值及最大值）
-XX:NewRatio  //配置新生代与老年代在堆结构的占比
-XX:SurvivorRatio  //设置新生代中Eden和S0/S1空间的比例
-XX:MaxTenuringThreshold  //设置新生代垃圾的最大年龄
-XX:+PrintGCDetails //输出详细的GC处理日志
//打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc
-XX:HandlePromotionFalilure：//是否设置空间分配担保
</code></pre>
<p>在发生Minor GC之前，虚拟机会 <strong>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</strong></p>
<ul>
<li>如果大于，则此次Minor GC是安全的</li>
<li>如果小于，则虚拟机会查看 <code>-XX:HandlePromotionFailure</code>设置值是否设置空间分配担保<ul>
<li>如果 <code>-XX:HandlePromotionFalilure=true</code>，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小<ul>
<li>如果大于，则尝试进行一次Minor GC,但这次Minor GC依然能是有风险的</li>
<li>如果小于，则改为进行一次Full GC</li>
</ul>
</li>
<li>如果 <code>-XX:HandlePromotionFalilure=false</code>，则改为进行一次Full GC</li>
</ul>
</li>
</ul>
<p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC</strong>，否则将进行Full GC。</p>
<h3 id="堆时分配对象的唯一选择？"><a href="#堆时分配对象的唯一选择？" class="headerlink" title="堆时分配对象的唯一选择？"></a>堆时分配对象的唯一选择？</h3><p>早《深入理解java虚拟机》中关于java堆内存有这样一段描述：</p>
<blockquote>
<p>随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了</p>
</blockquote>
<p>在java虚拟机中，对象在java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个度一想并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收，这也是最常见的堆外存储技术</p>
<h4 id="逃逸分析概述"><a href="#逃逸分析概述" class="headerlink" title="逃逸分析概述"></a>逃逸分析概述</h4><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段</p>
<p>这是一种可以有效减少java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</p>
<p>通过逃逸分析，java HotSpot 编译器能够分析出一个新的对象引用的适用范围从而决定是否要将这个对象分配到堆上</p>
<p>逃逸分析的基本行为就是分析对象动态作用域</p>
<ul>
<li>当一个对像在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中</li>
</ul>
<p><strong>举例1</strong></p>
<pre><code class="prettyprint">public void my_method() &#123;
    V v = new V();
    // use v
    // ....
    v = null;
&#125;
</code></pre>
<p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧</p>
<pre><code class="prettyprint">public static StringBuffer createStringBuffer(String s1, String s2) &#123;
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb;
&#125;
</code></pre>
<p>上述方法如果想要<code>StringBuffer sb</code>不发生逃逸，可以这样写</p>
<pre><code class="prettyprint">public static String createStringBuffer(String s1, String s2) &#123;
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb.toString();
&#125;
</code></pre>
<p><strong>举例2</strong></p>
<pre><code class="prettyprint">public class EscapeAnalysis &#123;

    public EscapeAnalysis obj;

    /**
     * 方法返回EscapeAnalysis对象，发生逃逸
     * @return
     */
    public EscapeAnalysis getInstance() &#123;
        return obj == null ? new EscapeAnalysis() : obj;
    &#125;

    /**
     * 为成员属性赋值，发生逃逸
     */
    public void setObj() &#123;
        this.obj = new EscapeAnalysis();
    &#125;

    /**
     * 对象的作用于仅在当前方法中有效，没有发生逃逸
     */
    public void useEscapeAnalysis() &#123;
        EscapeAnalysis e = new EscapeAnalysis();
    &#125;

    /**
     * 引用成员变量的值，发生逃逸
     */
    public void useEscapeAnalysis2() &#123;
        EscapeAnalysis e = getInstance();
    &#125;
&#125;
</code></pre>
<p><strong>参数设置</strong></p>
<p>在JDK 6u23 版本之后，HotSpot中默认就已经开启逃逸分析</p>
<p>如果使用的时较早的版本，开发人员则可以通过</p>
<ul>
<li>选项 <code>-XX:+DoEscapeAnalysis</code>显示开启逃逸分析</li>
<li>通过选项 <code>-XX:+PrintEscapeAnalysis</code>查看逃逸分析的筛选结果</li>
</ul>
<blockquote>
<p>开发中能使用局部变量的，就不要使用在方法外定义</p>
</blockquote>
<h4 id="逃逸分析：代码优化"><a href="#逃逸分析：代码优化" class="headerlink" title="逃逸分析：代码优化"></a>逃逸分析：代码优化</h4><p>使用逃逸分析，比一起可以堆代码做如下优化：</p>
<ul>
<li><strong>栈上分配：</strong>将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li>
<li><strong>同步省略：</strong>如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>
<li><strong>分离对象或标量替换：</strong>有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中</li>
</ul>
<h5 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h5><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>
<p><strong>常见的栈上分配的场景</strong></p>
<p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递</p>
<h5 id="同步省略（锁消除）"><a href="#同步省略（锁消除）" class="headerlink" title="同步省略（锁消除）"></a>同步省略（锁消除）</h5><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能</p>
<p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p>
<p><strong>举例：</strong></p>
<pre><code class="prettyprint">public void f() &#123;
    Object hellis = new Object();
    synchronized(hellis) &#123;
        System.out.println(hellis);
    &#125;
&#125;
</code></pre>
<p>代码中堆hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程访问到，所以在JIT编译阶段就会被优化掉，优化成：</p>
<pre><code class="prettyprint">public void f() &#123;
    Object hellis = new Object();
    System.out.println(hellis);
&#125;
</code></pre>
<h5 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h5><p>**标量(scalar)**是指一个无法再分解成更小的数据的数据。java中原始数据类型就是标量</p>
<p>相对的，那些还可以分解的数据叫做**聚合量(Aggregate)**，java中的对象就是聚合量，因为他们可以分解成其他聚合量和标量</p>
<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个成员变量来代替，这个过程就是标量替换。</p>
<p><strong>举例：</strong></p>
<pre><code class="prettyprint">public static void main(String args[]) &#123;
    alloc();
&#125;
private static void alloc() &#123;
    Point point = new Point(1,2);
    System.out.println(&quot;point.x&quot; + point.x + &quot;;point.y&quot; + point.y);
&#125;
class Point &#123;
    private int x;
    private int y;
&#125;
</code></pre>
<p>以上代码，经过标量替换后就会变成：</p>
<pre><code class="prettyprint">private static void alloc() &#123;
    int x = 1;
    int y = 2;
    System.out.println(&quot;point.x = &quot; + x + &quot;; point.y=&quot; + y);
&#125;
</code></pre>
<p>可以看到，Point这个聚合量经过逃逸分析后，发现它并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用，因为一旦不需要创建对象了，那么就不在需要分配堆内存了。标量替换为栈上分配提供了很好的基础。</p>
<p><strong>标量替换参数设置</strong></p>
<p>上述代码在主函数中进行了1亿次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p>
<pre><code class="prettyprint">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations
</code></pre>
<p>这里设置参数如下：</p>
<ul>
<li><p>参数<code>-server</code>：启动Server模式，因为在server模式下，才可以启用逃逸分析。</p>
</li>
<li><p>参数<code>-XX:+DoEscapeAnalysis</code>：启用逃逸分析</p>
</li>
<li><p>参数<code>-Xmx10m</code>：指定了堆空间最大为10MB</p>
</li>
<li><p>参数<code>-XX:+PrintGC</code>：将打印Gc日志</p>
</li>
<li><p>参数<code>-XX:+EliminateAllocations</code>：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</p>
</li>
</ul>
<h4 id="逃逸分析小结"><a href="#逃逸分析小结" class="headerlink" title="逃逸分析小结"></a>逃逸分析小结</h4><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟。</p>
<p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 </p>
<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</p>
<p>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</p>
<p>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。</p>
<blockquote>
<p>小结：</p>
<p>年轻代时对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命</p>
<p>老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的java对象，当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。</p>
<p>当GC发生在老年代时则被称为Major GC或者Full GC。一般的Minor GC发生的频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>CRON表达式例子</title>
    <url>/2021/09/13/cron-biao-da-shi-li-zi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>*/5 * * * * ? 每隔5秒执行一次
 0 */1 * * * ? 每隔1分钟执行一次
 0 0 5-15 * * ? 每天5-15点整点触发
 0 0/3 * * * ? 每三分钟触发一次
 0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 
 0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发
 0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
 0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时
 0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 
 
 0 0 12 ? * WED 表示每个星期三中午12点
 0 0 17 ? * TUES,THUR,SAT 每周二、四、六下午五点
 0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 
 0 15 10 ? * MON-FRI 周一至周五的上午10:15触发
 0 0 23 L * ? 每月最后一天23点执行一次
 0 15 10 L * ? 每月最后一日的上午10:15触发 
 0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 
 0 15 10 * * ? 2005 2005年的每天上午10:15触发 
 0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 
 0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发


&quot;30 * * * * ?&quot; 每半分钟触发任务
&quot;30 10 * * * ?&quot; 每小时的10分30秒触发任务
&quot;30 10 1 * * ?&quot; 每天1点10分30秒触发任务
&quot;30 10 1 20 * ?&quot; 每月20号1点10分30秒触发任务
&quot;30 10 1 20 10 ? *&quot; 每年10月20号1点10分30秒触发任务
&quot;30 10 1 20 10 ? 2011&quot; 2011年10月20号1点10分30秒触发任务
&quot;30 10 1 ? 10 * 2011&quot; 2011年10月每天1点10分30秒触发任务
&quot;30 10 1 ? 10 SUN 2011&quot; 2011年10月每周日1点10分30秒触发任务
&quot;15,30,45 * * * * ?&quot; 每15秒，30秒，45秒时触发任务
&quot;15-45 * * * * ?&quot; 15到45秒内，每秒都触发任务
&quot;15/5 * * * * ?&quot; 每分钟的每15秒开始触发，每隔5秒触发一次
&quot;15-30/5 * * * * ?&quot; 每分钟的15秒到30秒之间开始触发，每隔5秒触发一次
&quot;0 0/3 * * * ?&quot; 每小时的第0分0秒开始，每三分钟触发一次
&quot;0 15 10 ? * MON-FRI&quot; 星期一到星期五的10点15分0秒触发任务
&quot;0 15 10 L * ?&quot; 每个月最后一天的10点15分0秒触发任务
&quot;0 15 10 LW * ?&quot; 每个月最后一个工作日的10点15分0秒触发任务
&quot;0 15 10 ? * 5L&quot; 每个月最后一个星期四的10点15分0秒触发任务
&quot;0 15 10 ? * 5#3&quot; 每个月第三周的星期四的10点15分0秒触发任务
</code></pre>
]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
  </entry>
  <entry>
    <title>typora快捷键记录</title>
    <url>/2023/03/02/typora-kuai-jie-jian-ji-lu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><a href="https://support.typoraio.cn/Shortcut-Keys/#change-shortcut-keys">Shortcut Keys - Typora Support (typoraio.cn)</a></p>
</blockquote>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><h3 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl+"></a>Ctrl+</h3><h4 id="Ctrl-数字"><a href="#Ctrl-数字" class="headerlink" title="Ctrl+数字"></a>Ctrl+数字</h4><ul>
<li>Ctrl + 1 ：一级标题</li>
<li>Ctrl + 2 ：二级标题</li>
<li>Ctrl + 3 ：三级标题</li>
<li>Ctrl + 4 ：四级标题</li>
<li>Ctrl + 5 ：五级标题</li>
<li>Ctrl + 6 ：六级标题</li>
<li>Ctrl + 0 ：段落</li>
</ul>
<h4 id="Ctrl-字符"><a href="#Ctrl-字符" class="headerlink" title="Ctrl+字符"></a>Ctrl+字符</h4><ul>
<li>Ctrl + &#x3D; ：提升标题等级</li>
<li>Ctrl + - ：降低标题等级</li>
<li>Ctrl + Home ：跳转到文首</li>
<li>Ctrl + End ：跳转到文末</li>
<li>Ctrl + Tab ：应用内窗口切换</li>
<li>Ctrl + &#x2F; ：源代码模式</li>
<li>Ctrl + \ ：清除样式</li>
<li>Ctrl + [ ：减少缩进</li>
<li>Ctrl + ] ：增加缩进</li>
<li>Ctrl + 逗号 ：偏好设置</li>
</ul>
<h4 id="Ctrl-字母"><a href="#Ctrl-字母" class="headerlink" title="Ctrl+字母"></a>Ctrl+字母</h4><ul>
<li>Ctrl + A ：全选</li>
<li>Ctrl + B ：加粗</li>
<li>Ctrl + C ： 复制</li>
<li>Ctrl + D ：选中当前词</li>
<li>Ctrl + E ：选中当前格式文本</li>
<li>Ctrl + F ：查找</li>
<li>Ctrl + F3 ：查找下一个</li>
<li>Ctrl + shift + F3 ：查找上一个</li>
<li>Ctrl + H ：替换</li>
<li>Ctrl + I ：斜体</li>
<li>Ctrl + J ：跳转到所选内容</li>
<li>Ctrl + K ：超链接</li>
<li>Ctrl + L ：选中当前行</li>
<li>Ctrl + N ：新建文件</li>
<li>Ctrl + O ：打开</li>
<li>Ctrl + P ：快速打开（快速打开之前编辑过的历史文件）</li>
<li>Ctrl + S ：保存</li>
<li>Ctrl + T ：插入表格</li>
<li>Ctrl + U ：下划线</li>
<li>Ctrl + V ：粘贴</li>
<li>Ctrl + W ：关闭</li>
<li>Ctrl + X ：剪切</li>
<li>Ctrl + Y ：重做</li>
<li>Ctrl + Z ：撤销</li>
</ul>
<h3 id="Ctrl-shift"><a href="#Ctrl-shift" class="headerlink" title="Ctrl+shift+"></a>Ctrl+shift+</h3><h4 id="Ctrl-shift-数字"><a href="#Ctrl-shift-数字" class="headerlink" title="Ctrl+shift+数字"></a>Ctrl+shift+数字</h4><ul>
<li>Ctrl + shift + 1 ：大纲</li>
<li>Ctrl + shift + 2 ：文档列表</li>
<li>Ctrl + shift + 3 ：文件树</li>
<li>Ctrl + shift + 9 ：实际大小</li>
</ul>
<h4 id="Ctrl-shift-字母"><a href="#Ctrl-shift-字母" class="headerlink" title="Ctrl+shift+字母"></a>Ctrl+shift+字母</h4><ul>
<li>Ctrl + shift + C ：复制为MarkDown格式</li>
<li>Ctrl + shift + D ：删除当前词</li>
<li>Ctrl + shift + E ：使用上一次设置导出</li>
<li>Ctrl + shift + F ：搜索</li>
<li>Ctrl + shift + I ：插入图片</li>
<li>Ctrl + shift + K ：插入代码块</li>
<li>Ctrl + shift + L ：显示&#x2F;隐藏侧边栏</li>
<li>Ctrl + shift + M ：插入公式</li>
<li>Ctrl + shift + N ：新建窗口</li>
<li>Ctrl + shift + Q ：引用</li>
<li>Ctrl + shift + S ：另存为</li>
<li>Ctrl + shift + T ：重新打开关闭的文件</li>
<li>Ctrl + shift + V ：粘贴为纯文本格式</li>
<li>Ctrl + shift + X ：任务列表</li>
</ul>
<h4 id="Ctrl-shift-字符"><a href="#Ctrl-shift-字符" class="headerlink" title="Ctrl+shift+字符"></a>Ctrl+shift+字符</h4><ul>
<li>Ctrl + shift + [ ：有序列表</li>
<li>Ctrl + shift + ] ：无序列表</li>
<li>Ctrl + shift + &#x3D; ：放大</li>
<li>Ctrl + shift + - ：缩小</li>
<li>Ctrl + shift + &#96; ：代码</li>
</ul>
<h3 id="Alt-shift"><a href="#Alt-shift" class="headerlink" title="Alt+shift+"></a>Alt+shift+</h3><ul>
<li>Alt + shift + P ：打印</li>
<li>Alt + shift + 5 ：删除线</li>
</ul>
<h3 id="Alt-Ctrl"><a href="#Alt-Ctrl" class="headerlink" title="Alt + Ctrl +"></a>Alt + Ctrl +</h3><ul>
<li>Alt + Ctrl + P ：选择段落或块</li>
<li>Alt + Ctrl + shift + P ：删除块</li>
<li>Alt + Ctrl + shift + L ：删除当前行或句</li>
<li>Alt + Ctrl + shift + E ：删除当前格式文本</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7安装mysql8</title>
    <url>/2021/11/14/centos7-an-zhuang-mysql8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li>下载 MySQL 所需要的安装包<code>https://dev.mysql.com/downloads/mysql/</code></li>
<li>Select Operating System: 选择 Red Hat ，CentOS 是基于红帽的，Select OS Version: 选择 linux 7</li>
<li>选择 RPM Bundle 点击 Download</li>
<li><code>rpm -qa | grep mariadb</code> 命令查看 mariadb 的安装包</li>
<li><code>rpm -e mariadb-libs-5.5.56-2.el7.x86_64 --nodeps</code> 命令装卸 mariadb</li>
<li><code>rpm -qa | grep mariadb</code> 命令再次查看 mariadb 的安装包</li>
</ol>
<p>7.<code>tar -xvf mysql-8.0.11-1.el7.x86_64.rpm-bundle.tar</code>  命令解压 tar 包<br>8. <code>yum localinstall *.rpm</code> 安装所有rpm包<br>9. <code>rpm -qa | grep mysql</code> 命令查看 mysql 的安装包<br>10. 通过以下命令，完成对 mysql 数据库的初始化和相关配置</p>
<pre><code class="prettyprint">mysqld --initialize;
chown mysql:mysql /var/lib/mysql -R;
systemctl start mysqld.service;
systemctl  enable mysqld;
</code></pre>
<ol start="11">
<li>通过 cat &#x2F;var&#x2F;log&#x2F;mysqld.log | grep password 命令查看数据库的密码</li>
<li>通过 mysql -uroot -p 敲回车键进入数据库登陆界面</li>
<li>输入刚刚查到的密码，进行数据库的登陆，复制粘贴就行，MySQL 的登陆密码也是不显示的</li>
<li>通过 <code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;;</code> 命令来修改密码（复杂点）</li>
<li>通过 exit; 命令退出 MySQL，然后通过新密码再次登陆</li>
<li>通过以下命令，进行远程访问的授权<pre><code class="prettyprint">create user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;root&#39;;
grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; with grant option;
flush privileges;
</code></pre>
</li>
<li>通过 <code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39; PASSWORD EXPIRE NEVER;</code> 命令修改加密规则，MySql8.0 版本 和 5.0 的加密规则不一样，而现在的可视化工具只支持旧的加密方式。</li>
<li>通过 <code>flush privileges;</code> 命令刷新修该后的权限</li>
<li>通过 exit; 命令退出 MySQL</li>
<li>通过以下命令，关闭 firewall<pre><code class="prettyprint">systemctl stop firewalld.service;
systemctl disable firewalld.service;
systemctl mask firewalld.service;
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>23中设计模式学习</title>
    <url>/2023/02/20/23-zhong-she-ji-mo-shi-xue-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>设计模式分为三大类:</p>
<ul>
<li>创建型（五种）： 工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</li>
<li>结构型模式（七种）: 适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</li>
<li>行为型模式（十一种）：策略模式、模版方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</li>
</ul>
</blockquote>
<h2 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><blockquote>
<p>定义了一个创建对象的类，由这个类来封装实例化对象的行为。</p>
</blockquote>
<p><strong>举例：</strong>（我们举一个<code>pizza</code>工厂的例子）</p>
<p>pizza工厂一共生产三种类型的<code>pizza</code>：<code>chesse</code>、<code>pepper</code>、<code>greak</code>。通过工厂类（<code>SimplePizzaFactory</code>）实例化这三种类型的对象。</p>
<pre><code class="prettyprint">public class SimplePizzaFactory &#123;
    public Pizza CreatePizza(String ordertype) &#123;
        Pizza pizza = null;
        if (ordertype.equals(&quot;cheese&quot;)) &#123;
            pizza = new CheesePizza();
        &#125; else if (ordertype.equals(&quot;greek&quot;)) &#123;
            pizza = new GreekPizza();
        &#125; else if (ordertype.equals(&quot;pepper&quot;)) &#123;
            pizza = new PepperPizza();
        &#125;
        return pizza;
    &#125;
&#125;

interface Pizza &#123;
    void prepare();
&#125;

class CheesePizza implements Pizza &#123;

    @Override
    public void prepare() &#123;

    &#125;
&#125;

class GreekPizza implements Pizza &#123;

    @Override
    public void prepare() &#123;

    &#125;
&#125;

class PepperPizza implements Pizza &#123;

    @Override
    public void prepare() &#123;

    &#125;
&#125;
</code></pre>
<p>简单工厂存在的问题与解决方法： 简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则，所以，从设计角度考虑，有一定的问题，如何解决？我们可以定义一个创建对象的抽象方法并创建多个不同的工厂类实现该抽象方法，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。这种方法也就是我们接下来要说的工厂方法模式。</p>
<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><blockquote>
<p> 定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。</p>
</blockquote>
<p><strong>举例：</strong>（我们依然举<code>pizza</code>工厂的例子，不过这个例子中，<code>pizza</code>产地有两个：伦敦和纽约）。添加了一个新的产地，如果用简单工厂模式的的话，我们要去修改工厂代码，并且会增加一堆的if else语句。而工厂方法模式克服了简单工厂要修改代码的缺点，它会直接创建两个工厂，纽约工厂和伦敦工厂。</p>
<pre><code class="prettyprint">public abstract class OrderPizza &#123;
    abstract Pizza createPizza(String orderType);
&#125;
</code></pre>
<p>两个工厂类继承<code>OrderPizza</code>并实现抽象方法：</p>
<pre><code class="prettyprint">public class LDOrderPizza extends OrderPizza &#123;
    @Override
    Pizza createPizza(String orderType) &#123;
        Pizza pizza = null;
        if (orderType.equals(&quot;cheese&quot;)) &#123;
            pizza = new LDCheesePizza();
        &#125; else if (orderType.equals(&quot;pepper&quot;)) &#123;
            pizza = new LDPepperPizza();
        &#125;
        return pizza;
    &#125;
&#125;
/************************************************/
public class NYOrderPizza extends OrderPizza &#123;

    Pizza createPizza(String orderType) &#123;
        Pizza pizza = null;
        if (orderType.equals(&quot;cheese&quot;)) &#123;
            pizza = new NYCheesePizza();
        &#125; else if (orderType.equals(&quot;pepper&quot;)) &#123;
            pizza = new NYPepperPizza();
        &#125;
        return pizza;

    &#125;

&#125;
</code></pre>
<p><strong>工厂方法存在的问题与解决方法：</strong>客户端需要创建类的具体的实例。简单来说就是用户要订纽约工厂的披萨，他必须去纽约工厂，想订伦敦工厂的披萨，必须去伦敦工厂。 当伦敦工厂和纽约工厂发生变化了，用户也要跟着变化，这无疑就增加了用户的操作复杂性。为了解决这一问题，我们可以把工厂类抽象为接口，用户只需要去找默认的工厂提出自己的需求（传入参数），便能得到自己想要产品，而不用根据产品去寻找不同的工厂，方便用户操作。这也就是我们接下来要说的抽象工厂模式。</p>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><blockquote>
<p>定义了一个接口用于创建相关或有依赖关系的对象族，而无需明确指定具体类。</p>
</blockquote>
<p><strong>举例：</strong>（我们依然举<code>pizza</code>工厂的例子，<code>pizza</code>工厂有两个：纽约工厂和伦敦工厂）。</p>
<p>工厂接口：</p>
<pre><code class="prettyprint">public interface AbsFactory &#123;
       Pizza CreatePizza(String ordertype) ;
&#125;
</code></pre>
<p>工厂的具体实现：</p>
<pre><code class="prettyprint">public class LDFactory implements AbsFactory &#123;
       @Override
       public Pizza CreatePizza(String ordertype) &#123;
              Pizza pizza = null;
              if (&quot;cheese&quot;.equals(ordertype)) &#123;
                     pizza = new LDCheesePizza();
              &#125; else if (&quot;pepper&quot;.equals(ordertype)) &#123;
                     pizza = new LDPepperPizza();
              &#125;
              return pizza;
       &#125;
&#125;
</code></pre>
<p><code>PizzaStroe</code>的代码如下:</p>
<pre><code class="prettyprint">public class PizzaStroe &#123;
       public static void main(String[] args) &#123;
              OrderPizza mOrderPizza;
              mOrderPizza = new OrderPizza(&quot;London&quot;);
       &#125;
&#125;
</code></pre>
<p>解决了工厂方法模式的问题：在抽象工厂中<code>PizzaStroe</code>中只需要传入参数就可以实例化对象。</p>
<h4 id="工厂模式适用的场合"><a href="#工厂模式适用的场合" class="headerlink" title="工厂模式适用的场合"></a>工厂模式适用的场合</h4><p>大量的产品需要创建，并且这些产品具有共同的接口 </p>
<h4 id="三种工厂模式的使用选择"><a href="#三种工厂模式的使用选择" class="headerlink" title="三种工厂模式的使用选择"></a>三种工厂模式的使用选择</h4><ul>
<li><p><strong>简单工厂 ：</strong> 用来生产同一等级结构中的任意产品。（不支持拓展增加产品）</p>
</li>
<li><p><strong>工厂方法 ：</strong>用来生产同一等级结构中的固定产品。（支持拓展增加产品）</p>
</li>
<li><p><strong>抽象工厂 ：</strong>用来生产不同产品族的全部产品。（支持拓展增加产品；支持增加产品族）</p>
</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote>
<p><strong>定义：</strong>确保一个类最多只有一个实例，并提供一个全局访问点</p>
<p>单例模式分为懒汉式（懒加载）和饿汉式（预加载）</p>
</blockquote>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><blockquote>
<p>预先加载。再进一步解释就是还没有使用该单例对象，但是，该单例对象就已经被加载到内存了。</p>
</blockquote>
<pre><code class="prettyprint">public class PreloadSingleton &#123;
       
       public static PreloadSingleton instance = new PreloadSingleton();
   
       //其他的类无法实例化单例类的对象
       private PreloadSingleton() &#123;
       &#125;;
       
       public static PreloadSingleton getInstance() &#123;
              return instance;
       &#125;
&#125;
</code></pre>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><blockquote>
<p>为了避免内存的浪费，我们可以采用懒加载，即用到该单例对象的时候再创建。</p>
</blockquote>
<pre><code class="prettyprint">public class Singleton &#123;
       
       private static Singleton instance=null;
       
       private Singleton()&#123;
       &#125;;
       
       public static Singleton getInstance()
       &#123;
              if(instance==null)
              &#123;
                     instance=new Singleton();
              &#125;
              return instance;
              
       &#125;
&#125;
</code></pre>
<h4 id="单例模式和线程安全"><a href="#单例模式和线程安全" class="headerlink" title="单例模式和线程安全"></a>单例模式和线程安全</h4><ul>
<li><p>预加载只有一条语句<code>return instance</code>,这显然可以保证线程安全。但是，我们知道预加载会造成内存的浪费。</p>
</li>
<li><p>懒加载不浪费内存，但是无法保证线程的安全。首先，if判断以及其内存执行代码是非原子性的。其次，<code>new Singleton()</code>无法保证执行的顺序性。</p>
<ul>
<li><p>不满足原子性或者顺序性，线程肯定是不安全的。为什么new Singleton()无法保证顺序性。我们知道创建一个对象分三步:</p>
<pre><code class="prettyprint">memory=allocate();//1:初始化内存空
ctorInstance(memory);//2:初始化对象
instance=memory();//3:设置instance指向刚分配的内存地址
</code></pre>
<p>jvm为了提高程序执行性能，会对没有依赖关系的代码进行重排序，上面2和3行代码可能被重新排序。我们用两个线程来说明线程是不安全的。线程A和线程B都创建对象。其中，A2和A3的重排序，将导致线程B在B1处判断出instance不为空，线程B接下来将访问instance引用的对象。此时，线程B将会访问到一个还未初始化的对象（线程不安全）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="保证懒加载的线程安全"><a href="#保证懒加载的线程安全" class="headerlink" title="保证懒加载的线程安全"></a>保证懒加载的线程安全</h4><p>我们首先想到的就是使用<code>synchronized</code>关键字。<code>synchronized</code>加载<code>getInstace()</code>函数上确实保证了线程的安全。但是，如果要经常的调用<code>getInstance()</code>方法，不管有没有初始化实例，都会唤醒和阻塞线程。为了避免线程的上下文切换消耗大量时间，如果对象已经实例化了，我们没有必要再使用<code>synchronized</code>加锁，直接返回对象。</p>
<pre><code class="prettyprint">public class Singleton &#123;
       private static Singleton instance = null;
       private Singleton() &#123;
       &#125;;
       public static synchronized Singleton getInstance() &#123;
              if (instance == null) &#123;
                     instance = new Singleton();
              &#125;
              return instance;
       &#125;
&#125;
</code></pre>
<p>我们把<code>sychronized</code>加在if(instance&#x3D;&#x3D;null)判断语句里面，<strong>保证instance未实例化的时候才加锁</strong></p>
<pre><code class="prettyprint">public class Singleton &#123;
       private static Singleton instance = null;
       private Singleton() &#123;
       &#125;;
       public static synchronized Singleton getInstance() &#123;
              if (instance == null) &#123;
                     synchronized (Singleton.class) &#123;
                           if (instance == null) &#123;
                                  instance = new Singleton();
                           &#125;
                     &#125;
              &#125;
              return instance;
       &#125;
&#125;
</code></pre>
<p>我们经过前面的讨论知道new一个对象的代码是无法保证顺序性的，因此，我们需要使用另一个关键字<code>volatile</code>保证对象实例化过程的顺序性。<strong>双重校验锁</strong></p>
<pre><code class="prettyprint">public class Singleton &#123;
       private static volatile Singleton instance = null;
       private Singleton() &#123;
       &#125;;
       public static synchronized Singleton getInstance() &#123;
              if (instance == null) &#123;
                     synchronized (instance) &#123;
                           if (instance == null) &#123;
                                  instance = new Singleton();
                           &#125;
                     &#125;
              &#125;
              return instance;
       &#125;
&#125;
</code></pre>
<h4 id="当然还是静态内部类"><a href="#当然还是静态内部类" class="headerlink" title="当然还是静态内部类"></a>当然还是静态内部类</h4><pre><code class="prettyprint">public class Singleton &#123;  
    private static class SingletonHolder &#123;  
    private static final Singleton INSTANCE = new Singleton();  
    &#125;  
    private Singleton ()&#123;&#125;  
    public static final Singleton getInstance() &#123;  
        return SingletonHolder.INSTANCE;  
    &#125;  
&#125;
</code></pre>
<h4 id="枚举-默认就是单例的线程安全的"><a href="#枚举-默认就是单例的线程安全的" class="headerlink" title="枚举,默认就是单例的线程安全的"></a>枚举,默认就是单例的线程安全的</h4><pre><code class="prettyprint">public enum Singleton &#123;  
    INSTANCE;  
    public void whateverMethod() &#123;  
    &#125;  
&#125;
</code></pre>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><blockquote>
<p><strong>定义：</strong>封装一个复杂对象构造过程，并允许按步骤构造。</p>
<p><strong>定义解释：</strong> 我们可以将建造者模式理解为，假设我们有一个对象需要建立，这个对象是由多个组件（<code>Component</code>）组合而成，每个组件的建立都比较复杂，但运用组件来建立所需的对象非常简单，所以我们就可以将构建复杂组件的步骤与运用组件构建对象分离，使用<code>builder</code>模式可以建立。</p>
</blockquote>
<h4 id="模式的结构和代码示例"><a href="#模式的结构和代码示例" class="headerlink" title="模式的结构和代码示例"></a>模式的结构和代码示例</h4><p>建造者模式结构中包括四种角色：</p>
<ul>
<li>产品(<code>Product</code>)：具体生产器要构造的复杂对象；</li>
<li>抽象建造者(<code>Bulider</code>)：抽象建造者是一个接口，该接口除了为创建一个<code>Product</code>对象的各个组件定义了若干个方法之外，还要定义返回Product对象的方法（定义构造步骤）；</li>
<li>具体生产器(<code>ConcreteBuilder</code>)：实现<code>Builder</code>接口的类，具体建造者将实现<code>Builder</code>接口所定义的方法（生产各个组件）；</li>
<li>指挥者(<code>Director</code>)：指挥者是一个类，该类需要含有<code>Builder</code>接口声明的变量。指挥者的职责是负责向用户提供具体建造者，即指挥者将请求具体建造者类来构造用户所需要的<code>Product</code>对象，如果所请求的具体建造者成功地构造出<code>Product</code>对象，指挥者就可以让该具体生产器返回所构造的<code>Product</code>对象。（按照步骤组装部件，并返回<code>Product</code>）</li>
</ul>
<p><strong>举例：</strong>我们如果构建生成一台电脑，那么我们可能需要这么几个步骤（1）需要一个主机（2）需要一个显示器（3）需要一个键盘（4）需要一个鼠标。虽然我们具体在构建一台主机的时候，每个对象的实际步骤是不一样的，比如，有的对象构建了i7cpu的主机，有的对象构建了i5cpu的主机，有的对象构建了普通键盘，有的对象构建了机械键盘等。但不管怎样，你总是需要经过一个步骤就是构建一台主机，一台键盘。对于这个例子，我们就可以使用建造者模式来生成一台电脑，他需要通过多个步骤来生成。</p>
<p><code>ComputerBuilder</code>类定义构造步骤：</p>
<pre><code class="prettyprint">public abstract class ComputerBuilder &#123;
   
    protected Computer computer;
   
    public Computer getComputer() &#123;
        return computer;
    &#125;
   
    public void buildComputer() &#123;
        computer = new Computer();
        System.out.println(&quot;生成了一台电脑！！！&quot;);
    &#125;
    public abstract void buildMaster();
    public abstract void buildScreen();
    public abstract void buildKeyboard();
    public abstract void buildMouse();
    public abstract void buildAudio();
&#125;
</code></pre>
<p><code>HPComputerBuilder</code>定义各个组件：</p>
<pre><code class="prettyprint">public class HPComputerBuilder extends ComputerBuilder &#123;
    @Override
    public void buildMaster() &#123;
        // TODO Auto-generated method stub
        computer.setMaster(&quot;i7,16g,512SSD,1060&quot;);
        System.out.println(&quot;(i7,16g,512SSD,1060)的惠普主机&quot;);
    &#125;
    @Override
    public void buildScreen() &#123;
        // TODO Auto-generated method stub
        computer.setScreen(&quot;1080p&quot;);
        System.out.println(&quot;(1080p)的惠普显示屏&quot;);
    &#125;
    @Override
    public void buildKeyboard() &#123;
        // TODO Auto-generated method stub
        computer.setKeyboard(&quot;cherry 青轴机械键盘&quot;);
        System.out.println(&quot;(cherry 青轴机械键盘)的键盘&quot;);
    &#125;
    @Override
    public void buildMouse() &#123;
        // TODO Auto-generated method stub
        computer.setMouse(&quot;MI 鼠标&quot;);
        System.out.println(&quot;(MI 鼠标)的鼠标&quot;);
    &#125;
    @Override
    public void buildAudio() &#123;
        // TODO Auto-generated method stub
        computer.setAudio(&quot;飞利浦 音响&quot;);
        System.out.println(&quot;(飞利浦 音响)的音响&quot;);
    &#125;
&#125;
</code></pre>
<p><code>Director</code>类对组件进行组装并生成产品</p>
<pre><code class="prettyprint">public class Director &#123;
   
    private ComputerBuilder computerBuilder;
    public void setComputerBuilder(ComputerBuilder computerBuilder) &#123;
        this.computerBuilder = computerBuilder;
    &#125;
   
    public Computer getComputer() &#123;
        return computerBuilder.getComputer();
    &#125;
   
    public void constructComputer() &#123;
        computerBuilder.buildComputer();
        computerBuilder.buildMaster();
        computerBuilder.buildScreen();
        computerBuilder.buildKeyboard();
        computerBuilder.buildMouse();
        computerBuilder.buildAudio();
    &#125;
&#125;
</code></pre>
<h4 id="建造者模式的优缺点"><a href="#建造者模式的优缺点" class="headerlink" title="建造者模式的优缺点"></a>建造者模式的优缺点</h4><blockquote>
<p>优点：</p>
<ul>
<li>将一个对象分解为各个组件</li>
<li>将对象组件的构造封装起来</li>
<li>可以控制整个对象的生成过程</li>
</ul>
<p>缺点：</p>
<ul>
<li>对不同类型的对象需要实现不同的具体构造器的类，这可能回答大大增加类的数量</li>
</ul>
</blockquote>
<h4 id="建造者模式与工厂模式的不同"><a href="#建造者模式与工厂模式的不同" class="headerlink" title="建造者模式与工厂模式的不同"></a>建造者模式与工厂模式的不同</h4><p>建造者模式构建对象的时候，对象通常构建的过程中需要多个步骤，就像我们例子中的先有主机，再有显示屏，再有鼠标等等，建造者模式的作用就是将这些复杂的构建过程封装起来。工厂模式构建对象的时候通常就只有一个步骤，调用一个工厂方法就可以生成一个对象。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><blockquote>
<p><strong>定义：</strong>通过复制现有实例来创建新的实例，无需知道相应类的信息。</p>
<p>其实就是当需要创建一个指定的对象时，我们刚好有一个这样的对象，但是又不能直接使用，我会clone一个一毛一样的新对象来使用；基本上这就是原型模式。关键字：Clone。</p>
</blockquote>
<h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p><strong>深拷贝：</strong>将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。clone明显是深复制，clone出来的对象是是不能去影响原型对象的</p>
<p><strong>浅拷贝：</strong>将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的</p>
<h4 id="原型模式的结构和代码示例"><a href="#原型模式的结构和代码示例" class="headerlink" title="原型模式的结构和代码示例"></a>原型模式的结构和代码示例</h4><ul>
<li><p><code>Client</code>：使用者</p>
</li>
<li><p><code>Prototype</code>：接口（抽象类），声明具备clone能力，例如java中得Cloneable接口</p>
</li>
<li><p><code>ConcretePrototype</code>：具体的原型类</p>
</li>
</ul>
<p>重点在于<code>Prototype</code>接口和<code>Prototype</code>接口的实现类<code>ConcretePrototype</code>。原型模式的具体实现：一个原型类，只需要实现<code>Cloneable</code>接口，覆写<code>clone</code>方法，此处<code>clone</code>方法可以改成任意的名称，因为<code>Cloneable</code>接口是个空接口，你可以任意定义实现类的方法名，如<code>cloneA</code>或者<code>cloneB</code>，因为此处的重点是<code>super.clone()</code>这句话，<code>super.clone()</code>调用的是<code>Object</code>的<code>clone()</code>方法。</p>
<pre><code class="prettyprint">public class Prototype implements Cloneable &#123;  
     public Object clone() throws CloneNotSupportedException &#123;  
         Prototype proto = (Prototype) super.clone();  
         return proto;  
     &#125;  
&#125;  
</code></pre>
<blockquote>
<p>原型模式的本质就是clone，可以解决构建复杂对象的资源消耗问题，能再某些场景中提升构建对象的效率；还有一个重要的用途就是保护性拷贝，可以通过返回一个拷贝对象的形式，实现只读的限制。</p>
</blockquote>
<h2 id="结构模式"><a href="#结构模式" class="headerlink" title="结构模式"></a>结构模式</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><blockquote>
<p><strong>定义：</strong> 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。分为类的适配器模式，对象的适配器模式，接口的适配器模式</p>
</blockquote>
<h4 id="类的适配器模式"><a href="#类的适配器模式" class="headerlink" title="类的适配器模式"></a>类的适配器模式</h4><blockquote>
<p>通过多重继承目标接口和被适配者类方式来实现适配。<em>将USB接口转为VGA接口</em></p>
</blockquote>
<p><code>USBImpl</code></p>
<pre><code class="prettyprint">public class USBImpl implements USB&#123;
       @Override
       public void showPPT() &#123;
              System.out.println(&quot;PPT内容演示&quot;);
       &#125;
&#125;
</code></pre>
<p><code>USB2VGAAdapter</code>继承<code>USBImpl</code>获取<code>USB</code>的功能，其次，实现<code>VGA</code>接口，表示该类的类型为<code>VGA</code>。</p>
<pre><code class="prettyprint">public class USB2VGAAdapter extends USBImpl implements VGA &#123;
       @Override
       public void projection() &#123;
              super.showPPT();
       &#125;
&#125;
</code></pre>
<p><code>Projector</code>将<code>USB</code>映射为<code>VGA</code>，只有<code>VGA</code>接口才可以连接上投影仪进行投影</p>
<pre><code class="prettyprint">public class Projector&lt;T&gt; &#123;
       public void projection(T t) &#123;
              if (t instanceof VGA) &#123;
                     System.out.println(&quot;开始投影&quot;);
                     VGA v = (VGA) t;
                     v.projection();
              &#125; else &#123;
                     System.out.println(&quot;接口不匹配，无法投影&quot;);
              &#125;
       &#125;
    // 测试
    public static void main(String[] args)&#123;
        //通过适配器创建一个VGA对象，这个适配器实际是使用的是USB的showPPT（）方法
        VGA a=new USB2VGAAdapter();
        //进行投影
        Projector p1=new Projector();
        p1.projection(a);
    &#125;
&#125;
</code></pre>
<h4 id="对象的适配器模式"><a href="#对象的适配器模式" class="headerlink" title="对象的适配器模式"></a>对象的适配器模式</h4><blockquote>
<p>对象适配器和类适配器使用了不同的方法实现适配，<strong>对象适配器使用组合，类适配器使用继承</strong>。<em>将USB接口转为VGA接口</em></p>
</blockquote>
<pre><code class="prettyprint">public class USB2VGAAdapter implements VGA &#123;
       USB u = new USBImpl();
       @Override
       public void projection() &#123;
              u.showPPT();
       &#125;
&#125;
</code></pre>
<h4 id="接口的适配器模式"><a href="#接口的适配器模式" class="headerlink" title="接口的适配器模式"></a>接口的适配器模式</h4><blockquote>
<p>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。<em>将USB接口转为VGA接口，VGA中的b()和c()不会被实现</em></p>
</blockquote>
<pre><code class="prettyprint">public abstract class USB2VGAAdapter implements VGA &#123;
       USB u = new USBImpl();
       @Override
       public void projection() &#123;
              u.showPPT();
       &#125;
       @Override
       public void b() &#123;
       &#125;;
       @Override
       public void c() &#123;
       &#125;;
&#125;
</code></pre>
<p>USB2VGAAdapter实现，不用去实现b()和c()方法。</p>
<pre><code class="prettyprint">public class AdapterUSB2VGAImpl extends AdapterUSB2VGA &#123;
       public void projection() &#123;
              super.projection();
       &#125;
&#125;
</code></pre>
<ul>
<li><strong>类适配器模式：</strong>当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</li>
<li><strong>对象适配器模式：</strong>当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。</li>
<li><strong>接口适配器模式：</strong>当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。</li>
</ul>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><blockquote>
<p><strong>定义：</strong>动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性。</p>
</blockquote>
<h4 id="装饰者模式结构图与代码示例"><a href="#装饰者模式结构图与代码示例" class="headerlink" title="装饰者模式结构图与代码示例"></a>装饰者模式结构图与代码示例</h4><ul>
<li><code>Component</code>（被装饰对象的基类）</li>
</ul>
<p>定义一个对象接口，可以给这些对象动态地添加职责。</p>
<ul>
<li><code>ConcreteComponent</code>（具体被装饰对象）</li>
</ul>
<p>定义一个对象，可以给这个对象添加一些职责。</p>
<ul>
<li><code>Decorator</code>（装饰者抽象类）</li>
</ul>
<p>维持一个指向Component实例的引用，并定义一个与Component接口一致的接口。</p>
<ul>
<li><code>ConcreteDecorator</code>（具体装饰者）</li>
</ul>
<p>具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。</p>
<img src="/2023/02/20/23-zhong-she-ji-mo-shi-xue-xi/image-20230221211208840.png" class="asset-class" title="image-20230221211208840">

<p>被装饰对象和修饰者继承自同一个超类</p>
<pre><code class="prettyprint">public abstract class Drink &#123;
    public String description=&quot;&quot;;
    private float price=0f;;


    public void setDescription(String description)
    &#123;
        this.description=description;
    &#125;

    public String getDescription()
    &#123;
        return description+&quot;-&quot;+this.getPrice();
    &#125;
    public float getPrice()
    &#123;
        return price;
    &#125;
    public void setPrice(float price)
    &#123;
        this.price=price;
    &#125;
    public abstract float cost();

&#125;
</code></pre>
<p>被装饰的对象</p>
<pre><code class="prettyprint">public class Coffee extends Drink &#123;
    @Override
    public float cost() &#123;
        return super.getPrice();
    &#125;

&#125;
</code></pre>
<pre><code class="prettyprint">public class Decaf extends Coffee &#123;
    public Decaf()&#123;
        super();
        this.setPrice(1.5f);
    &#125;
&#125;
</code></pre>
<pre><code class="prettyprint">public class LongBlack extends Coffee &#123;
    public LongBlack()&#123;
        super();
        this.setPrice(1f);
    &#125;
&#125;
</code></pre>
<p>装饰者不仅要考虑自身，还要考虑被它修饰的对象，它是在被修饰的对象上继续添加修饰。例如，咖啡里面加牛奶，再加巧克力。加糖后价格为coffee+milk。再加牛奶价格为coffee+milk+chocolate。</p>
<pre><code class="prettyprint">public class Decorator extends Drink &#123;
    private Drink Obj;
    public Decorator(Drink Obj) &#123;
        this.Obj = Obj;
    &#125;;
    @Override
    public float cost() &#123;
        return super.getPrice() + Obj.cost();
    &#125;
    @Override
    public String getDescription() &#123;
        return super.description + &quot;-&quot; + super.getPrice() + &quot;&amp;&amp;&quot; + Obj.getDescription();
    &#125;
&#125;
</code></pre>
<p>装饰者实例化（加牛奶）</p>
<pre><code class="prettyprint">public class Milk extends Decorator &#123;
    public Milk(Drink Obj) &#123;
        super(Obj);
        super.setDescription(&quot;Milk&quot;);
        super.setPrice(2.0f);
    &#125;
&#125;
</code></pre>
<p>装饰者实例化（加巧克力）</p>
<pre><code class="prettyprint">public class Chocolate extends Decorator &#123;
    public Chocolate(Drink Obj) &#123;
        super(Obj);
        super.setDescription(&quot;Chocolate&quot;);
        super.setPrice(3.0f);
    &#125;
&#125;
</code></pre>
<p>coffee店：初始化一个被修饰对象，修饰者实例需要对被修改者实例化，才能对具体的被修饰者进行修饰</p>
<pre><code class="prettyprint">public class CoffeeBar &#123;
    public static void main(String[] args) &#123;
        Drink order;
        order = new Decaf();
        System.out.println(&quot;order1 price:&quot; + order.cost());
        System.out.println(&quot;order1 desc:&quot; + order.getDescription());
        System.out.println(&quot;****************&quot;);
        order = new LongBlack();
        order = new Milk(order);
        order = new Chocolate(order);
        order = new Chocolate(order);
        System.out.println(&quot;order2 price:&quot; + order.cost());
        System.out.println(&quot;order2 desc:&quot; + order.getDescription());
    &#125;
&#125;
</code></pre>
<blockquote>
<p>装饰者和被装饰者之间必须是一样的类型,也就是要有共同的超类。在这里应用继承并不是实现方法的复制,而是实现类型的匹配。因为装饰者和被装饰者是同一个类型,因此装饰者可以取代被装饰者,这样就使被装饰者拥有了装饰者独有的行为。根据装饰者模式的理念,我们可以在任何时候,实现新的装饰者增加新的行为。如果是用继承,每当需要增加新的行为时,就要修改原程序了。</p>
</blockquote>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><blockquote>
<p><strong>定义：</strong>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。</p>
</blockquote>
<h4 id="为什么要用代理模式？"><a href="#为什么要用代理模式？" class="headerlink" title="为什么要用代理模式？"></a>为什么要用代理模式？</h4><p>中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。</p>
<p>开闭原则，增加功能：代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。</p>
<p>代理模式分为三类：1. 静态代理 2. 动态代理 3. CGLIB代理</p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><img src="/2023/02/20/23-zhong-she-ji-mo-shi-xue-xi/image-20230221212332891.png" class="asset-class" title="image-20230221212332891">

<ul>
<li><p>创建接口类</p>
<pre><code class="prettyprint">public interface BuyHouse &#123;
    void buyHouse();
&#125;
</code></pre>
</li>
<li><p>实现服务接口</p>
<pre><code class="prettyprint">public class BuyHouseImpl implements BuyHouse &#123;
    @Override
    public void buyHouse() &#123;
        System.out.println(&quot;我要买房&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>创建代理</p>
<pre><code class="prettyprint">public class BuyHouseProxy implements BuyHouse &#123;
    private final BuyHouse buyHouse;
    public BuyHouseProxy(final BuyHouse buyHouse) &#123;
        this.buyHouse = buyHouse;
    &#125;
    @Override
    public void buyHouse() &#123;
        System.out.println(&quot;BuyHouseProxy----买房前准备&quot;);
        buyHouse.buyHouse();
        System.out.println(&quot;BuyHouseProxy---买房后装修&quot;);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<blockquote>
<p><strong>优点：</strong>可以做到在符合开闭原则的情况下对目标对象进行功能扩展。</p>
<p><strong>缺点：</strong> 代理对象与目标对象要实现相同的接口，我们得为每一个服务都得创建代理类，不易管理。同时接口一旦发生改变，代理类也得相应修改。</p>
</blockquote>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><blockquote>
<ul>
<li><p>代理对象,不需要实现接口</p>
</li>
<li><p>代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象&#x2F;目标对象实现的接口的类型)</p>
</li>
<li><p>代理类不用再实现接口了。但是，要求被代理对象必须有接口。</p>
</li>
</ul>
</blockquote>
<p>动态代理实现：</p>
<p><code>Java.lang.reflect.Proxy</code>类可以直接生成一个代理对象</p>
<p>**Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) **生成一个代理对象</p>
<ul>
<li>参数1:<code>ClassLoader loader</code> 代理对象的类加载器 一般使用被代理对象的类加载器</li>
<li>参数2:<code>Class&lt;?&gt;[] interfaces</code> 代理对象的要实现的接口 一般使用的被代理对象实现的接口</li>
<li>参数3:<code>InvocationHandler h</code> (接口)执行处理类</li>
</ul>
<p><strong>InvocationHandler中的invoke(Object proxy, Method method, Object[] args)方法：</strong>调用代理类的任何方法，此方法都会执行</p>
<ul>
<li>参数1:代理对象(慎用)</li>
<li>参数2:当前执行的方法</li>
<li>参数3:当前执行的方法运行时传递过来的参数</li>
</ul>
<p><strong>编写动态处理器</strong></p>
<pre><code class="prettyprint">public class DynamicProxyHandler implements InvocationHandler &#123;
    private Object object;
    public DynamicProxyHandler(final Object object) &#123;
        this.object = object;
    &#125;
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        System.out.println(&quot;DynamicProxyHandler---买房前准备&quot;);
        Object result = method.invoke(object, args);
        System.out.println(&quot;DynamicProxyHandler---买房后装修&quot;);
        return result;
    &#125;
&#125;
</code></pre>
<p><strong>测试类</strong></p>
<pre><code class="prettyprint">public class DynamicProxyTest &#123;
    public static void main(String[] args) &#123;
        BuyHouse buyHouse = new BuyHouseImpl();
        BuyHouse proxyBuyHouse = (BuyHouse) Proxy.newProxyInstance(BuyHouse.class.getClassLoader(), new
                Class[]&#123;BuyHouse.class&#125;, new DynamicProxyHandler(buyHouse));
        proxyBuyHouse.buyHouse();
    &#125;
&#125;
</code></pre>
<blockquote>
<p>虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。但是还是有一点点小小的遗憾之处，那就是我们要使用被代理的对象的接口</p>
</blockquote>
<h4 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h4><blockquote>
<p>CGLIB 原理：动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快。</p>
<p>CGLIB 底层：使用字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</p>
<p>CGLIB缺点：对于final方法，无法进行代理。</p>
</blockquote>
<p><strong>jar包引入</strong></p>
<pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;cglib&lt;/groupId&gt;
    &lt;artifactId&gt;cglib&lt;/artifactId&gt;
    &lt;version&gt;3.3.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>定义类方法</strong></p>
<pre><code class="prettyprint">public class BuyHouse &#123;
    public void buyHouse(String name)&#123;
        System.out.println(name + &quot;要买房&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>定义拦截器</strong></p>
<pre><code class="prettyprint">public class BuyHouseInterceptor implements MethodInterceptor &#123;

    /**
     * 这里Enhancer类是CGLib中的一个字节码增强器，它可以方便的对你想要处理的类进行扩展，以后会经常看到它。
     * 首先将被代理类TargetObject设置成父类，
     * 然后设置拦截器TargetInterceptor，
     * 最后执行enhancer.create()动态生成一个代理类，并从Object强制转型成父类型TargetObject。
     *
     * @return
     */
    public Object getInstance(Class clazz) &#123;
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(clazz);
        enhancer.setCallback(this);
        return enhancer.create();
    &#125;

    @Override
    public Object intercept(Object obj, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;
        System.out.println(&quot;Before invoking buyHouse...&quot;);
        Object result = methodProxy.invokeSuper(obj, objects);
        System.out.println(&quot;After invoking buyHouse...&quot;);
        return result;
    &#125;
&#125;
</code></pre>
<p><strong>参数：</strong><code>Object</code>为由<code>CGLib</code>动态生成的代理类实例，<code>Method</code>为上文中实体类所调用的被代理的方法引用，<code>Object[]</code>为参数值列表，<code>MethodProxy</code>为生成的代理类对方法的代理引用。</p>
<p><strong>返回：</strong>从代理实例的方法调用返回的值。</p>
<p>其中，<code>proxy.invokeSuper(obj,arg) </code>调用代理类实例上的<code>proxy</code>方法的父类方法（即实体类<code>TargetObject</code>中对应的方法）</p>
<p><strong>调用测试</strong></p>
<pre><code class="prettyprint">public class DebuggingCglibDemo &#123;

    public static void main(String[] args) throws Exception &#123;
        String location = DebuggingCglibDemo.class.getResource(&quot;&quot;).getPath().replaceAll(&quot;%20&quot;, &quot; &quot;) + &quot;debugging/&quot;;
        System.out.println(&quot;location -&gt; &quot; + location);
        // 设置 CGLIB 的 debug 输出位置
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, location);
        BuyHouseInterceptor buyHouseInterceptor = new BuyHouseInterceptor();
        BuyHouse buyHouse = (BuyHouse) buyHouseInterceptor.getInstance(BuyHouse.class);
        buyHouse.buyHouse(&quot;roc&quot;);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。</p>
</blockquote>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><blockquote>
<p>**定义： **隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。</p>
</blockquote>
<p>该模式就是把一些复杂的流程封装成一个接口供给外部用户更简单的使用。这个模式中，设计到3个角色。</p>
<ul>
<li><p>门面角色：外观模式的核心。它被客户角色调用，它熟悉子系统的功能。内部根据客户角色的需求预定了几种功能的组合。（客户调用，同时自身调用子系统功能）</p>
</li>
<li><p>子系统角色：实现了子系统的功能。它对客户角色和Facade时未知的。它内部可以有系统内的相互交互，也可以由供外界调用的接口。（实现具体功能）</p>
</li>
<li><p>客户角色：通过调用Facede来完成要实现的功能（调用门面角色）。</p>
</li>
</ul>
<p>举例：每个Computer都有CPU、Memory、Disk。在Computer开启和关闭的时候，相应的部件也会开启和关闭</p>
<p><strong>子系统角色</strong></p>
<pre><code class="prettyprint">public class CPU &#123;

    public void start() &#123;
        System.out.println(&quot;cpu is start...&quot;);
    &#125;

    public void shutDown() &#123;
        System.out.println(&quot;CPU is shutDown...&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="prettyprint">public class Disk &#123;
    public void start() &#123;
        System.out.println(&quot;Disk is start...&quot;);
    &#125;

    public void shutDown() &#123;
        System.out.println(&quot;Disk is shutDown...&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="prettyprint">public class Memory &#123;
    public void start() &#123;
        System.out.println(&quot;Memory is start...&quot;);
    &#125;

    public void shutDown() &#123;
        System.out.println(&quot;Memory is shutDown...&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>门面角色</strong></p>
<pre><code class="prettyprint">public class Computer &#123;

    private CPU cpu;
    private Memory memory;
    private Disk disk;

    public Computer() &#123;
        cpu = new CPU();
        memory = new Memory();
        disk = new Disk();
    &#125;

    public void start() &#123;
        System.out.println(&quot;Computer start begin&quot;);
        cpu.start();
        disk.start();
        memory.start();
        System.out.println(&quot;Computer start end&quot;);
    &#125;

    public void shutDown() &#123;
        System.out.println(&quot;Computer shutDown begin&quot;);
        cpu.shutDown();
        disk.shutDown();
        memory.shutDown();
        System.out.println(&quot;Computer shutDown end...&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>客户角色</strong></p>
<pre><code class="prettyprint">public class Client &#123;
    public static void main(String[] args) &#123;
        Computer computer = new Computer();
        computer.start();
        System.out.println(&quot;=================&quot;);
        computer.shutDown();
    &#125;
&#125;
</code></pre>
<blockquote>
<p><em>松散耦合</em>：使得客户端和子系统之间解耦，让子系统内部的模块功能更容易扩展和维护；</p>
<p><em>简单易用</em>：客户端根本不需要知道子系统内部的实现，或者根本不需要知道子系统内部的构成，它只需要跟Facade类交互即可。</p>
<p><em>更好的划分访问层次</em>：有些方法是对系统外的，有些方法是系统内部相互交互的使用的。子系统把那些暴露给外部的功能集中到门面中，这样就可以实现客户端的使用，很好的隐藏了子系统内部的细节。</p>
</blockquote>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><blockquote>
<p><strong>定义：</strong> 将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
</blockquote>
<img src="/2023/02/20/23-zhong-she-ji-mo-shi-xue-xi/image-20230221224001605.png" class="asset-class" title="image-20230221224001605">

<ul>
<li><p>创建桥接实现接口</p>
<pre><code class="prettyprint">public interface Software &#123;
    public void run();
&#125;
</code></pre>
</li>
<li><p>创建实现了 <em>Software</em> 接口的实体桥接实现类。</p>
<pre><code class="prettyprint">public class AppStore implements Software &#123;
     
    @Override
    public void run() &#123;
        System.out.println(&quot;run app store&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="prettyprint">public class Camera implements Software &#123;
     
    @Override
    public void run() &#123;
        System.out.println(&quot;run camera&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>使用 <em>Software</em> 接口创建抽象类 <em>Phone</em>。</p>
<pre><code class="prettyprint">public abstract class Phone &#123;
 
    protected Software software;
 
    public void setSoftware(Software software) &#123;
        this.software = software;
    &#125;
 
    public abstract void run();
 
&#125;
</code></pre>
</li>
<li><p>创建实现了 <em>Phone</em> 抽象类的实体类。</p>
<pre><code class="prettyprint">public class Oppo extends Phone &#123;
    public Oppo(Software software)&#123;
        this.software = software;
    &#125;

    @Override
    public void run() &#123;
        this.software.run();
    &#125;
&#125;
</code></pre>
</li>
<li><p>使用 <em>Phone</em> 和 <em>Software</em> 类运行不同的软件</p>
<pre><code class="prettyprint">public class BridgePatternDemo &#123;
    public static void main(String[] args) &#123;
        Phone oppo1 = new Oppo(new Camera());
        Phone oppo2 = new Oppo(new AppStore());
        oppo1.run();
        oppo2.run();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<blockquote>
<p>从桥接模式的设计上我们可以看出聚合是一种比继承要弱的关联关系，手机类和软件类都可独立的进行变化，不会互相影响</p>
</blockquote>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><blockquote>
<p> <strong>定义：</strong>有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。 </p>
<p> <strong>意图：</strong>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 </p>
<p> <strong>主要解决：</strong>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。 </p>
<p> <strong>关键代码：</strong>树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p>
</blockquote>
<p><strong>优点：</strong></p>
<ul>
<li><p>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</p>
</li>
<li><p>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</p>
</li>
<li><p>不容易限制容器中的构件；</p>
</li>
<li><p>不容易用继承的方法来增加构件的新功能；</p>
</li>
</ul>
<h4 id="模式结构和代码示例"><a href="#模式结构和代码示例" class="headerlink" title="模式结构和代码示例"></a>模式结构和代码示例</h4><ul>
<li>抽象构件（<code>Component</code>）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</li>
<li>树叶构件（<code>Leaf</code>）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</li>
<li>树枝构件（<code>Composite</code>）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 <code>Add()</code>、<code>Remove()</code>、<code>GetChild()</code> 等方法</li>
</ul>
<p><strong>举例：</strong>部门人员上下级关系</p>
<ul>
<li><p>组件</p>
<pre><code class="prettyprint">public interface Component &#123;
    public void add(Component c);
    public void remove(Component c);
    public List&lt;Component&gt; getAllChild();
    public void operation();
&#125;
</code></pre>
</li>
<li><p>叶子结点</p>
<pre><code class="prettyprint">public class Employee implements Component &#123;
    private String name;
    private String dept;
    private int salary;
    private List&lt;Component&gt; subordinates;

    //构造函数
    public Employee(String name,String dept, int sal) &#123;
        this.name = name;
        this.dept = dept;
        this.salary = sal;
        subordinates = new ArrayList&lt;Component&gt;();
    &#125;

    @Override
    public String toString()&#123;
        return (&quot;Employee :[ Name : &quot;+ name
                +&quot;, dept : &quot;+ dept + &quot;, salary :&quot;
                + salary+&quot; ]&quot;);
    &#125;

    @Override
    public void add(Component c) &#123;
        subordinates.add(c);
    &#125;

    @Override
    public void remove(Component c) &#123;
        subordinates.remove(c);
    &#125;
    
    @Override
    public List&lt;Component&gt; getAllChild() &#123;
        return subordinates;
    &#125;

    @Override
    public void operation() &#123;
        System.out.println(&quot;Employee :[ Name : &quot;+ name
                +&quot;, dept : &quot;+ dept + &quot;, salary :&quot;
                + salary+&quot; ]&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="prettyprint">public class CompositePatternDemo &#123;
    public static void main(String[] args) &#123;
        Employee CEO = new Employee(&quot;John&quot;,&quot;CEO&quot;, 30000);

        Employee headSales = new Employee(&quot;Robert&quot;,&quot;Head Sales&quot;, 20000);

        Employee headMarketing = new Employee(&quot;Michel&quot;,&quot;Head Marketing&quot;, 20000);

        Employee clerk1 = new Employee(&quot;Laura&quot;,&quot;Marketing&quot;, 10000);
        Employee clerk2 = new Employee(&quot;Bob&quot;,&quot;Marketing&quot;, 10000);

        Employee salesExecutive1 = new Employee(&quot;Richard&quot;,&quot;Sales&quot;, 10000);
        Employee salesExecutive2 = new Employee(&quot;Rob&quot;,&quot;Sales&quot;, 10000);

        CEO.add(headSales);
        CEO.add(headMarketing);

        headSales.add(salesExecutive1);
        headSales.add(salesExecutive2);

        headMarketing.add(clerk1);
        headMarketing.add(clerk2);

        //打印该组织的所有员工
        CEO.operation();
        for (Component headEmployee : CEO.getAllChild()) &#123;
            headEmployee.operation();
            for (Component employee : headEmployee.getAllChild()) &#123;
                employee.operation();
            &#125;
        &#125;
    &#125;
&#125;
/**
 * Employee :[ Name : John, dept : CEO, salary :30000 ]
 * Employee :[ Name : Robert, dept : Head Sales, salary :20000 ]
 * Employee :[ Name : Richard, dept : Sales, salary :10000 ]
 * Employee :[ Name : Rob, dept : Sales, salary :10000 ]
 * Employee :[ Name : Michel, dept : Head Marketing, salary :20000 ]
 * Employee :[ Name : Laura, dept : Marketing, salary :10000 ]
 * Employee :[ Name : Bob, dept : Marketing, salary :10000 ]
 */
</code></pre>
</li>
</ul>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><blockquote>
<p><strong>定义</strong>：通过共享的方式高效的支持大量细粒度的对象。</p>
<p><strong>主要解决</strong>：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p>
<p><strong>关键代码</strong>：用 <code>HashMap </code>存储这些对象</p>
</blockquote>
<p> <strong>何时使用：</strong> </p>
<ul>
<li><p>系统中有大量对象。 </p>
</li>
<li><p>这些对象消耗大量内存。</p>
</li>
<li><p>这些对象的状态大部分可以外部化。 </p>
</li>
<li><p>这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。</p>
</li>
<li><p>系统不依赖于这些对象身份，这些对象是不可分辨的。</p>
</li>
</ul>
<p> <strong>应用实例</strong>： 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 </p>
<p> <strong>优点</strong>：大大减少对象的创建，降低系统的内存，使效率提高。 </p>
<p> <strong>缺点</strong>：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。 </p>
<h4 id="享元模式代码示例"><a href="#享元模式代码示例" class="headerlink" title="享元模式代码示例"></a>享元模式代码示例</h4><ul>
<li><p><code>Flyweight</code> (享元抽象类)：一般是接口或者抽象类，定义了享元类的公共方法。这些方法可以分享内部状态的数据，也可以调用这些方法修改外部状态。</p>
</li>
<li><p><code>ConcreteFlyweight</code>(具体享元类)：具体享元类实现了抽象享元类的方法，为享元对象开辟了内存空间来保存享元对象的内部数据，同时可以通过和单例模式结合只创建一个享元对象。</p>
</li>
<li><p><code>FlyweightFactory</code>(享元工厂类)：享元工厂类创建并且管理享元类，享元工厂类针对享元类来进行编程，通过提供一个享元池来进行享元对象的管理。一般享元池设计成键值对，或者其他的存储结构来存储。当客户端进行享元对象的请求时，如果享元池中有对应的享元对象则直接返回对应的对象，否则工厂类创建对应的享元对象并保存到享元池。</p>
</li>
</ul>
<ol>
<li><p>创建享元对象接口</p>
<pre><code class="prettyprint">public interface IFlyweight &#123;
    void print();
&#125;
</code></pre>
</li>
<li><p>创建具体享元对象</p>
<pre><code class="prettyprint">public class Flyweight implements IFlyweight &#123;
    private String id;
    public Flyweight(String id)&#123;
        this.id = id;
    &#125;
    @Override
    public void print() &#123;
        System.out.println(&quot;Flyweight.id = &quot; + getId() + &quot; ...&quot;);
    &#125;
    public String getId() &#123;
        return id;
    &#125;
&#125;
</code></pre>
</li>
<li><p>创建工厂，这里要特别注意，为了避免享元对象被重复创建，我们使用HashMap中的key值保证其唯一。</p>
</li>
</ol>
<pre><code class="prettyprint">public class FlyweightFactory &#123;
    private final Map&lt;String, IFlyweight&gt; flyweightMap = new HashMap&lt;&gt;();
    public IFlyweight getFlyweight(String str)&#123;
        IFlyweight flyweight = flyweightMap.get(str);
        if(flyweight == null)&#123;
            flyweight = new Flyweight(str);
            flyweightMap.put(str, flyweight);
        &#125;
        return  flyweight;
    &#125;
    public int getFlyweightMapSize()&#123;
        return flyweightMap.size();
    &#125;
&#125;
</code></pre>
<ol start="4">
<li>测试，我们创建三个字符串，但是只会产生两个享元对象</li>
</ol>
<pre><code class="prettyprint">public class MainTest &#123;
    public static void main(String[] args) &#123;
        FlyweightFactory flyweightFactory = new FlyweightFactory();
        IFlyweight flyweight1 = flyweightFactory.getFlyweight(&quot;A&quot;);
        IFlyweight flyweight2 = flyweightFactory.getFlyweight(&quot;B&quot;);
        IFlyweight flyweight3 = flyweightFactory.getFlyweight(&quot;A&quot;);
        flyweight1.print();
        flyweight2.print();
        flyweight3.print();
        System.out.println(flyweightFactory.getFlyweightMapSize());
    &#125;
&#125;
/**
 * Flyweight.id = A ...
 * Flyweight.id = B ...
 * Flyweight.id = A ...
 * 2
 */
</code></pre>
<h2 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h2><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><blockquote>
<p> <strong>定义：</strong>策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。  </p>
<p> <strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。 </p>
<p> <strong>关键代码：</strong>实现同一个接口。</p>
</blockquote>
<p><strong>优点：</strong> </p>
<ul>
<li><p>算法可以自由切换。 </p>
</li>
<li><p>避免使用多重条件判断。 </p>
</li>
<li><p>扩展性良好。</p>
</li>
</ul>
<p><strong>缺点：</strong> </p>
<ul>
<li>策略类会增多。 -</li>
<li>所有策略类都需要对外暴露。</li>
</ul>
<p> <strong>使用场景：</strong> </p>
<ul>
<li><p>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 </p>
</li>
<li><p>一个系统需要动态地在几种算法中选择一种。 </p>
</li>
<li><p>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p>
</li>
</ul>
<h4 id="策略模式结构和示例代码"><a href="#策略模式结构和示例代码" class="headerlink" title="策略模式结构和示例代码"></a>策略模式结构和示例代码</h4><p><strong>抽象策略角色</strong>： 这个是一个抽象的角色，通常情况下使用接口或者抽象类去实现。对比来说，就是我们的Comparator接口。</p>
<p><strong>具体策略角色</strong>：包装了具体的算法和行为。对比来说，就是实现了Comparator接口的实现一组实现类。</p>
<p><strong>环境角色</strong>：内部会持有一个抽象角色的引用，给客户端调用。</p>
<ul>
<li><p>定义策略接口</p>
<pre><code class="prettyprint">public interface RejectStrategy &#123;
    void reject(String message, Map&lt;String,Object&gt; paramMap, Fix fix);
&#125;
</code></pre>
</li>
<li><p>定义具体策略角色</p>
<pre><code class="prettyprint">@Slf4j
public class AnyMatchStrategy implements RejectStrategy&#123;
    @Override
    public void reject(String message, Map&lt;String, Object&gt; paramMap, Fix fix) &#123;
        Set&lt;String&gt; paramKetSet= paramMap.keySet();
        if(CollectionUtils.intersection(PlaceHolderUtils.keySet(message,fix),paramKetSet).size() &lt;= 0)&#123;
            log.error(&quot;消息占位符替换参数与消息模版完全不匹配，message = &#123;&#125;,param = &#123;&#125;&quot;,message,paramMap);
            throw new RuntimeException(&quot;消息占位符替换参数与消息模版完全不匹配&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="prettyprint">public class IgnoreRejectStrategy implements RejectStrategy&#123;
    @Override
    public void reject(String message, Map&lt;String, Object&gt; paramMap, Fix fix) &#123;

    &#125;
&#125;
</code></pre>
<pre><code class="prettyprint">@Slf4j
public class TotallyMatchStrategy implements RejectStrategy&#123;
    @Override
    public void reject(String message, Map&lt;String, Object&gt; paramMap, Fix fix) &#123;
        Set&lt;String&gt; paramKetSet= paramMap.keySet();
        if(!paramKetSet.containsAll(PlaceHolderUtils.keySet(message,fix)))&#123;
            log.error(&quot;消息占位符替换参数与消息模版不完全匹配，message = &#123;&#125;,param = &#123;&#125;&quot;,message,paramMap);
            throw new RuntimeException(&quot;消息占位符替换参数与消息模版不完全匹配&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>定义策略工厂</p>
<pre><code class="prettyprint">public class RejectStrategyFactory &#123;
    private static final IgnoreRejectStrategy IGNORE_REJECT_STRATEGY = new IgnoreRejectStrategy();
    private static final AnyMatchStrategy ANY_MATCH_STRATEGY = new AnyMatchStrategy();
    private static final TotallyMatchStrategy TOTALLY_MATCH_STRATEGY = new TotallyMatchStrategy();

    private RejectStrategyFactory()&#123;&#125;
    public static RejectStrategy getRejectStrategy(RejectStrategyEnum rejectStrategyEnum)&#123;
        switch (rejectStrategyEnum)&#123;
            case IGNORE:
                return IGNORE_REJECT_STRATEGY;
            case ANY_MATCH:
                return ANY_MATCH_STRATEGY;
            case TOTALLY_MATCH:
                return TOTALLY_MATCH_STRATEGY;
            default:
                throw new IllegalArgumentException(&quot;Illegal StrategyEnum Param&quot;);
        &#125;
    &#125;
    public static RejectStrategy getRejectStrategy()&#123;
        return IGNORE_REJECT_STRATEGY;
    &#125;
&#125;
public enum RejectStrategyEnum &#123;
    /*忽略，部分匹配，全匹配*/
    IGNORE,
    ANY_MATCH,
    TOTALLY_MATCH
&#125;
</code></pre>
</li>
<li><p>其他消息策略相关类</p>
<pre><code class="prettyprint">public class PlaceHolderUtils &#123;
    public static String replacePlaceholder(String message, Map&lt;String,Object&gt; paramMap, Fix fix)&#123;
        for(Map.Entry&lt;String, Object&gt; entry:paramMap.entrySet())&#123;
            message = message.replace(fix.getPrefix()+entry.getKey()+fix.getSuffix(), entry.getValue() == null ?&quot;&quot;:(CharSequence) entry.getValue() );
        &#125;
        return message;
    &#125;
    public static Set&lt;String&gt; keySet(String message, Fix fix)&#123;
        Set&lt;String&gt; strings = new HashSet&lt;&gt;();
        if(StringUtils.isNotBlank(message))&#123;
            while(message.indexOf(fix.getPrefix()) &gt; 0)&#123;
                int beg = message.indexOf(fix.getPrefix())+fix.getPrefix().length();
                int end = message.indexOf(fix.getSuffix());
                String sub = message.substring(beg, end);
                message = message.substring(end+fix.getSuffix().length());
                String param = sub.replace(fix.getPrefix(), &quot;&quot;).replace(fix.getSuffix(), &quot;&quot;);
                strings.add(param);
            &#125;
        &#125;
        return strings;
    &#125;
&#125;
// 消息参数替换格式
public class Fix &#123;
    private String prefix = &quot;&#123;&quot;;
    private String suffix = &quot;&#125;&quot;;

    public String getPrefix() &#123;
        return prefix;
    &#125;

    public void setPrefix(String prefix) &#123;
        this.prefix = prefix;
    &#125;

    public String getSuffix() &#123;
        return suffix;
    &#125;

    public void setSuffix(String suffix) &#123;
        this.suffix = suffix;
    &#125;
&#125;
// 消息模板处理接口
public interface TemplatePlaceHolderHandler &#123;
    String handler(String message, Map&lt;String,Object&gt; paramMap, Fix fix);
&#125;
// 消息模板，默认处理规则
public class DefaultTemplatePlaceHolderHandler implements TemplatePlaceHolderHandler&#123;
    private RejectStrategy rejectStrategy;

    public DefaultTemplatePlaceHolderHandler(RejectStrategy rejectStrategy) &#123;
        this.rejectStrategy = rejectStrategy;
    &#125;

    @Override
    public String handler(String message, Map&lt;String, Object&gt; paramMap, Fix fix) &#123;
        rejectStrategy.reject(message,paramMap,fix);
        return PlaceHolderUtils.replacePlaceholder(message,paramMap,fix);
    &#125;
&#125;
</code></pre>
</li>
<li><p>测试调用</p>
<pre><code class="prettyprint">// 获取对应策略对象
    private TemplatePlaceHolderHandler placeholder1 = new DefaultTemplatePlaceHolderHandler(RejectStrategyFactory.getRejectStrategy(RejectStrategyEnum.IGNORE));
// 执行方法
 String content = placeholder1.handler(messages.get(5), paramMap, commonProperties.getFix());
</code></pre>
</li>
</ul>
<h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><blockquote>
<p> <strong>定义：</strong>定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。 </p>
<p> 完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。 </p>
</blockquote>
<ul>
<li>抽象的做菜父类：</li>
</ul>
<pre><code class="prettyprint">public abstract class Dish &#123;
    /**
     * 具体的整个过程
     */
    protected void doDish()&#123;
        this.preparation();
        this.doing();
        this.carriedDishes();
    &#125;
    /**
     * 备料
     */
    public abstract void preparation();
    /**
     * 做菜
     */
    public abstract void doing();
    /**
     * 上菜
     */
    public abstract void carriedDishes ();
&#125;
</code></pre>
<ul>
<li>番茄炒蛋（EggsWithTomato）和红烧肉（Bouilli）实现父类中的抽象方法</li>
</ul>
<pre><code class="prettyprint">public class EggsWithTomato extends Dish &#123;

    @Override
    public void preparation() &#123;
        System.out.println(&quot;洗并切西红柿，打鸡蛋。&quot;);
    &#125;

    @Override
    public void doing() &#123;
        System.out.println(&quot;鸡蛋倒入锅里，然后倒入西红柿一起炒。&quot;);
    &#125;

    @Override
    public void carriedDishes() &#123;
        System.out.println(&quot;将炒好的西红寺鸡蛋装入碟子里，端给客人吃。&quot;);
    &#125;

&#125;
</code></pre>
<pre><code class="prettyprint">public class Bouilli extends Dish&#123;

    @Override
    public void preparation() &#123;
        System.out.println(&quot;切猪肉和土豆。&quot;);
    &#125;

    @Override
    public void doing() &#123;
        System.out.println(&quot;将切好的猪肉倒入锅中炒一会然后倒入土豆连炒带炖。&quot;);
    &#125;

    @Override
    public void carriedDishes() &#123;
        System.out.println(&quot;将做好的红烧肉盛进碗里端给客人吃。&quot;);
    &#125;

&#125;
</code></pre>
<ul>
<li>在测试类中我们来做菜：</li>
</ul>
<pre><code class="prettyprint">public class MainTest &#123;
    public static void main(String[] args) &#123;
        Dish eggsWithTomato = new EggsWithTomato();
        eggsWithTomato.doDish();

        System.out.println(&quot;-----------------------------&quot;);

        Dish bouilli = new Bouilli();
        bouilli.doDish();
    &#125;

&#125;
/**
 * 洗并切西红柿，打鸡蛋。
 * 鸡蛋倒入锅里，然后倒入西红柿一起炒。
 * 将炒好的西红寺鸡蛋装入碟子里，端给客人吃。
 * -----------------------------
 * 切猪肉和土豆。
 * 将切好的猪肉倒入锅中炒一会然后倒入土豆连炒带炖。
 * 将做好的红烧肉盛进碗里端给客人吃。
 */
</code></pre>
<blockquote>
<p><strong>优点：</strong></p>
<ul>
<li>具体细节步骤实现定义在子类中，子类定义详细处理算法是不会改变算法整体结构。</li>
<li>代码复用的基本技术，在数据库设计中尤为重要。</li>
<li>存在一种反向的控制结构，通过一个父类调用其子类的操作，通过子类对父类进行扩展增加新的行为，符合“开闭原则”。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>每个不同的实现都需要定义一个子类，会导致类的个数增加，系统更加庞大。</li>
</ul>
</blockquote>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><blockquote>
<p> <strong>定义：</strong> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 (广播)</p>
<p> <strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 </p>
<p> <strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。</p>
</blockquote>
<h4 id="模式结构图和代码示例"><a href="#模式结构图和代码示例" class="headerlink" title="模式结构图和代码示例"></a>模式结构图和代码示例</h4><ul>
<li><strong>抽象被观察者角色：</strong>也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。</li>
<li><strong>抽象观察者角色：</strong>为所有的具体观察者定义一个接口，在得到主题通知时更新自己</li>
<li><strong>具体被观察者角色：</strong>也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。</li>
<li><strong>具体观察者角色：</strong>实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。</li>
</ul>
<ol>
<li><p>定义一个抽象被观察者接口<code>Subject </code></p>
<pre><code class="prettyprint">public interface Subject &#123;
    public void registerObserver(Observer o);
    public void removeObserver(Observer o);
    public void notifyObserver();
&#125;
</code></pre>
</li>
<li><p>定义一个抽象观察者接口</p>
<pre><code class="prettyprint">public interface Observer &#123;
    public void update(String message);
&#125;
</code></pre>
</li>
<li><p>定义被观察者，实现了Subject接口，对Subject接口的三个方法进行了具体实现，同时有一个List集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可。</p>
</li>
</ol>
<pre><code class="prettyprint">public class WechatServer implements Subject &#123;

    private List&lt;Observer&gt; list;
    private String message;

    public WechatServer() &#123;
        list = new ArrayList&lt;Observer&gt;();
    &#125;

    @Override
    public void registerObserver(Observer o) &#123;
        list.add(o);
    &#125;

    @Override
    public void removeObserver(Observer o) &#123;
        if (!list.isEmpty()) &#123;
            list.remove(o);
        &#125;
    &#125;

    @Override
    public void notifyObserver() &#123;
        for (Observer o : list) &#123;
            o.update(message);
        &#125;
    &#125;

    public void setInfomation(String s) &#123;
        this.message = s;
        System.out.println(&quot;微信服务更新消息： &quot; + s);
        // 消息更新，通知所有观察者
        notifyObserver();
    &#125;

&#125;
</code></pre>
<ol start="4">
<li>定义具体观察者，微信公众号的具体观察者为用户User</li>
</ol>
<pre><code class="prettyprint">public class User implements Observer &#123;

    private String name;
    private String message;

    public User(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public void update(String message) &#123;
        this.message = message;
        read();
    &#125;

    public void read() &#123;
        System.out.println(name + &quot; 收到推送消息： &quot; + message);
    &#125;

&#125;
</code></pre>
<ol start="5">
<li><p>测试</p>
<pre><code class="prettyprint">public class MainTest &#123;
    public static void main(String[] args) &#123;

        WechatServer server = new WechatServer();

        Observer userZhang = new User(&quot;ZhangSan&quot;);
        Observer userLi = new User(&quot;LiSi&quot;);
        Observer userWang = new User(&quot;WangWu&quot;);

        server.registerObserver(userZhang);
        server.registerObserver(userLi);
        server.registerObserver(userWang);
        server.setInfomation(&quot;PHP是世界上最好用的语言！&quot;);

        System.out.println(&quot;----------------------------------------------&quot;);
        server.removeObserver(userZhang);
        server.setInfomation(&quot;JAVA是世界上最好用的语言！&quot;);

    &#125;
&#125;
/**
 * 微信服务更新消息： PHP是世界上最好用的语言！
 * ZhangSan 收到推送消息： PHP是世界上最好用的语言！
 * LiSi 收到推送消息： PHP是世界上最好用的语言！
 * WangWu 收到推送消息： PHP是世界上最好用的语言！
 * ----------------------------------------------
 * 微信服务更新消息： JAVA是世界上最好用的语言！
 * LiSi 收到推送消息： JAVA是世界上最好用的语言！
 * WangWu 收到推送消息： JAVA是世界上最好用的语言！
 */
</code></pre>
</li>
</ol>
<blockquote>
<p><strong>优点：</strong></p>
<ul>
<li><p>观察者和被观察者是抽象耦合的。</p>
</li>
<li><p>建立一套触发机制。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</p>
</li>
<li><p>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</p>
</li>
<li><p>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p>
</li>
</ul>
</blockquote>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><blockquote>
<p><strong>定义：</strong>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p>
<p><strong>优点：</strong> </p>
<ul>
<li><p>它支持以不同的方式遍历一个聚合对象。</p>
</li>
<li><p>迭代器简化了聚合类。</p>
</li>
<li><p>在同一个聚合上可以有多个遍历。</p>
</li>
<li><p>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p>
</li>
</ul>
<p><strong>缺点：</strong>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p>
<p><strong>关键代码：</strong>定义接口：<code>hasNext()</code>, <code>next()</code>。</p>
</blockquote>
<h4 id="迭代器模式结构和代码示例"><a href="#迭代器模式结构和代码示例" class="headerlink" title="迭代器模式结构和代码示例"></a>迭代器模式结构和代码示例</h4><ul>
<li><p>迭代器角色（<code>Iterator</code>）:定义遍历元素所需要的方法，一般来说会有这么三个方法：取得下一个元素的方法<code>next()</code>，判断是否遍历结束的方法<code>hasNext()</code>，移出当前对象的方法<code>remove()</code></p>
</li>
<li><p>具体迭代器角色（<code>Concrete Iterator</code>）：实现迭代器接口中定义的方法，完成集合的迭代。</p>
</li>
<li><p>容器角色(<code>Aggregate</code>): 一般是一个接口，提供一个<code>iterator()</code>方法，例如java中的<code>Collection</code>接口，<code>List</code>接口，<code>Set</code>接口等</p>
</li>
<li><p>具体容器角色（<code>ConcreteAggregate</code>）：就是抽象容器的具体实现类，比如<code>List</code>接口的有序列表实现<code>ArrayList</code>，&#96;&#96;List接口的链表实现<code>LinkList</code>，<code>Set</code>接口的哈希列表的实现<code>HashSet</code>等。</p>
</li>
</ul>
<ol>
<li><p>迭代器接口</p>
<pre><code class="prettyprint">public interface Iterator &#123;
    public boolean hasNext();
    public Object next();
&#125;
</code></pre>
<pre><code class="prettyprint">@AllArgsConstructor
@Data
public class MenuItem &#123;
    String name;
    String description;
    boolean vegetable;
    float price;
&#125;
</code></pre>
</li>
<li><p>咖啡店菜单和咖啡店菜单遍历器</p>
<pre><code class="prettyprint">public class CakeHouseMenu &#123;
    private ArrayList&lt;MenuItem&gt; menuItems;

    public CakeHouseMenu() &#123;
        menuItems = new ArrayList&lt;MenuItem&gt;();
        addItem(&quot;KFC Cake Breakfast&quot;, &quot;boiled eggs&amp;toast&amp;cabbage&quot;, true, 3.99f);
        addItem(&quot;MDL Cake Breakfast&quot;, &quot;fried eggs&amp;toast&quot;, false, 3.59f);
        addItem(&quot;Stawberry Cake&quot;, &quot;fresh stawberry&quot;, true, 3.29f);
        addItem(&quot;Regular Cake Breakfast&quot;, &quot;toast&amp;sausage&quot;, true, 2.59f);
    &#125;

    private void addItem(String name, String description, boolean vegetable, float price) &#123;
        MenuItem menuItem = new MenuItem(name, description, vegetable, price);
        menuItems.add(menuItem);
    &#125;

    public Iterator getIterator() &#123;
        return new CakeHouseIterator();
    &#125;

    class CakeHouseIterator implements Iterator &#123;
        private int position = 0;

        public CakeHouseIterator() &#123;
            position = 0;
        &#125;

        @Override
        public boolean hasNext() &#123;
            if (position &lt; menuItems.size()) &#123;
                return true;
            &#125;

            return false;
        &#125;

        @Override
        public Object next() &#123;
            MenuItem menuItem = menuItems.get(position);
            position++;
            return menuItem;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>中餐厅菜单和中餐厅菜单遍历器</p>
<pre><code class="prettyprint">public class DinerMenu &#123;
    private final static int Max_Items = 5;
    private int numberOfItems = 0;
    private MenuItem[] menuItems;

    public DinerMenu() &#123;
        menuItems = new MenuItem[Max_Items];
        addItem(&quot;vegetable Blt&quot;, &quot;bacon&amp;lettuce&amp;tomato&amp;cabbage&quot;, true, 3.58f);
        addItem(&quot;Blt&quot;, &quot;bacon&amp;lettuce&amp;tomato&quot;, false, 3.00f);
        addItem(&quot;bean soup&quot;, &quot;bean&amp;potato salad&quot;, true, 3.28f);
        addItem(&quot;hotdog&quot;, &quot;onions&amp;cheese&amp;bread&quot;, false, 3.05f);
    &#125;

    private void addItem(String name, String description, boolean vegetable,float price) &#123;
        MenuItem menuItem = new MenuItem(name, description, vegetable, price);
        if (numberOfItems &gt;= Max_Items) &#123;
            System.err.println(&quot;sorry,menu is full!can not add another item&quot;);
        &#125; else &#123;
            menuItems[numberOfItems] = menuItem;
            numberOfItems++;
        &#125;
    &#125;

    public Iterator getIterator() &#123;
        return new DinerIterator();
    &#125;

    class DinerIterator implements Iterator &#123;
        private int position;

        public DinerIterator() &#123;
            position = 0;
        &#125;

        @Override
        public boolean hasNext() &#123;
            if (position &lt; numberOfItems) &#123;
                return true;
            &#125;
            return false;
        &#125;

        @Override
        public Object next() &#123;
            MenuItem menuItem = menuItems[position];
            position++;
            return menuItem;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>服务员上菜</p>
<pre><code class="prettyprint">public class Waitress &#123;
    private ArrayList&lt;Iterator&gt; iterators = new ArrayList&lt;Iterator&gt;();

    public void addIterator(Iterator iterator) &#123;
        iterators.add(iterator);
    &#125;

    public void printMenu() &#123;
        Iterator iterator;
        MenuItem menuItem;
        for (int i = 0, len = iterators.size(); i &lt; len; i++) &#123;
            iterator = iterators.get(i);
            while (iterator.hasNext()) &#123;
                menuItem = (MenuItem) iterator.next();
                System.out.println(menuItem.getName() + &quot;----------&quot; + menuItem.getPrice() + &quot;----------&quot; + menuItem.getDescription());
            &#125;
            System.out.println(&quot;------------------------------------------------&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="prettyprint">public class MainTest &#123;
    public static void main(String[] args) &#123;
        Waitress waitress = new Waitress();
        waitress.addIterator(new CakeHouseMenu().getIterator());
        waitress.addIterator(new DinerMenu().getIterator());
        waitress.printMenu();
    &#125;
&#125;
/**
 * KFC Cake Breakfast----------3.99----------boiled eggs&amp;toast&amp;cabbage
 * MDL Cake Breakfast----------3.59----------fried eggs&amp;toast
 * Stawberry Cake----------3.29----------fresh stawberry
 * Regular Cake Breakfast----------2.59----------toast&amp;sausage
 * ------------------------------------------------
 * vegetable Blt----------3.58----------bacon&amp;lettuce&amp;tomato&amp;cabbage
 * Blt----------3.0----------bacon&amp;lettuce&amp;tomato
 * bean soup----------3.28----------bean&amp;potato salad
 * hotdog----------3.05----------onions&amp;cheese&amp;bread
 */
</code></pre>
</li>
</ol>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><blockquote>
<p><strong>定义：</strong>如果有多个对象有机会处理请求，责任链可使请求的发送者和接受者解耦，请求沿着责任链传递，直到有一个对象处理了它为止。</p>
<p><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<p><strong>关键代码：</strong><code>Handler</code> 里面聚合它自己，在 <code>HandlerRequest </code>里判断是否合适，如果没达到条件则向下传递，向谁传递之前<code>set</code>进去。</p>
</blockquote>
<h4 id="责任链模式的结构和代码示例"><a href="#责任链模式的结构和代码示例" class="headerlink" title="责任链模式的结构和代码示例"></a>责任链模式的结构和代码示例</h4><ul>
<li>抽象处理者<code>Handler</code>角色：定义一个处理请求的接口，包含抽象处理方法和一个<strong>后继连接</strong>。</li>
<li>具体处理者<code>Concrete Handler</code>角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类<code>Client</code>角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ul>
<ol>
<li><p>决策者抽象类，包含对请求处理的函数，同时还包含指定下一个决策者的函数</p>
<pre><code class="prettyprint">public abstract class Approver &#123;
    Approver successor;
    String Name;

    public Approver(String Name) &#123;
        this.Name = Name;
    &#125;

    public abstract void ProcessRequest(PurchaseRequest request);

    public void SetSuccessor(Approver successor) &#123;
        this.successor = successor;
    &#125;
&#125;
</code></pre>
</li>
<li><p>客户端以及请求</p>
<pre><code class="prettyprint">public class PurchaseRequest &#123;
    private int Type = 0;
    private int Number = 0;
    private float Price = 0;
    private int ID = 0;

    public PurchaseRequest(int Type, int Number, float Price) &#123;
        this.Type = Type;
        this.Number = Number;
        this.Price = Price;
    &#125;

    public int GetType() &#123;
        return Type;
    &#125;

    public float GetSum() &#123;
        return Number * Price;
    &#125;

    public int GetID() &#123;
        return (int) (Math.random() * 1000);
    &#125;
&#125;
public class Client &#123;

    public PurchaseRequest sendRequest(int Type, int Number, float Price) &#123;
        return new PurchaseRequest(Type, Number, Price);
    &#125;

&#125;
</code></pre>
</li>
<li><p>组长、部长。。。继承决策者抽象类</p>
<pre><code class="prettyprint">public class GroupApprover extends Approver &#123;

    public GroupApprover(String Name) &#123;
        super(Name + &quot; GroupLeader&quot;);
    &#125;

    @Override
    public void ProcessRequest(PurchaseRequest request) &#123;
        if (request.GetSum() &lt; 5000) &#123;
            System.out.println(&quot;**This request &quot; + request.GetID() + &quot; will be handled by &quot; + this.Name + &quot; **&quot;);
        &#125; else &#123;
            successor.ProcessRequest(request);
        &#125;
    &#125;

&#125;
public class DepartmentApprover extends Approver &#123;

    public DepartmentApprover(String Name) &#123;
        super(Name + &quot; DepartmentLeader&quot;);
    &#125;

    @Override
    public void ProcessRequest(PurchaseRequest request) &#123;
        if ((5000 &lt;= request.GetSum()) &amp;&amp; (request.GetSum() &lt; 10000)) &#123;
            System.out.println(&quot;**This request &quot; + request.GetID()
                    + &quot; will be handled by &quot; + this.Name + &quot; **&quot;);
        &#125; else &#123;
            successor.ProcessRequest(request);
        &#125;
    &#125;
&#125;
public class VicePresidentApprover extends Approver &#123;

    public VicePresidentApprover(String Name) &#123;
        super(Name + &quot; VicePresidentmentLeader&quot;);
    &#125;

    @Override
    public void ProcessRequest(PurchaseRequest request) &#123;
        if ((10000 &lt;= request.GetSum()) &amp;&amp; (request.GetSum() &lt; 20000)) &#123;
            System.out.println(&quot;**This request &quot; + request.GetID()
                    + &quot; will be handled by &quot; + this.Name + &quot; **&quot;);
        &#125; else &#123;
            successor.ProcessRequest(request);
        &#125;
    &#125;
&#125;
public class PresidentApprover extends Approver &#123;
    public PresidentApprover(String Name) &#123;
        super(Name + &quot; PresidentLeader&quot;);
    &#125;

    @Override
    public void ProcessRequest(PurchaseRequest request) &#123;
        if ((20000 &lt;= request.GetSum())) &#123;
            System.out.println(&quot;**This request &quot; + request.GetID()
                    + &quot; will be handled by &quot; + this.Name + &quot; **&quot;);
        &#125; else &#123;
            successor.ProcessRequest(request);
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="prettyprint">public class MainTest &#123;
    public static void main(String[] args) &#123;
        Client mClient = new Client();
        Approver GroupLeader = new GroupApprover(&quot;Tom&quot;);
        Approver VicePresident = new VicePresidentApprover(&quot;Kate&quot;);
        Approver DepartmentLeader = new DepartmentApprover(&quot;Jerry&quot;);
        Approver President = new PresidentApprover(&quot;Bush&quot;);
        /*组长、副部、部长、总裁*/
        GroupLeader.SetSuccessor(VicePresident);
        VicePresident.SetSuccessor(DepartmentLeader);
        DepartmentLeader.SetSuccessor(President);
        President.SetSuccessor(GroupLeader);
        GroupLeader.ProcessRequest(mClient.sendRequest(1, 400, 40));
    &#125;
&#125;
</code></pre>
</li>
</ol>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><blockquote>
<p><strong>定义：</strong>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。 </p>
<p><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。 </p>
</blockquote>
<h4 id="命令模式结构和代码示例"><a href="#命令模式结构和代码示例" class="headerlink" title="命令模式结构和代码示例"></a>命令模式结构和代码示例</h4><ul>
<li>抽象命令类 <code>Command</code> 角色：声明执行命令的接口，拥有执行命令的抽象方法 <code>execute()</code>。</li>
<li>具体命令角色 <code>Concrete Command</code> 角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li>
<li>实现者&#x2F;接收者 <code>Receiver</code>角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>
<li>调用者&#x2F;请求者 <code>Invoke</code> 角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>
</ul>
<p><strong>举例：关灯</strong></p>
<ol>
<li>命令抽象类</li>
</ol>
<pre><code class="prettyprint">public interface Command &#123;
    public void execute();
    public void undo();
&#125;
</code></pre>
<ol start="2">
<li><p>具体命令对象</p>
<pre><code class="prettyprint">public class TurnOffLight implements Command &#123;

    private Light light;

    public TurnOffLight(Light light) &#123;
        this.light = light;
    &#125;

    @Override
    public void execute() &#123;
        light.Off();
    &#125;

    @Override
    public void undo() &#123;
        light.On();
    &#125;

&#125;
</code></pre>
</li>
<li><p>实现者</p>
<pre><code class="prettyprint">public class Light &#123;

    String loc = &quot;&quot;;

    public Light(String loc) &#123;
        this.loc = loc;
    &#125;

    public void On() &#123;

        System.out.println(loc + &quot; On&quot;);
    &#125;

    public void Off() &#123;

        System.out.println(loc + &quot; Off&quot;);
    &#125;

&#125;
</code></pre>
</li>
<li><p>请求者</p>
<pre><code class="prettyprint">public class Controller &#123;
    public void commandExecute(Command command) &#123;
        command.execute();
    &#125;

    public void commandUndo(Command command) &#123;
        command.undo();
    &#125;
&#125;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="prettyprint">public class MainTest &#123;
    public static void main(String[] args) &#123;
        Controller controller = new Controller();
        TurnOffLight turnOffLight = new TurnOffLight(new Light(&quot;roc&quot;));
        controller.commandUndo(turnOffLight);
        controller.commandExecute(turnOffLight);
    &#125;
&#125;
</code></pre>
</li>
</ol>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><blockquote>
<p><strong>定义：</strong> 在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 <code>context</code> 对象。 </p>
<p><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p>
<p><strong>关键代码：</strong>通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。  </p>
</blockquote>
<p><strong>优点：</strong> </p>
<ul>
<li><p>封装了转换规则。 </p>
</li>
<li><p>枚举可能的状态，在枚举状态之前需要确定状态种类。 </p>
</li>
<li><p>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</p>
</li>
<li><p>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</p>
</li>
<li><p>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p>
</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>状态模式的使用必然会增加系统类和对象的个数。 </li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 </li>
<li>状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</li>
</ul>
<h4 id="状态模式结构和代码示例"><a href="#状态模式结构和代码示例" class="headerlink" title="状态模式结构和代码示例"></a>状态模式结构和代码示例</h4><ul>
<li><strong>State抽象状态角色</strong></li>
</ul>
<p>接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。</p>
<ul>
<li><strong>ConcreteState具体状态角色</strong></li>
</ul>
<p>具体状态主要有两个职责：一是处理本状态下的事情，二是从本状态如何过渡到其他状态。</p>
<ul>
<li><strong>Context环境角色</strong></li>
</ul>
<p>定义客户端需要的接口，并且负责具体状态的切换。</p>
<ol>
<li><p><code>state</code> 抽象接口</p>
<pre><code class="prettyprint">public interface State &#123;
    public void doAction(Context context);
&#125;
</code></pre>
</li>
<li><p>状态实例</p>
<pre><code class="prettyprint">public class StartState implements State &#123;

    @Override
    public void doAction(Context context) &#123;
        System.out.println(&quot;Player is in start state&quot;);
        context.setState(this);
    &#125;

    @Override
    public String toString()&#123;
        return &quot;Start State&quot;;
    &#125;
&#125;
</code></pre>
<pre><code class="prettyprint">public class StopState implements State &#123;

    @Override
    public void doAction(Context context) &#123;
        System.out.println(&quot;Player is in stop state&quot;);
        context.setState(this);
    &#125;

    @Override
    public String toString()&#123;
        return &quot;Stop State&quot;;
    &#125;
&#125;
</code></pre>
</li>
<li><p><code>context(player)</code>拥有状态的对象 </p>
<pre><code class="prettyprint">public class Context &#123;
    private State state;

    public Context()&#123;
        state = null;
    &#125;

    public void setState(State state)&#123;
        this.state = state;
    &#125;

    public State getState()&#123;
        return state;
    &#125;
&#125;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="prettyprint">public class MainTest &#123;
    public static void main(String[] args) &#123;
        Context context = new Context();
        StartState startState = new StartState();
        startState.doAction(context);
        System.out.println(context.getState().toString());
        StopState stopState = new StopState();
        stopState.doAction(context);
        System.out.println(context.getState().toString());
    &#125;
&#125;
/**
 * Player is in start state
 * Start State
 * Player is in stop state
 * Stop State
 */
</code></pre>
</li>
</ol>
<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><blockquote>
<p><strong>定义：</strong> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。备忘录模式是一种对象行为型模式 </p>
</blockquote>
<p><strong>优点：</strong></p>
<ul>
<li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li>
<li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li>
<li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li>
</ul>
<h4 id="备忘录模式结构图和代码示例"><a href="#备忘录模式结构图和代码示例" class="headerlink" title="备忘录模式结构图和代码示例"></a>备忘录模式结构图和代码示例</h4><ul>
<li>发起人 <code>Originator</code> 角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li>
<li>备忘录 <code>Memento</code> 角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>
<li>管理者 <code>Caretaker</code> 角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li>
</ul>
<ol>
<li><p>备忘录接口</p>
<pre><code class="prettyprint">public interface MementoIf &#123;
&#125;
</code></pre>
</li>
<li><p>备忘录</p>
<pre><code class="prettyprint">public class Memento implements MementoIf&#123;
    private String state;

    public Memento(String state) &#123;
        this.state = state;
    &#125;

    public String getState()&#123;
        return state;
    &#125;
&#125;
</code></pre>
</li>
<li><p>发起者(状态变更)</p>
<pre><code class="prettyprint">public class Originator &#123;
    private String state;

    public String getState() &#123;
        return state;
    &#125;

    public void setState(String state) &#123;
        this.state = state;
    &#125;

    public Memento saveStateToMemento() &#123;
        return new Memento(state);
    &#125;

    public String getStateFromMemento(MementoIf memento) &#123;
        return ((Memento) memento).getState();
    &#125;
&#125;
</code></pre>
</li>
<li><p>管理者(备份)</p>
<pre><code class="prettyprint">public class CareTaker &#123;
    private List&lt;MementoIf&gt; mementoList = new ArrayList&lt;MementoIf&gt;();

    public void add(MementoIf memento) &#123;
        mementoList.add(memento);
    &#125;

    public MementoIf get(int index) &#123;
        return mementoList.get(index);
    &#125;
&#125;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="prettyprint">public class MainTest &#123;
    public static void main(String[] args) &#123;
        Originator originator = new Originator();
        CareTaker careTaker = new CareTaker();
        originator.setState(&quot;State #1&quot;);
        originator.setState(&quot;State #2&quot;);
        careTaker.add(originator.saveStateToMemento());
        originator.setState(&quot;State #3&quot;);
        careTaker.add(originator.saveStateToMemento());
        originator.setState(&quot;State #4&quot;);

        System.out.println(&quot;Current State: &quot; + originator.getState());
        System.out.println(&quot;First saved State: &quot; + originator.getStateFromMemento(careTaker.get(0)));
        System.out.println(&quot;Second saved State: &quot; + originator.getStateFromMemento(careTaker.get(1)));
    &#125;
&#125;
/**
 * Current State: State #4
 * First saved State: State #2
 * Second saved State: State #3
 */
</code></pre>
</li>
</ol>
<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><blockquote>
<p><strong>定义：</strong> 将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离。 </p>
</blockquote>
<p><strong>优点：</strong></p>
<ul>
<li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li>
<li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li>
<li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li>
<li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</li>
<li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</li>
<li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li>
</ul>
<h4 id="访问者模式结构和代码示例"><a href="#访问者模式结构和代码示例" class="headerlink" title="访问者模式结构和代码示例"></a>访问者模式结构和代码示例</h4><ul>
<li><p>抽象访问者 <code>Visitor</code> 角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 <code>visit()</code> ，该操作中的参数类型标识了被访问的具体元素。</p>
</li>
<li><p>具体访问者 <code>ConcreteVisitor</code> 角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</p>
</li>
<li><p>抽象元素 <code>Element</code> 角色：声明一个包含接受操作 <code>accept() </code>的接口，被接受的访问者对象作为 <code>accept() </code>方法的参数。</p>
</li>
<li><p>具体元素 <code>ConcreteElement</code> 角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 <code>visitor.visit(this) </code>，另外具体元素中可能还包含本身业务逻辑的相关操作。</p>
</li>
<li><p>对象结构 <code>Object Structure</code> 角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 <code>List、Set、Map</code> 等聚合类实现。</p>
</li>
</ul>
<ol>
<li><p>抽象访问者</p>
<pre><code class="prettyprint">public interface ComputerPartVisitor   &#123;
    public void visit(Computer computer);
    public void visit(Mouse mouse);
    public void visit(Keyboard keyboard);
    public void visit(Monitor monitor);
&#125;
</code></pre>
</li>
<li><p>具体访问者</p>
<pre><code class="prettyprint">public class ComputerPartDisplayVisitor implements ComputerPartVisitor &#123;

    @Override
    public void visit(Computer computer) &#123;
        System.out.println(&quot;Displaying Computer.&quot;);
    &#125;

    @Override
    public void visit(Mouse mouse) &#123;
        System.out.println(&quot;Displaying Mouse.&quot;);
    &#125;

    @Override
    public void visit(Keyboard keyboard) &#123;
        System.out.println(&quot;Displaying Keyboard.&quot;);
    &#125;

    @Override
    public void visit(Monitor monitor) &#123;
        System.out.println(&quot;Displaying Monitor.&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>抽象元素</p>
<pre><code class="prettyprint">public interface ComputerPart  &#123;
    public void accept(ComputerPartVisitor computerPartVisitor);
&#125;
</code></pre>
</li>
<li><p>具体元素</p>
<pre><code class="prettyprint">public class Keyboard  implements ComputerPart &#123;

    @Override
    public void accept(ComputerPartVisitor computerPartVisitor) &#123;
        computerPartVisitor.visit(this);
    &#125;
&#125;
</code></pre>
<pre><code class="prettyprint">public class Mouse  implements ComputerPart &#123;

    @Override
    public void accept(ComputerPartVisitor computerPartVisitor) &#123;
        computerPartVisitor.visit(this);
    &#125;
&#125;
</code></pre>
<pre><code class="prettyprint">public class Monitor  implements ComputerPart &#123;

    @Override
    public void accept(ComputerPartVisitor computerPartVisitor) &#123;
        computerPartVisitor.visit(this);
    &#125;
&#125;
</code></pre>
</li>
<li><p>对象结构</p>
<pre><code class="prettyprint">public class Computer implements ComputerPart &#123;
    ComputerPart[] parts;

    public Computer()&#123;
        parts = new ComputerPart[] &#123;new Mouse(), new Keyboard(), new Monitor()&#125;;
    &#125;


    @Override
    public void accept(ComputerPartVisitor computerPartVisitor) &#123;
        for (int i = 0; i &lt; parts.length; i++) &#123;
            parts[i].accept(computerPartVisitor);
        &#125;
        computerPartVisitor.visit(this);
    &#125;
&#125;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="prettyprint">public class MainTest &#123;
    public static void main(String[] args) &#123;
        ComputerPart computer = new Computer();
        computer.accept(new ComputerPartDisplayVisitor());
    &#125;
&#125;
/**
 * Displaying Mouse.
 * Displaying Keyboard.
 * Displaying Monitor.
 * Displaying Computer.
 */
</code></pre>
</li>
</ol>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><blockquote>
<p> <strong>定义：</strong>定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。 </p>
</blockquote>
<p><strong>优点：</strong></p>
<ul>
<li>降低了对象之间的耦合性，使得对象易于独立地被复用。 </li>
<li>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</li>
</ul>
<h4 id="模中介者式结构和代码示例"><a href="#模中介者式结构和代码示例" class="headerlink" title="模中介者式结构和代码示例"></a>模中介者式结构和代码示例</h4><ul>
<li><p>抽象中介者 <code>Mediator</code> 角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</p>
</li>
<li><p>具体中介者 <code>ConcreteMediator</code> 角色：实现中介者接口，定义一个 <code>List </code>来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</p>
</li>
<li><p>抽象同事类 <code>Colleague</code> 角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</p>
</li>
<li><p>具体同事类 <code>Concrete Colleague</code> 角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p>
</li>
</ul>
<ol>
<li><p>抽象中介者</p>
<pre><code class="prettyprint">public interface Mediator &#123;
    void register(Colleague colleague); // 客户注册
    void relay(String from, String to,String ad); // 转发
&#125;
</code></pre>
</li>
<li><p>具体中介者</p>
<pre><code class="prettyprint">public class ConcreteMediator implements Mediator &#123;
    private List&lt;Colleague&gt; colleagues = new ArrayList&lt;Colleague&gt;();
    @Override
    public void register(Colleague colleague) &#123;
        if (!colleagues.contains(colleague)) &#123;
            colleagues.add(colleague);
            colleague.setMedium(this);
        &#125;
    &#125;
    @Override
    public void relay(String from, String to, String ad) &#123;
        for (Colleague cl : colleagues) &#123;
            String name = cl.getName();
            if (name.equals(to)) &#123;
                cl.receive(from, ad);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>抽象同事类</p>
<pre><code class="prettyprint">public abstract class Colleague &#123;
    protected Mediator mediator;
    protected String name;

    public Colleague(String name) &#123;
        this.name = name;
    &#125;

    public void setMedium(Mediator mediator) &#123;
        this.mediator = mediator;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public abstract void Send(String to, String ad);

    public abstract void receive(String from, String ad);
&#125;
</code></pre>
</li>
<li><p>具体同事类</p>
<pre><code class="prettyprint">public class Buyer extends Colleague &#123;

    public Buyer(String name) &#123;
        super(name);
    &#125;

    @Override
    public void Send(String to, String ad) &#123;
        mediator.relay(name, to, ad);
    &#125;

    @Override
    public void receive(String from, String ad) &#123;
        System.out.println(name + &quot;接收到来自&quot; + from + &quot;的消息:&quot; + ad);
    &#125;

&#125;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="prettyprint">public class MainTest &#123;
    public static void main(String[] args) &#123;
        Buyer b = new Buyer(&quot;张三&quot;);
        Buyer c = new Buyer(&quot;李四&quot;);
        ConcreteMediator concreteMediator = new ConcreteMediator();
        concreteMediator.register(b);
        concreteMediator.register(c);
        c.Send(&quot;张三&quot;,&quot;你好张三&quot;);
        b.Send(&quot;李四&quot;,&quot;你好李四&quot;);
    &#125;
&#125;
/**
 * 张三接收到来自李四的消息:你好张三
 * 李四接收到来自张三的消息:你好李四
 */
</code></pre>
</li>
</ol>
<p>参照原文链接：  <a href="https://blog.csdn.net/A1342772/article/details/91349142">23 种设计模式详解（全23种）_鬼灭之刃的博客-CSDN博客_设计模式</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>Controller注入Service出现空指针情况</title>
    <url>/2022/04/15/controller-zhu-ru-service-chu-xian-kong-zhi-zhen-qing-kuang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="第一种情况（注入没有使用注解-Autowired-Resource）"><a href="#第一种情况（注入没有使用注解-Autowired-Resource）" class="headerlink" title="第一种情况（注入没有使用注解@Autowired,@Resource）"></a>第一种情况（注入没有使用注解<code>@Autowired</code>,<code>@Resource</code>）</h4><pre><code class="prettyprint">public class TestController &#123;
    private ITestService testService
&#125;
</code></pre>
<p>解决方式</p>
<ol>
<li>增加注入注解</li>
</ol>
<pre><code class="prettyprint">public class TestController &#123;
    @Autowired
    private ITestService testService
&#125;
</code></pre>
<ol>
<li>使用构造方法注入(或者set方法注入)</li>
</ol>
<pre><code class="prettyprint">public class TestController &#123;
    private final ITestService testService;
    public TestController(ITestService testService)&#123;
         this.testService = testService;
    &#125;
&#125;
</code></pre>
<h4 id="第二种情况（service实现类没有-Service注解）加上注解就行"><a href="#第二种情况（service实现类没有-Service注解）加上注解就行" class="headerlink" title="第二种情况（service实现类没有@Service注解）加上注解就行"></a>第二种情况（service实现类没有@Service注解）加上注解就行</h4><h4 id="第三种情况（包扫描没有扫描到），配置扫描路径"><a href="#第三种情况（包扫描没有扫描到），配置扫描路径" class="headerlink" title="第三种情况（包扫描没有扫描到），配置扫描路径"></a>第三种情况（包扫描没有扫描到），配置扫描路径</h4><h4 id="第四种情况（最难发现的问题，在controller类中使用-Value从配置文件中获取数据，而配置文件却没有配置）"><a href="#第四种情况（最难发现的问题，在controller类中使用-Value从配置文件中获取数据，而配置文件却没有配置）" class="headerlink" title="第四种情况（最难发现的问题，在controller类中使用@Value从配置文件中获取数据，而配置文件却没有配置）"></a>第四种情况（最难发现的问题，在controller类中使用@Value从配置文件中获取数据，而配置文件却没有配置）</h4><pre><code class="prettyprint">public class TestController &#123;
    @Value(&quot;$&#123;prop.test&#125;&quot;)
    @Autowired
    private ITestService testService
&#125;
</code></pre>
<p>解决方法：<br>1、在配置文件中加上配置<br>2、给与默认值</p>
<pre><code class="prettyprint">public class TestController &#123;
    @Value(&quot;$&#123;prop.test:&#125;&quot;)
    @Autowired
    private ITestService testService
&#125;
</code></pre>
<img src="/2022/04/15/controller-zhu-ru-service-chu-xian-kong-zhi-zhen-qing-kuang/4.jpg" class="asset-class" title="(6).jpg">
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 安装部署RabbitMQ</title>
    <url>/2021/10/16/docker-an-zhuang-bu-shu-rabbitmq/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>这里注意获取镜像的时候要获取management版本的，不要获取last版本的，management版本的才带有管理界面。</code></p>
<h3 id="1、查询镜像"><a href="#1、查询镜像" class="headerlink" title="1、查询镜像"></a>1、查询镜像</h3><p><code>docker search rabbitmq:management</code></p>
<h3 id="2、获取镜像"><a href="#2、获取镜像" class="headerlink" title="2、获取镜像"></a>2、获取镜像</h3><p><code>docker pull rabbitmq:management</code></p>
<h3 id="3、运行镜像"><a href="#3、运行镜像" class="headerlink" title="3、运行镜像"></a>3、运行镜像</h3><p><code>docker run -d -p 5672:5672 -p 15672:15672 --name rabbitmq rabbitmq:management</code></p>
<p>访问管理界面的地址就是 http:&#x2F;&#x2F;[宿主机IP]:15672，可以使用默认的账户登录，用户名和密码都guest</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 部署 Halo</title>
    <url>/2021/10/16/docker-bu-shu-halo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="使用-Docker-镜像"><a href="#使用-Docker-镜像" class="headerlink" title="使用 Docker 镜像#"></a>使用 Docker 镜像#</h4><p>Halo 在 Docker Hub 上发布的镜像为 halohub&#x2F;halo</p>
<h4 id="创建工作目录"><a href="#创建工作目录" class="headerlink" title="创建工作目录"></a>创建工作目录</h4><p><code>mkdir ~/.halo &amp;&amp; cd ~/.halo</code><br>下载示例配置文件到工作目录<br><code>wget https://dl.halo.run/config/application-template.yaml -O ./application.yaml</code><br>编辑配置文件，配置数据库或者端口等，如需配置请参考参考配置<br><code>vim application.yaml</code><br>拉取最新的 Halo 镜像<br><code>docker pull halohub/halo:1.4.12</code><br>INFO<br>查看最新版本镜像：<code>https://hub.docker.com/r/halohub/halo</code> ，我们推荐使用具体版本号的镜像，但也提供了 latest 标签的镜像，它始终是最新的。</p>
<p>创建容器<br><code>docker run -it -d --name halo -p 8090:8090 -v ~/.halo:/root/.halo --restart=unless-stopped halohub/halo:1.4.12</code></p>
<pre><code class="-it：">-d： 后台运行容器
--name： 为容器指定一个名称
-p： 端口映射，格式为 主机(宿主)端口:容器端口 ，可在 application.yaml 配置。
-v： 工作目录映射。形式为：-v 宿主机路径:/root/.halo，后者不能修改。
--restart： 建议设置为 unless-stopped，在 Docker 启动的时候自动启动 Halo 容器。
</code></pre>
<p>打开 <a href="http://ip:端口号">http://ip:端口号</a> 即可看到安装引导界面。<br>TIP<br>如果需要配置域名访问，建议先配置好反向代理以及域名解析再进行初始化。如果通过 <a href="http://ip:端口号">http://ip:端口号</a> 的形式无法访问，请到服务器厂商后台将运行的端口号添加到安全组，如果服务器使用了 Linux 面板，请检查此 Linux 面板是否有还有安全组配置，需要同样将端口号添加到安全组。</p>
<p>反向代理#<br>你可以在下面的反向代理软件中任选一项，我们假设你已经安装好了其中一项，并对其的基本操作有一定了解。如果你对 Nginx 不熟悉，我们推荐使用 OneinStack 来管理 Nginx。</p>
<pre><code class="prettyprint#">upstream halo &#123;
  server 127.0.0.1:8090;
&#125;
server &#123;
  listen 80;
  listen [::]:80;
  server_name www.yourdomain.com;
  client_max_body_size 1024m;
  location / &#123;
    proxy_pass http://halo;
    proxy_set_header HOST $host;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  &#125;
&#125;
</code></pre>
<p>以上配置都可以在 <a href="https://github.com/halo-dev/halo-common">https://github.com/halo-dev/halo-common</a> 找到。</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker中安装并配置redis</title>
    <url>/2021/10/16/docker-zhong-an-zhuang-bing-pei-zhi-redis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、找到一个合适的docker的redis的版本"><a href="#一、找到一个合适的docker的redis的版本" class="headerlink" title="一、找到一个合适的docker的redis的版本"></a>一、找到一个合适的docker的redis的版本</h3><p>可以去docker hub中去找一下</p>
<p><a href="https://hub.docker.com/_/redis?tab=tags">https://hub.docker.com/_/redis?tab=tags</a></p>
<h3 id="二、使用docker安装redis"><a href="#二、使用docker安装redis" class="headerlink" title="二、使用docker安装redis"></a>二、使用docker安装redis</h3><p>docker pull redis</p>
<p>安装好之后使用docker images即可查看</p>
<p>docker images</p>
<h3 id="三、准备redis的配置文件"><a href="#三、准备redis的配置文件" class="headerlink" title="三、准备redis的配置文件"></a>三、准备redis的配置文件</h3><p>因为需要redis的配置文件，这里最好还是去redis的官方去下载一个redis使用里面的配置文件即可</p>
<p>redis中文官方网站：<a href="http://www.redis.cn/download.html">http://www.redis.cn/download.html</a></p>
<p>下载后解压出来：</p>
<p>这个redis.conf文件就是咱们需要的，为了保险，还是拷贝一下，做个备份。</p>
<h3 id="四、配置redis-conf配置文件"><a href="#四、配置redis-conf配置文件" class="headerlink" title="四、配置redis.conf配置文件"></a>四、配置redis.conf配置文件</h3><p>修改redis.conf配置文件：<br>主要配置的如下：</p>
<pre><code>bind 127.0.0.1 #注释掉这部分，使redis可以外部访问
daemonize no#用守护线程的方式启动
requirepass 你的密码#给redis设置密码
appendonly yes#redis持久化　　默认是no
tcp-keepalive 300 #防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300
</code></pre>
<h3 id="五、创建本地与docker映射的目录，即本地存放的位置"><a href="#五、创建本地与docker映射的目录，即本地存放的位置" class="headerlink" title="五、创建本地与docker映射的目录，即本地存放的位置"></a>五、创建本地与docker映射的目录，即本地存放的位置</h3><p>创建本地存放redis的位置;</p>
<p>可以自定义，因为我的docker的一些配置文件都是存放在&#x2F;data目录下面的，所以我依然在&#x2F;data目录下创建一个redis目录，这样是为了方便后期管理</p>
<p>mkdir &#x2F;data&#x2F;redis<br>mkdir &#x2F;data&#x2F;redis&#x2F;data</p>
<p>把配置文件拷贝到刚才创建好的文件里</p>
<p>因为我本身就是Linux操作系统，所以我可以直接拷贝过去，如果你是windows的话，可能需要使用ftp拷贝过去，或者直接复制内容，然后粘贴过去。</p>
<p>cp -p redis.conf &#x2F;data&#x2F;redis&#x2F;</p>
<h3 id="六、启动docker-redis"><a href="#六、启动docker-redis" class="headerlink" title="六、启动docker redis"></a>六、启动docker redis</h3><p>启动：</p>
<pre><code>docker run -p 6379:6379 --name redis -v /data/redis/redis.conf:/etc/redis/redis.conf  -v /data/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes
</code></pre>
<p>参数解释：</p>
<pre><code>-p 6379:6379:把容器内的6379端口映射到宿主机6379端口
-v /data/redis/redis.conf:/etc/redis/redis.conf：把宿主机配置好的redis.conf放到容器内的这个位置中
-v /data/redis/data:/data：把redis持久化的数据在宿主机内显示，做数据备份
redis-server /etc/redis/redis.conf：这个是关键配置，让redis不是无配置启动，而是按照这个redis.conf的配置启动
–appendonly yes：redis启动后数据持久化
</code></pre>
<h3 id="七、查看是否启动成功"><a href="#七、查看是否启动成功" class="headerlink" title="七、查看是否启动成功"></a>七、查看是否启动成功</h3><p>查看是否成功启动：sudo docker ps</p>
<p>可以查看一下日志：sudo docker logs redis</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装MySQL8.0</title>
    <url>/2021/10/16/docker-an-zhuang-mysql8-0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>CentOS 7.5<br>Docker 1.13.1<br>MySQL 8.0.16</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h5><p>默认拉取最新版本的镜像</p>
<p><code>pull mysql</code><br>如果要指定版本，使用下面的命令</p>
<p><code>docker pull mysql:8.0.16</code><br>创建数据目录和配置文件<br>在宿主机创建放置mysql的配置文件的目录和数据目录，并且进行授权</p>
<p><code>mkdir -p /usr/mysql/conf /usr/mysql/data</code></p>
<p><code>chmod -R 755 /usr/mysql/</code><br>创建配置文件<br>在上面创建的配置文件目录&#x2F;usr&#x2F;mysql&#x2F;conf下创建MySQL的配置文件my.cnf</p>
<p><code>vim /usr/mysql/conf/my.cnf</code><br>添加以下内容到上述创建的配置文件中</p>
<pre><code class="[client]">
#socket = /usr/mysql/mysqld.sock

default-character-set = utf8mb4

[mysqld]

#pid-file        = /var/run/mysqld/mysqld.pid

#socket          = /var/run/mysqld/mysqld.sock

#datadir         = /var/lib/mysql

#socket = /usr/mysql/mysqld.sock

#pid-file = /usr/mysql/mysqld.pid

datadir = /usr/mysql/data

character_set_server = utf8mb4

collation_server = utf8mb4_bin

secure-file-priv= NULL

# Disabling symbolic-links is recommended to prevent assorted security risks

symbolic-links=0

# Custom config should go here

!includedir /etc/mysql/conf.d/
</code></pre>
<p>启动创建容器</p>
<pre><code>docker run --restart=unless-stopped -d --name mysql -v /usr/mysql/conf/my.cnf:/etc/mysql/my.cnf -v 
/usr/mysql/data:/var/lib/mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql
</code></pre>
<p>参数解释：</p>
<pre><code>-v : 挂载宿主机目录和 docker容器中的目录，前面是宿主机目录，后面是容器内部目录

-d : 后台运行容器

-p 映射容器端口号和宿主机端口号

-e 环境参数，MYSQL_ROOT_PASSWORD设置root用户的密码
</code></pre>
<p>执行上述命令后，执行查询容器的命令就可以看到创建的mysql容器</p>
<p><code>docker ps -a</code></p>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>上述虽然安装好了mysql，但是使用远程的Navicat连接时提示错误，不能正确连接mysql，此时需要修改按照下面说的步骤修改一下mysql的密码模式以及主机等内容才可以。</p>
<p>修改mysql密码以及可访问主机</p>
<pre><code>#进入容器内部
docker exec -it mysql /bin/bash`
连接mysql
mysql -uroot -p`
使用mysql库
mysql&gt; use mysql`
修改访问主机以及密码等，设置为所有主机可访问
mysql&gt; ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;
</code></pre>
<p>注意：</p>
<p>mysql_native_password，mysql8.x版本必须使用这种模式，否则navicate无法正确连接</p>
<p>刷新<br>$ mysql&gt; flush privileges<br>经过以上步骤，再次远程使用Navicat连接数据库时就可以正常连接了。</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装nacos</title>
    <url>/2021/10/16/docker-an-zhuang-nacos/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-拉取镜像"><a href="#1-拉取镜像" class="headerlink" title="1. 拉取镜像"></a>1. 拉取镜像</h4><p><code>docker pull nacos/nacos-server</code></p>
<h4 id="2-启动"><a href="#2-启动" class="headerlink" title="2. 启动"></a>2. 启动</h4><p><code>docker run -d -p 8848:8848 \ --name nacos \ --env MODE=standalone \ --env SPRING_DATASOURCE_PLATFORM=mysql \ --env MYSQL_SERVICE_HOST=127.0.0.1 \ --env MYSQL_SERVICE_PORT=3306 \ --env MYSQL_SERVICE_DB_NAME=nacos_config \ --env MYSQL_SERVICE_USER=root \ --env MYSQL_SERVICE_PASSWORD=root \ nacos/nacos-server</code></p>
<h4 id="3-查看"><a href="#3-查看" class="headerlink" title="3. 查看"></a>3. 查看</h4><p><code>docker ps -a</code></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装rocketmq</title>
    <url>/2021/10/19/docker-an-zhuang-rocketmq/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><pre><code class="prettyprint"># 查询镜像
docker search rocketmq
# 查询镜像版本
curl https://registry.hub.docker.com/v1/repositories/foxiswho/rocketmq/tags \
| tr -d &#39;[\[\]&quot; ]&#39; | tr &#39;&#125;&#39; &#39;\n&#39; \
| awk -F: -v image=&#39;foxiswho/rocketmq&#39; &#39;&#123;if(NR!=NF &amp;&amp; $3 != &quot;&quot;)&#123;printf(&quot;%s:%s\n&quot;,image,$3)&#125;&#125;&#39;

# 拉取镜像
docker pull foxiswho/rocketmq:server-4.7.0
docker pull foxiswho/rocketmq:broker-4.7.0
</code></pre>
<h4 id="创建数据挂载目录-x2F-文件"><a href="#创建数据挂载目录-x2F-文件" class="headerlink" title="创建数据挂载目录&#x2F;文件"></a>创建数据挂载目录&#x2F;文件</h4><pre><code class="prettyprint">mkdir -p /usr/local/rocketmq/rmqserver01/logs
mkdir -p /usr/local/rocketmq/rmqserver01/store
mkdir -p /usr/local/rocketmq/rmqbroker01/logs
mkdir -p /usr/local/rocketmq/rmqbroker01/store
mkdir -p /usr/local/rocketmq/rmqbroker01/conf


vim /usr/local/rocketmq/rmqbroker01/conf/broker.conf
</code></pre>
<h4 id="配置broker-conf"><a href="#配置broker-conf" class="headerlink" title="配置broker.conf"></a>配置broker.conf</h4><pre><code class="prettyprint">brokerIP1=47.105.140.253
# 支持过滤
enablePropertyFilter=true
</code></pre>
<h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><pre><code class="prettyprint"># 运行server
docker run -d -p 9876:9876 --name rmqserver  \
 -v /usr/local/rocketmq/rmqserver01/logs:/opt/logs \
 -v /usr/local/rocketmq/rmqserver01/store:/opt/store \
 foxiswho/rocketmq:server-4.7.0
# 运行broker
docker run -d -p 10911:10911 -p 10909:10909 \
 --name rmqbroker --link rmqserver:namesrv \
 -e &quot;NAMESRV_ADDR=namesrv:9876&quot; -e &quot;JAVA_OPTS=-Duser.home=/opt&quot; \
 -e &quot;JAVA_OPT_EXT=-server -Xms128m -Xmx128m&quot; \
 -v /usr/local/rocketmq/rmqbroker01/conf/broker.conf:/etc/rocketmq/broker.conf \
 -v /usr/local/rocketmq/rmqbroker01/logs:/opt/logs \
 -v /usr/local/rocketmq/rmqbroker01/store:/opt/store \
 foxiswho/rocketmq:broker-4.7.0
</code></pre>
<h4 id="部署Rocketmq管理UI工具"><a href="#部署Rocketmq管理UI工具" class="headerlink" title="部署Rocketmq管理UI工具"></a>部署Rocketmq管理UI工具</h4><pre><code class="prettyprint"># 查询镜像
docker search rocketmq-console-ng

# 查询镜像版本
curl https://registry.hub.docker.com/v1/repositories/styletang/rocketmq-console-ng/tags \
| tr -d &#39;[\[\]&quot; ]&#39; | tr &#39;&#125;&#39; &#39;\n&#39; \
| awk -F: -v image=&#39;styletang/rocketmq-console-ng&#39; &#39;&#123;if(NR!=NF &amp;&amp; $3 != &quot;&quot;)&#123;printf(&quot;%s:%s\n&quot;,image,$3)&#125;&#125;&#39;

docker pull styletang/rocketmq-console-ng:1.0.0

# 运行镜像
docker run -d --name rmqconsole -p 8180:8080 --link rmqserver:namesrv\
 -e &quot;JAVA_OPTS=-Drocketmq.namesrv.addr=namesrv:9876\
 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot;\
 -t styletang/rocketmq-console-ng:1.0.0
</code></pre>
<h4 id="访问前端UI"><a href="#访问前端UI" class="headerlink" title="访问前端UI"></a>访问前端UI</h4><p><a href="http://ip:8180/">http://ip:8180</a></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/2021/10/16/docker-chang-yong-ming-ling/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1、Docker容器信息"><a href="#1、Docker容器信息" class="headerlink" title="1、Docker容器信息"></a>1、Docker容器信息</h4><pre><code>##查看docker容器版本
docker version
##查看docker容器信息
docker info
##查看docker容器帮助
docker --help
</code></pre>
<h4 id="2、镜像操作"><a href="#2、镜像操作" class="headerlink" title="2、镜像操作"></a>2、镜像操作</h4><p>提示：对于镜像的操作可使用镜像名、镜像长ID和短ID。</p>
<h5 id="2-1、镜像查看"><a href="#2-1、镜像查看" class="headerlink" title="2.1、镜像查看"></a>2.1、镜像查看</h5><pre><code>##列出本地images
docker images
##含中间映像层
docker images -a


##只显示镜像ID
docker images -q
##含中间映像层
docker images -qa   


##显示镜像摘要信息(DIGEST列)
docker images --digests
##显示镜像完整信息
docker images --no-trunc


##显示指定镜像的历史创建；参数：-H 镜像大小和日期，默认为true；--no-trunc  显示完整的提交记录；-q  仅列出提交记录ID
docker history -H redis
</code></pre>
<h5 id="2-2、镜像搜索"><a href="#2-2、镜像搜索" class="headerlink" title="2.2、镜像搜索"></a>2.2、镜像搜索</h5><pre><code>##搜索仓库MySQL镜像
docker search mysql
##--filter=stars=600：只显示 starts&gt;=600 的镜像
docker search --filter=stars=600 mysql
##--no-trunc 显示镜像完整 DESCRIPTION 描述
docker search --no-trunc mysql
##--automated ：只列出 AUTOMATED=OK 的镜像
docker search  --automated mysql
</code></pre>
<h5 id="2-3-镜像版本查看"><a href="#2-3-镜像版本查看" class="headerlink" title="2.3 镜像版本查看"></a>2.3 镜像版本查看</h5><pre><code>curl https://registry.hub.docker.com/v1/repositories/seataio/seata-server/tags \
| tr -d &#39;[\[\]&quot; ]&#39; | tr &#39;&#125;&#39; &#39;\n&#39; \
| awk -F: -v image=&#39;seataio/seata-server&#39; &#39;&#123;if(NR!=NF &amp;&amp; $3 != &quot;&quot;)&#123;printf(&quot;%s:%s\n&quot;,image,$3)&#125;&#125;&#39;
</code></pre>
<h5 id="2-4、镜像下载"><a href="#2-4、镜像下载" class="headerlink" title="2.4、镜像下载"></a>2.4、镜像下载</h5><pre><code>##下载Redis官方最新镜像，相当于：docker pull redis:latest
docker pull redis
##下载仓库所有Redis镜像
docker pull -a redis
##下载私人仓库镜像
docker pull bitnami/redis
</code></pre>
<h5 id="2-5、镜像删除"><a href="#2-5、镜像删除" class="headerlink" title="2.5、镜像删除"></a>2.5、镜像删除</h5><pre><code>##单个镜像删除，相当于：docker rmi redis:latest
docker rmi redis
##强制删除(针对基于镜像有运行的容器进程)
docker rmi -f redis
##多个镜像删除，不同镜像间以空格间隔
docker rmi -f redis tomcat nginx
##删除本地全部镜像
docker rmi -f $(docker images -q)
</code></pre>
<h5 id="2-6、镜像构建"><a href="#2-6、镜像构建" class="headerlink" title="2.6、镜像构建"></a>2.6、镜像构建</h5><pre><code>##（1）编写dockerfile
cd /docker/dockerfile
vim mycentos
##（2）构建docker镜像
docker build -f /docker/dockerfile/mycentos -t mycentos:1.1
</code></pre>
<h4 id="3、容器操作"><a href="#3、容器操作" class="headerlink" title="3、容器操作"></a>3、容器操作</h4><p>提示：对于容器的操作可使用CONTAINER ID 或 NAMES。</p>
<h5 id="3-1、容器启动"><a href="#3-1、容器启动" class="headerlink" title="3.1、容器启动"></a>3.1、容器启动</h5><pre><code>##新建并启动容器，参数：-i  以交互模式运行容器；-t  为容器重新分配一个伪输入终端；--name  为容器指定一个名称
docker run -i -t --name mycentos
##后台启动容器，参数：-d  已守护方式启动容器
docker run -d mycentos
注意：此时使用&quot;docker ps -a&quot;会发现容器已经退出。这是docker的机制：要使Docker容器后台运行，就必须有一个前台进程。解决方案：将你要运行的程序以前台进程的形式运行。

##启动一个或多个已经被停止的容器
docker start redis
##重启容器
docker restart redis
</code></pre>
<h5 id="3-2、容器进程"><a href="#3-2、容器进程" class="headerlink" title="3.2、容器进程"></a>3.2、容器进程</h5><pre><code>##top支持 ps 命令参数，格式：docker top [OPTIONS] CONTAINER [ps OPTIONS]
##列出redis容器中运行进程
docker top redis
##查看所有运行容器的进程信息
for i in  `docker ps |grep Up|awk &#39;&#123;print $1&#125;&#39;`;do echo \ &amp;&amp;docker top $i; done
</code></pre>
<h5 id="3-3、容器日志"><a href="#3-3、容器日志" class="headerlink" title="3.3、容器日志"></a>3.3、容器日志</h5><pre><code>##查看redis容器日志，默认参数
docker logs rabbitmq
##查看redis容器日志，参数：-f  跟踪日志输出；-t   显示时间戳；--tail  仅列出最新N条容器日志；
docker logs -f -t --tail=20 redis
##查看容器redis从2019年05月21日后的最新10条日志。
docker logs --since=&quot;2019-05-21&quot; --tail=10 redis
</code></pre>
<h5 id="3-4、容器的进入与退出"><a href="#3-4、容器的进入与退出" class="headerlink" title="3.4、容器的进入与退出"></a>3.4、容器的进入与退出</h5><pre><code>##使用run方式在创建时进入
docker run -it centos /bin/bash
##关闭容器并退出
exit
##仅退出容器，不关闭
快捷键：Ctrl + P + Q
##直接进入centos 容器启动命令的终端，不会启动新进程，多个attach连接共享容器屏幕，参数：--sig-proxy=false  确保CTRL-D或CTRL-C不会关闭容器
docker attach --sig-proxy=false centos 
##在 centos 容器中打开新的交互模式终端，可以启动新进程，参数：-i  即使没有附加也保持STDIN 打开；-t  分配一个伪终端
docker exec -i -t  centos /bin/bash
##以交互模式在容器中执行命令，结果返回到当前终端屏幕
docker exec -i -t centos ls -l /tmp
##以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端
docker exec -d centos  touch cache.txt 
</code></pre>
<h5 id="3-5、查看容器"><a href="#3-5、查看容器" class="headerlink" title="3.5、查看容器"></a>3.5、查看容器</h5><pre><code>##查看正在运行的容器
docker ps
##查看正在运行的容器的ID
docker ps -q
##查看正在运行+历史运行过的容器
docker ps -a
##显示运行容器总文件大小
docker ps -s



##显示最近创建容器
docker ps -l
##显示最近创建的3个容器
docker ps -n 3
##不截断输出
docker ps --no-trunc 


##获取镜像redis的元信息
docker inspect redis
##获取正在运行的容器redis的 IP
docker inspect --format=&#39;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#39; redis
</code></pre>
<h5 id="3-6、容器的停止与删除"><a href="#3-6、容器的停止与删除" class="headerlink" title="3.6、容器的停止与删除"></a>3.6、容器的停止与删除</h5><pre><code>##停止一个运行中的容器
docker stop redis
##杀掉一个运行中的容器
docker kill redis
##删除一个已停止的容器
docker rm redis
##删除一个运行中的容器
docker rm -f redis
##删除多个容器
docker rm -f $(docker ps -a -q)
docker ps -a -q | xargs docker rm
  -l 移除容器间的网络连接，连接名为 db
docker rm -l db 
  -v 删除容器，并删除容器挂载的数据卷
docker rm -v redis
</code></pre>
<h5 id="3-7、生成镜像"><a href="#3-7、生成镜像" class="headerlink" title="3.7、生成镜像"></a>3.7、生成镜像</h5><pre><code>##基于当前redis容器创建一个新的镜像；参数：-a 提交的镜像作者；-c 使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停
docker commit -a=&quot;DeepInThought&quot; -m=&quot;my redis&quot; [redis容器ID]  myredis:v1.1
</code></pre>
<h5 id="3-8、容器与主机间的数据拷贝"><a href="#3-8、容器与主机间的数据拷贝" class="headerlink" title="3.8、容器与主机间的数据拷贝"></a>3.8、容器与主机间的数据拷贝</h5><pre><code>##将rabbitmq容器中的文件copy至本地路径
docker cp rabbitmq:/[container_path] [local_path]
##将主机文件copy至rabbitmq容器
docker cp [local_path] rabbitmq:/[container_path]/
##将主机文件copy至rabbitmq容器，目录重命名为[container_path]（注意与非重命名copy的区别）
docker cp [local_path] rabbitmq:/[container_path]
</code></pre>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA配置注释</title>
    <url>/2021/11/26/idea-pei-zhi-zhu-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一、类注释</p>
<ul>
<li>打开<code>serrings --&gt; Editor --&gt; File and Code Template</code>点击右边的Class,添加注释</li>
</ul>
<pre><code class="prettyprint">/**
 * @author jitwxs
 * @date $&#123;YEAR&#125;年$&#123;MONTH&#125;月$&#123;DAY&#125;日 $&#123;TIME&#125;
 */
</code></pre>
<p>二、方法注释</p>
<ul>
<li><p>打开<code>serrings --&gt; Editor --&gt; Live Template</code></p>
</li>
<li><p>先新增Template group（如：define）</p>
</li>
<li><p>选中新增的group(如：define)</p>
</li>
<li><p>修改该模板的 Abbreviation、Description 和 Template text<br>  Abbreviation：*<br>  Description :方法注释<br>  Template text：</p>
</li>
</ul>
<pre><code class="prettyprint">/**
 * @Description 
 * @Author pengp
 * @Date $date$ $time$$param$ $return$
 */
</code></pre>
<ul>
<li><p>选择No applicable contexts yet(Define)，选择java</p>
</li>
<li><p>点击 Edit variables 配置自定义参数<code>$date$ $time$$param$ $return$</code></p>
</li>
</ul>
<pre><code class="prettyprint">date：date()
time：time()
param：groovyScript(&quot;def result = &#39;&#39;;def params = \&quot;$&#123;_1&#125;\&quot;.replaceAll(&#39;[\\\\[|\\\\]|\\\\s]&#39;, &#39;&#39;).split(&#39;,&#39;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;if(params[i] != &#39;&#39;)result+=&#39;* @param &#39; + params[i] + ((i &lt; params.size() - 1) ? &#39;\\r\\n &#39; : &#39;&#39;)&#125;; return result == &#39;&#39; ? null : &#39;\\r\\n &#39; + result&quot;, methodParameters())
return：groovyScript(&quot;return \&quot;$&#123;_1&#125;\&quot; == &#39;void&#39; ? null : &#39;\\r\\n * @return &#39; + \&quot;$&#123;_1&#125;\&quot;&quot;, methodReturnType())
</code></pre>
]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>centos初始化安装</title>
    <url>/2022/04/07/centos-chu-shi-hua-an-zhuang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="配置阿里云镜像地址"><a href="#配置阿里云镜像地址" class="headerlink" title="配置阿里云镜像地址"></a>配置阿里云镜像地址</h4><pre><code class="prettyprint"># 下载
curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
# 清理
yum clean all
#缓存
yum makecache
</code></pre>
<h4 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h4><ul>
<li>登录阿里云，选择<code>容器镜像服务</code></li>
</ul>
<img src="/2022/04/07/centos-chu-shi-hua-an-zhuang/image-20220830211532886.png" class="asset-class" title="image-20220830211532886">

<ul>
<li>选择<code>镜像加速器</code></li>
</ul>
<img src="/2022/04/07/centos-chu-shi-hua-an-zhuang/image-20220830211609835.png" class="asset-class" title="image-20220830211609835">

<ul>
<li>执行命令</li>
</ul>
<pre><code class="prettyprint">mkdir -p /etc/docker
tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;
&#123;
  &quot;registry-mirrors&quot;: [&quot;https://bkp0r8cc.mirror.aliyuncs.com&quot;]
&#125;
EOF
systemctl daemon-reload
# 需要安装docker
systemctl restart docker
</code></pre>
<h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><ul>
<li>如果有旧的docker要先卸载</li>
</ul>
<pre><code class="prettyprint">yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
</code></pre>
<ul>
<li>安装yum工具</li>
</ul>
<pre><code class="prettyprint">yum install -y yum-utils
# 配置docker仓库源，我们配置阿里云
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre>
<ul>
<li>安装docker 引擎</li>
</ul>
<pre><code class="prettyprint">yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin
</code></pre>
<ul>
<li>启动、测试</li>
</ul>
<pre><code class="prettyprint"># 启动
systemctl start|restart|stop|status|enable|disable docker
docker version
</code></pre>
<img src="/2022/04/07/centos-chu-shi-hua-an-zhuang/image-20220830212012004.png" class="asset-class" title="image-20220830212012004">



<h4 id="安装ifconfig"><a href="#安装ifconfig" class="headerlink" title="安装ifconfig"></a>安装ifconfig</h4><pre><code class="prettyprint">yum search ifconfig # 查看ifconfig命令包
yum install net-tools.x86_64 # 安装
</code></pre>
<h4 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h4><pre><code class="prettyprint">yum -y install vim
</code></pre>
<h4 id="安装wget"><a href="#安装wget" class="headerlink" title="安装wget"></a>安装wget</h4><pre><code class="prettyprint">yum -y install wget
</code></pre>
<h4 id="nginx初始化环境"><a href="#nginx初始化环境" class="headerlink" title="nginx初始化环境"></a>nginx初始化环境</h4><h5 id="GCC编译器"><a href="#GCC编译器" class="headerlink" title="GCC编译器"></a>GCC编译器</h5><p>Nginx是使用C语言编写的程序，因此想要运行Nginx就需要安装一个编译工具。GCC就是一个开源的编译器集合，用于处理各种各样的语言，其中就包含了C语言。</p>
<p>使用命令<code>yum install -y gcc</code>来安装</p>
<p>安装成功后，可以通过<code>gcc --version</code>来查看gcc是否安装成功</p>
<h5 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE"></a>PCRE</h5><p>Nginx在编译过程中需要使用到PCRE库（perl Compatible Regular Expressoin 兼容正则表达式库)，因为在Nginx的Rewrite模块和http核心模块都会使用到PCRE正则表达式语法。</p>
<p>可以使用命令<code>yum install -y pcre pcre-devel</code>来进行安装</p>
<p>安装成功后，可以通过<code>rpm -qa pcre pcre-devel</code>来查看是否安装成功</p>
<h5 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h5><p>zlib库提供了开发人员的压缩算法，在Nginx的各个模块中需要使用gzip压缩，所以我们也需要提前安装其库及源代码zlib和zlib-devel</p>
<p>可以使用命令<code>yum install -y zlib zlib-devel</code>来进行安装</p>
<p>安装成功后，可以通过<code>rpm -qa zlib zlib-devel</code>来查看是否安装成功</p>
<h5 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h5><p>OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包进行安全通信，并且避免被窃听。</p>
<p>SSL:Secure Sockets Layer安全套接协议的缩写，可以在Internet上提供秘密性传输，其目标是保证两个应用间通信的保密性和可靠性。在Nginx中，如果服务器需要提供安全网页时就需要用到OpenSSL库，所以我们需要对OpenSSL的库文件及它的开发安装包进行一个安装。</p>
<p>可以使用命令<code>yum install -y openssl openssl-devel</code>来进行安装</p>
<p>安装成功后，可以通过<code>rpm -qa openssl openssl-devel</code>来查看是否安装成功</p>
<p>上述命令，一个个来的话比较麻烦，我们也可以通过一条命令来进行安装</p>
<p><code>yum install -y gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel</code>进行全部安装。</p>
<h4 id="建议集合"><a href="#建议集合" class="headerlink" title="建议集合"></a>建议集合</h4><pre><code>yum -y install lshw pciutils gdisk system-storage-manager
yum -y install bash-completion zip unzip bzip2 tree tmpwatch pinfo man-pages
yum -y install vnano vim-enhanced tmux screen
yum -y install net-tools psmisclsof sysstat
yum -y install yum-plugin-security yum-utils createrepo
yum -y install get wget curl eliks lynx lftp mailx mutt reync 
yum -y install libaio make cmake gcc-c++ gcc zib zlib-devel open openssl-devel pcre pcre-devel
</code></pre>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose安装</title>
    <url>/2021/11/20/docker-compose-an-zhuang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下载<br>我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：<a href="https://github.com/docker/compose/releases%E3%80%82">https://github.com/docker/compose/releases。</a></p>
<p><code>docker-compose-linux-x86_64</code><br>改名<br><code>mv  docker-compose-linux-x86_64 /usr/local/bin/docker-compose</code><br>赋权<br> <code>chmod +x /usr/local/bin/docker-compose</code><br>创建软链：<br><code>ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</code><br>测试是否安装成功：<br> <code>docker-compose --version</code></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>centos安装mysql5.7</title>
    <url>/2021/11/14/centos-an-zhuang-mysql5-7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>卸载CentOS7系统自带mariadb</p>
<p>查看系统自带的Mariadb<br>[root@CDH-141 ~]# rpm -qa|grep mariadb<br>mariadb-libs-5.5.44-2.el7.centos.x86_64<br>卸载系统自带的Mariadb<br>[root@CDH-141 ~]# rpm -e –nodeps mariadb-libs-5.5.442.el7.centos.x86_64<br>删除etc目录下的my.cnf ，一定要删掉，等下再重新建，之前我将就用这个文件，后面改配置各种不生效<br>[root@CDH-141 ~]# rm &#x2F;etc&#x2F;my.cnf</p>
<p>rpm -qa |grep -i mysql   查看yum 安装的所有mysql相关安装包。</p>
<p>yum remove mysql-community mysql-community-server mysql-community-libs mysql-community-common   依次删除</p>
<p>一定要删除干净 rpm -qa |grep -i mysql 后没有任何安装包。</p>
<p>然后 find &#x2F; -name mysql  查看mysql相关文件  rm -rf  文件或者文件夹目录路径</p>
<p>mysql5.7.20安装过程</p>
<p>1.下载mysql yum源文件并安装</p>
<p> 下载：wget <a href="http://repo.mysql.com/mysql57-community-release-el7-10.noarch.rpm">http://repo.mysql.com/mysql57-community-release-el7-10.noarch.rpm</a></p>
<p> 安装：rpm -Uvh mysql57-community-release-el7-10.noarch.rpm</p>
<p>2.安装mysql服务端需要等待一段时间</p>
<p>命令：yum install  -y  mysql-community-server</p>
<p>3.开启mysql</p>
<p>命令：service mysqld start</p>
<p>查看mysql是否启动命令：service mysqld status</p>
<p>4.进入mysql 修改密码</p>
<p>查看初始密码命令：grep “password” &#x2F;var&#x2F;log&#x2F;mysqld.log</p>
<p>登录 <code>mysql -uroot -p</code></p>
<p>修改密码过于简单会报错</p>
<p>这一错误其实与validate_password_policy值的设置有关</p>
<p>validate_password_policy值默认为1，即MEDIUM，所以刚开始设置的密码必须符合长度要求，且必须含有数字，小写或大写字母，特殊字符</p>
<p>如果我们只是做为测试用而不需要如此复杂的密码，可使用如下方式修改validate_password_policy值</p>
<p>命令：<code>set global validate_password_policy=0;</code></p>
<p>密码的最小长度由validate_password_length值决定，validate_password_length参数默认为8</p>
<p>修改长度命令：<code>set global validate_password_length=4;</code></p>
<p>修改密码命令：<code>SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;root&#39;);</code></p>
<p>配置mysql远程链接：<br><code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;root&#39; WITH GRANT OPTION;</code></p>
<p>刷新权限： flush privileges;</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose搭建zookeeper集群</title>
    <url>/2021/10/21/docker-compose-da-jian-zookeeper-ji-qun/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h4><p><a href="https://github.com/docker/compose/releases%E4%B8%8B%E8%BD%BD">https://github.com/docker/compose/releases下载</a><br><code>docker-compose-linux-x86_64</code></p>
<pre><code class="prettyprint"># 拷贝文件
cp docker-compose-linux-x86_64 /usr/local/bin/docker-compose
# 授权
chmod +x /usr/local/bin/docker-compose
# 查看版本
docker-compose --version
</code></pre>
<h4 id="安装zookeeper集群"><a href="#安装zookeeper集群" class="headerlink" title="安装zookeeper集群"></a>安装zookeeper集群</h4><pre><code># 创建文件存放路径
mkdir -p /usr/local/zookeeper
mkdir -p /usr/local/zookeeper/zk1/data
mkdir -p /usr/local/zookeeper/zk1/datalog
mkdir -p /usr/local/zookeeper/zk2/data
mkdir -p /usr/local/zookeeper/zk2/datalog
mkdir -p /usr/local/zookeeper/zk3/data
mkdir -p /usr/local/zookeeper/zk3/datalog
</code></pre>
<p>在对应的data文件夹下创建myid文件 文件内容分别是1,2,3</p>
<p>在<code>/usr/local/zookeeper</code>文件夹下创建<code>docker-compose.yml</code>文件[zookeeper版本3.7.0]</p>
<pre><code class="prettyprint">version: &#39;3.7&#39;

# 给zk集群配置一个网络，网络名为zk-net
networks:
  zk-net:
    name: zk-net

# 配置zk集群的
# container services下的每一个子配置都对应一个zk节点的docker container
services:
  zk1:
    # docker container所使用的docker image
    image: zookeeper:3.7.0
    hostname: zk1
    container_name: zk1
    # 配置docker container和宿主机的端口映射
    ports:
      - 2181:2181
      - 8081:8080
    # 配置docker container的环境变量
    environment:
      # 当前zk实例的id
      ZOO_MY_ID: 1
      # 整个zk集群的机器、端口列表
      ZOO_SERVERS: server.1=0.0.0.0:2888:3888;2181 server.2=zk2:2888:3888;2181 server.3=zk3:2888:3888;2181
    # 将docker container上的路径挂载到宿主机上 实现宿主机和docker container的数据共享
    volumes:
      - /usr/local/zookeeper/zk1/data:/data
      - /usr/local/zookeeper/zk1/datalog:/datalog
    # 当前docker container加入名为zk-net的隔离网络
    networks:
      - zk-net

  zk2:
    image: zookeeper:3.7.0
    hostname: zk2
    container_name: zk2
    ports:
      - 2182:2181
      - 8082:8080
    environment:
      ZOO_MY_ID: 2
      ZOO_SERVERS: server.1=zk1:2888:3888;2181 server.2=0.0.0.0:2888:3888;2181 server.3=zk3:2888:3888;2181
    volumes:
      - /usr/local/zookeeper/zk2/data:/data
      - /usr/local/zookeeper/zk2/datalog:/datalog
    networks:
      - zk-net

  zk3:
    image: zookeeper:3.7.0
    hostname: zk3
    container_name: zk3
    ports:
      - 2183:2181
      - 8083:8080
    environment:
      ZOO_MY_ID: 3
      ZOO_SERVERS: server.1=zk1:2888:3888;2181 server.2=zk2:2888:3888;2181 server.3=0.0.0.0:2888:3888;2181
    volumes:
      - /usr/local/zookeeper/zk3/data:/data
      - /usr/local/zookeeper/zk3/datalog:/datalog
    networks:
      - zk-net
</code></pre>
<p>在<code>docker-compose.yml</code>所在目录下启动</p>
<pre><code># 启动
docker-compose up
# 后台启动
docker-compose up -d
# 停止
docker-compose stop
# 删除
docker-compose rm
# 停止并删除
docker-compose down
# 重启
docker-compose restart
# 查看容器
docker-compose ps
</code></pre>
<p>查看zookeeper状态</p>
<pre><code># 进入容器
docker exec -it zk1 /bin/bash
#查看状态
./bin/zkServer.sh status
</code></pre>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis常用命令</title>
    <url>/2021/10/20/redis-chang-yong-ming-ling/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="五种基本数据结构"><a href="#五种基本数据结构" class="headerlink" title="五种基本数据结构"></a>五种基本数据结构</h3><h4 id="字符串-（String）"><a href="#字符串-（String）" class="headerlink" title="字符串 （String）"></a>字符串 （String）</h4><p>字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这意味着该类型可以接受任何格式的数据，如JPEG图像数据或json对象描述信息等。在Redis中字符串类型的value最多可以容纳的数据长度是512M。</p>
<p>常用命令：</p>
<ul>
<li>set key value 设置值</li>
<li>get key 获取值</li>
<li>getset 将给定的值设置进去，并返回旧值</li>
<li>mget key1 key2… 获取一个或多个key的值</li>
<li>setnx key value 当key不存在时才设置值(redis实现分布式锁)</li>
<li>incr key 将key存储的值+1</li>
<li>incrby key increment 将 key 所储存的值加上给定的增量值（increment）</li>
<li>decr key 将key存储的值-1</li>
<li>decrby key increment 将 key 所储存的值减去给定的增量值（increment）</li>
<li>strlen key 返回key所存储的字符串的长度</li>
</ul>
<h4 id="散列（hash）"><a href="#散列（hash）" class="headerlink" title="散列（hash）"></a>散列（hash）</h4><p>Redis中Hash类型可以看成句又String key和String value的map容器。所以该类型非常适合存储对象的信息。</p>
<p>常用命令：</p>
<ul>
<li>hset key field value</li>
<li>hget key field</li>
<li>hmset key field1 value1 [field2 value2 ] 同时set多个field值</li>
<li>hmget key field1 [field2]</li>
<li>hgetall key 获取key的所有值</li>
<li>hincrby key field increment 给指定的key的field增加给定的增量值(increment)</li>
<li>hkeys key 获取某个key的所有field</li>
<li>hvals key 获取某个key的所有value</li>
<li>hlen key 获取hash表中字段的数量</li>
<li>hexists key field 查看hash表中的字段是否存在</li>
<li>hdel key field1 [field2] 删除一个或多个hash表字段</li>
</ul>
<h4 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h4><p>在Redis中，List类型是按照插入顺序排序的字符串链表。和数据库结构中的普通链表一样，可以在头部和尾部添加新的元素。在插入时如果键不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也会被从数据库中删除。</p>
<p>常用命令：</p>
<ul>
<li>lpush key value1 [value2] 将一个值或多个值插入到列表头部</li>
<li>rpush key value1 [value2] 将一个值或多个值插入到列表尾部</li>
<li>lrange key start stop 获取列表指定范围的元素</li>
<li>lpop key 移出并获取列表中的第一个元素</li>
<li>rpop key 移出并获取列表中的最后一个元素</li>
<li>blpop key1 [key2 ] timeout 阻塞性的移出并获取列表的第一个元素，如果没有元素就会阻塞到超时或有元素为止</li>
<li>brpop key1 [key2 ] timeout 阻塞性的移出并获取列表的最后一个元素，如果没有元素就会阻塞到超时或有元素为止</li>
<li>lindex key index 通过索引位置获取列表中的元素</li>
<li>llen key 获取列表长度</li>
<li>lset key index value 通过索引位置设置值</li>
<li>ltrim key start stop 对一个列表进行修剪，只保留指定区间的元素，区间外的都删除掉</li>
</ul>
<h4 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h4><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。集合中最大的成员数为 2^32 - 1</p>
<p>常用命令：</p>
<ul>
<li>sadd key member1 [member2] 向集合中添加元素</li>
<li>scard key 获取集合的成员数</li>
<li>sdiff key1 [key2] 返回第一个集合与其他集合之间的差异</li>
<li>sinter key1 [key2] 返回给定所有集合的交集</li>
<li>sunion key1 [key2] 返回给定集合的并集</li>
<li>sismember key member 判断member元素是否是集合中的成员</li>
<li>smembers key 返回集合中所有成员</li>
<li>spop key 移除并返回集中中的一个随机元素</li>
<li>srandmember key [count] 返回集合中一个或多个随机数</li>
<li>srem key member1 [member2] 移除集合中一个或多个成员</li>
</ul>
<h4 id="有序集合（sorted-set）"><a href="#有序集合（sorted-set）" class="headerlink" title="有序集合（sorted set）"></a>有序集合（sorted set）</h4><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>常用命令：</p>
<ul>
<li>zadd key score1 member1 [score2 member2] 向有序集合中添加一个或多个成员，或更新已有成员的分数</li>
<li>zcard key 获取有序集合中的成员数量</li>
<li>zrange key start end [withscores] 通过索引区间返回有序集合中的成员</li>
<li>zrevrange key start stop [WITHSCORES] 通过索引区间返回有序集合中的成员，分数从高到低</li>
<li>zrangebyscore key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员</li>
<li>zrevrangebyscore key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员，分数由高到低排序</li>
<li>zrem key member [member …] 移除</li>
<li>zremrangebyrank key start stop 移除给定排名区间的所有成员</li>
<li>zremrangebyscore key min max 移除给定分数区间的所有成员</li>
<li>zscore key member 返回有序集合中成员的分数</li>
</ul>
<h3 id="三种高级数据结构"><a href="#三种高级数据结构" class="headerlink" title="三种高级数据结构"></a>三种高级数据结构</h3><h4 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h4><ul>
<li>Bitmaps：setbit&#x2F;getbit&#x2F;bitop&#x2F;bitcount&#x2F;bitpos bitmaps不是一个真实的数据结构。而是String类型上的一组面向bit操作的集合。由于 strings是二进制安全的blob，并且它们的最大长度是512m，所以bitmaps能最大设置 2^32个不同的bit。</li>
</ul>
<h4 id="Hyperloglogs"><a href="#Hyperloglogs" class="headerlink" title="Hyperloglogs"></a>Hyperloglogs</h4><ul>
<li>Hyperloglogs：pfadd&#x2F;pfcount&#x2F;pfmerge 在redis的实现中，您使用标准错误小于1％的估计度量结束。这个算法的神奇在于不再 需要与需要统计的项相对应的内存，取而代之，使用的内存一直恒定不变。最坏的情况 下只需要12k，就可以计算接近2^64个不同元素的基数。</li>
</ul>
<h4 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h4><ul>
<li>GEO：geoadd&#x2F;geohash&#x2F;geopos&#x2F;geodist&#x2F;georadius&#x2F;georadiusbymember Redis的GEO特性在 Redis3.2版本中推出，这个功能可以将用户给定的地理位置（经 度和纬度）信息储存起来，并对这些信息进行操作。</li>
</ul>
<h3 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h3><pre><code class="prettyprint">#-a * 密码认证
redis-benchmark -a * -n 100000 -c 32 -t SET,GET,INCR,HSET,LPUSH,MSET -q
redis-benchmark -a * -n 100000 -c 32
</code></pre>
<h3 id="前置命令"><a href="#前置命令" class="headerlink" title="前置命令"></a>前置命令</h3><ul>
<li>查看状态：<code>ping</code></li>
<li>查看当前数据库中key的数量：<code>dbsize</code></li>
<li>选择数据库：<code>select 2</code></li>
<li>删除当前数据库数据：<code>flushdb</code></li>
<li>删除所有数据库数据：<code>flushall</code></li>
<li>退出：<code>exit或quit</code></li>
<li>显示所有key：<code>keys *</code><ul>
<li><code>keys *i</code>：显示以<code>i</code>结尾的key</li>
<li><code>keys j?</code>：匹配以<code>j</code>开头的两个字符的key</li>
</ul>
</li>
<li>判断是否存在：<code>exists key</code></li>
<li>设置key的存活时间：<code>expire key seconds</code>(单位秒)</li>
<li>查看key的存活时间：<code>ttl key</code></li>
<li>获取key所存数据类型：<code>type key</code></li>
<li>删除key：<code>del key</code></li>
<li>备份：<code>sava</code></li>
<li>异步备份：<code>bgsave</code></li>
</ul>
<h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><ul>
<li>消息发布：<code>publish key message</code></li>
<li>消息订阅：<code>subscribe key</code></li>
</ul>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ul>
<li>获取锁–单个原子性操作 <code>SET lock 1 NX PX 30000</code> (毫秒)</li>
<li>释放锁–lua脚本-保证原子性+单线程，从而具有事务性</li>
</ul>
<pre><code class="prettyprint">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then
    return redis.call(&quot;del&quot;,KEYS[1])
else
    return 0
end
</code></pre>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><pre><code class="prettyprint">#实现乐观锁,watch只能在客户端开启事务之前执行
watch key
#开启事务
multi
#命令入队列，会返回QUEUED
#执行事务，开启watch之后如果当前key被其他客户端修改，返回nil,如果没有返回ok
exec
#取消事务
discard
</code></pre>
<blockquote>
<p>java代码</p>
</blockquote>
<pre><code class="prettyprint">import redis.clients.jedis.Jedis;
import redis.clients.jedis.Transaction;
 
public class TransactionExample &#123;
    public static void main(String[] args) &#123;
        // 创建 Redis 连接
        Jedis jedis = new Jedis(&quot;xxx.xxx.xxx.xxx&quot;, 6379);
        // 设置 Redis 密码
        jedis.auth(&quot;xxx&quot;);
        // 设置键值
        jedis.set(&quot;k&quot;, &quot;v&quot;);
        // 开启监视 watch
        jedis.watch(&quot;k&quot;);
        // 开始事务
        Transaction tx = jedis.multi();
        // 命令入列
        tx.set(&quot;k&quot;, &quot;v2&quot;);
        // 执行事务
        tx.exec();
        System.out.println(jedis.get(&quot;k&quot;));
        jedis.close();
    &#125;
&#125;
</code></pre>
<h3 id="redis管道（pipeline）"><a href="#redis管道（pipeline）" class="headerlink" title="redis管道（pipeline）"></a>redis管道（pipeline）</h3><blockquote>
<p> 管道的作用就是可以让客户端一次性发送多个请求，将所有的命令都放在一个缓冲区中最后一次性将所有命令打包发送到服务端。</p>
<p>管道的作用就是降低我们与redis交互的网络开销，原本每次请求都需要建立一次连接，而现在将多次请求打包只需要建立一次连接。</p>
<p>当然也不是打包的请求越多越好，因为redis必须要将所有的请求的结果进行缓存，请求越多所消耗的内存也自然越多。</p>
<p>管道是不具备原子性的，有可能打包的多个命令中执行过程中有某一条请求执行失败，那也不会影响其他的命令继续执行的</p>
</blockquote>
<h4 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h4><pre><code class="prettyprint">public static void main(String[] args) &#123;
    JedisPoolConfig config = new JedisPoolConfig();
    config.setMaxTotal(20);
    config.setMaxIdle(10);
    config.setMinIdle(5);

    JedisPool jedisPool = new JedisPool(config, &quot;127.0.0.1&quot;, 6379, 3000, null);
    Jedis jedis = jedisPool.getResource();
    Pipeline pl = jedis.pipelined();
    for (int i = 0; i &lt; 10; i++) &#123;
        pl.incr(&quot;pipelineKey&quot;);
        pl.set(&quot;data&quot; + i, &quot;data&quot;);
    &#125;
    List&lt;Object&gt; results = pl.syncAndReturnAll();
    System.out.println(results);
&#125;
</code></pre>
<h4 id="lua脚本-具备管道和事务，原子操作"><a href="#lua脚本-具备管道和事务，原子操作" class="headerlink" title="lua脚本(具备管道和事务，原子操作)"></a>lua脚本(具备管道和事务，原子操作)</h4><ul>
<li>Lua脚本具备了Pipeline和事务的功能。在管道的基础上添加了原子操作，保证管道中的请求要么都成功要么都失败。</li>
<li>具备了管道的优点 ”减少网络开销“和原子性操作，redis会将整个脚本当作一个整体来执行。</li>
<li>替代了redis的事务功能，redis的自身事务可用性并不是很高，一般我们在开发中都是使用lua脚本保证事务。</li>
<li>EVAL命令如： EVAL script numkeys key [key …] arg [arg …]</li>
<li>script：是Lua脚本，</li>
<li>numkeys参数用于指定键名参数的个数。</li>
<li>键名参数 key [key …] 表示在脚本中所用到的那些Redis键(key)，这些键名参数可以在 Lua中通过全局变量KEYS数组，用1为基址的形式访问( KEYS[1] ， KEYS[2] )。</li>
<li>附加参数 arg [arg …] ，可以在Lua中通过全局变量ARGV数组访问， 访问的形式和KEYS变量类似( ARGV[1] 、 ARGV[2] )。</li>
<li>如： eval “return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}” 2 key1 key2 first second。</li>
<li>在 Lua 脚本中，可以使用redis.call()函数来执行命令。</li>
</ul>
<pre><code class="prettyprint">public static void main(String[] args) &#123;
    JedisPoolConfig config = new JedisPoolConfig();
    config.setMaxTotal(20);
    config.setMaxIdle(10);
    config.setMinIdle(5);

    JedisPool jedisPool = new JedisPool(config, &quot;127.0.0.1&quot;, 6379, 3000, null);
    Jedis jedis = jedisPool.getResource();

    jedis.set(&quot;coupon_size&quot;, &quot;10&quot;);//初始化优惠券的数量
    String script = &quot; local count = redis.call(&#39;get&#39;, KEYS[1]) &quot; //获取coupon_size数量
        + &quot; local a = tonumber(count) &quot;     //将券数量转为数值
        + &quot; local b = tonumber(ARGV[1]) &quot;   //将传入的领券数量转入数值
        + &quot; if a &gt;= b then &quot;                //如果券数量大于要领取的数量
        + &quot; redis.call(&#39;set&#39;, KEYS[1], a‐b) &quot;   //进行券数量扣减
        + &quot; return 1 &quot;                          //扣减成功，返回：1 
        + &quot; end &quot;                               
        + &quot; return 0 &quot;;                         //否则返回：0
    Object obj = jedis.eval(script, //脚本
                            Arrays.asList(&quot;coupon_size&quot;),   //键值 
                            Arrays.asList(&quot;10&quot;));           //附加值
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compsoe安装kafka</title>
    <url>/2021/10/26/docker-compsoe-an-zhuang-kafka/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><pre><code class="prettyprint">version: &#39;3&#39;
services:
  zookeeper:
    image: wurstmeister/zookeeper
    container_name: zookeeper
    restart: always
    ports:
      - 2181:2181

  kafka:
    image: wurstmeister/kafka
    container_name: kafka
    ports:
      - 9092:9092
    environment:
      KAFKA_ADVERTISED_HOST_NAME: kafka
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
    restart: always
    volumes:
      - ./docker.sock:/var/run/docker.sock
</code></pre>
<h4 id="运行kafka镜像"><a href="#运行kafka镜像" class="headerlink" title="运行kafka镜像"></a>运行kafka镜像</h4><pre><code class="prettyprint">docker-compose up
docker-compose up -d
</code></pre>
<h4 id="验证kafka"><a href="#验证kafka" class="headerlink" title="验证kafka"></a>验证kafka</h4><pre><code class="prettyprint">docker exec -it kafka /bin/bash
</code></pre>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装dubbo-admin</title>
    <url>/2021/10/27/docker-an-zhuang-dubbo-admin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><pre><code>docker pull apache/dubbo-admin
</code></pre>
<h4 id="安装zookeeper"><a href="#安装zookeeper" class="headerlink" title="安装zookeeper"></a>安装zookeeper</h4><p><a href="http://47.105.140.253:8090/archives/docker-compose-da-jian-zookeeper-ji-qun">docker-compose搭建zookeeper集群</a></p>
<h4 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h4><pre><code>docker run -d \
--name dubbo-admin \
-v /usr/local/dubbo/data:/data \
-p 9600:8080 \
-e admin.registry.address=zookeeper://47.105.140.253:2181,47.105.140.253:2182,47.105.140.253:2183 \
-e admin.config-center=zookeeper://47.105.140.253:2181,47.105.140.253:2182,47.105.140.253:2183 \
-e admin.metadata-report.address=zookeeper://47.105.140.253:2181,47.105.140.253:2182,47.105.140.253:2183 \
--restart=always \
docker.io/apache/dubbo-admin
</code></pre>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><a href="http://47.105.140.253:9600/">dubbo-admin</a> 账号root&#x2F;root</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装nginx</title>
    <url>/2021/10/28/docker-an-zhuang-nginx/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h5><pre><code class="prettyprint"># 查询镜像
docker search nginx
# 查询镜像版本
curl https://registry.hub.docker.com/v1/repositories/nginx/tags \
| tr -d &#39;[\[\]&quot; ]&#39; | tr &#39;&#125;&#39; &#39;\n&#39; \
| awk -F: -v image=&#39;nginx&#39; &#39;&#123;if(NR!=NF &amp;&amp; $3 != &quot;&quot;)&#123;printf(&quot;%s:%s\n&quot;,image,$3)&#125;&#125;&#39;
# 拉取镜像
docker pull nginx
</code></pre>
<h5 id="创建挂载目录"><a href="#创建挂载目录" class="headerlink" title="创建挂载目录"></a>创建挂载目录</h5><pre><code class="prettyprint">mkdir -p /usr/local/nginx/conf
mkdir -p /usr/local/nginx/html
mkdir -p /usr/local/nginx/logs
</code></pre>
<h5 id="进入conf-新建nginx-conf"><a href="#进入conf-新建nginx-conf" class="headerlink" title="进入conf,新建nginx.conf"></a>进入conf,新建nginx.conf</h5><pre><code class="prettyprint">
#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events &#123;
    worker_connections  1024;
&#125;


http &#123;
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;
    upstream halo &#123;
        server 47.105.140.253:8090;
    &#125;
    server &#123;
        listen       80;
        listen [::]:80
        server_name  www.pengp.store;
        client_max_body_size 1024m;
        location / &#123;
            proxy_pass http://halo;
            proxy_set_header HOST $host;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_buffering off;
            proxy_redirect off;
            proxy_read_timeout 120;
            proxy_connect_timeout 600;
        &#125;
        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html &#123;
            root   html;
        &#125;

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ &#123;
        #    proxy_pass   http://127.0.0.1;
        #&#125;

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ &#123;
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #&#125;

        # deny access to .htaccess files, if Apache&#39;s document root
        # concurs with nginx&#39;s one
        #
        #location ~ /\.ht &#123;
        #    deny  all;
        #&#125;
    &#125;


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server &#123;
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / &#123;
    #        root   html;
    #        index  index.html index.htm;
    #    &#125;
    #&#125;


    # HTTPS server
    #
    #server &#123;
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / &#123;
    #        root   html;
    #        index  index.html index.htm;
    #    &#125;
    #&#125;

&#125;
</code></pre>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><pre><code class="prettyprint">docker run --name nginx -d -p 80:80 -v /usr/local/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /usr/local/nginx/html:/etc/nginx/html -v /usr/local/nginx/logs:/var/log/nginx nginx
</code></pre>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql小技巧</title>
    <url>/2022/04/07/mysql-xiao-ji-qiao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1、this-is-incompatible-with-sql-mode-x3D-only-full-group-by"><a href="#1、this-is-incompatible-with-sql-mode-x3D-only-full-group-by" class="headerlink" title="1、this is incompatible with sql_mode&#x3D;only_full_group_by"></a>1、this is incompatible with sql_mode&#x3D;only_full_group_by</h3><pre><code class="prettyprint">--  mysql 7、8问题
SELECT @@global.sql_mode  
--结果
&#39;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;
--修改方式
SET @@global.sql_mode = &#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;
</code></pre>
<h3 id="2、日期获取"><a href="#2、日期获取" class="headerlink" title="2、日期获取"></a>2、日期获取</h3><pre><code class="prettyprint">SELECT @num:=@num+1 num,DATE_FORMAT(ADDDATE(&#39;2018-06-10&#39;, INTERVAL @num DAY),&#39;%Y-%m-%d&#39;) AS DATE
FROM pt_code,(SELECT @num:=0) t WHERE ADDDATE(&#39;2018-06-10&#39;, INTERVAL @num DAY) &lt;= DATE_FORMAT(CURDATE(),&#39;%Y-%m-%d&#39;)
LIMIT 0,30
</code></pre>
<h3 id="3、转化成数字排序"><a href="#3、转化成数字排序" class="headerlink" title="3、转化成数字排序"></a>3、转化成数字排序</h3><pre><code class="prettyprint">ORDER BY CAST(DATA1 AS SIGNED)
</code></pre>
<h3 id="4、CSV文件导入数据"><a href="#4、CSV文件导入数据" class="headerlink" title="4、CSV文件导入数据"></a>4、CSV文件导入数据</h3><pre><code class="prettyprint">LOAD DATA LOCAL INFILE 
    &#39;C:\\Users\\Administrator\\Desktop\\AAA.csv&#39;
    INTO TABLE `blog`.`k_lrp`
FIELDS ESCAPED BY &#39;\\&#39;  
TERMINATED BY &#39;,&#39;   
ENCLOSED BY &#39;&quot;&#39;  
LINES TERMINATED BY   &#39;\r\n&#39;  
(`LRP_ID`, `ORG_NO`, `YM`, `X_VALUE`, `DATA_OPER_TIME`, `DATA_OPER_TYPE`,`Y_VAULE`)
</code></pre>
<h3 id="5、前2个月"><a href="#5、前2个月" class="headerlink" title="5、前2个月"></a>5、前2个月</h3><pre><code class="prettyprint">SELECT 
  DATE_FORMAT(
    DATE_ADD(
      STR_TO_DATE(CONCAT(&#39;20201210&#39;, &#39;01&#39;), &#39;%Y%m%d&#39;),
      INTERVAL (1 - CAST(k.rn AS SIGNED INTEGER)) MONTH
    ),
    &#39;%Y%m&#39;
  ) stat_cycle 
FROM
  (SELECT 
    @rn := @rn + 1 rn 
  FROM
    pt_code g,
    (SELECT 
      @rn := 0) f 
  LIMIT 0, 31) k 
WHERE k.rn &lt;= 12 
</code></pre>
<h3 id="6、前30天数据"><a href="#6、前30天数据" class="headerlink" title="6、前30天数据"></a>6、前30天数据</h3><pre><code class="prettyprint">--不包含当天
SELECT @num:=@num+1 num,DATE_FORMAT(ADDDATE(&#39;20201210&#39;, INTERVAL -@num DAY),&#39;%Y%m%d&#39;) AS stat_cycle
FROM pt_code,(SELECT @num:=0) t
LIMIT 0,30
--包含当天
SELECT @num:=@num+1 num,DATE_FORMAT(ADDDATE(&#39;20201210&#39;, INTERVAL 1-@num DAY),&#39;%Y%m%d&#39;) AS stat_cycle
FROM pt_code,(SELECT @num:=0) t
LIMIT 0,30
</code></pre>
]]></content>
      <categories>
        <category>数据</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置https</title>
    <url>/2022/04/06/nginx-pei-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="linux先安装nginx"><a href="#linux先安装nginx" class="headerlink" title="linux先安装nginx"></a>linux先安装nginx</h4><h5 id="安装gcc-c-编译器"><a href="#安装gcc-c-编译器" class="headerlink" title="安装gcc-c++编译器"></a>安装gcc-c++编译器</h5><pre><code class="prettyprint">yum install gcc-c++
yum install -y openssl openssl-devel
</code></pre>
<h5 id="再安装pcre包"><a href="#再安装pcre包" class="headerlink" title="再安装pcre包"></a>再安装pcre包</h5><pre><code class="prettyprint">yum install -y pcre pcre-devel
</code></pre>
<h5 id="安装zlib包"><a href="#安装zlib包" class="headerlink" title="安装zlib包"></a>安装zlib包</h5><pre><code class="prettyprint">yum install -y zlib zlib-devel
</code></pre>
<h5 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h5><pre><code class="prettyprint"># 创建文件夹
mkdir /usr/local/nginx
# 下载
wget https://nginx.org/download/nginx-1.19.9.tar.gz
# 解压并进入
tar -zxvf nginx-1.19.9.tar.gz
cd nginx-1.19.9
# 使用默认配置
./configure
# 编译安装
make
make install
# 查找安装路径并启动
whereis nginx
./nginx
#查看启动成功
ps -ef | grep nginx
</code></pre>
<h4 id="获取ssl证书"><a href="#获取ssl证书" class="headerlink" title="获取ssl证书"></a>获取ssl证书</h4><ol>
<li><p>阿里云搜索<code>ssl</code><br><img src="/images/upload/2022/04/image-6126ceaeb4124eab9b756943f856157a.png" alt="image.png"></p>
</li>
<li><p>选择免费版（注意需要有自己的域名）</p>
</li>
<li><p>下载nginx版<br><img src="/images/upload/2022/04/image-67be79a34bd74f4f864fd13a15df385c.png" alt="image.png"><br><img src="/images/upload/2022/04/image-4ca21e25058a4549953467875478d351.png" alt="image.png"></p>
<h4 id="nginx的ssl模块安装"><a href="#nginx的ssl模块安装" class="headerlink" title="nginx的ssl模块安装"></a>nginx的ssl模块安装</h4><pre><code class="prettyprint"># 确认是否安装ssl模块,进入sbin目录
./nginx -V
# 查看是否存在 --with-http_ssl_module， 如果存在可以跳过此步骤，如若不存在进入/usr/local/nginx/nginx-1.19.9 目录执行以下命令
./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module
# 然后执行make，切记不要make install
make
# 找到objs目录下的面nginx替换到sbin目录下
cp /usr/local/nginx/nginx-1.19.9/objs/nginx /usr/local/nginx/sbin/nginx
# 进入sbin查看
./nginx -V
</code></pre>
<p><img src="/images/upload/2022/04/image-d70d33f8323a4e71b5eed842b8d06c2f.png" alt="image.png"></p>
<h4 id="配置ssl"><a href="#配置ssl" class="headerlink" title="配置ssl"></a>配置<code>ssl</code></h4><pre><code class="prettyprint">server &#123;
#监听443端口
 listen 443;
 #你的域名
 server_name www.pengp.store; 
 ssl on;
 #ssl证书的pem文件路径
 ssl_certificate  /root/card/7560621_www.pengp.store.pem;
 #ssl证书的key文件路径
 ssl_certificate_key /root/card/7560621_www.pengp.store.key;
 location / &#123;
  proxy_pass  http://公网地址:项目端口号;
 &#125;
&#125;
server &#123;
 listen 80;
 server_name www.pengp.store;
 #将请求转成https
 rewrite ^(.*)$ https://$host$1 permanent;
&#125;
</code></pre>
<p><img src="/images/upload/2022/04/image-61e99890b55a4b9c95e2f7804aa9e5f1.png" alt="image.png"></p>
<h4 id="nginx配置systemctl服务"><a href="#nginx配置systemctl服务" class="headerlink" title="nginx配置systemctl服务"></a>nginx配置systemctl服务</h4><pre><code class="prettyprint">vim /usr/lib/systemd/system/nginx.service
</code></pre>
</li>
</ol>
<p>[Unit]<br>Description&#x3D;nginx - web server<br>After&#x3D;network.target remote-fs.target nss-lookup.target<br>[Service]<br>Type&#x3D;forking<br>PIDFile&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid<br>ExecStartPre&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -t -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf<br>ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf<br>ExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload<br>ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s stop<br>ExecQuit&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s quit<br>PrivateTmp&#x3D;true<br>[Install]<br>WantedBy&#x3D;multi-user.target</p>
<h1 id="重新加载系统服务"><a href="#重新加载系统服务" class="headerlink" title="重新加载系统服务"></a>重新加载系统服务</h1><p>systemctl daemon-reload</p>
<h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>systemctl start nginx.service</p>
<h1 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h1><p>systemctl enable nginx.servic</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nvm安装多版本node</title>
    <url>/2022/04/14/nvm-an-zhuang-duo-ban-ben-node/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="nvm下载"><a href="#nvm下载" class="headerlink" title="nvm下载"></a>nvm下载</h4><p><code>https://github.com/coreybutler/nvm-windows/releases</code></p>
<p><img src="https://img-blog.csdnimg.cn/6e3fcc0b10c9400aa6e598901b8b3c1e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5L2g6IS45LiK5pyJQlVH,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="nvm安装"><a href="#nvm安装" class="headerlink" title="nvm安装"></a>nvm安装</h4><p>解压到任意位置，安装是尽量使用管理员操作，关闭360</p>
<h4 id="修改镜像地址-nvm安装目录setting-txt"><a href="#修改镜像地址-nvm安装目录setting-txt" class="headerlink" title="修改镜像地址 nvm安装目录setting.txt"></a>修改镜像地址 nvm安装目录<code>setting.txt</code></h4><pre><code class="prettyprint">node_mirror: https://npm.taobao.org/mirrors/node/
npm_mirror: https://npm.taobao.org/mirrors/npm/
</code></pre>
<h4 id="查看可以安装的node"><a href="#查看可以安装的node" class="headerlink" title="查看可以安装的node"></a>查看可以安装的node</h4><p><code>nvm list available</code> [<a href="https://nodejs.org/en/download/releases/">Previous Releases | Node.js (nodejs.org)</a>]</p>
<h4 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h4><p><code>nvm install 版本号</code>（本人hexo使用12.14.1，node14版本会出现空白页）</p>
<h4 id="使用node"><a href="#使用node" class="headerlink" title="使用node"></a>使用node</h4><p><code>nvm use node</code>(注意使用管理员启动cmd执行命令)</p>
<h4 id="卸载node"><a href="#卸载node" class="headerlink" title="卸载node"></a>卸载node</h4><p><code>nvm uninstall 需要删除的版本</code></p>
<h4 id="配置cnpm"><a href="#配置cnpm" class="headerlink" title="配置cnpm"></a>配置cnpm</h4><p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle小技巧</title>
    <url>/2022/04/07/oracle-xiao-ji-qiao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1、megre-into"><a href="#1、megre-into" class="headerlink" title="1、megre into"></a>1、megre into</h3><pre><code class="prettyprint">MERGE INTO table1 T1
        USING (SELECT  &#39;&#39; cloumn 
                 FROM DUAL) T2
        ON (T1.cloumn      = T2.cloumn)
        WHEN MATCHED THEN
          UPDATE
             SET T1.cloumn1      = T2.cloumn1
        WHEN NOT MATCHED THEN
        insert
          (cloumn1)
        values
          (T2.cloumn1)
</code></pre>
<h3 id="2、连续前几周连续的周日期数据-2019W14-2019W25"><a href="#2、连续前几周连续的周日期数据-2019W14-2019W25" class="headerlink" title="2、连续前几周连续的周日期数据(2019W14-2019W25)"></a>2、连续前几周连续的周日期数据(2019W14-2019W25)</h3><pre><code class="prettyprint">select to_char(t.statCycle, &#39;yyyyMMdd&#39;) statCycleDay,
       to_char(t.statCycle, &#39;yyyy&#39;) || &#39;W&#39; || to_char(t.statCycle, &#39;WW&#39;) statCycle
  from (select Rownum rn,
               (trunc(to_date(&#39;20190622&#39;, &#39;yyyyMMdd&#39;) + Rownum - 7 * 12,
                      &#39;dd&#39;)) statCycle
          from dual
        connect by rownum &lt;= 7 * 12) t
 where t.rn / 7 = cast(t.rn / 7 as int)
 order by t.rn
</code></pre>
<h3 id="3、获取前几天的天日期数据"><a href="#3、获取前几天的天日期数据" class="headerlink" title="3、获取前几天的天日期数据"></a>3、获取前几天的天日期数据</h3><pre><code class="prettyprint">select Rownum rn,
       to_char((trunc(to_date(&#39;20190622&#39;, &#39;yyyyMMdd&#39;) + Rownum - 12, &#39;dd&#39;)),
               &#39;yyyyMMdd&#39;) statCycle
  from dual
connect by rownum &lt;= 12
</code></pre>
<h3 id="4、获取前几个月的月日期数据"><a href="#4、获取前几个月的月日期数据" class="headerlink" title="4、获取前几个月的月日期数据"></a>4、获取前几个月的月日期数据</h3><pre><code class="prettyprint">select k.stat_cycle statCycle
  from (select t.stat_cycle, rownum rn
          from (select to_char(to_date(&#39;201906&#39;, &#39;yyyyMM&#39;), &#39;yyyy&#39;) - 1 ||
                       lpad(level, 2, 0) stat_cycle
                  from dual
                 start with level = 0
                connect by level &lt;= 12
                union all
                select to_char(to_date(&#39;201906&#39;, &#39;yyyyMM&#39;), &#39;yyyy&#39;) ||
                       lpad(level, 2, 0) stat_cycle
                  from dual
                connect by level &lt;=
                           to_char(to_date(&#39;201906&#39;, &#39;yyyyMM&#39;), &#39;MM&#39;)) t) k
 where k.rn &gt; to_char(to_date(&#39;201906&#39;, &#39;yyyyMM&#39;), &#39;MM&#39;)
</code></pre>
<h3 id="5、获取最近24小时数据"><a href="#5、获取最近24小时数据" class="headerlink" title="5、获取最近24小时数据"></a>5、获取最近24小时数据</h3><pre><code class="prettyprint">select Rownum, trunc(sysdate, &#39;hh&#39;) + rownum / 24 past24
  from dual
connect by rownum &lt;= 24
</code></pre>
<h3 id="6、字符串’aaa-bbb-ccc’转表数据’aaa’-’bbb’-’ccc’"><a href="#6、字符串’aaa-bbb-ccc’转表数据’aaa’-’bbb’-’ccc’" class="headerlink" title="6、字符串’aaa,bbb,ccc’转表数据’aaa’,’bbb’,’ccc’"></a>6、字符串’aaa,bbb,ccc’转表数据’aaa’,’bbb’,’ccc’</h3><pre><code class="prettyprint">select regexp_substr(&#39;aaa,bbb,ccc&#39;, &#39;[^,]+&#39;, 1, level)
  from dual
connect by level &lt;=
           length(&#39;aaa,bbb,ccc&#39;) - length(replace(&#39;aaa,bbb,ccc&#39;, &#39;,&#39;)) + 1
</code></pre>
<h3 id="7、Oracle中rank-over-dense-rank-row-number-的区别"><a href="#7、Oracle中rank-over-dense-rank-row-number-的区别" class="headerlink" title="7、Oracle中rank() over, dense_rank(), row_number() 的区别"></a>7、Oracle中rank() over, dense_rank(), row_number() 的区别</h3><pre><code class="prettyprint">--1. rank over ()可以实现对学生排名，特点是成绩相同的两名是并列，如下1 2 2 4 5
select name,
      course,
      rank() over(partition by course order by score desc) as rank
  from student;
--2. dense_rank()和rank over()很像，但学生成绩并列后并不会空出并列所占的名次，如下1 2 2 3 4
 
select name,
      course,
      dense_rank() over(partition by course order by score desc) as rank
  from student;
--3. row_number这个函数不需要考虑是否并列，那怕根据条件查询出来的数值相同也会进行连续排名
select name,
      course,
      row_number() over(partition by course order by score desc) as rank
  from student;
</code></pre>
<h3 id="8、group-by-与-partition-by-区别"><a href="#8、group-by-与-partition-by-区别" class="headerlink" title="8、group by 与 partition by 区别"></a>8、group by 与 partition by 区别</h3><pre><code class="prettyprint">1. partition by用于给结果集进行分区。
2. partition by和group by有何区别？
partition by只是将原始数据进行名次排列(记录数不变)
group by是对原始数据进行聚合统计(记录数可能变少, 每组返回一条)
3. 使用rank over()的时候，空值是最大的，如果排序字段为null, 可能造成null字段排在最前面，影响排序结果。
可以这样： rank over(partition by course order by score desc nulls last)
</code></pre>
<h3 id="9、DDL"><a href="#9、DDL" class="headerlink" title="9、DDL"></a>9、DDL</h3><pre><code class="prettyprint">--修改字段类型
ALTER TABLE ADDRESS MODIFY COLUMN CITY CHAR(30);
--修改字段长度
ALTER TABLE ADDRESS MODIFY COLUMN CITY VARCHAR(32);
--新增字段
ALTER TABLE ADDRESS ADD (CITY VARCHAR2(256));
-- 给字段添加注释
COMMENT ON COLUMN ADDRESS.CITY
  IS &#39;发帖人联系方式&#39;;
</code></pre>
<h3 id="10、plsq注册码"><a href="#10、plsq注册码" class="headerlink" title="10、plsq注册码"></a>10、plsq注册码</h3><ul>
<li>Product Code：4t46t6vydkvsxekkvf3fjnpzy5wbuhphqz</li>
<li>serial Number：601769</li>
<li>password：xs374ca</li>
</ul>
<h3 id="11、行转列"><a href="#11、行转列" class="headerlink" title="11、行转列"></a>11、行转列</h3><p><code>LISTAGG*(BUY,&#39;,&#39;) WITHIN GROUP(ORDER BY BUY DESC)</code></p>
<h3 id="12、根据某一个字段排序获取序号"><a href="#12、根据某一个字段排序获取序号" class="headerlink" title="12、根据某一个字段排序获取序号"></a>12、根据某一个字段排序获取序号</h3><p><code>ROW_NUMBER() OVER(PARTITION BY A.org_no ORDER BY a.det_id DESC) rowflag</code></p>
<h3 id="13、根据某一个字段获取数量"><a href="#13、根据某一个字段获取数量" class="headerlink" title="13、根据某一个字段获取数量"></a>13、根据某一个字段获取数量</h3><p><code>count(*) over(partition by A.field) coutflag</code></p>
<h3 id="14、数据库赋权"><a href="#14、数据库赋权" class="headerlink" title="14、数据库赋权"></a>14、数据库赋权</h3><p><code>Grant select on db1.table to db2</code></p>
]]></content>
      <categories>
        <category>数据</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>windows编辑生成的shell脚本在linux执行问题调整</title>
    <url>/2021/10/30/windows-bian-ji-sheng-cheng-de-shell-jiao-ben-zai-linux-zhi-xing-wen-ti-diao-zheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li>打开shell脚本</li>
<li>vim file.sh</li>
<li>shift+: 打开命令行</li>
<li>输入 set ff 查看 发现显示 dos</li>
<li>输入 set ff&#x3D;unix</li>
</ol>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序构建npm问题</title>
    <url>/2022/04/05/wei-xin-xiao-cheng-xu-gou-jian-npm-wen-ti/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li><code>npm init -y</code> 生成<code>package.json</code></li>
<li>修改 <code>project.config.json</code> 中<code>packNpmManually</code> 为false</li>
<li><code>npm install &quot;需要下载的包&quot;</code></li>
<li>npm构建</li>
<li>如果没有生成<code>miniprogram_npm</code> 就再<code>npm init -y</code></li>
</ol>
]]></content>
      <categories>
        <category>微信</category>
      </categories>
  </entry>
  <entry>
    <title>安全问题整改</title>
    <url>/2022/04/07/an-quan-wen-ti-zheng-gai/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1、心脏滴血安全问题"><a href="#1、心脏滴血安全问题" class="headerlink" title="1、心脏滴血安全问题"></a>1、心脏滴血安全问题</h2><p>​	就是把openssl版本换成了1.0.1g，然后重新编译了Nginx</p>
<h2 id="2、加密会话（SSL-）Cookie-中缺少-Secure"><a href="#2、加密会话（SSL-）Cookie-中缺少-Secure" class="headerlink" title="2、加密会话（SSL ）Cookie  中缺少 Secure"></a>2、加密会话（SSL ）Cookie  中缺少 Secure</h2><p>​	web.xml 配置</p>
<pre><code class="prettyprint">&lt;session-config&gt;
    &lt;cookie-config&gt;
        &lt;secure&gt;true&lt;/secure&gt;
    &lt;/cookie-config&gt;
&lt;/session-config&gt;
</code></pre>
<h2 id="3、X-Frame-Options"><a href="#3、X-Frame-Options" class="headerlink" title="3、X-Frame-Options"></a>3、X-Frame-Options</h2><p>​	过滤器xml配置</p>
<pre><code class="prettyprint">&lt;filter&gt;
    &lt;filter-name&gt;xFrameOptionFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;XFrameOptionFilter&lt;/filter-class&gt;
    &lt;async-supported&gt;true&lt;/async-supported&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;xFrameOptionFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<p>​	过滤器java</p>
<pre><code class="prettyprint">HttpServletResponse response=(HttpServletResponse) rep;
    response.addHeader(&quot;x-frame-options&quot;,&quot;SAMEORIGIN&quot;);
    chain.doFilter(req, response);
</code></pre>
<h2 id="4、存储性xss攻击（前端解决方法）"><a href="#4、存储性xss攻击（前端解决方法）" class="headerlink" title="4、存储性xss攻击（前端解决方法）"></a>4、存储性xss攻击（前端解决方法）</h2><p>​	xss.js路径&lt;C:\Users\Administrator\Desktop\work\xss.js&gt;</p>
<p>​	引入xss.js    调用filterXSS方法</p>
<h2 id="5、启用了不安全的HTTP方法（OPTIONS）"><a href="#5、启用了不安全的HTTP方法（OPTIONS）" class="headerlink" title="5、启用了不安全的HTTP方法（OPTIONS）"></a>5、启用了不安全的HTTP方法（OPTIONS）</h2><p>​	 在web.xml添加</p>
<pre><code class="prettyprint">&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
        &lt;web-resource-name&gt;HttpMethod&lt;/web-resource-name&gt;
        &lt;description&gt;HttpMethod&lt;/description&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
        &lt;http-method&gt;PUT&lt;/http-method&gt;
        &lt;http-method&gt;DELETE&lt;/http-method&gt;
        &lt;http-method&gt;HEAD&lt;/http-method&gt; 
        &lt;http-method&gt;OPTIONS&lt;/http-method&gt;
        &lt;http-method&gt;TRACE&lt;/http-method&gt;
        &lt;http-method&gt;PATH&lt;/http-method&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;&lt;/auth-constraint&gt;
&lt;/security-constraint&gt;
</code></pre>
<h2 id="6、错误信息泄露中间件版本信息。-web-xml配置错误页面（poseidon）"><a href="#6、错误信息泄露中间件版本信息。-web-xml配置错误页面（poseidon）" class="headerlink" title="6、错误信息泄露中间件版本信息。  web.xml配置错误页面（poseidon）"></a>6、错误信息泄露中间件版本信息。  web.xml配置错误页面（poseidon）</h2><pre><code class="prettyprint">&lt;error-page&gt;  
&lt;error-code&gt;400&lt;/error-code&gt;  
&lt;location&gt;/error/error.html&lt;/location&gt;  
&lt;/error-page&gt; 
</code></pre>
<h2 id="7、网站存在样例-x2F-说明文件"><a href="#7、网站存在样例-x2F-说明文件" class="headerlink" title="7、网站存在样例&#x2F;说明文件"></a>7、网站存在样例&#x2F;说明文件</h2><p>​	删除wepapps&#x2F;docs</p>
<h2 id="8、jsp转码安全漏洞"><a href="#8、jsp转码安全漏洞" class="headerlink" title="8、jsp转码安全漏洞"></a>8、jsp转码安全漏洞</h2><p>​	&lt;%&#x3D;ESAPI.encoder().encodeForJavaScript(String.valueOf(request.getParameter(“mapTool”)))%&gt;</p>
<h2 id="9、Fortify-fix-for-XML-External-Entity-Injection"><a href="#9、Fortify-fix-for-XML-External-Entity-Injection" class="headerlink" title="9、Fortify fix for XML External Entity Injection"></a>9、Fortify fix for XML External Entity Injection</h2><h4 id="1）、TransformerFactory-trfactory-x3D-TransformerFactory-newInstance"><a href="#1）、TransformerFactory-trfactory-x3D-TransformerFactory-newInstance" class="headerlink" title="1）、TransformerFactory trfactory &#x3D; TransformerFactory.newInstance();"></a>1）、TransformerFactory trfactory &#x3D; TransformerFactory.newInstance();</h4><pre><code class="prettyprint">//TransformerFactory trfactory = TransformerFactory.newInstance(); 
//使用以下实现类替换
TransformerFactoryImpl transformerFactoryImpl = new TransformerFactoryImpl();
Transformer transformer = transformerFactoryImpl.newTransformer();
</code></pre>
<h4 id="2）、DocumentBuilder-x3D-x3D-gt-parse-is"><a href="#2）、DocumentBuilder-x3D-x3D-gt-parse-is" class="headerlink" title="2）、DocumentBuilder &#x3D;&#x3D;&gt;parse(is);"></a>2）、DocumentBuilder &#x3D;&#x3D;&gt;parse(is);</h4><pre><code class="prettyprint">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        
        
String FEATURE = null;
try &#123;
    FEATURE = &quot;http://apache.org/xml/features/disallow-doctype-decl&quot;;
    dbf.setFeature(FEATURE, true);
    FEATURE = &quot;http://xml.org/sax/features/external-general-entities&quot;;
    dbf.setFeature(FEATURE, false);
    FEATURE = &quot;http://xml.org/sax/features/external-parameter-entities&quot;;
    dbf.setFeature(FEATURE, false);
    FEATURE = &quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;;
    dbf.setFeature(FEATURE, false);
    dbf.setXIncludeAware(false);
    dbf.setExpandEntityReferences(false);
&#125; catch (Exception e) &#123;
    e.printStackTrace();
&#125;


DocumentBuilder builder = dbf.newDocumentBuilder();
InputSource is = new InputSource();
is.setCharacterStream(new StringReader(filterXXE(xml)));
Document doc = builder.parse(is);
</code></pre>
<p>参考：<a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.md">https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.md</a></p>
<h2 id="10、Random随机数问题"><a href="#10、Random随机数问题" class="headerlink" title="10、Random随机数问题"></a>10、Random随机数问题</h2><pre><code class="prettyprint">private SecureRandom random() throws NoSuchAlgorithmException&#123;
    return SecureRandom.getInstance(&quot;SHA1PRNG&quot;);
&#125;
//使用SecureRandom替换Random
</code></pre>
<h2 id="11、Header-Manipulation"><a href="#11、Header-Manipulation" class="headerlink" title="11、Header Manipulation"></a>11、Header Manipulation</h2><pre><code class="prettyprint">//response.addHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot; + fileOrgnName);
//将文件名过滤
public String filterFileName(String filename)&#123;
    String regex = &quot;[`~!@#$%^&amp;*()\\+\\=\\&#123;&#125;|:\&quot;?&gt;&lt;【】\\/r\\/n]&quot;;
    Pattern pa = Pattern.compile(regex);
    Matcher ma = pa.matcher(filename);
    if(ma.find())&#123;
        filename = ma.replaceAll(&quot;&quot;);
    &#125;
    return filename;
&#125;
response.addHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot; + filterFileName(fileOrgnName));
</code></pre>
<h2 id="12、Access-Control-Database"><a href="#12、Access-Control-Database" class="headerlink" title="12、Access Control:Database"></a>12、Access Control:Database</h2><p>单字符串 <code>StringEscapeUtils.escapeSql(）</code>转义<br>对象可以使用JSON转化</p>
<pre><code class="prettyprint">import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class JSONUtils &#123;
    private static final ObjectMapper MAPPER = new ObjectMapper();
    public static &lt;T&gt; List&lt;T&gt; jsonToList(String jsonText,Class&lt;T&gt; clazz) &#123;
        try &#123;
            return MAPPER.readValue(jsonText, new TypeReference&lt;List&lt;T&gt;&gt;() &#123;&#125;);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return new ArrayList&lt;&gt;();
    &#125;
    public static &lt;T&gt; String listToJson(List&lt;T&gt; list,Class&lt;T&gt; clazz)&#123;
        try &#123;
            return MAPPER.writeValueAsString(list);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return &quot;&quot;;
    &#125;
    
    public static Map jsonToMap(String jsonText)&#123;
        try &#123;
            return MAPPER.readValue(jsonText, Map.class);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return new HashMap();
    &#125;
    public static Map jsonToMapArr(String jsonText,String key)&#123;
        try &#123;
            Map map = MAPPER.readValue(jsonText, Map.class);
            String[] keys = key.split(&quot;,&quot;);
            for (String k:keys)&#123;
                map.put(k,((List&lt;?&gt;)map.get(k)).toArray(new String[((List&lt;?&gt;)map.get(k)).size()]));
            &#125;
            return map;
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return new HashMap();
    &#125;
    
    public static String mapToJson(Map map)&#123;
        try &#123;
            return MAPPER.writeValueAsString(map);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return &quot;&quot;;
    &#125;

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T jsonToObject(String jsonText,Class&lt;T&gt; clazz) &#123;
        try &#123;
            return MAPPER.readValue(jsonText, clazz);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;
    public static &lt;T&gt; String ObjectToJson(T t,Class&lt;T&gt; clazz)&#123;
        try &#123;
            return MAPPER.writeValueAsString(t);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return &quot;&quot;;
    &#125;
    
    public static Object getMapValueByKey(Map&lt;String,Object&gt; param,String str)&#123;
        return param.get(str) == null?&quot;&quot;:param.get(str);
    &#125;
&#125;
</code></pre>
<h2 id="13、Formula-Injection-Input-Validation-and-Representation-Data-Flow"><a href="#13、Formula-Injection-Input-Validation-and-Representation-Data-Flow" class="headerlink" title="13、Formula Injection (Input Validation and Representation, Data Flow)"></a>13、Formula Injection (Input Validation and Representation, Data Flow)</h2><p>导出excel时用bos.write会出现</p>
<pre><code>is = DataDealUtil.dataToInputStram(tableName, tableUnit, tableData, tableTitle,cellWidth != null?cellWidth:6,cellHeight != null?cellHeight:12);
            // 璁剧疆response鍙傛暟锛屽彲浠ユ墦寮�涓嬭浇椤甸潰
            response.reset();
            response.setContentType(&quot;application/vnd.ms-excel;charset=utf-8&quot;);

            tableName = URLEncoder.encode(tableName, &quot;utf-8&quot;);
            response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot; + tableName + &quot;.xls&quot;);

            ServletOutputStream out = response.getOutputStream();
            bis = new BufferedInputStream(is);
            bos = new BufferedOutputStream(out);

            byte[] buff = new byte[2048];
            int bytesRead; // Simple read/write loop.

            while (-1 != (bytesRead = bis.read(buff, 0, buff.length))) &#123;
                bos.write(buff, 0, bytesRead);
            &#125;
</code></pre>
<p>修改方式：直接使用HSSFWorkbook.write</p>
<pre><code>workbook = DataDealUtil.dataToInputStram(tableName, tableUnit, tableData, tableTitle,cellWidth != null?cellWidth:6,cellHeight != null?cellHeight:12);
            // 设置response参数，可以打开下载页面
            response.reset();
            response.setContentType(&quot;application/vnd.ms-excel;charset=utf-8&quot;);

            tableName = URLEncoder.encode(tableName, &quot;utf-8&quot;);
            response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot; + tableName + &quot;.xls&quot;);
            output = response.getOutputStream();
            workbook.write(output);
</code></pre>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
  </entry>
  <entry>
    <title>算法可视化地址</title>
    <url>/2021/10/11/suan-fa-ke-shi-hua-di-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a><br><a href="https://algorithm-visualizer.org/">https://algorithm-visualizer.org/</a></p>
<div class="aplayer-box" data-url='http://www.ytmp3.cn/down/51689.mp3' data-name='你一定要幸福' data-artist='简弘亦' data-cover='http://img.ytmp3.cn/image/52.jpg' data-lrc='http://img.ytmp3.cn/image/52..lrc' data-lrcType='3' ></div>

]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
  </entry>
  <entry>
    <title>杂乱无章.md</title>
    <url>/2021/08/31/za-luan-wu-zhang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、在js里面引入js或css"><a href="#一、在js里面引入js或css" class="headerlink" title="一、在js里面引入js或css"></a>一、在js里面引入js或css</h2><pre><code class="javascript">//论坛首页 各模块铁贴数
var new_element=document.createElement(&quot;script&quot;);
new_element.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);
new_element.setAttribute(&quot;src&quot;,&quot;../prompt/prompt.js&quot;);// 在这里引入了a.js
document.body.appendChild(new_element);
function loadStyle(url)&#123;
    var link = document.createElement(&#39;link&#39;);
        link.type = &#39;text/css&#39;;
        link.rel = &#39;stylesheet&#39;;
        link.href = url;
        var head = document.getElementsByTagName(&#39;head&#39;)[0];
        head.appendChild(link);
    &#125;
loadStyle(&#39;../prompt/prompt.css&#39;);
</code></pre>
<h2 id="二、自定义confirm"><a href="#二、自定义confirm" class="headerlink" title="二、自定义confirm"></a>二、自定义confirm</h2><h3 id="1、javascript部分"><a href="#1、javascript部分" class="headerlink" title="1、javascript部分"></a>1、javascript部分</h3><pre><code class="prettyprint">function showPop(string,callback)&#123;
    function set()&#123;
        let popDom = &#39;&lt;div class=&quot;popUps_mask&quot;&gt;&#39;;
        popDom += &#39;&lt;div&gt;&#39;;
        popDom += &#39;&lt;div class=&quot;shutDown&quot;&gt;+&lt;/div&gt;&#39;;
        popDom += &#39;&lt;div class=&quot;theme&quot;&gt;&#39;+string+&#39;&lt;/div&gt;&#39;;
        popDom += &#39;&lt;div class=&quot;buttonList&quot;&gt;&lt;button class=&quot;cancel&quot;&gt;取消&lt;/button&gt;&lt;button class=&quot;confirm&quot;&gt;确认&lt;/button&gt;&lt;/div&gt;&#39;;
        popDom += &#39;&lt;/div&gt;&#39;;
        popDom += &#39;&lt;/div&gt;&#39;;
        $(&#39;body&#39;).append(popDom);
    &#125;
    set();
    $(&#39;.shutDown&#39;).click(function()&#123;
        $(&#39;.popUps_mask&#39;).remove();
    &#125;);
    $(&#39;.cancel&#39;).click(function()&#123;
        $(&#39;.popUps_mask&#39;).remove();
    &#125;);
    $(&#39;.confirm&#39;).click(function()&#123;
        callback&amp;&amp;callback();
        $(&#39;.popUps_mask&#39;).remove();
    &#125;)
&#125;
</code></pre>
<h3 id="2、css部分"><a href="#2、css部分" class="headerlink" title="2、css部分"></a>2、css部分</h3><pre><code class="prettyprint">.popUps_mask&#123;
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    z-index: 1024;
&#125;

.popUps_mask &gt;div&#123;
    width: 350px;
    box-shadow: 0px 0px 7px #8e8787;
    height: 210px;
    background: white;
    margin: 10% auto;
    position: relative;
&#125;

.popUps_mask &gt;div .shutDown&#123;
    font-size: 35px;
    position: absolute;
    top: -4px;
    right: 7px;
    color: #d6d0d0;
    transform: rotate(45deg);
    -ms-transform: rotate(45deg);
    -moz-transform: rotate(45deg);
    -webkit-transform: rotate(45deg);
    -o-transform: rotate(45deg);
    cursor: pointer;
&#125;    

.popUps_mask &gt;div .theme&#123;
    text-align: center;
    font-size: 25px;
    color: black;
    padding-top: 60px;
&#125;    

.popUps_mask &gt;div .buttonList&#123;
    text-align: center;
    margin-top: 35px;
&#125;    

.popUps_mask &gt;div .buttonList .cancel&#123;
    width: 70px;
    border: 1px solid #e1e1e1;
    border-radius: 4px;
    height: 30px;
    background: #f8f8f8;
&#125;

.popUps_mask &gt;div .buttonList .cancel&#123;
    width: 70px;
    border: 1px solid #e1e1e1;
    border-radius: 4px;
    height: 30px;
    background: #f8f8f8;
    margin-right: 5px;
    cursor: pointer;
&#125;

.popUps_mask &gt;div .buttonList .confirm&#123;
    width: 70px;
    border: 1px solid #277BAD;
    border-radius: 4px;
    height: 30px;
    background: white;
    color: #277BAD;
    margin-left: 5px;
    cursor: pointer;
&#125;
</code></pre>
<h3 id="3、调用方式"><a href="#3、调用方式" class="headerlink" title="3、调用方式"></a>3、调用方式</h3><pre><code class="prettyprint">showPop(&quot;是否确认删除！&quot;,
        function()&#123;
                //doSomething
        &#125;)
</code></pre>
<h2 id="三、常用的js方法"><a href="#三、常用的js方法" class="headerlink" title="三、常用的js方法"></a>三、常用的js方法</h2><pre><code class="prettyprint">// 日期格式化
Date.prototype.format = function (fmt) &#123;
    var o = &#123;
        &quot;y+&quot;: this.getYear(),
        &quot;M+&quot;: this.getMonth() + 1, //月份 
        &quot;d+&quot;: this.getDate(), //日 
        &quot;h+&quot;: this.getHours(), //小时 
        &quot;m+&quot;: this.getMinutes(), //分 
        &quot;s+&quot;: this.getSeconds(), //秒 
        &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), //季度 
        &quot;S&quot;: this.getMilliseconds() //毫秒 
    &#125;;
    if (/(y+)/.test(fmt)) &#123;
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length));
    &#125;
    for (var k in o)&#123;
        if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt))&#123;
            fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)));
        &#125;
    &#125;
    return fmt;
&#125;
var commonUtils = &#123;
        sleep:function(numberMillis)&#123;
             var now = new Date();
                var exitTime = now.getTime() + numberMillis;
                while (true) &#123;
                    now = new Date();
                    if (now.getTime() &gt; exitTime)
                        return;
                &#125;
        &#125;,
        round:function(src,pos)&#123;
            if(typeof src !==&#39;number&#39;)&#123;
                src = parseFloat(src);
                if(isNaN(src))&#123;
                    src = 0;
                &#125;
            &#125;
            if(!pos)&#123;
                pos = 2;
            &#125;
            return (Math.round(src*Math.pow(10, pos))/Math.pow(10, pos)).toFixed(pos);
        &#125;,
        
        booleanValueOf:function(value)&#123;
            if(value==true || /^true$/ig.test(value))&#123;
                return true;
            &#125;else&#123;
                return false;
            &#125;
        &#125;,
        getLength:function(object) &#123;
            var count = 0;
            for(var i in object) count++;
            return count;
        &#125;,
        isObject: function(obj)&#123;
            return Object.prototype.toString.call(obj) === &quot;[object Object]&quot;;
        &#125;,
        isArray: function(obj)&#123;
            return Object.prototype.toString.call(obj) === &quot;[object Array]&quot;;
        &#125;,
        isFunction: function(obj)&#123;
            return Object.prototype.toString.call(obj) === &quot;[object Function]&quot;;
        &#125;,
        isBoolean: function(obj)&#123;
            return Object.prototype.toString.call(obj) === &quot;[object Boolean]&quot;;
        &#125;,
        isNumber: function(obj)&#123;
            return Object.prototype.toString.call(obj) === &quot;[object Number]&quot;;
        &#125;,
        isString: function(obj)&#123;
            return Object.prototype.toString.call(obj) === &quot;[object String]&quot;;
        &#125;,
        isUndefined: function(obj)&#123;
            return Object.prototype.toString.call(obj) === &quot;[object Undefined]&quot;;
        &#125;,
        isEmpty: function(obj)&#123;
            if(obj == null || obj == &#39;undefined&#39; || obj == undefined || obj.length==0)&#123;
                return true;
            &#125;else&#123;
                return false;
            &#125;
            
        &#125;,
        //设置百分率
        setRate: function (data)&#123;
            data = data +&quot;&quot;;
            return data.indexOf(&quot;NaN&quot;) != - 1?&quot;0.00&quot;:parseFloat(data).toFixed(2)+&quot;&quot;;
        &#125;,
        //去除空格
        trim: function (str)&#123; 
            
          return String(str).replace(/(^\s*)|(\s*$)/g, &quot;&quot;); 
        &#125;,
        /**
         * 计算输入值得最小整数值
         * @param &#123;Object&#125; val
         */
        getYMinVal : function(min,max)&#123;
            if((min + Math.abs(min)) != 0)&#123;
                var minS = &quot;&quot;;
                var minC = min+&quot;&quot;;
                if(minC.indexOf(&quot;.&quot;) != -1 &amp;&amp; &quot;0&quot; == (minC.substring(0,minC.indexOf(&quot;.&quot;))))&#123;
                    if(max &lt;3)&#123;
                        minS =  minC.substring(0,minC.indexOf(&quot;.&quot;)+2);
                    &#125;else&#123;
                        minS = &quot;0&quot;;
                    &#125;
                &#125;else &#123;
                	if(minC.indexOf(&quot;.&quot;)!=-1)&#123;
                		if(max &lt; 5)&#123;
                			minS = ((minC * 0.98)+&quot;&quot;).substring(0,((minC * 0.98)+&quot;&quot;).indexOf(&quot;.&quot;)+2)
                		&#125;else if(max &lt; 10)&#123;
                			minS = ((minC * 0.95)+&quot;&quot;).substring(0,((minC * 0.95)+&quot;&quot;).indexOf(&quot;.&quot;)+2)
                		&#125;else if(max &lt; 20)&#123;
                			minS = ((minC * 0.9)+&quot;&quot;).substring(0,((minC * 0.9)+&quot;&quot;).indexOf(&quot;.&quot;)+2)
                		&#125;else&#123;
                			minS = minC.substring(0,minC.indexOf(&quot;.&quot;));
                			if(minS.length == 1)&#123;
                                if(max &gt; 30)&#123;
                                    minS = &quot;0&quot;;
                                &#125;
                            &#125;else if(minS.length &lt; 3)&#123;
                                var zeros = &quot;&quot;;
                                for(var i=0;i&lt;minS.length-1;i++)&#123;
                                    zeros += &quot;0&quot;;
                                &#125;
                                minS = minS.substring(0,1)+zeros;
                            &#125;else&#123;
                                var zeros = &quot;&quot;;
                                for(var i=0;i&lt;minS.length-2;i++)&#123;
                                    zeros += &quot;0&quot;;
                                &#125;
                                minS = minS.substring(0,2)+zeros;
                            &#125;
                		&#125;
                	&#125;else&#123;
                		minS = minC;
                		if(minS.length == 1)&#123;
                            if(max &lt; 30)&#123;
                                minCS = &quot;0&quot;;
                            &#125;
                        &#125;else if(minS.length &lt;= 3)&#123;
                            var zeros = &quot;&quot;;
                            for(var i=0;i&lt;minS.length-1;i++)&#123;
                                zeros += &quot;0&quot;;
                            &#125;
                            minS = minS.substring(0,1)+zeros;
                        &#125;else&#123;
                            var zeros = &quot;&quot;;
                            for(var i=0;i&lt;minS.length-2;i++)&#123;
                                zeros += &quot;0&quot;;
                            &#125;
                            minS = minS.substring(0,2)+zeros;
                        &#125;
                	&#125;
                &#125;

                return minS.indexOf(&quot;.&quot;) != -1?parseFloat(minS):parseInt(minS);
            &#125;
            
            if(isNaN(min) || min==0)&#123;
                return 0;
            &#125;
            if(max-min&lt;=5)&#123;
                return Math.floor(min);
            &#125;
            
            var t_val = Math.abs(min);
            var temp = 0;
            
            if(t_val&lt;100)&#123;
                temp = Math.floor((min)/5)*5;
            &#125;else if(t_val&gt;=100 &amp;&amp; t_val&lt;1000)&#123;
                temp = Math.floor((min)/50)*50;
            &#125;else if(t_val&gt;=1000 &amp;&amp; t_val&lt;10000)&#123;
                temp = Math.floor((min)/500)*500;
            &#125;else if(t_val&gt;=10000 &amp;&amp; t_val&lt;100000)&#123;
                temp = Math.floor((min)/5000)*5000;
            &#125;else if(t_val&gt;=100000)&#123;
                temp = Math.floor((min)/50000)*50000;
            &#125;
            if(min&gt;0 &amp;&amp; max&gt;0 &amp;&amp; temp&lt;0)&#123;
                return 0;
            &#125;else&#123;
                return temp;
            &#125;
        &#125;,
        getIndexWithArr: function(_arr,_obj) &#123;
            var len = _arr.length;
            for(var i = 0; i &lt; len; i++)
            &#123;
                if(_arr[i] == _obj)
                &#123;
                    return parseInt(i);
                &#125;
            &#125;
            return -1;
        &#125;,
        removeObjWithArr :function (_arr,_obj) &#123;
            var length = _arr.length;
            for(var i = 0; i &lt; length; i++)&#123;
                if(_arr[i] == _obj)&#123;
                	return _arr.splice(i,1);
                    if(i == 0)&#123;
                        _arr.shift(); //删除并返回数组的第一个元素
                        return;
                    &#125;else if(i == length-1)&#123;
                        _arr.pop();  //删除并返回数组的最后一个元素
                        return;
                    &#125;else&#123;
                    	return _arr.splice(i,1); //删除下标为i的元素
                        
                    &#125;
                &#125;
            &#125;
        &#125;,
        /*比较对象*/
        compare:function(objA, objB) &#123;
            var flag = true;
            if(!commonUtils.isObject(objA) || !commonUtils.isObject(objB))&#123;
            	flag = false; //判断类型是否正确
            &#125;
            if(commonUtils.getLength(objA) != commonUtils.getLength(objB))&#123;
            	flag = false; //判断长度是否一致
            &#125;
            for(var key in objA) &#123;
                if(!flag) //跳出整个循环
                    break;
                if(!objB.hasOwnProperty(key)) &#123;
                    flag = false;
                    break;
                &#125;
                if(!commonUtils.isArray(objA[key])) &#123; //子级不是数组时,比较属性值
                    if(objB[key] != objA[key]) &#123;
                        flag = false;
                        break;
                    &#125;
                &#125; else &#123;
                    if(!commonUtils.isArray(objB[key])) &#123;
                        flag = false;
                        break;
                    &#125;
                    var oA = objA[key],
                        oB = objB[key];
                    if(oA.length != oB.length) &#123;
                        flag = false;
                        break;
                    &#125;
                    for(var k in oA) &#123;
                        if(!flag) //这里跳出循环是为了不让递归继续
                            break;
                        flag = CompareObj(oA[k], oB[k], flag);
                    &#125;
                &#125;
            &#125;
            return flag;
        &#125;
&#125;
</code></pre>
<h2 id="四、java里面一些日期处理方法"><a href="#四、java里面一些日期处理方法" class="headerlink" title="四、java里面一些日期处理方法"></a>四、java里面一些日期处理方法</h2><pre><code class="prettyprint">public class DateUtils &#123;

    /**
     * 
     * 方法说明：获取当前日期最近的星期五 Author： PengP Create Date： 2018年7月27日 上午10:06:37
     * 如果是星期五获取上个星期五的数据
     * @param date
     *            日期 2018-7-27
     * @param format
     *            yyyy-MM-dd
     * @return
     * @throws ParseException
     */
    public static String getLastForWeekForInit(Date dateParam)&#123;
        SimpleDateFormat sdfDefault = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Date date = null;
        try &#123;
            String yzTime = getTimeInterval(dateParam,&quot;yyyy-MM-dd&quot;);// 获取选中日期本周时间区间
            String array[] = yzTime.split(&quot;,&quot;);
            String startTime = array[0];// 本周第一天
            String endTime = array[1]; // 本周最后一天
            // 格式化日期
            Date dBegin = sdfDefault.parse(startTime);
            Date dEnd = sdfDefault.parse(endTime);
            List&lt;Date&gt; lDate = findDates(dBegin, dEnd);// 获取这周所有date
            if (lDate.get(4).getTime() &gt; dateParam.getTime() - 24 * 3600 * 1000) &#123;
                date = new Date(lDate.get(4).getTime() - 7 * 24 * 3600 * 1000);
            &#125;else&#123;
                date = lDate.get(4);
            &#125;
        &#125; catch (ParseException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        return sdfDefault.format(date);
    &#125;
    /**
     * 
     * 方法说明：获取当前日期最近的星期五
     * 如果是星期五获取这个星期五的数据
     * Author： PengP               
     * Create Date： 2018年8月2日 上午10:46:09
     * @param dateParam
     * @return
     */
    public static String getLastForWeek(Date dateParam)&#123;
        SimpleDateFormat sdfDefault = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Date date = null;
        try &#123;
            String yzTime = getTimeInterval(dateParam,&quot;yyyy-MM-dd&quot;);// 获取选中日期本周时间区间
            String array[] = yzTime.split(&quot;,&quot;);
            String startTime = array[0];// 本周第一天
            String endTime = array[1]; // 本周最后一天
            // 格式化日期
            Date dBegin = sdfDefault.parse(startTime);
            Date dEnd = sdfDefault.parse(endTime);
            List&lt;Date&gt; lDate = findDates(dBegin, dEnd);// 获取这周所有date
            if (lDate.get(4).getTime() &gt; dateParam.getTime()) &#123;
                date = new Date(lDate.get(4).getTime() - 7 * 24 * 3600 * 1000);
            &#125;else&#123;
                date = lDate.get(4);
            &#125;
        &#125; catch (ParseException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        return sdfDefault.format(date);
    &#125;
    /**
     * 
     * 方法说明：获取当前日期最近的星期五 Author： PengP Create Date： 2018年7月27日 上午10:06:37
     * 今天星期五就上个星期五
     * @param date
     *            日期 2018-7-27
     * @param format
     *            yyyy-MM-dd
     * @return
     * @throws ParseException
     */
    public static String getLastForWeekForInit(String dateStr, String format)&#123;
        Date date = null;
        SimpleDateFormat sdf = new SimpleDateFormat(format);
        try&#123;
            String yzTime = getTimeInterval(sdf.parse(dateStr),format);// 获取选中日期本周时间区间
            String array[] = yzTime.split(&quot;,&quot;);
            String startTime = array[0];// 本周第一天
            String endTime = array[1]; // 本周最后一天
            // 格式化日期
            Date dBegin = sdf.parse(startTime);
            Date dEnd = sdf.parse(endTime);
            List&lt;Date&gt; lDate = findDates(dBegin, dEnd);// 获取这周所有date
            if (lDate.get(4).getTime() &gt; sdf.parse(dateStr).getTime()-24 * 3600 * 1000) &#123;
                date = new Date(lDate.get(4).getTime() - 7 * 24 * 3600 * 1000);
            &#125;else&#123;
                date = lDate.get(4);
            &#125;
        &#125; catch (ParseException e) &#123;
            e.printStackTrace();
        &#125;
        return sdf.format(date);
    &#125;
    /**
     * 
     * 方法说明：获取当前日期最近的星期五 Author： PengP Create Date： 2018年7月27日 上午10:06:37
     * 今天星期五就星期五
     * @param date
     *            日期 2018-7-27
     * @param format
     *            yyyy-MM-dd
     * @return
     * @throws ParseException
     */
    public static String getLastForWeek(String dateStr, String format)&#123;
        Date date = null;
        SimpleDateFormat sdf = new SimpleDateFormat(format);
        try&#123;
            String yzTime = getTimeInterval(sdf.parse(dateStr),format);// 获取选中日期本周时间区间
            String array[] = yzTime.split(&quot;,&quot;);
            String startTime = array[0];// 本周第一天
            String endTime = array[1]; // 本周最后一天
            // 格式化日期
            Date dBegin = sdf.parse(startTime);
            Date dEnd = sdf.parse(endTime);
            List&lt;Date&gt; lDate = findDates(dBegin, dEnd);// 获取这周所有date
            if (lDate.get(4).getTime() &gt; sdf.parse(dateStr).getTime()) &#123;
                date = new Date(lDate.get(4).getTime() - 7 * 24 * 3600 * 1000);
            &#125;else&#123;
                date = lDate.get(4);
            &#125;
        &#125; catch (ParseException e) &#123;
            e.printStackTrace();
        &#125;
        return sdf.format(date);
    &#125;
    /**
     * 
     * 方法说明：根据当前日期获得上个月月份  Author： HaoRanY Create Date： 2018年8月24日
     * 上午11:11:30
     * 
     * @param date
     * @return
     */
     public static String getLastMonthDate(Date dateParam) &#123;
         SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMM&quot;);
         Calendar c = Calendar.getInstance();
         c.setTime(dateParam);
         c.add(Calendar.MONTH, -1);
 
         return sdf.format(c.getTime());
     &#125;
     
    /**
     * 方法说明：根据当前日期获得上个月月份 
     * @author haokaih，2018年8月29日
     * @param dateParam date参数
     * @param format 以什么格式返回 如 &quot;yyyy-MM&quot;
     * @return 根据参数进行转化 如 &quot;2018-08&quot;
     */
    public static String getLastMonth(Date dateParam, String format) &#123;
        SimpleDateFormat sdf = new SimpleDateFormat(format);
        Calendar c = Calendar.getInstance();
        c.setTime(dateParam);
        c.add(Calendar.MONTH, -1);
        return sdf.format(c.getTime());
    &#125;

    /**
     * 
     * 方法说明：根据当前日期获得所在周的日期区间（周一和周日日期） Author： PengP Create Date： 2018年7月27日
     * 上午10:20:30
     * 
     * @param date
     * @return
     */
    public static String getTimeInterval(Date date,String format) &#123;
        SimpleDateFormat sdf = new SimpleDateFormat(format);
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        // 判断要计算的日期是否是周日，如果是则减一天计算周六的，否则会出问题，计算到下一周去了
        int dayWeek = cal.get(Calendar.DAY_OF_WEEK);// 获得当前日期是一个星期的第几天
        if (1 == dayWeek) &#123;
            cal.add(Calendar.DAY_OF_MONTH, -1);
        &#125;
        // System.out.println(&quot;要计算日期为:&quot; + sdf.format(cal.getTime())); // 输出要计算日期
        // 设置一个星期的第一天，按中国的习惯一个星期的第一天是星期一
        cal.setFirstDayOfWeek(Calendar.MONDAY);
        // 获得当前日期是一个星期的第几天
        int day = cal.get(Calendar.DAY_OF_WEEK);
        // 根据日历的规则，给当前日期减去星期几与一个星期第一天的差值
        cal.add(Calendar.DATE, cal.getFirstDayOfWeek() - day);
        String imptimeBegin = sdf.format(cal.getTime());
        // System.out.println(&quot;所在周星期一的日期：&quot; + imptimeBegin);
        cal.add(Calendar.DATE, 6);
        String imptimeEnd = sdf.format(cal.getTime());
        // System.out.println(&quot;所在周星期日的日期：&quot; + imptimeEnd);
        return imptimeBegin + &quot;,&quot; + imptimeEnd;
    &#125;
    public static String getLastForWeekForInit(String dateStr)&#123;
        return DateUtils.getLastForWeekForInit(dateStr, &quot;yyyy-MM-dd&quot;);
    &#125;
    public static String getLastForWeek(String dateStr)&#123;
        return DateUtils.getLastForWeek(dateStr, &quot;yyyy-MM-dd&quot;);
    &#125;
    /**
     * 
     * 方法说明：根据当前日期获得上周的日期区间（上周周一和周日日期） Author： PengP Create Date： 2018年7月27日
     * 上午10:20:13
     * 
     * @return
     */
    public static String getLastTimeInterval() &#123;
        SimpleDateFormat sdfDefault = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Calendar calendar1 = Calendar.getInstance();
        Calendar calendar2 = Calendar.getInstance();
        int dayOfWeek = calendar1.get(Calendar.DAY_OF_WEEK) - 1;
        int offset1 = 1 - dayOfWeek;
        int offset2 = 7 - dayOfWeek;
        calendar1.add(Calendar.DATE, offset1 - 7);
        calendar2.add(Calendar.DATE, offset2 - 7);
        // System.out.println(sdf.format(calendar1.getTime()));// last Monday
        String lastBeginDate = sdfDefault.format(calendar1.getTime());
        // System.out.println(sdf.format(calendar2.getTime()));// last Sunday
        String lastEndDate = sdfDefault.format(calendar2.getTime());
        return lastBeginDate + &quot;,&quot; + lastEndDate;
    &#125;

    /**
     * 
     * 方法说明：获取一周开始到结束的list集合 Author： PengP Create Date： 2018年7月27日 上午10:19:37
     * 
     * @param dBegin
     *            开始日期
     * @param dEnd
     *            结束日期
     * @return
     */
    public static List&lt;Date&gt; findDates(Date dBegin, Date dEnd) &#123;
        List&lt;Date&gt; lDate = new ArrayList&lt;Date&gt;();
        lDate.add(dBegin);
        Calendar calBegin = Calendar.getInstance();
        // 使用给定的 Date 设置此 Calendar 的时间
        calBegin.setTime(dBegin);
        Calendar calEnd = Calendar.getInstance();
        // 使用给定的 Date 设置此 Calendar 的时间
        calEnd.setTime(dEnd);
        // 测试此日期是否在指定日期之后
        while (dEnd.after(calBegin.getTime())) &#123;
            // 根据日历的规则，为给定的日历字段添加或减去指定的时间量
            calBegin.add(Calendar.DAY_OF_MONTH, 1);
            lDate.add(calBegin.getTime());
        &#125;
        return lDate;
    &#125;
    /**
     * 
     * 方法说明：根据格式获取日期字符串
     * Author： PengP               
     * Create Date： 2018年7月27日 上午11:34:57
     * @param Date
     * @param format
     * @return
     */
    public static String getStrDate(Date date,String format)&#123;
        return new SimpleDateFormat(format).format(date);
    &#125;
    /**
     * 
     * 方法说明：根据默认格式获取日期字符串
     * Author： PengP               
     * Create Date： 2018年7月27日 上午11:36:48
     * @param date
     * @return
     */
    public static String getStrDate(Date date)&#123;
        return getStrDate(date, &quot;yyyy-MM-dd&quot;);
    &#125;

    /**
     * 获取指定日期(不包括指定日期)的前指定数量周日期数据
     * 日期参数和格式参数要一致，返回的格式也是由格式参数决定
     * @param dateStr 20180727
     * @param period 指定周期数
     * @param formatter yyyyMMdd
     * @return
     */
    public static List&lt;String&gt; getDateStrList(String dateStr, int period, String formatter) &#123;
        List&lt;String&gt; dateStrs = new ArrayList&lt;String&gt;();
        try &#123;
            SimpleDateFormat dateFormat = new SimpleDateFormat(formatter);
            Calendar calendar = Calendar.getInstance();
            Date date = dateFormat.parse(dateStr);
            calendar.setTime(date);
            for (int i = 1; i &lt; period; i++) &#123;
                calendar.add(Calendar.WEEK_OF_MONTH, -1);
                dateStrs.add(dateFormat.format(calendar.getTime()));
            &#125;
        &#125; catch (ParseException e) &#123;
            e.printStackTrace();
        &#125;
        return dateStrs;
    &#125;
    
    /**
     * 
     * 方法说明：获取传入时间的最近十二个月
     * Author：lve               
     * Create Date： 2018年8月24日 上午9:06:50
     * @param time 支持 2018-01的时间字符串格式
     * @return
     */
    public static List&lt;String&gt; getLast12Months(String time)&#123;  
        //处理月份输入条件
        if(time.length()==7)&#123;
            time=time+&quot;-01 00:00:00&quot;;
        &#125;else if(time.length()==110)&#123;
            time=time.substring(0,7)+&quot;-01 00:00:00&quot;;
        &#125;
        Date date = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);  
        try &#123;
             date= sdf.parse(time);
        &#125; catch (ParseException e) &#123;
            return null;
        &#125; 
        
        Calendar cal = Calendar.getInstance();
        //设置输入条件时间
        cal.setTime(date);
        
        cal.set(Calendar.MONTH, cal.get(Calendar.MONTH)+1); //要先+1,才能把本月的算进去
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        for(int i=0; i&lt;11; i++)&#123; 
            cal.set(Calendar.MONTH, cal.get(Calendar.MONTH)-1); //逐次往前推1个月  
            list.add(cal.get(Calendar.YEAR)+ &quot;&quot; + addZeroForNum(String.valueOf(cal.get(Calendar.MONTH)+1), 2));  
        &#125;  
        return list;  
    &#125;  
    /**
     * 
     * 方法说明：时间格式补0
     * Author： lve               
     * Create Date： 2018年8月24日 上午9:08:53
     * @param str
     * @param strLength
     * @return
     */
    public static String addZeroForNum(String str, int strLength) &#123;  
        int strLen = str.length();  
        if (strLen &lt; strLength) &#123;  
            while (strLen &lt; strLength) &#123;  
                StringBuffer sb = new StringBuffer();  
                sb.append(&quot;0&quot;).append(str);// 左补0    
                str = sb.toString();  
                strLen = str.length();  
            &#125;  
        &#125;  
        return str;  
    &#125;  

    public static void main(String[] args) &#123;
        System.out.println(getLast12Months(&quot;2018-07&quot;));
    &#125;
    
&#125;
</code></pre>
<h2 id="五、oracle-SQL小技巧"><a href="#五、oracle-SQL小技巧" class="headerlink" title="五、oracle SQL小技巧"></a>五、oracle SQL小技巧</h2><h3 id="1、megre-into"><a href="#1、megre-into" class="headerlink" title="1、megre into"></a>1、megre into</h3><pre><code class="prettyprint">MERGE INTO table1 T1
        USING (SELECT  &#39;&#39; cloumn 
                 FROM DUAL) T2
        ON (T1.cloumn      = T2.cloumn)
        WHEN MATCHED THEN
          UPDATE
             SET T1.cloumn1      = T2.cloumn1
        WHEN NOT MATCHED THEN
        insert
          (cloumn1)
        values
          (T2.cloumn1)
</code></pre>
<h3 id="2、连续前几周连续的周日期数据-2019W14-2019W25"><a href="#2、连续前几周连续的周日期数据-2019W14-2019W25" class="headerlink" title="2、连续前几周连续的周日期数据(2019W14-2019W25)"></a>2、连续前几周连续的周日期数据(2019W14-2019W25)</h3><pre><code class="prettyprint">select to_char(t.statCycle, &#39;yyyyMMdd&#39;) statCycleDay,
       to_char(t.statCycle, &#39;yyyy&#39;) || &#39;W&#39; || to_char(t.statCycle, &#39;WW&#39;) statCycle
  from (select Rownum rn,
               (trunc(to_date(&#39;20190622&#39;, &#39;yyyyMMdd&#39;) + Rownum - 7 * 12,
                      &#39;dd&#39;)) statCycle
          from dual
        connect by rownum &lt;= 7 * 12) t
 where t.rn / 7 = cast(t.rn / 7 as int)
 order by t.rn
</code></pre>
<h3 id="3、获取前几天的天日期数据"><a href="#3、获取前几天的天日期数据" class="headerlink" title="3、获取前几天的天日期数据"></a>3、获取前几天的天日期数据</h3><pre><code class="prettyprint">select Rownum rn,
       to_char((trunc(to_date(&#39;20190622&#39;, &#39;yyyyMMdd&#39;) + Rownum - 12, &#39;dd&#39;)),
               &#39;yyyyMMdd&#39;) statCycle
  from dual
connect by rownum &lt;= 12
</code></pre>
<h3 id="4、获取前几个月的月日期数据"><a href="#4、获取前几个月的月日期数据" class="headerlink" title="4、获取前几个月的月日期数据"></a>4、获取前几个月的月日期数据</h3><pre><code class="prettyprint">select k.stat_cycle statCycle
  from (select t.stat_cycle, rownum rn
          from (select to_char(to_date(&#39;201906&#39;, &#39;yyyyMM&#39;), &#39;yyyy&#39;) - 1 ||
                       lpad(level, 2, 0) stat_cycle
                  from dual
                 start with level = 0
                connect by level &lt;= 12
                union all
                select to_char(to_date(&#39;201906&#39;, &#39;yyyyMM&#39;), &#39;yyyy&#39;) ||
                       lpad(level, 2, 0) stat_cycle
                  from dual
                connect by level &lt;=
                           to_char(to_date(&#39;201906&#39;, &#39;yyyyMM&#39;), &#39;MM&#39;)) t) k
 where k.rn &gt; to_char(to_date(&#39;201906&#39;, &#39;yyyyMM&#39;), &#39;MM&#39;)
</code></pre>
<h3 id="5、获取最近24小时数据"><a href="#5、获取最近24小时数据" class="headerlink" title="5、获取最近24小时数据"></a>5、获取最近24小时数据</h3><pre><code class="prettyprint">select Rownum, trunc(sysdate, &#39;hh&#39;) + rownum / 24 past24
  from dual
connect by rownum &lt;= 24
</code></pre>
<h3 id="6、字符串’aaa-bbb-ccc’转表数据’aaa’-’bbb’-’ccc’"><a href="#6、字符串’aaa-bbb-ccc’转表数据’aaa’-’bbb’-’ccc’" class="headerlink" title="6、字符串’aaa,bbb,ccc’转表数据’aaa’,’bbb’,’ccc’"></a>6、字符串’aaa,bbb,ccc’转表数据’aaa’,’bbb’,’ccc’</h3><pre><code class="prettyprint">select regexp_substr(&#39;aaa,bbb,ccc&#39;, &#39;[^,]+&#39;, 1, level)
  from dual
connect by level &lt;=
           length(&#39;aaa,bbb,ccc&#39;) - length(replace(&#39;aaa,bbb,ccc&#39;, &#39;,&#39;)) + 1
</code></pre>
<h3 id="7、Oracle中rank-over-dense-rank-row-number-的区别"><a href="#7、Oracle中rank-over-dense-rank-row-number-的区别" class="headerlink" title="7、Oracle中rank() over, dense_rank(), row_number() 的区别"></a>7、Oracle中rank() over, dense_rank(), row_number() 的区别</h3><pre><code class="prettyprint">--1. rank over ()可以实现对学生排名，特点是成绩相同的两名是并列，如下1 2 2 4 5
select name,
      course,
      rank() over(partition by course order by score desc) as rank
  from student;
--2. dense_rank()和rank over()很像，但学生成绩并列后并不会空出并列所占的名次，如下1 2 2 3 4
 
select name,
      course,
      dense_rank() over(partition by course order by score desc) as rank
  from student;
--3. row_number这个函数不需要考虑是否并列，那怕根据条件查询出来的数值相同也会进行连续排名
select name,
      course,
      row_number() over(partition by course order by score desc) as rank
  from student;
</code></pre>
<h3 id="8、group-by-与-partition-by-区别"><a href="#8、group-by-与-partition-by-区别" class="headerlink" title="8、group by 与 partition by 区别"></a>8、group by 与 partition by 区别</h3><pre><code class="prettyprint">1. partition by用于给结果集进行分区。
2. partition by和group by有何区别？
partition by只是将原始数据进行名次排列(记录数不变)
group by是对原始数据进行聚合统计(记录数可能变少, 每组返回一条)
3. 使用rank over()的时候，空值是最大的，如果排序字段为null, 可能造成null字段排在最前面，影响排序结果。
可以这样： rank over(partition by course order by score desc nulls last)
</code></pre>
<h3 id="9、DDL"><a href="#9、DDL" class="headerlink" title="9、DDL"></a>9、DDL</h3><pre><code class="prettyprint">--修改字段类型
ALTER TABLE ADDRESS MODIFY COLUMN CITY CHAR(30);
--修改字段长度
ALTER TABLE ADDRESS MODIFY COLUMN CITY VARCHAR(32);
--新增字段
ALTER TABLE ADDRESS ADD (CITY VARCHAR2(256));
-- 给字段添加注释
COMMENT ON COLUMN ADDRESS.CITY
  IS &#39;发帖人联系方式&#39;;
</code></pre>
<h3 id="10、plsq注册码"><a href="#10、plsq注册码" class="headerlink" title="10、plsq注册码"></a>10、plsq注册码</h3><p>​	Product Code：4t46t6vydkvsxekkvf3fjnpzy5wbuhphqz</p>
<p>​	serial Number：601769</p>
<p>​	password：xs374ca</p>
<h3 id="11、行转列"><a href="#11、行转列" class="headerlink" title="11、行转列"></a>11、行转列</h3><p>​	<em>LISTAGG</em>(BUY,’,’) WITHIN GROUP(ORDERBYBUYDESC)</p>
<h3 id="12、根据某一个字段排序获取序号"><a href="#12、根据某一个字段排序获取序号" class="headerlink" title="12、根据某一个字段排序获取序号"></a>12、根据某一个字段排序获取序号</h3><p>​	ROW_NUMBER() OVER(PARTITION BY A.org_no ORDER BY a.det_id DESC) rowflag</p>
<h3 id="13、根据某一个字段获取数量"><a href="#13、根据某一个字段获取数量" class="headerlink" title="13、根据某一个字段获取数量"></a>13、根据某一个字段获取数量</h3><p>​	count(*) over(partition by A.org_no) coutflag</p>
<h3 id="14、数据库赋权"><a href="#14、数据库赋权" class="headerlink" title="14、数据库赋权"></a>14、数据库赋权</h3><p>Grant select on iima_comm.table to iima_idx</p>
<h2 id="六、css"><a href="#六、css" class="headerlink" title="六、css"></a>六、css</h2><h3 id="1、google浏览器自动填充颜色"><a href="#1、google浏览器自动填充颜色" class="headerlink" title="1、google浏览器自动填充颜色"></a>1、google浏览器自动填充颜色</h3><pre><code class="prettyprint">input:-webkit-autofill &#123;
    -webkit-box-shadow: 0 0 0px 1000px #fff inset !important;
    -webkit-text-fill-color: rgba(255,255,255,1)!important;

&#125;
</code></pre>
<p>​		<a href="https://www.cnblogs.com/garfieldzhong/p/4759690.html">input:-webkit-autofill 导致chrome的输入框背景颜色变成黄色</a></p>
<h3 id="2、滚动条改造"><a href="#2、滚动条改造" class="headerlink" title="2、滚动条改造"></a>2、滚动条改造</h3><pre><code class="prettyprint">/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/
#table tbody::-webkit-scrollbar&#123;
    width: 16px;
    height: 16px;
    background-color: rgba(24, 13, 120, 1);
&#125;
/*定义滚动条轨道 内阴影+圆角*/
#table tbody::-webkit-scrollbar-track&#123;
    -webkit-box-shadow: inset 0 0 6px #8ab1ff;
    background-color: rgba(24, 13, 120, 1);
&#125;
/*定义滑块 内阴影+圆角*/
#table tbody::-webkit-scrollbar-thumb&#123;
    border-radius: 10px;
    -webkit-box-shadow: inset 0 0 6px #8ab1ff;
    background-color: rgba(95, 137, 220, 1);
&#125;
</code></pre>
<h3 id="3、select下拉框改造"><a href="#3、select下拉框改造" class="headerlink" title="3、select下拉框改造"></a>3、select下拉框改造</h3><pre><code class="prettyprint">#page select::-ms-expand&#123;display:none;&#125;
#page select&#123;
  appearance:none;
 -moz-appearance:none;
 -webkit-appearance:none;
&#125;
#page select &#123;
    appearance:none;
    -moz-appearance:none;
     -webkit-appearance:none;
    -webkit-appearance: menulist;
    box-sizing: border-box;
    align-items: center;
    white-space: pre;
    -webkit-rtl-ordering: logical;
    color: #8ab1ff;
    background-color: rgba(255, 255, 255, -0.6);
    cursor: default;
    border-width: 1px;
    border-style: solid;
    border-color: initial;
    border-image: initial;
    border-radius: 3px;
    height: 22px;
    width: 60px;
    font-size: 16px;
&#125;
#page option &#123;
    background-color: rgb(27,17,117);
&#125;
</code></pre>
<h2 id="七、mysql"><a href="#七、mysql" class="headerlink" title="七、mysql"></a>七、mysql</h2><h3 id="1、this-is-incompatible-with-sql-mode-x3D-only-full-group-by"><a href="#1、this-is-incompatible-with-sql-mode-x3D-only-full-group-by" class="headerlink" title="1、this is incompatible with sql_mode&#x3D;only_full_group_by"></a>1、this is incompatible with sql_mode&#x3D;only_full_group_by</h3><pre><code class="prettyprint">--  mysql 7、8问题
SELECT @@global.sql_mode  
--结果
&#39;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;
--修改方式
SET @@global.sql_mode = &#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;
</code></pre>
<h3 id="2、日期获取"><a href="#2、日期获取" class="headerlink" title="2、日期获取"></a>2、日期获取</h3><pre><code class="prettyprint">SELECT @num:=@num+1 num,DATE_FORMAT(ADDDATE(&#39;2018-06-10&#39;, INTERVAL @num DAY),&#39;%Y-%m-%d&#39;) AS DATE
FROM pt_code,(SELECT @num:=0) t WHERE ADDDATE(&#39;2018-06-10&#39;, INTERVAL @num DAY) &lt;= DATE_FORMAT(CURDATE(),&#39;%Y-%m-%d&#39;)
LIMIT 0,30
</code></pre>
<h3 id="3、转化成数字排序"><a href="#3、转化成数字排序" class="headerlink" title="3、转化成数字排序"></a>3、转化成数字排序</h3><pre><code class="prettyprint">ORDER BY CAST(DATA1 AS SIGNED)
</code></pre>
<h3 id="4、CSV文件导入数据"><a href="#4、CSV文件导入数据" class="headerlink" title="4、CSV文件导入数据"></a>4、CSV文件导入数据</h3><pre><code class="prettyprint">LOAD DATA LOCAL INFILE 
    &#39;C:\\Users\\Administrator\\Desktop\\AAA.csv&#39;
    INTO TABLE `blog`.`k_lrp`
FIELDS ESCAPED BY &#39;\\&#39;  
TERMINATED BY &#39;,&#39;   
ENCLOSED BY &#39;&quot;&#39;  
LINES TERMINATED BY   &#39;\r\n&#39;  
(`LRP_ID`, `ORG_NO`, `YM`, `X_VALUE`, `DATA_OPER_TIME`, `DATA_OPER_TYPE`,`Y_VAULE`)
</code></pre>
<h3 id="5、前2个月"><a href="#5、前2个月" class="headerlink" title="5、前2个月"></a>5、前2个月</h3><pre><code class="prettyprint">SELECT 
  DATE_FORMAT(
    DATE_ADD(
      STR_TO_DATE(CONCAT(&#39;20201210&#39;, &#39;01&#39;), &#39;%Y%m%d&#39;),
      INTERVAL (1 - CAST(k.rn AS SIGNED INTEGER)) MONTH
    ),
    &#39;%Y%m&#39;
  ) stat_cycle 
FROM
  (SELECT 
    @rn := @rn + 1 rn 
  FROM
    pt_code g,
    (SELECT 
      @rn := 0) f 
  LIMIT 0, 31) k 
WHERE k.rn &lt;= 12 
</code></pre>
<h3 id="6、前30天数据"><a href="#6、前30天数据" class="headerlink" title="6、前30天数据"></a>6、前30天数据</h3><pre><code class="prettyprint">--不包含当天
SELECT @num:=@num+1 num,DATE_FORMAT(ADDDATE(&#39;20201210&#39;, INTERVAL -@num DAY),&#39;%Y%m%d&#39;) AS stat_cycle
FROM pt_code,(SELECT @num:=0) t
LIMIT 0,30
--包含当天
SELECT @num:=@num+1 num,DATE_FORMAT(ADDDATE(&#39;20201210&#39;, INTERVAL 1-@num DAY),&#39;%Y%m%d&#39;) AS stat_cycle
FROM pt_code,(SELECT @num:=0) t
LIMIT 0,30
</code></pre>
<h2 id="八、nginx"><a href="#八、nginx" class="headerlink" title="八、nginx"></a>八、nginx</h2><h3 id="1、win启动"><a href="#1、win启动" class="headerlink" title="1、win启动"></a>1、win启动</h3><p>cmd进入nginx根目录执行   <code>nginx -t -c conf\nginx.conf</code></p>
<p>重启：nginx -s reload</p>
<p>启动：start nginx</p>
<p>停止：nginx -s stop</p>
<h3 id="2、简单配置"><a href="#2、简单配置" class="headerlink" title="2、简单配置"></a>2、简单配置</h3><pre><code class="prettyprint.conf"> server &#123;
        listen       8088;
        server_name  172.19.3.229;
        location /http-bind&#123;
            #重定向openfire请求
            proxy_pass http://172.19.3.229:17070/http-bind;
            proxy_buffering off;
            proxy_redirect off;
            proxy_read_timeout 120;
            proxy_connect_timeout 600;
        &#125;
        error_page   500 502 503 504  /50x.html;
        location = /50x.html &#123;
            root   html;
        &#125;
    &#125;
</code></pre>
<h2 id="九、javascript"><a href="#九、javascript" class="headerlink" title="九、javascript"></a>九、javascript</h2><h3 id="1、变化title"><a href="#1、变化title" class="headerlink" title="1、变化title"></a>1、变化title</h3><pre><code class="prettyprint">document.addEventListener(&#39;visibilitychange&#39;,function()&#123;
    if(document.visibilityState==&#39;hidden&#39;)&#123;
        normal_title=document.title;
        document.title=&#39;来啊.快活啊&#39;;
    &#125;else&#123;
        document.title=normal_title;
    &#125;
&#125;);
</code></pre>
<h3 id="3、js实现模态框拖拽"><a href="#3、js实现模态框拖拽" class="headerlink" title="3、js实现模态框拖拽"></a>3、js实现模态框拖拽</h3><pre><code class="prettyprint">//拖拽功能(主要是触发三个事件：onmousedown\onmousemove\onmouseup) 
var drag = document.getElementById(&#39;drag&#39;);
//点击某物体时，用drag对象即可，move和up是全局区域，也就是整个文档通用，应该使用document对象而不是drag对象(否则，采用drag对象时物体只能往右方或下方移动) 
drag.onmousedown = function(e) &#123;
    var e = e || window.event; //兼容ie浏览器 
    var diffX = e.clientX - drag.offsetLeft; //鼠标点击物体那一刻相对于物体左侧边框的距离=点击时的位置相对于浏览器最左边的距离-物体左边框相对于浏览器最左边的距离 
    var diffY = e.clientY - drag.offsetTop;
    /*低版本ie bug:物体被拖出浏览器可是窗口外部时，还会出现滚动条， 
              解决方法是采用ie浏览器独有的2个方法setCapture()\releaseCapture(),这两个方法， 
              可以让鼠标滑动到浏览器外部也可以捕获到事件，而我们的bug就是当鼠标移出浏览器的时候， 
              限制超过的功能就失效了。用这个方法，即可解决这个问题。注：这两个方法用于onmousedown和onmouseup中*/
    if(typeof drag.setCapture != &#39;undefined&#39;) &#123;
        drag.setCapture();
    &#125;
    document.onmousemove = function(e) &#123;
        var e = e || window.event; //兼容ie浏览器 
        var left = e.clientX - diffX;
        var top = e.clientY - diffY;
        //控制拖拽物体的范围只能在浏览器视窗内，不允许出现滚动条 
        if(left &lt; 0) &#123;
            left = 0;
        &#125; else if(left &gt; window.innerWidth - drag.offsetWidth) &#123;
            left = window.innerWidth - drag.offsetWidth;
        &#125;
        if(top &lt; 0) &#123;
            top = 0;
        &#125; else if(top &gt; window.innerHeight - drag.offsetHeight) &#123;
            top = window.innerHeight - drag.offsetHeight;
        &#125;
        //移动时重新得到物体的距离，解决拖动时出现晃动的现象 
        drag.style.left = left + &#39;px&#39;;
        drag.style.top = top + &#39;px&#39;;
    &#125;;
    document.onmouseup = function(e) &#123; //当鼠标弹起来的时候不再移动 
        this.onmousemove = null;
        this.onmouseup = null; //预防鼠标弹起来后还会循环（即预防鼠标放上去的时候还会移动） 
        //修复低版本ie bug 
        if(typeof drag.releaseCapture != &#39;undefined&#39;) &#123;
            drag.releaseCapture();
        &#125;
    &#125;;
&#125;;
</code></pre>
<h3 id="3、字符转义"><a href="#3、字符转义" class="headerlink" title="3、字符转义"></a>3、字符转义</h3><pre><code class="prettyprint">var HtmlUtil = &#123;
    /*1.用浏览器内部转换器实现html转码*/
    htmlEncode:function (html)&#123;
        //1.首先动态创建一个容器标签元素，如DIV
        var temp = document.createElement (&quot;div&quot;);
        //2.然后将要转换的字符串设置为这个元素的innerText(ie支持)或者textContent(火狐，google支持)
        (temp.textContent != undefined ) ? (temp.textContent = html) : (temp.innerText = html);
        //3.最后返回这个元素的innerHTML，即得到经过HTML编码转换的字符串了
        var output = temp.innerHTML;
        temp = null;
        return output;
    &#125;,
    /*2.用浏览器内部转换器实现html解码*/
    htmlDecode:function (text)&#123;
        //1.首先动态创建一个容器标签元素，如DIV
        var temp = document.createElement(&quot;div&quot;);
        //2.然后将要转换的字符串设置为这个元素的innerHTML(ie，火狐，google都支持)
        temp.innerHTML = text;
        //3.最后返回这个元素的innerText(ie支持)或者textContent(火狐，google支持)，即得到经过HTML解码的字符串了。
        var output = temp.innerText || temp.textContent;
        temp = null;
        return output;
    &#125;,
    /*3.用正则表达式实现html转码*/
    htmlEncodeByRegExp:function (str)&#123;  
        var s = &quot;&quot;;
        if(str.length == 0) return &quot;&quot;;
        s = str.replace(/&amp;/g,&quot;&amp;amp;&quot;);
        s = s.replace(/&lt;/g,&quot;&amp;lt;&quot;);
        s = s.replace(/&gt;/g,&quot;&amp;gt;&quot;);
        s = s.replace(/ /g,&quot;&amp;nbsp;&quot;);
        s = s.replace(/\&#39;/g,&quot;&amp;#39;&quot;);
        s = s.replace(/\&quot;/g,&quot;&amp;quot;&quot;);
        return s;  
    &#125;,
    /*4.用正则表达式实现html解码*/
    htmlDecodeByRegExp:function (str)&#123;  
        var s = &quot;&quot;;
        if(str.length == 0) return &quot;&quot;;
        s = str.replace(/&amp;amp;/g,&quot;&amp;&quot;);
        s = s.replace(/&amp;lt;/g,&quot;&lt;&quot;);
        s = s.replace(/&amp;gt;/g,&quot;&gt;&quot;);
        s = s.replace(/&amp;nbsp;/g,&quot; &quot;);
        s = s.replace(/&amp;#39;/g,&quot;\&#39;&quot;);
        s = s.replace(/&amp;quot;/g,&quot;\&quot;&quot;);
        return s;  
    &#125;
&#125;;
</code></pre>
<h3 id="4、js关闭页面"><a href="#4、js关闭页面" class="headerlink" title="4、js关闭页面"></a>4、js关闭页面</h3><pre><code class="prettyprint">function CloseWebPage() &#123;
    if (navigator.userAgent.indexOf(&quot;MSIE&quot;) &gt; 0) &#123;
        if (navigator.userAgent.indexOf(&quot;MSIE 6.0&quot;) &gt; 0) &#123;
            window.opener = null;
            window.close();
        &#125; else &#123;
            window.open(&#39; &#39;, &#39;_top&#39;);
            window.top.close();
        &#125;
    &#125; else if (navigator.userAgent.indexOf(&quot;Firefox&quot;) &gt; 0) &#123;
        window.opener = null;
        window.open(&#39; &#39;, &#39;_top&#39;);
        window.close();
    &#125; else if (navigator.userAgent.indexOf(&quot;Chrome&quot;) &gt; 0) &#123;
        window.opener = null;
        window.open(&#39; &#39;, &#39;_self&#39;);
        window.close();
    &#125; else &#123;
        window.opener = null;
        window.open(&#39; &#39;, &#39;_self&#39;);
        window.close();
    &#125;
&#125;
</code></pre>
<h3 id="5、div滚动播放"><a href="#5、div滚动播放" class="headerlink" title="5、div滚动播放"></a>5、div滚动播放</h3><pre><code class="prettyprint">&lt;div class=&quot;scroll-div&quot;&gt;
    &lt;ul&gt;
        &lt;li&gt;
            aaaa
        &lt;/li&gt;
        &lt;li&gt;
            bbb
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="prettyprint">/*滚动js*/
$(&#39;.scroll-div li:even&#39;).addClass(&#39;lieven&#39;);

$(&quot;div.scroll-div&quot;).myScroll(&#123;
    speed:13, //数值越大，速度越慢
    rowHeight:270 //li的高度
&#125;);
$.fn.myScroll = function(options)&#123;
        //默认配置
        var defaults = &#123;
            speed:40,  //滚动速度,值越大速度越慢
            rowHeight:24 //每行的高度
        &#125;;
        var opts = $.extend(&#123;&#125;, defaults, options),intId = [];
        this.each(function(i)&#123;
            var sh = opts[&quot;rowHeight&quot;];
            var speed = opts[&quot;speed&quot;];
            var _this = $(this);
            intId[i] = setInterval(function()&#123;
                marquee(_this, sh);
            &#125;, speed);

            _this.hover(function()&#123;
                clearInterval(intId[i]);
            &#125;,function()&#123;
                intId[i] = setInterval(function()&#123;
                    marquee(_this, sh);
                &#125;, speed);
            &#125;);
        
        &#125;);
        //滚动效果
        function marquee(obj, step)&#123;
            obj.find(&quot;ul&quot;).animate(&#123;
                marginTop: &#39;-=1&#39;
            &#125;,0,function()&#123;
                var s = Math.abs(parseInt($(this).css(&quot;margin-top&quot;)));
                if(s &gt;= step)&#123;
                    $(this).find(&quot;li&quot;).slice(0, 1).appendTo($(this));
                    $(this).css(&quot;margin-top&quot;, 0);
                &#125;
            &#125;);
        &#125;
    &#125;
&#125;)(jQuery);
</code></pre>
<pre><code class="prettyprint">.scroll-div&#123;
    overflow:hidden;
    font-size:13px; 
    margin-top: 12px;
    height: 268px;
&#125;
.scroll-div ul,
.scroll-div ul li&#123;
    height: 273px;
    width: 100%;
&#125;
</code></pre>
<h2 id="十、redis"><a href="#十、redis" class="headerlink" title="十、redis"></a>十、redis</h2><h3 id="1、查看连接数"><a href="#1、查看连接数" class="headerlink" title="1、查看连接数"></a>1、查看连接数</h3><p>​	netstat -an|grep 6379|wc -l</p>
<h2 id="十一、正则表达式"><a href="#十一、正则表达式" class="headerlink" title="十一、正则表达式"></a>十一、正则表达式</h2><h3 id="1、阶段替换"><a href="#1、阶段替换" class="headerlink" title="1、阶段替换"></a>1、阶段替换</h3><pre><code class="prettyprint">String sql = &quot;select * from a where a.no = #&#123;no,jdbcType=VARCHAR&#125; and a.name = #&#123;name,jdbcType=VARCHAR&#125;&quot;;
sql.replaceAll(&quot;\\#\\&#123;.+?\\&#125;&quot;,&quot;?&quot;); 
//sql = select * from a where a.no = ? and a.name = ? 
</code></pre>
<h2 id="十二、cron范例"><a href="#十二、cron范例" class="headerlink" title="十二、cron范例"></a>十二、cron范例</h2><pre><code>每隔5秒执行一次：*/5 * * * * ?

每隔1分钟执行一次：0 */1 * * * ?

每天23点执行一次：0 0 23 * * ?

每天凌晨1点执行一次：0 0 1 * * ?

每月1号凌晨1点执行一次：0 0 1 1 * ?

每月最后一天23点执行一次：0 0 23 L * ?

每周星期天凌晨1点实行一次：0 0 1 ? * L

在26分、29分、33分执行一次：0 26,29,33 * * * ?

每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?
</code></pre>
]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
  </entry>
  <entry>
    <title>浅谈领域驱动和MVC模式在应用开发上的区别</title>
    <url>/2021/10/09/qian-tan-ling-yu-qu-dong-he-mvc-mo-shi-zai-ying-yong-kai-fa-shang-de-qu-bie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>概述<br>MVC：在传统B&#x2F;S开发模式下几乎都是使用MVC架构模式，MVC把javaweb开发分为三个模块，模型（Model）、视图（View）和控制器（Controller）<br>DDD(领域驱动)：在分布式微服务项目开发中，软件应用开发发不可能是一步到位，在业务开发之前需要大量的知识梳理，然后进行设计，其后才是开发。然而在收集材料，知识整理过程中，肯定会形成摸个领域知识，而后根据领域知识驱动软件设计，这就是DDD（Domain-Driven Design 领域驱动设计）的基本概念</li>
<li>开发</li>
</ul>
<p>MVC:</p>
<ol>
<li><p>模型<code>Model</code>：<br>Model制定业务逻辑，处理需求核心功能并且反馈处理后数据结果。<br>Model层返回的数据根据需求的不同有不同的可能，这样一个Model能为多个View提供数据。由于应用于Model的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。 </p>
</li>
<li><p>视图<code>View</code>：<br>View是用户看到并与之交互的界面，负责处理界面的变化。<br>MVC一个大的好处是它能为你的应用程序处理很多不同的视图。在View中其实没有真正的处理发生业务，作为视图来讲，它只是作为一种输出数据并允许用户操纵的方式。 </p>
</li>
<li><p>控制器<code>Controller</code>：<br>Controller接受用户的输入并调用Model和View去完成用户的需求。<br>Controller本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个Model构件去处理请求，然后用确定用哪个View来显示Model处理返回的数据。</p>
</li>
</ol>
<p>DDD：</p>
<ol>
<li><p>应用层<code>application</code><br> 应用服务位于应用层。用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装。<br>应用层的服务包括应用服务和领域事件相关服务。<br>应用服务可对微服务内的领域服务以及微服务外的应用服务进行组合和编排，或者对基础层如文件、缓存等数据直接操作形成应用服务，对外提供粗粒度的服务。<br>领域事件服务包括两类：领域事件的发布和订阅。通过事件总线和消息队列实现异步数据传输，实现微服务之间的解耦。</p>
</li>
<li><p>领域层<code>domain</code><br> 领域服务位于领域层，为完成领域中跨实体或值对象的操作转换而封装的服务，领域服务以与实体和值对象相同的方式参与实施过程。<br>领域服务对同一个实体的一个或多个方法进行组合和封装，或对多个不同实体的操作进行组合或编排，对外暴露成领域服务。领域服务封装了核心的业务逻辑。实体自身的行为在实体类内部实现，向上封装成领域服务暴露。<br>为隐藏领域层的业务逻辑实现，所有领域方法和服务等均须通过领域服务对外暴露。<br>为实现微服务内聚合之间的解耦，原则上禁止跨聚合的领域服务调用和跨聚合的数据相互关联。</p>
</li>
<li><p>基础层<code>infrastructrue</code><br> 基础服务位于基础层。为各层提供资源服务（如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务逻辑的影响。<br>基础服务主要为仓储服务，通过依赖反转的方式为各层提供基础资源服务，领域服务和应用服务调用仓储服务接口，利用仓储实现持久化数据对象或直接访问基础资源。</p>
</li>
<li><p>接口层<code>interfaces</code><br> 接口服务位于用户接口层，用于处理用户发送的Restful请求和解析用户输入的配置文件等，并将信息传递给应用层。<br><img src="/upload/2021/10/QQ%E5%9B%BE%E7%89%8720211011143247-f34e856e0c2b458fad315349343cb5d9.png" alt="QQ图片20211011143247.png"></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>若依学习-验证码</title>
    <url>/2021/08/31/ruo-yi-xue-xi-yan-zheng-ma/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h3><pre><code class="prettyprint">&lt;properties&gt;
    &lt;anji-plus.version&gt;1.2.4&lt;/anji-plus.version&gt;
&lt;/properties&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.github.anji-plus&lt;/groupId&gt;
    &lt;artifactId&gt;captcha-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;$&#123;anji-plus.version&#125;&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>在captcha-spring-boot-starter-1.2.4.jar下面有两个接口用于获取验证码和校验验证码<br><code>/captcha/get</code><br><code>/captcha/check</code><br><code>/captcha/verify</code></p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="vue校验使用路径prettyprint-components-verifition"><a href="#vue校验使用路径prettyprint-components-verifition" class="headerlink" title="vue校验使用路径prettyprint/components/verifition"></a>vue校验使用路径<code>prettyprint/components/verifition</code></h3><p><code>Verify.vue</code> 是主页面，<br>  <code>Verify/VerifySlide.vue</code> 滑动验证码	<br>  <code>Verify/VerifyPoints.vue</code> 点击文字验证码	</p>
<p><a href="https://captcha.anji-plus.com/#/" title="https://captcha.anji-plus.com/#/">AJ-Captcha在线体验</a>  <a href="https://captcha.anji-plus.com/#/">https://captcha.anji-plus.com/#/</a></p>
]]></content>
      <categories>
        <category>若依</category>
      </categories>
  </entry>
  <entry>
    <title>解决mapper.xml不在resources下面无法编译的问题</title>
    <url>/2021/11/11/jie-jue-mapper-xml-bu-zai-resources-xia-mian-wu-fa-bian-yi-de-wen-ti/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在pom.xml增加<code>&lt;build&gt;</code>配置</p>
<pre><code class="prettyprint">&lt;!-- 构建配置 --&gt;
    &lt;build&gt;
        &lt;!-- 配置资源目录, 主要解决idea无法将代码中的mapper.xml编译的问题  --&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/java&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
            &lt;/resource&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/resources&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.*&lt;/include&gt;
                &lt;/includes&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
    &lt;/build&gt;
</code></pre>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
  </entry>
  <entry>
    <title>记一次dubbo获取服务接口问题</title>
    <url>/2022/03/30/ji-yi-ci-dubbo-huo-qu-fu-wu-jie-kou-wen-ti/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li>新版本程序使用旧版本zk导致，服务存在但是新增接口方法不存在</li>
<li>清理zk数据，未重启服务导致所有服务不存在</li>
<li>重启服务解决问题<br>ps:zk如果宕机会取本地缓存，但是没有宕机，服务数据不存在就会找不到对应的服务及接口</li>
</ol>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
  </entry>
  <entry>
    <title>阿里云服务器安装Docker</title>
    <url>/2021/10/16/a-li-yun-fu-wu-qi-an-zhuang-docker/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在阿里云服务器上安装Docker，服务器的系统是CentOS 7.6，</p>
<p>所以可以看官方Docker安装文档：<a href="https://docs.docker.com/install/linux/docker-ce/centos/">https://docs.docker.com/install/linux/docker-ce/centos/</a></p>
<p>从阅读官网来看，首先若是没有较旧的Docker版本只需3步就可以完成Dockers的安装；但是有旧版本的话，需要先卸载旧版本</p>
<pre><code class="prettyprint">yum remove docker \
              docker-client \
              docker-client-latest \
              docker-common \
              docker-latest \
              docker-latest-logrotate \
              docker-logrotate \
              docker-engine
</code></pre>
<p>无旧版本时(3步)</p>
<p>1.安装所需的软件包</p>
<pre><code class="prettyprint">yum install -y yum-utils \
  device-mapper-persistent-data \
  lvm2
</code></pre>
<p>2.配置阿里云Docker Yum源(个人觉的好)</p>
<pre><code class="prettyprint">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre>
<p>3.安装最新版本的Docker</p>
<pre><code class="prettyprint">yum install docker-ce docker-ce-cli containerd.io
</code></pre>
<p>这样之后就OK了，执行启动Docker的命令：systemctl start docker，然后走一波，完美！！</p>
<p>注，重要的事情说三遍。大多数人的执行完第二步后，会出现以下错误 <code>Loaded plugins: fastestmirror</code><br>解决方法如下：<br>1、</p>
<pre><code class="prettyprint">vi  /etc/yum/pluginconf.d/fastestmirror.conf
</code></pre>
<pre><code class="prettyprint">enabled=0    //由 1 改成0 ，禁用该插件
verbose=0
always_print_best_host = true
socket_timeout=3
#  Relative paths are relative to the cachedir (and so works for users as well
# as root).
hostfilepath=timedhosts.txt
maxhostfileage=10
maxthreads=15
#exclude=.gov, facebook
#include_only=.nl,.de,.uk,.ie
</code></pre>
<p>2、</p>
<pre><code class="prettyprint">vi /etc/yum.conf
</code></pre>
<pre><code class="prettyprint">[main]
cachedir=/var/cache/yum/$basearch/$releasever
keepcache=0
debuglevel=2
logfile=/var/log/yum.log
exactarch=1
obsoletes=1
gpgcheck=1
plugins=1 #将plugins的值修改为0
installonly_limit=5
</code></pre>
<p>3、</p>
<pre><code class="prettyprint">yum clean dbcache
</code></pre>
<p>之后重新执行配置源和安装命令即可。</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>防火墙命令</title>
    <url>/2021/11/13/fang-huo-qiang-ming-ling/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>查看防火墙状态：firewall-cmd –state<br>查看防火墙：firewall-cmd –list-all<br>更新防火墙：firewall-cmd  –reload<br>临时增加 (reload之后消失)：不需要reload<br>firewall-cmd –add-port&#x3D;999&#x2F;tcp<br>永久增加 ：reload后生效<br>firewall-cmd  –permanent –add-port&#x3D;999&#x2F;tcp<br>firewall-cmd  –reload<br>移除端口<br>firewall-cmd –remove-port&#x3D;999&#x2F;tcp</p>
<p>firewall-cmd  –permanent –remove-port&#x3D;999&#x2F;tcp<br>firewall-cmd  –reload<br>查询端口<br>firewall-cmd –query-port&#x3D;999&#x2F;tcp<br>查看所有放行端口<br>firewall-cmd –list-ports<br>防火墙服务的状态：<br>systemctl status firewalld.service<br>systemctl start firewalld.service<br>systemctl stop firewalld.service<br>所有支持的服务<br>firewall-cmd –get-services<br>临时增加服务<br>firewall-cmd –add-service&#x3D;http<br>删除服务： (临时删除)<br>firewall-cmd –remove-service&#x3D;http<br>查询服务：<br>firewall-cmd –query-service&#x3D;http</p>
<pre><code class="prettyprint">Usage: firewall-cmd [OPTIONS...]

General Options
  -h, --help           Prints a short help text and exists
  -V, --version        Print the version string of firewalld
  -q, --quiet          Do not print status messages

Status Options
  --state              Return and print firewalld state
  --reload             Reload firewall and keep state information
  --complete-reload    Reload firewall and lose state information
  --runtime-to-permanent
                       Create permanent from runtime configuration

Log Denied Options
  --get-log-denied     Print the log denied value
  --set-log-denied=&lt;value&gt;
                       Set log denied value

Automatic Helpers Options
  --get-automatic-helpers
                       Print the automatic helpers value
  --set-automatic-helpers=&lt;value&gt;
                       Set automatic helpers value

Permanent Options
  --permanent          Set an option permanently
                       Usable for options marked with [P]

Zone Options
  --get-default-zone   Print default zone for connections and interfaces
  --set-default-zone=&lt;zone&gt;
                       Set default zone
  --get-active-zones   Print currently active zones
  --get-zones          Print predefined zones [P]
  --get-services       Print predefined services [P]
  --get-icmptypes      Print predefined icmptypes [P]
  --get-zone-of-interface=&lt;interface&gt;
                       Print name of the zone the interface is bound to [P]
  --get-zone-of-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;
                       Print name of the zone the source is bound to [P]
  --list-all-zones     List everything added for or enabled in all zones [P]
  --new-zone=&lt;zone&gt;    Add a new zone [P only]
  --new-zone-from-file=&lt;filename&gt; [--name=&lt;zone&gt;]
                       Add a new zone from file with optional name [P only]
  --delete-zone=&lt;zone&gt; Delete an existing zone [P only]
  --load-zone-defaults=&lt;zone&gt;
                       Load zone default settings [P only] [Z]
  --zone=&lt;zone&gt;        Use this zone to set or query options, else default zone
                       Usable for options marked with [Z]
  --get-target         Get the zone target [P only] [Z]
  --set-target=&lt;target&gt;
                       Set the zone target [P only] [Z]
  --info-zone=&lt;zone&gt;   Print information about a zone
  --path-zone=&lt;zone&gt;   Print file path of a zone [P only]

IPSet Options
  --get-ipset-types    Print the supported ipset types
  --new-ipset=&lt;ipset&gt; --type=&lt;ipset type&gt; [--option=&lt;key&gt;[=&lt;value&gt;]]..
                       Add a new ipset [P only]
  --new-ipset-from-file=&lt;filename&gt; [--name=&lt;ipset&gt;]
                       Add a new ipset from file with optional name [P only]
  --delete-ipset=&lt;ipset&gt;
                       Delete an existing ipset [P only]
  --load-ipset-defaults=&lt;ipset&gt;
                       Load ipset default settings [P only]
  --info-ipset=&lt;ipset&gt; Print information about an ipset
  --path-ipset=&lt;ipset&gt; Print file path of an ipset [P only]
  --get-ipsets         Print predefined ipsets
  --ipset=&lt;ipset&gt; --set-description=&lt;description&gt;
                       Set new description to ipset [P only]
  --ipset=&lt;ipset&gt; --get-description
                       Print description for ipset [P only]
  --ipset=&lt;ipset&gt; --set-short=&lt;description&gt;
                       Set new short description to ipset [P only]
  --ipset=&lt;ipset&gt; --get-short
                       Print short description for ipset [P only]
  --ipset=&lt;ipset&gt; --add-entry=&lt;entry&gt;
                       Add a new entry to an ipset [P]
  --ipset=&lt;ipset&gt; --remove-entry=&lt;entry&gt;
                       Remove an entry from an ipset [P]
  --ipset=&lt;ipset&gt; --query-entry=&lt;entry&gt;
                       Return whether ipset has an entry [P]
  --ipset=&lt;ipset&gt; --get-entries
                       List entries of an ipset [P]
  --ipset=&lt;ipset&gt; --add-entries-from-file=&lt;entry&gt;
                       Add a new entries to an ipset [P]
  --ipset=&lt;ipset&gt; --remove-entries-from-file=&lt;entry&gt;
                       Remove entries from an ipset [P]

IcmpType Options
  --new-icmptype=&lt;icmptype&gt;
                       Add a new icmptype [P only]
  --new-icmptype-from-file=&lt;filename&gt; [--name=&lt;icmptype&gt;]
                       Add a new icmptype from file with optional name [P only]
  --delete-icmptype=&lt;icmptype&gt;
                       Delete an existing icmptype [P only]
  --load-icmptype-defaults=&lt;icmptype&gt;
                       Load icmptype default settings [P only]
  --info-icmptype=&lt;icmptype&gt;
                       Print information about an icmptype
  --path-icmptype=&lt;icmptype&gt;
                       Print file path of an icmptype [P only]
  --icmptype=&lt;icmptype&gt; --set-description=&lt;description&gt;
                       Set new description to icmptype [P only]
  --icmptype=&lt;icmptype&gt; --get-description
                       Print description for icmptype [P only]
  --icmptype=&lt;icmptype&gt; --set-short=&lt;description&gt;
                       Set new short description to icmptype [P only]
  --icmptype=&lt;icmptype&gt; --get-short
                       Print short description for icmptype [P only]
  --icmptype=&lt;icmptype&gt; --add-destination=&lt;ipv&gt;
                       Enable destination for ipv in icmptype [P only]
  --icmptype=&lt;icmptype&gt; --remove-destination=&lt;ipv&gt;
                       Disable destination for ipv in icmptype [P only]
  --icmptype=&lt;icmptype&gt; --query-destination=&lt;ipv&gt;
                       Return whether destination ipv is enabled in icmptype [P only]
  --icmptype=&lt;icmptype&gt; --get-destinations
                       List destinations in icmptype [P only]

Service Options
  --new-service=&lt;service&gt;
                       Add a new service [P only]
  --new-service-from-file=&lt;filename&gt; [--name=&lt;service&gt;]
                       Add a new service from file with optional name [P only]
  --delete-service=&lt;service&gt;
                       Delete an existing service [P only]
  --load-service-defaults=&lt;service&gt;
                       Load icmptype default settings [P only]
  --info-service=&lt;service&gt;
                       Print information about a service
  --path-service=&lt;service&gt;
                       Print file path of a service [P only]
  --service=&lt;service&gt; --set-description=&lt;description&gt;
                       Set new description to service [P only]
  --service=&lt;service&gt; --get-description
                       Print description for service [P only]
  --service=&lt;service&gt; --set-short=&lt;description&gt;
                       Set new short description to service [P only]
  --service=&lt;service&gt; --get-short
                       Print short description for service [P only]
  --service=&lt;service&gt; --add-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Add a new port to service [P only]
  --service=&lt;service&gt; --remove-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Remove a port from service [P only]
  --service=&lt;service&gt; --query-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Return whether the port has been added for service [P only]
  --service=&lt;service&gt; --get-ports
                       List ports of service [P only]
  --service=&lt;service&gt; --add-protocol=&lt;protocol&gt;
                       Add a new protocol to service [P only]
  --service=&lt;service&gt; --remove-protocol=&lt;protocol&gt;
                       Remove a protocol from service [P only]
  --service=&lt;service&gt; --query-protocol=&lt;protocol&gt;
                       Return whether the protocol has been added for service [P only]
  --service=&lt;service&gt; --get-protocols
                       List protocols of service [P only]
  --service=&lt;service&gt; --add-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Add a new source port to service [P only]
  --service=&lt;service&gt; --remove-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Remove a source port from service [P only]
  --service=&lt;service&gt; --query-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Return whether the source port has been added for service [P only]
  --service=&lt;service&gt; --get-source-ports
                       List source ports of service [P only]
  --service=&lt;service&gt; --add-module=&lt;module&gt;
                       Add a new module to service [P only]
  --service=&lt;service&gt; --remove-module=&lt;module&gt;
                       Remove a module from service [P only]
  --service=&lt;service&gt; --query-module=&lt;module&gt;
                       Return whether the module has been added for service [P only]
  --service=&lt;service&gt; --get-modules
                       List modules of service [P only]
  --service=&lt;service&gt; --set-destination=&lt;ipv&gt;:&lt;address&gt;[/&lt;mask&gt;]
                       Set destination for ipv to address in service [P only]
  --service=&lt;service&gt; --remove-destination=&lt;ipv&gt;
                       Disable destination for ipv i service [P only]
  --service=&lt;service&gt; --query-destination=&lt;ipv&gt;:&lt;address&gt;[/&lt;mask&gt;]
                       Return whether destination ipv is set for service [P only]
  --service=&lt;service&gt; --get-destinations
                       List destinations in service [P only]

Options to Adapt and Query Zones
  --list-all           List everything added for or enabled in a zone [P] [Z]
  --list-services      List services added for a zone [P] [Z]
  --timeout=&lt;timeval&gt;  Enable an option for timeval time, where timeval is
                       a number followed by one of letters &#39;s&#39; or &#39;m&#39; or &#39;h&#39;
                       Usable for options marked with [T]
  --set-description=&lt;description&gt;
                       Set new description to zone [P only] [Z]
  --get-description    Print description for zone [P only] [Z]
  --set-short=&lt;description&gt;
                       Set new short description to zone [P only] [Z]
  --get-short          Print short description for zone [P only] [Z]
  --add-service=&lt;service&gt;
                       Add a service for a zone [P] [Z] [T]
  --remove-service=&lt;service&gt;
                       Remove a service from a zone [P] [Z]
  --query-service=&lt;service&gt;
                       Return whether service has been added for a zone [P] [Z]
  --list-ports         List ports added for a zone [P] [Z]
  --add-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Add the port for a zone [P] [Z] [T]
  --remove-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Remove the port from a zone [P] [Z]
  --query-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Return whether the port has been added for zone [P] [Z]
  --list-protocols     List protocols added for a zone [P] [Z]
  --add-protocol=&lt;protocol&gt;
                       Add the protocol for a zone [P] [Z] [T]
  --remove-protocol=&lt;protocol&gt;
                       Remove the protocol from a zone [P] [Z]
  --query-protocol=&lt;protocol&gt;
                       Return whether the protocol has been added for zone [P] [Z]
  --list-source-ports  List source ports added for a zone [P] [Z]
  --add-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Add the source port for a zone [P] [Z] [T]
  --remove-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Remove the source port from a zone [P] [Z]
  --query-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Return whether the source port has been added for zone [P] [Z]
  --list-icmp-blocks   List Internet ICMP type blocks added for a zone [P] [Z]
  --add-icmp-block=&lt;icmptype&gt;
                       Add an ICMP block for a zone [P] [Z] [T]
  --remove-icmp-block=&lt;icmptype&gt;
                       Remove the ICMP block from a zone [P] [Z]
  --query-icmp-block=&lt;icmptype&gt;
                       Return whether an ICMP block has been added for a zone
                       [P] [Z]
  --add-icmp-block-inversion
                       Enable inversion of icmp blocks for a zone [P] [Z]
  --remove-icmp-block-inversion
                       Disable inversion of icmp blocks for a zone [P] [Z]
  --query-icmp-block-inversion
                       Return whether inversion of icmp blocks has been enabled
                       for a zone [P] [Z]
  --list-forward-ports List IPv4 forward ports added for a zone [P] [Z]
  --add-forward-port=port=&lt;portid&gt;[-&lt;portid&gt;]:proto=&lt;protocol&gt;[:toport=&lt;portid&gt;[-&lt;portid&gt;]][:toaddr=&lt;address&gt;[/&lt;mask&gt;]]
                       Add the IPv4 forward port for a zone [P] [Z] [T]
  --remove-forward-port=port=&lt;portid&gt;[-&lt;portid&gt;]:proto=&lt;protocol&gt;[:toport=&lt;portid&gt;[-&lt;portid&gt;]][:toaddr=&lt;address&gt;[/&lt;mask&gt;]]
                       Remove the IPv4 forward port from a zone [P] [Z]
  --query-forward-port=port=&lt;portid&gt;[-&lt;portid&gt;]:proto=&lt;protocol&gt;[:toport=&lt;portid&gt;[-&lt;portid&gt;]][:toaddr=&lt;address&gt;[/&lt;mask&gt;]]
                       Return whether the IPv4 forward port has been added for
                       a zone [P] [Z]
  --add-masquerade     Enable IPv4 masquerade for a zone [P] [Z] [T]
  --remove-masquerade  Disable IPv4 masquerade for a zone [P] [Z]
  --query-masquerade   Return whether IPv4 masquerading has been enabled for a
                       zone [P] [Z]
  --list-rich-rules    List rich language rules added for a zone [P] [Z]
  --add-rich-rule=&lt;rule&gt;
                       Add rich language rule &#39;rule&#39; for a zone [P] [Z] [T]
  --remove-rich-rule=&lt;rule&gt;
                       Remove rich language rule &#39;rule&#39; from a zone [P] [Z]
  --query-rich-rule=&lt;rule&gt;
                       Return whether a rich language rule &#39;rule&#39; has been
                       added for a zone [P] [Z]

Options to Handle Bindings of Interfaces
  --list-interfaces    List interfaces that are bound to a zone [P] [Z]
  --add-interface=&lt;interface&gt;
                       Bind the &lt;interface&gt; to a zone [P] [Z]
  --change-interface=&lt;interface&gt;
                       Change zone the &lt;interface&gt; is bound to [Z]
  --query-interface=&lt;interface&gt;
                       Query whether &lt;interface&gt; is bound to a zone [P] [Z]
  --remove-interface=&lt;interface&gt;
                       Remove binding of &lt;interface&gt; from a zone [P] [Z]

Options to Handle Bindings of Sources
  --list-sources       List sources that are bound to a zone [P] [Z]
  --add-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;
                       Bind the source to a zone [P] [Z]
  --change-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;
                       Change zone the source is bound to [Z]
  --query-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;
                       Query whether the source is bound to a zone [P] [Z]
  --remove-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;
                       Remove binding of the source from a zone [P] [Z]

Helper Options
  --new-helper=&lt;helper&gt; --module=&lt;module&gt; [--family=&lt;family&gt;]
                       Add a new helper [P only]
  --new-helper-from-file=&lt;filename&gt; [--name=&lt;helper&gt;]
                       Add a new helper from file with optional name [P only]
  --delete-helper=&lt;helper&gt;
                       Delete an existing helper [P only]
  --load-helper-defaults=&lt;helper&gt;
                       Load helper default settings [P only]
  --info-helper=&lt;helper&gt; Print information about an helper
  --path-helper=&lt;helper&gt; Print file path of an helper [P only]
  --get-helpers         Print predefined helpers
  --helper=&lt;helper&gt; --set-description=&lt;description&gt;
                       Set new description to helper [P only]
  --helper=&lt;helper&gt; --get-description
                       Print description for helper [P only]
  --helper=&lt;helper&gt; --set-short=&lt;description&gt;
                       Set new short description to helper [P only]
  --helper=&lt;helper&gt; --get-short
                       Print short description for helper [P only]
  --helper=&lt;helper&gt; --add-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Add a new port to helper [P only]
  --helper=&lt;helper&gt; --remove-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Remove a port from helper [P only]
  --helper=&lt;helper&gt; --query-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Return whether the port has been added for helper [P only]
  --helper=&lt;helper&gt; --get-ports
                       List ports of helper [P only]
  --helper=&lt;helper&gt; --set-module=&lt;module&gt;
                       Set module to helper [P only]
  --helper=&lt;helper&gt; --get-module
                       Get module from helper [P only]
  --helper=&lt;helper&gt; --set-family=&#123;ipv4|ipv6|&#125;
                       Set family for helper [P only]
  --helper=&lt;helper&gt; --get-family
                       Get module from helper [P only]

Direct Options
  --direct             First option for all direct options
  --get-all-chains
                       Get all chains [P]
  --get-chains &#123;ipv4|ipv6|eb&#125; &lt;table&gt;
                       Get all chains added to the table [P]
  --add-chain &#123;ipv4|ipv6|eb&#125; &lt;table&gt; &lt;chain&gt;
                       Add a new chain to the table [P]
  --remove-chain &#123;ipv4|ipv6|eb&#125; &lt;table&gt; &lt;chain&gt;
                       Remove the chain from the table [P]
  --query-chain &#123;ipv4|ipv6|eb&#125; &lt;table&gt; &lt;chain&gt;
                       Return whether the chain has been added to the table [P]
  --get-all-rules
                       Get all rules [P]
  --get-rules &#123;ipv4|ipv6|eb&#125; &lt;table&gt; &lt;chain&gt;
                       Get all rules added to chain in table [P]
  --add-rule &#123;ipv4|ipv6|eb&#125; &lt;table&gt; &lt;chain&gt; &lt;priority&gt; &lt;arg&gt;...
                       Add rule to chain in table [P]
  --remove-rule &#123;ipv4|ipv6|eb&#125; &lt;table&gt; &lt;chain&gt; &lt;priority&gt; &lt;arg&gt;...
                       Remove rule with priority from chain in table [P]
  --remove-rules &#123;ipv4|ipv6|eb&#125; &lt;table&gt; &lt;chain&gt;
                       Remove rules from chain in table [P]
  --query-rule &#123;ipv4|ipv6|eb&#125; &lt;table&gt; &lt;chain&gt; &lt;priority&gt; &lt;arg&gt;...
                       Return whether a rule with priority has been added to
                       chain in table [P]
  --passthrough &#123;ipv4|ipv6|eb&#125; &lt;arg&gt;...
                       Pass a command through (untracked by firewalld)
  --get-all-passthroughs
                       Get all tracked passthrough rules [P]
  --get-passthroughs &#123;ipv4|ipv6|eb&#125; &lt;arg&gt;...
                       Get tracked passthrough rules [P]
  --add-passthrough &#123;ipv4|ipv6|eb&#125; &lt;arg&gt;...
                       Add a new tracked passthrough rule [P]
  --remove-passthrough &#123;ipv4|ipv6|eb&#125; &lt;arg&gt;...
                       Remove a tracked passthrough rule [P]
  --query-passthrough &#123;ipv4|ipv6|eb&#125; &lt;arg&gt;...
                       Return whether the tracked passthrough rule has been
                       added [P]

Lockdown Options
  --lockdown-on        Enable lockdown.
  --lockdown-off       Disable lockdown.
  --query-lockdown     Query whether lockdown is enabled

Lockdown Whitelist Options
  --list-lockdown-whitelist-commands
                       List all command lines that are on the whitelist [P]
  --add-lockdown-whitelist-command=&lt;command&gt;
                       Add the command to the whitelist [P]
  --remove-lockdown-whitelist-command=&lt;command&gt;
                       Remove the command from the whitelist [P]
  --query-lockdown-whitelist-command=&lt;command&gt;
                       Query whether the command is on the whitelist [P]
  --list-lockdown-whitelist-contexts
                       List all contexts that are on the whitelist [P]
  --add-lockdown-whitelist-context=&lt;context&gt;
                       Add the context context to the whitelist [P]
  --remove-lockdown-whitelist-context=&lt;context&gt;
                       Remove the context from the whitelist [P]
  --query-lockdown-whitelist-context=&lt;context&gt;
                       Query whether the context is on the whitelist [P]
  --list-lockdown-whitelist-uids
                       List all user ids that are on the whitelist [P]
  --add-lockdown-whitelist-uid=&lt;uid&gt;
                       Add the user id uid to the whitelist [P]
  --remove-lockdown-whitelist-uid=&lt;uid&gt;
                       Remove the user id uid from the whitelist [P]
  --query-lockdown-whitelist-uid=&lt;uid&gt;
                       Query whether the user id uid is on the whitelist [P]
  --list-lockdown-whitelist-users
                       List all user names that are on the whitelist [P]
  --add-lockdown-whitelist-user=&lt;user&gt;
                       Add the user name user to the whitelist [P]
  --remove-lockdown-whitelist-user=&lt;user&gt;
                       Remove the user name user from the whitelist [P]
  --query-lockdown-whitelist-user=&lt;user&gt;
                       Query whether the user name user is on the whitelist [P]

Panic Options
  --panic-on           Enable panic mode
  --panic-off          Disable panic mode
  --query-panic        Query whether panic mode is enabled
</code></pre>
]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
  </entry>
  <entry>
    <title>牛路村万年台</title>
    <url>/2023/07/06/niu-lu-cun-wan-nian-tai/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="集资记录"><a href="#集资记录" class="headerlink" title="集资记录"></a>集资记录</h1><img src="/2023/07/06/niu-lu-cun-wan-nian-tai/image-20230708084938346.png" class="asset-class" title="image-20230708084938346">

<h1 id="牛路上文化中心柱子上的对联初稿"><a href="#牛路上文化中心柱子上的对联初稿" class="headerlink" title="牛路上文化中心柱子上的对联初稿"></a>牛路上文化中心柱子上的对联初稿</h1><pre><code class="prettyprint">1、牛路大门常打开，开怀容纳天地
    情感闸阀永不关，关切游子世界。
2、小牛路历经风雨岁月洗礼出奇迹
    大家庭沐浴阳光时空变幻有能人。
3、牛气冲天，不坠青云之志，默默耕耘此乃幸福人生
    路途艰险，只贪躺平之念，碌碌无为岂是英雄本色。
4、牛路畅通致富路上笔耕不辍初心不忘
    秀美乡村共享当中共同理想责任在肩。
5、舍小家顾大家甘愿奉献不计回报
    历风雨经世面宁可牺牲不图名利。
6、牛气冲天默默耕耘乃为幸福人生
    路途艰险碌碌无为岂是英雄本色。
7、勇毅前行敬天敬地敬祖宗生生不息
    踔力奋发爱党爱国爱家乡步步莲花。
</code></pre>
<h1 id="开工致辞"><a href="#开工致辞" class="headerlink" title="开工致辞"></a>开工致辞</h1><pre><code class="prettyprint">双丰牛路村万年台奠基仪式主持词

  尊敬的各位领导、各位来宾、各位父老乡亲：大家好！
  期盼已久、激动人心的建造万年台的神圣而庄严的时刻终于
  迈着轻盈的脚步款款向我们走来，那是牛路上人梦寐以求、
  具有历史意义时刻。对于全村来讲，是一件值得铭记、值得
  庆祝、值得留下美好记忆的时刻。她见证着牛路上人团结一
  致、齐心协力追逐梦想的热情，浓缩着牛路精神。勤劳质朴，
  热情似火，奋勇向前，不甘寂寞的精神风貌。感谢这方热土
  孕育着不少有识之士一贯以来对村集体的默默付出；感谢祖
  先们给我们作出了表率，无论是什么时期都有一批又一批为
  村里做贡献的人，我们村虽说没有达官贵族，至少我们是守
  法公民，监狱里总不见我们的人儿。像现在彭士有、彭士利
  的事业都与国外接壤，说明了后生可畏，后生了不起。我们
  村上小老板也不少，他们都在努力学习、努力拼搏，为了自
  己、为了家庭、为了给牛路上人争口气都在勤奋努力地工作
  着，致敬全体牛路上人！！！这块神奇的土地上有祖先洒过
  的汗水，年轻人流过的辛酸泪，更有我们人人出钱出力、亲
  手建造的万年台。预祝理事会所有成员健康快乐、团结一致、
  互相配合、合作愉快地度过建造万年台的每一个艰苦的日子。
  祝福我们全村泰平美满、人心更齐，意气风发地行走在寻找
  幸福的途中快乐轻松！愿未来与我们所愿，祝奠基成功！

——彭伶春
</code></pre>
<h1 id="开工烟花"><a href="#开工烟花" class="headerlink" title="开工烟花"></a>开工烟花</h1><pre><code class="prettyprint">001 彭芳习       100元
002 彭水波       100元
003 彭士财       100元
004 彭俊海       100元
005 彭士发       100元
006 彭士贵       100元
007 彭芳锦       100元
008 彭照会       100元
009 彭俊池       100元
010 彭国平       100元
011 彭 鹏        100元
012 彭 江        200元
013 彭士亮       100元
014 彭照培       100元
015 彭俊雪       100元
016 彭芳绿       100元
017 彭照明       100元
018 彭芳雪       100元
019 彭 飞        100元
020 彭小飞       100元
021 彭传旺       100元
022 彭照龙       100元
023 彭国帅       100元
024 彭照勤       100元
025 彭俊华       100元
026 彭俊意       100元
027 彭俊金       100元
028 彭士卫       100元
029 彭俊乐       100元
030 彭国华       100元
031 彭俊生       100元
032 彭芳国       100元
033 彭乃池       100元
034 彭传刚       100元
035 彭芳造       100元
036 彭士海       100元
037 彭芳明       100元
038 彭天佑       100元
039 彭照宇       100元
040 彭  炤       100元
041 彭  炜       100元
042 彭俊谱       100元
043 彭士荣       100元
044 彭俊贤       100元
045 彭氏顺       100元
046 彭国通       100元
047 彭芳在       100元
048 彭俊园       100元
049 彭照财       100元
050 彭照会西边100元
051 彭林钟       100元
052 彭  建       100元
053彭俊明（蒙得）  100元
054 彭 登        100元
055 彭士义       100元
056 彭传意       100元
057 彭士喜       100元
058 彭俊爱       100元
059 彭俊虎       100元
060 彭俊永       100元
061 彭士正       100元
062 彭士勇       100元
063 彭芳照       100元
下面是个人和集体赞助
赵明华                1个
彭芳真                1个
彭俊光                1个
彭芳好                1个
彭芳中                1个
彭俊功                1个
彭芳水                1个
彭芳布                1个
彭俊国（村会计）	    1个
彭起标                1个
彭照军                1个
彭士爱                1个
彭芳友                2个
彭传长                1个
彭俊發                1个
村委会                1个
</code></pre>
<h1 id="个人宣言"><a href="#个人宣言" class="headerlink" title="个人宣言"></a>个人宣言</h1><pre><code class="prettyprint">吉日良辰天地开张
起土动土四季平安
三羊开泰福星照
紫气东来艳阳娇
平安二字值千金
千年福运天天有
亿万财源滚滚来
发人发财发富贵
添福添寿万万年
祝贺牛路村万年台文化活动中心奠基仪式圆满成功！

——彭士愿宣
</code></pre>
<hr>
]]></content>
      <categories>
        <category>牛路村</category>
      </categories>
      <tags>
        <tag>万年台</tag>
      </tags>
  </entry>
</search>
