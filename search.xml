<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>加密算法之java实现AES</title>
    <url>/2022/04/18/jia-mi-suan-fa-zhi-java-shi-xian-aes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>AESUtil</code>工具类</p>
<pre><code class="prettyprint">public class AESUtil &#123;
    //自己定义
    public static String AES_KEY_VALUE = &quot;&quot;;
    private static final String KEY_ALGORITHM = &quot;AES&quot;;
    /**
     * 默认的加密算法
     */
    private static final String DEFAULT_CIPHER_ALGORITHM = &quot;AES/ECB/PKCS5Padding&quot;;

    /**
     * 随机生成密钥
     *
     * @return
     */
    public static String getAESRandomKey() &#123;
        SecureRandom random = new SecureRandom();
        long randomKey = random.nextLong();
        return String.valueOf(randomKey);
    &#125;

    /**
     * AES 加密操作
     *
     * @param content 待加密内容
     * @param key     加密密钥
     * @return 返回Base64转码后的加密数据
     */
    public static String encrypt(String content, String key)  &#123;
        try &#123;
            // 创建密码器
            Cipher cipher = Cipher.getInstance(DEFAULT_CIPHER_ALGORITHM);
            byte[] byteContent = content.getBytes(&quot;utf-8&quot;);
            // 初始化为加密模式的密码器
            cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(key));
            // 加密
            byte[] result = cipher.doFinal(byteContent);
            //通过Base64转码返回
            return HexUtil.getHexString(result);
        &#125; catch (Exception ex) &#123;
            ex.printStackTrace();
        &#125;

        return null;
    &#125;

    /**
     * AES 解密操作
     *
     * @param content
     * @param key
     * @return
     */
    public static String decrypt(String content, String key) &#123;
        try &#123;
            //实例化
            Cipher cipher = Cipher.getInstance(DEFAULT_CIPHER_ALGORITHM);
            //使用密钥初始化，设置为解密模式
            cipher.init(Cipher.DECRYPT_MODE, getSecretKey(key));
            //执行操作
            byte[] result = cipher.doFinal(HexUtil.hexStringToBytes(content));
            return new String(result, &quot;utf-8&quot;);
        &#125; catch (Exception ex) &#123;
            ex.printStackTrace();
        &#125;

        return null;
    &#125;

    /**
     * 生成加密秘钥
     *
     * @return
     */
    private static SecretKeySpec getSecretKey(final String key) &#123;
        //返回生成指定算法密钥生成器的 KeyGenerator 对象
        try &#123;
            KeyGenerator kg = KeyGenerator.getInstance(KEY_ALGORITHM);
            // 此类提供加密的强随机数生成器 (RNG)，该实现在windows上每次生成的key都相同，但是在部分linux或solaris系统上则不同。
            // SecureRandom random = new SecureRandom(key.getBytes());
            // 指定算法名称，不同的系统上生成的key是相同的。
            SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);
            random.setSeed(key.getBytes());
            //AES 要求密钥长度为 128
            kg.init(128, random);
            //生成一个密钥
            SecretKey secretKey = kg.generateKey();
            // 转换为AES专用密钥
            return new SecretKeySpec(secretKey.getEncoded(), KEY_ALGORITHM);
        &#125; catch (NoSuchAlgorithmException ex) &#123;
            ex.printStackTrace();
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<p><code>AESUtilTest</code>测试类</p>
<pre><code class="prettyprint">@Test
    public void encodeAndDecode() throws Exception &#123;
//        String data = &quot;阿斯达斯&quot;;
        SecureRandom random = new SecureRandom();
        String data = String.valueOf(random.nextInt(50));
        data += &quot;123456789789456123&quot;;
        String secretKey = AESUtil.AES_KEY_VALUE;
        System.out.println(&quot;传输数据:&quot;+data);
        //加密
        String encrypte = AESUtil.encrypt(data, secretKey);
        System.out.println(&quot;加密后数据:&quot;+encrypte+&quot;，长度：&quot;+encrypte.length());
        //数据解密
        String decryptDatas = AESUtil.decrypt(encrypte, secretKey);
        System.out.println(&quot;解密后数据：&quot;+decryptDatas);
    &#125;
</code></pre>
<p>转载:[Java加密-AES加解密](<a href="https://www.jianshu.com/p/7f17792609cc">Java加密-AES加解密 - 简书 (jianshu.com)</a>)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>加密算法之java实现DES</title>
    <url>/2022/04/18/jia-mi-suan-fa-zhi-java-shi-xian-des/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>简介：</strong></p>
<p>数据加密算法（Data Encryption Algorithm，DEA）是一种对称加密算法，很可能是使用最广泛的密钥系统，特别是在保护金融数据的安全中，最初开发的DEA是嵌入硬件中的。通常，自动取款机（Automated Teller Machine，ATM）都使用DEA。它出自IBM的研究工作，IBM也曾对它拥有几年的专利权，但是在1983年已到期后，处于公有范围中，允许在特定条件下可以免除专利使用费而使用。1977年被美国政府正式采纳。</p>
<p>1998年后实用化DES破译机的出现彻底宣告DES算法已不具备安全性，1999年NIST颁布新标准，规定DES算法只能用于遗留加密系统，但不限制使用DESede算法。当今DES算法正是推出历史舞台，AES算法称为他的替代者。</p>
<p><strong>加密原理：</strong></p>
<p>DES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位，产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但 最后一个循环不交换。DES 使用 16 个循环，使用异或，置换，代换，移位操作四种基本运算。</p>
<p><strong>JDK对DES算法的支持</strong></p>
<p>密钥长度：56位</p>
<p>工作模式：ECB&#x2F;CBC&#x2F;PCBC&#x2F;CTR&#x2F;CTS&#x2F;CFB&#x2F;CFB8 to CFB128&#x2F;OFB&#x2F;OBF8 to OFB128</p>
<p>填充方式：Nopadding&#x2F;PKCS5Padding&#x2F;ISO10126Padding&#x2F;</p>
<p><strong>Java 加密解密之对称加密算法DESede</strong></p>
<p>DESede 即三重DES加密算法，也被称为3DES或者Triple DES。使用三(或两)个不同的密钥对数据块进行三次(或两次)DES加密(加密一次要比进行普通加密的三次要快)。三重DES的强度大约和112- bit的密钥强度相当。通过迭代次数的提高了安全性，但同时也造成了加密效率低的问题。正因DESede算法效率问题，AES算法诞生了。</p>
<p>到目前为止，还没有人给出攻击三重DES的有效方法。对其密钥空间中密钥进行蛮干搜索，那么由于空间太大，这实际上是不可行的。若用差分攻击的方法，相对于单一DES来说复杂性以指数形式增长。</p>
<p><strong>三重DES有四种模型</strong></p>
<ul>
<li>DES-EEE3，使用三个不同密钥，顺序进行三次加密变换。</li>
<li>DES-EDE3，使用三个不同密钥，依次进行加密-解密-加密变换。</li>
<li>DES-EEE2，其中密钥K1&#x3D;K3，顺序进行三次加密变换。</li>
<li>DES-EDE2， 其中密钥K1&#x3D;K3，依次进行加密-解密-加密变换。</li>
</ul>
<p><code>DESUtil</code>工具类</p>
<pre><code class="prettyprint">public final class DESUtil &#123;
    //自己定义
    public static String DES_KEY_VALUE = &quot;&quot;;
    private DESUtil() &#123;
    &#125;
    private final static String DES = &quot;DES&quot;;

    public static byte[] encrypt(byte[] src, byte[] key) throws Exception &#123;
        // DES算法要求有一个可信任的随机数源
        SecureRandom sr = new SecureRandom();
        // 从原始密匙数据创建DESKeySpec对象
        DESKeySpec dks = new DESKeySpec(key);
        // 创建一个密匙工厂，然后用它把DESKeySpec转换成一个SecretKey对象
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);
        SecretKey securekey = keyFactory.generateSecret(dks);
        // Cipher对象实际完成加密操作
        Cipher cipher = Cipher.getInstance(DES);
        // 用密匙初始化Cipher对象
        cipher.init(Cipher.ENCRYPT_MODE, securekey, sr);
        // 正式执行加密操作
        return cipher.doFinal(src);
    &#125;

    /**
     *
     * @param password 密码
     * @param key 加密字符串
     * @return
     */
    public final static String encrypt(String password, String key) &#123;
        try &#123;
            return byte2String(encrypt(password.getBytes(), key.getBytes()));
        &#125; catch (Exception e) &#123;
        &#125;
        return null;
    &#125;

    public static String byte2String(byte[] b) &#123;
        String hs = &quot;&quot;;
        String stmp = &quot;&quot;;
        for (int n = 0; n &lt; b.length; n++) &#123;
            stmp = (Integer.toHexString(b[n] &amp; 0XFF));
            if (stmp.length() == 1) &#123;
                hs = hs + &quot;0&quot; + stmp;
            &#125; else &#123;
                hs = hs + stmp;
            &#125;
        &#125;
        return hs.toUpperCase();
    &#125;

    /**
     *
     * @param src 数据源
     * @param key 密钥，长度必须是8的倍数
     * @return
     * @throws Exception
     */
    public static byte[] decrypt(byte[] src, byte[] key) throws Exception &#123;
        // DES算法要求有一个可信任的随机数源
        SecureRandom sr = new SecureRandom();
        // 从原始密匙数据创建一个DESKeySpec对象
        DESKeySpec dks = new DESKeySpec(key);
        // 创建一个密匙工厂，然后用它把DESKeySpec对象转换成一个SecretKey对象
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);
        SecretKey securekey = keyFactory.generateSecret(dks);
        // Cipher对象实际完成解密操作
        Cipher cipher = Cipher.getInstance(DES);
        // 用密匙初始化Cipher对象
        cipher.init(Cipher.DECRYPT_MODE, securekey, sr);

        // 正式执行解密操作
        return cipher.doFinal(src);
    &#125;

    public final static String decrypt(String data, String key) &#123;
        try &#123;
            return new String(decrypt(String2byte(data.getBytes()), key.getBytes()));
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;

    public static byte[] String2byte(byte[] b) &#123;
        if ((b.length % 2) != 0)&#123;
            throw new IllegalArgumentException(&quot;长度不是偶数&quot;);
        &#125;
        byte[] b2 = new byte[b.length / 2];
        for (int n = 0; n &lt; b.length; n += 2) &#123;
            String item = new String(b, n, 2);
            b2[n / 2] = (byte) Integer.parseInt(item, 16);
        &#125;
        return b2;
    &#125;
&#125;
</code></pre>
<p><code>DESUtilTest</code> 测试类</p>
<pre><code class="prettyprint">@Test
public void encodeAndDecode()&#123;
    //        String data = &quot;阿斯达斯&quot;;
    SecureRandom random = new SecureRandom();
    String data = String.valueOf(random.nextInt(50));
    data += &quot;123456789789456123&quot;;
    String secretKey = DESUtil.DES_KEY_VALUE;
    System.out.println(&quot;传输数据:&quot;+data);
    //加密
    String encrypte = DESUtil.encrypt(data, secretKey);
    System.out.println(&quot;加密后数据:&quot;+encrypte+&quot;，长度：&quot;+encrypte.length());
    //数据解密
    String decryptDatas = DESUtil.decrypt(encrypte, secretKey);
    System.out.println(&quot;解密后数据：&quot;+decryptDatas);
&#125;
</code></pre>
<p><a href="https://gitee.com/RocPengHua/crypto.git">gitee地址</a></p>
<p>转载：[Java实现DES加解密算法解析](<a href="http://www.zzvips.com/article/78986.html">Java实现DES加解密算法解析_JAVA教程_服务器之家 (zzvips.com)</a>)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>加密算法之java实现SM4</title>
    <url>/2022/04/18/jia-mi-suan-fa-zhi-java-shi-xian-sm4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 1、引入依赖</p>
<pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;commons-codec&lt;/groupId&gt;
    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;
    &lt;version&gt;1.15&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;
    &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;
    &lt;version&gt;1.56&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、构造工具类</p>
<pre><code class="prettyprint">public class SM4Util &#123;
    static &#123;
        Security.addProvider(new BouncyCastleProvider());
    &#125;

    private static final String ENCODING = &quot;UTF-8&quot;;
    public static final String ALGORITHM_NAME = &quot;SM4&quot;;
    // 加密算法/分组加密模式/分组填充方式
    // PKCS5Padding-以8个字节为一组进行分组加密
    // 定义分组加密模式使用：PKCS5Padding
    public static final String ALGORITHM_NAME_ECB_PADDING = &quot;SM4/ECB/PKCS5Padding&quot;;
    // 128-32位16进制；256-64位16进制
    public static final int DEFAULT_KEY_SIZE = 128;

    /**
     * 自动生成密钥
     *
     * @return
     * @explain
     */
    public static String generateKey() throws Exception &#123;
        return new String(Hex.encodeHex(generateKey(DEFAULT_KEY_SIZE),false));
    &#125;

    /**
     * @param keySize
     * @return
     * @throws Exception
     * @explain
     */
    public static byte[] generateKey(int keySize) throws Exception &#123;
        KeyGenerator kg = KeyGenerator.getInstance(ALGORITHM_NAME, BouncyCastleProvider.PROVIDER_NAME);
        kg.init(keySize, new SecureRandom());
        return kg.generateKey().getEncoded();
    &#125;

    /**
     * 生成ECB暗号
     *
     * @param algorithmName 算法名称
     * @param mode          模式
     * @param key
     * @return
     * @throws Exception
     * @explain ECB模式（电子密码本模式：Electronic codebook）
     */
    private static Cipher generateEcbCipher(String algorithmName, int mode, byte[] key) throws Exception &#123;
        Cipher cipher = Cipher.getInstance(algorithmName, BouncyCastleProvider.PROVIDER_NAME);
        Key sm4Key = new SecretKeySpec(key, ALGORITHM_NAME);
        cipher.init(mode, sm4Key);
        return cipher;
    &#125;

    /**
     * sm4加密
     *
     * @param hexKey   16进制密钥（忽略大小写）
     * @param paramStr 待加密字符串
     * @return 返回16进制的加密字符串
     * @explain 加密模式：ECB
     * 密文长度不固定，会随着被加密字符串长度的变化而变化
     */
    public static String encryptEcb(String hexKey, String paramStr) &#123;
        try &#123;
            String cipherText = &quot;&quot;;
            // 16进制字符串--&amp;gt;byte[]
            byte[] keyData = ByteUtils.fromHexString(hexKey);
            // String--&amp;gt;byte[]
            byte[] srcData = paramStr.getBytes(ENCODING);
            // 加密后的数组
            byte[] cipherArray = encrypt_Ecb_Padding(keyData, srcData);
            // byte[]--&amp;gt;hexString
            cipherText = ByteUtils.toHexString(cipherArray);
            return cipherText;
        &#125; catch (Exception e) &#123;
            return paramStr;
        &#125;
    &#125;

    /**
     * 加密模式之Ecb
     *
     * @param key
     * @param data
     * @return
     * @throws Exception
     * @explain
     */
    public static byte[] encrypt_Ecb_Padding(byte[] key, byte[] data) throws Exception &#123;
        Cipher cipher = generateEcbCipher(ALGORITHM_NAME_ECB_PADDING, Cipher.ENCRYPT_MODE, key);
        return cipher.doFinal(data);
    &#125;

    /**
     * sm4解密
     *
     * @param hexKey     16进制密钥
     * @param cipherText 16进制的加密字符串（忽略大小写）
     * @return 解密后的字符串
     * @throws Exception
     * @explain 解密模式：采用ECB
     */
    public static String decryptEcb(String hexKey, String cipherText) &#123;
        // 用于接收解密后的字符串
        String decryptStr = &quot;&quot;;
        // hexString--&amp;gt;byte[]
        byte[] keyData = ByteUtils.fromHexString(hexKey);
        // hexString--&amp;gt;byte[]
        byte[] cipherData = ByteUtils.fromHexString(cipherText);
        // 解密
        byte[] srcData = new byte[0];
        try &#123;
            srcData = decrypt_Ecb_Padding(keyData, cipherData);
            // byte[]--&amp;gt;String
            decryptStr = new String(srcData, ENCODING);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return decryptStr;
    &#125;

    /**
     * 解密
     *
     * @param key
     * @param cipherText
     * @return
     * @throws Exception
     * @explain
     */
    public static byte[] decrypt_Ecb_Padding(byte[] key, byte[] cipherText) throws Exception &#123;
        Cipher cipher = generateEcbCipher(ALGORITHM_NAME_ECB_PADDING, Cipher.DECRYPT_MODE, key);
        return cipher.doFinal(cipherText);
    &#125;

    /**
     * 校验加密前后的字符串是否为同一数据
     *
     * @param hexKey     16进制密钥（忽略大小写）
     * @param cipherText 16进制加密后的字符串
     * @param paramStr   加密前的字符串
     * @return 是否为同一数据
     * @throws Exception
     * @explain
     */
    public static boolean verifyEcb(String hexKey, String cipherText, String paramStr) throws Exception &#123;
        // 用于接收校验结果
        boolean flag = false;
        // hexString--&amp;gt;byte[]
        byte[] keyData = ByteUtils.fromHexString(hexKey);
        // 将16进制字符串转换成数组
        byte[] cipherData = ByteUtils.fromHexString(cipherText);
        // 解密
        byte[] decryptData = decrypt_Ecb_Padding(keyData, cipherData);
        // 将原字符串转换成byte[]
        byte[] srcData = paramStr.getBytes(ENCODING);
        // 判断2个数组是否一致
        flag = Arrays.equals(decryptData, srcData);
        return flag;
    &#125;

&#125;
</code></pre>
<pre><code class="prettyprint">@Test
public void encodeAndDecode()&#123;
    try &#123;
        String json = &quot;BF7B6BD7C1204BC4F3C87D235692DE9DBF7B6BD7C1204BC4F3C87D235692DE9DBF7B6BD7C1204BC4F3C87D235692DE9D&quot;;
        System.out.println(&quot;加密前源数据————&quot; + json);
        // 生成32位16进制密钥(key不能随便取药使用生成的)
        //            String key = SM4Util.generateKey();
        String key = &quot;888368581322491ace9q79348a2757d1&quot;;
        System.out.println(key + &quot;-----生成key&quot;);
        String cipher = SM4Util.encryptEcb(key, json);
        System.out.println(&quot;加密串---&quot; + cipher);
        System.out.println(SM4Util.verifyEcb(key, cipher, json));
        json = SM4Util.decryptEcb(key, cipher);
        System.out.println(&quot;解密后数据---&quot; + json);
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle之base64</title>
    <url>/2022/04/19/oracle-zhi-base64/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>oracle:</p>
<pre><code class="prettyprint">select utl_raw.cast_to_varchar2(utl_encode.base64_encode(utl_raw.cast_to_raw(&#39;qwertyqwerty&#39;))) from dual;
select utl_raw.cast_to_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(&#39;cXdlcnR5cXdlcnR5&#39;))) from dual;

//hex
select rawtohex(utl_raw.cast_to_varchar2(utl_encode.base64_encode(utl_raw.cast_to_raw(&#39;130000000.56&#39;)))) from dual;
select utl_raw.cast_to_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(UTL_RAW.CAST_TO_varchar2(&#39;4D544D774D4441774D4441774C6A5532&#39;)))) from dual;
</code></pre>
<img src="/2022/04/19/oracle-zhi-base64/1650362471008.png" class="asset-class" width="1650362471008">

<p>java:</p>
<pre><code class="prettyprint">public class Base64Util &#123;
    public static String encode(String source) &#123;
        return Base64.encodeBase64String(StringUtils.getBytesUtf8(source));
    &#125;
    public static String decode(String target) &#123;
        return StringUtils.newStringUtf8(Base64.decodeBase64(target));
    &#125;
    public static String encrypt(String source) &#123;
        return HexUtil.getHexString(Base64.encodeBase64String(StringUtils.getBytesUtf8(source)).getBytes());
    &#125;
    public static String decrypt(String target) &#123;
        return StringUtils.newStringUtf8(Base64.decodeBase64(new String(HexUtil.hexStringToBytes(target))));
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>oracle函数实现des算法</title>
    <url>/2022/04/19/oracle-han-shu-shi-xian-des-suan-fa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>oracle函数实现des算法（CBC模式:hex&#x2F;base64）</p>
<p>加密<code>encrypt_des</code></p>
<pre><code class="prettyprint">create or replace function encrypt_des(p_text varchar2,p_key varchar2) return varchar2 is
  v_text        varchar2(4000);
    v_enc         varchar2(4000);
    raw_input     RAW(128);
    key_input     RAW(128);
    decrypted_raw RAW(2048);
  begin
    v_text    := rpad(p_text, (trunc(length(p_text) / 8) + 1) * 8, chr(0));
    raw_input := UTL_RAW.CAST_TO_RAW(v_text);
    key_input := UTL_RAW.CAST_TO_RAW(p_key);
    dbms_obfuscation_toolkit.DESEncrypt(input          =&gt; raw_input,
                                        key            =&gt; key_input,
                                        encrypted_data =&gt; decrypted_raw);
    /*hex转字符输出
    v_enc := rawtohex(decrypted_raw);*/
    /*转base64*/
    select utl_raw.cast_to_varchar2(utl_encode.base64_encode(decrypted_raw)) into v_enc from dual;
    dbms_output.put_line(v_enc);
    return v_enc;
end encrypt_des;
</code></pre>
<p>解密<code>decrypt_des</code></p>
<pre><code class="prettyprint">create or replace function decrypt_des(p_text varchar2, p_key varchar2) return varchar2 is
  v_text varchar2(2000);
  begin
    /*hex转字符输出
    dbms_obfuscation_toolkit.DESDECRYPT(input_string     =&gt; UTL_RAW.CAST_TO_varchar2(p_text),
                                        key_string       =&gt; p_key,
                                        decrypted_string =&gt; v_text);
                                        */
    /*base64转字符输出*/
    dbms_obfuscation_toolkit.DESDECRYPT(input_string     =&gt; UTL_RAW.CAST_TO_varchar2(utl_encode.base64_decode(utl_raw.cast_to_raw(p_text))),
                                        key_string       =&gt; p_key,
                                        decrypted_string =&gt; v_text);
                                        
    v_text := rtrim(v_text, chr(0));
    dbms_output.put_line(v_text);
    return v_text;
end decrypt_des;
</code></pre>
<p>hex:</p>
<img src="/2022/04/19/oracle-han-shu-shi-xian-des-suan-fa/1650360630842.png" class="asset-class" width="1650360630842">





<img src="/2022/04/19/oracle-han-shu-shi-xian-des-suan-fa/1650360647718.png" class="asset-class" width="1650360647718">

<p>base64:</p>
<img src="/2022/04/19/oracle-han-shu-shi-xian-des-suan-fa/1650361954868.png" class="asset-class" width="1650361954868">

<img src="/2022/04/19/oracle-han-shu-shi-xian-des-suan-fa/1650361965256.png" class="asset-class" width="1650361965256">

<p>java版本</p>
<pre><code class="prettyprint">public class OracleDesUtil &#123;
    private OracleDesUtil() &#123;
    &#125;
    public static String DES_KEY_VALUE = &quot;QAZXSW!@#123654*&quot;;
    private final static String DES = &quot;DES&quot;;
    private final static String CIPHER_DES = &quot;DES/CBC/NoPadding&quot;;

    /**
     *
     * @param data 数据
     * @param key 密钥
     * @return
     */
    public static String encrypt(String data, String key) &#123;
        try &#123;
            DESKeySpec desKey = new DESKeySpec(key.getBytes());
            SecretKey securekey = SecretKeyFactory.getInstance(DES).generateSecret(desKey);

            Cipher cipher = Cipher.getInstance(CIPHER_DES);
            cipher.init(Cipher.ENCRYPT_MODE, securekey, new IvParameterSpec(new byte[8]));

            byte[] inBytes = new byte[((int) (data.length() / 8) + 1) * 8];
            for (int i = 0; i &lt; data.length(); i++) &#123;
                inBytes[i] = data.getBytes()[i];
            &#125;

            byte[] enBytes = cipher.doFinal(inBytes);
            //base64
            //return Base64.encodeBase64String(enBytes);
            //hex
            return HexUtil.getHexString(enBytes);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;


    public static String decrypt(String data, String key) &#123;
        try &#123;
            DESKeySpec desKey = new DESKeySpec(key.getBytes());
            SecretKey secretKey = SecretKeyFactory.getInstance(DES).generateSecret(desKey);

            Cipher cipher = Cipher.getInstance(CIPHER_DES);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(new byte[8]));
            //base64
            //byte[]decryptBytes = cipher.doFinal(Base64.decodeBase64(data));
            //hex
            byte[]decryptBytes = cipher.doFinal(HexUtil.hexStringToBytes(data));

            return new String(decryptBytes);
        &#125;
        catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;

&#125;
</code></pre>
<img src="/2022/04/19/oracle-han-shu-shi-xian-des-suan-fa/1650360699530.png" class="asset-class" width="1650360699530">

<img src="/2022/04/19/oracle-han-shu-shi-xian-des-suan-fa/1650362060815.png" class="asset-class" width="1650362060815">

<p>转载:<a href="https://www.jianshu.com/p/332e13a49b6b">Oracle DES加密、Java 解密</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>记录执行时间工具类</title>
    <url>/2022/04/19/ji-lu-zhi-xing-shi-jian-gong-ju-lei/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code class="prettyprint">public class TimeTool &#123;
    private static final SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss:SSS&quot;);
    public interface Task&#123;
        void execute() throws Exception;
    &#125;
    public static void check(String title,Task task) throws Exception &#123;
        if(task == null)&#123;
            return;
        &#125;
        title = (title == null) ? &quot;&quot;:(&quot;【&quot;+title+&quot;】&quot;);
        System.out.println(title);
        System.out.println(&quot;开始：&quot; + sdf.format(new Date()));
        long begin = System.currentTimeMillis();
        task.execute();
        long end = System.currentTimeMillis();
        System.out.println(&quot;结束：&quot;+sdf.format(new Date()));
        long delta = (end - begin);
        System.out.println(&quot;耗时-----&quot;+delta+&quot;----毫秒&quot;);
        System.out.println(&quot;-----------------------&quot;);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>jmeter启动报错</title>
    <url>/2022/04/21/jmeter-qi-dong-bao-cuo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>jmeter-5.4启动时报错 could not create JAVA … </p>
<p>无法创建jvm,配置本地环境变量问题 jdk安装64位的</p>
<p><a href="https://dlcdn.apache.org//jmeter/binaries/apache-jmeter-5.4.3.zip">https://dlcdn.apache.org//jmeter/binaries/apache-jmeter-5.4.3.zip</a></p>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
  </entry>
  <entry>
    <title>centos7手动安装rocketmq</title>
    <url>/2022/04/23/centos7-shou-dong-an-zhuang-rocketmq/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="download"><a href="#download" class="headerlink" title="download"></a>download</h2><p><a href="https://dlcdn.apache.org/rocketmq/4.9.3/rocketmq-all-4.9.3-bin-release.zip">https://dlcdn.apache.org/rocketmq/4.9.3/rocketmq-all-4.9.3-bin-release.zip</a></p>
<h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul>
<li><p>linux64位系统</p>
</li>
<li><p>jdk1.8(64位)</p>
</li>
<li><p>源码安装需要maven3.2</p>
</li>
</ul>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="解压安装"><a href="#解压安装" class="headerlink" title="解压安装"></a>解压安装</h3><pre><code class="prettyprint">unzip rocketmq-all-4.9.3-bin-release.zip -d /usr/local/mq
cd /usr/local/mq
mv rocketmq-all-4.9.3-bin-release rocketmq
</code></pre>
<h3 id="创建文件存储文件夹"><a href="#创建文件存储文件夹" class="headerlink" title="创建文件存储文件夹"></a>创建文件存储文件夹</h3><pre><code class="prettyprint">mkdir /opt/module/rocketmq/logs
mkdir /opt/module/rocketmq/store
mkdir /opt/module/rocketmq/store/commitlog
mkdir /opt/module/rocketmq/store/consumequeue
mkdir /opt/module/rocketmq/store/index
</code></pre>
<h3 id="单机模式配置"><a href="#单机模式配置" class="headerlink" title="单机模式配置"></a>单机模式配置</h3><pre><code class="prettyprint"># 配置properties
cd rocketmq/conf/
# 2m-2s-async:2主2从异步
# 2m-2s-sync:2主2从同步
# 2m-noslaves:2主没有从
vim 2m-2s-async/brock.a.properties
</code></pre>
<img src="/2022/04/23/centos7-shou-dong-an-zhuang-rocketmq/image-20220423210803203.png" class="asset-class" title="image-20220423210803203">

<img src="/2022/04/23/centos7-shou-dong-an-zhuang-rocketmq/image-20220423210729592.png" class="asset-class" title="image-20220423210729592">

<h3 id="brock-a-properties配置内容"><a href="#brock-a-properties配置内容" class="headerlink" title="brock.a.properties配置内容"></a><code>brock.a.properties</code>配置内容</h3><pre><code class="prettyprint">#所属集群名字
brokerClusterName=rocketmq-cluster
#broker名字，注意此处不同的配置文件填写的不一样
brokerName=broker-a
#0 表示 Master，&gt;0 表示 Slave
brokername=0
#nameServer地址，分号分割 ---在hosts里面配置rocketmq-nameserver1  /etc/hosts
namesrvAddr=rocketmq-nameserver1:9876
#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数
defaultTopicQueueNums=4
#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭
autoCreateTopicEnable=true
#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭
autoCreateSubscriptionGroup=true
#Broker 对外服务的监听端口
listenPort=10911
#删除文件时间点，默认凌晨 4点
deleteWhen=04
#文件保留时间，默认 48 小时
fileReservedTime=120
#commitLog每个文件的大小默认1G
mapedFileSizeCommitLog=1073741824
#ConsumeQueue每个文件默认存30W条，根据业务情况调整
mapedFileSizeConsumeQueue=300000
#destroyMapedFileIntervalForcibly=120000
#redeleteHangedFileInterval=120000
#检测物理文件磁盘空间
diskMaxUsedSpaceRatio=88
#存储路径
storePathRootDir=/opt/module/rocketmq/store
#commitLog 存储路径
storePathCommitLog=/opt/module/rocketmq/store/commitlog
#消费队列存储路径存储路径
storePathConsumeQueue=/opt/module/rocketmq/store/comsumequeue
#消息索引存储路径
storePathIndex=/opt/module/rocketmq/store/index
#checkpoint 文件存储路径
storeCheckpoint=/opt/module/rocketmq/store/checkpoint
#abort 文件存储路径
abortFile=/opt/module/rocketmq/store/abort
#限制的消息大小
maxMessageSize=65536
#flushCommitLogLeastPages=4
#flushConsumeQueueLeastPages=2
#flushCommitLogThoroughInterval=10000
#flushConsumeQueueThoroughInterval=60000
#Broker 的角色
#- ASYNC_MASTER 异步复制Master
#- SYNC_MASTER 同步双写Master
#- SLAVE
brokerRole=ASYNC_MASTER
#刷盘方式
#- ASYNC_FLUSH 异步刷盘
#- SYNC_FLUSH 同步刷盘
flushDiskType=ASYNC_FLUSH
#checkTransactionMessageEnable=false
#发消息线程池数量
#sendMessageThreadPoolNums=128
#拉消息线程池数量
#pullMessageThreadPoolNums=128
</code></pre>
<h3 id="修改xml的文件路径"><a href="#修改xml的文件路径" class="headerlink" title="修改xml的文件路径"></a>修改xml的文件路径</h3><pre><code class="prettyprint">sed -i &#39;s#$&#123;user.home&#125;#/opt/module/rocketmq#g&#39; *.xml
</code></pre>
<p>注意：sed -i在这里起批量的作用</p>
<pre><code class="prettyprint">sed -i &#39;s#原字符#新字符#g&#39; 替换的文件
</code></pre>
<h3 id="修改启动脚本配置"><a href="#修改启动脚本配置" class="headerlink" title="修改启动脚本配置"></a>修改启动脚本配置</h3><p><code>/opt/module/rocketmq/bin/runbroker.sh</code></p>
<pre><code class="prettyprint">#改之前
JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms8g -Xmx8g&quot;
#改之后
JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g&quot;
</code></pre>
<p><code>/opt/module/rocketmq/bin/runserver.sh</code></p>
<pre><code class="prettyprint">#改之前
JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;
#改之后
JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;
</code></pre>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code class="prettyprint">cd /opt/module/rocketmq/bin
# 启动server
sh mqnamersrv &amp;
#启动brocker 指定文件路径(前面配置的文件)
sh mqbrocker -c ../conf/2m-2s-async/brock.a.properties &amp;
</code></pre>
<h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><pre><code class="prettyprint">cd /opt/module/rocketmq/bin
# 停止broker
sh mqshutdown broker
#停止namesrv
sh mqshutdown namesrv
</code></pre>
<h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><pre><code class="prettyprint"># 查看nameServer日志
tail -500f /opt/module/rabbitmq/logs/rocketmqlogs/namesrv.log
# 查看broker日志
tail -500f /opt/module/rabbitmq/logs/rocketmqlogs/broker.log
</code></pre>
<h2 id="监控程序"><a href="#监控程序" class="headerlink" title="监控程序"></a>监控程序</h2><h3 id="下载rocketmq-console"><a href="#下载rocketmq-console" class="headerlink" title="下载rocketmq-console"></a>下载<code>rocketmq-console</code></h3><p><a href="https://github.com/apache/rocketmq-externals">https://github.com/apache/rocketmq-externals</a></p>
<p><code>git clone -b release-rocketmq-console-1.0.0 https://github.com/apache/rocketmq-externals</code></p>
<p>修改配置文件rocketmq.config.namesrvAddr&#x3D;192.168.101.123:9876</p>
<p>然后打包启动</p>
<p>访问<a href="http://localhost:8080/">http://localhost:8080</a></p>
<img src="/2022/04/23/centos7-shou-dong-an-zhuang-rocketmq/image-20220423212702216.png" class="asset-class" title="image-20220423212702216">

]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>中文锚点跳转问题修复</title>
    <url>/2022/04/24/zhong-wen-mao-dian-tiao-zhuan-wen-ti-xiu-fu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>在content.ejs下增加脚本，将h标签的id调用<code>encodeURIComponent</code>使得和toc生成的锚点对应</li>
</ul>
<pre><code class="prettyprint">&lt;script&gt;
    //解决中文转义无法跳转锚点问题
    var blog = document.querySelector(&quot;#blog-content&quot;);
    var content = blog.innerHTML;
    var regExp2 = /&lt;h([1-6]) id=\&quot;(\S*?)\&quot;&gt;/g;
    var	data = content.replace(regExp2, function(word,i)&#123;
        var ws = word.split(&quot;\&quot;&quot;);
            return ws[0]+&quot;\&quot;&quot;+encodeURIComponent(ws[1])+&quot;\&quot;&quot;+ws[2];
        &#125;,&quot;g&quot;);
    blog.innerHTML = data;
&lt;/script&gt;
</code></pre>
<p>hexo无法在powershell使用</p>
<pre><code class="prettyprint">Set-ExecutionPolicy -ExecutionPolicy UNRESTRICTED
</code></pre>
<h3 id="这是标题一"><a href="#这是标题一" class="headerlink" title="这是标题一"></a>这是标题一</h3><img src="/2022/04/24/zhong-wen-mao-dian-tiao-zhuan-wen-ti-xiu-fu/image-20220528141523254.png" class="asset-class" title="image-20220528141523254">

<center class="half">
    <img src="/2022/04/24/zhong-wen-mao-dian-tiao-zhuan-wen-ti-xiu-fu/image-20220528141523254.png" class="asset-class" width="300" height="200" title="image-20220528141523254.png">
    <img src="/2022/04/24/zhong-wen-mao-dian-tiao-zhuan-wen-ti-xiu-fu/image-20220528141523254.png" class="asset-class" width="300" height="200" title="image-20220528141523254.png">
</center>

<h4 id="这是标题一一"><a href="#这是标题一一" class="headerlink" title="这是标题一一"></a>这是标题一一</h4><pre><code># msi文件权限不够
# 以管理员命令启动cmd
# 进入msi所在目录
# 执行脚本   msiexec /package xxxx.msi
#
#
#
#
</code></pre>
<h3 id="这是标题二"><a href="#这是标题二" class="headerlink" title="这是标题二"></a>这是标题二</h3><h4 id="这是标题二二"><a href="#这是标题二二" class="headerlink" title="这是标题二二"></a>这是标题二二</h4><pre><code>#
#
#
#
#
#
#
</code></pre>
<h3 id="这是标题三"><a href="#这是标题三" class="headerlink" title="这是标题三"></a>这是标题三</h3><h4 id="这是标题三三"><a href="#这是标题三三" class="headerlink" title="这是标题三三"></a>这是标题三三</h4><pre><code>#
#
#
#
#
#
#
</code></pre>
<h3 id="这是标题四"><a href="#这是标题四" class="headerlink" title="这是标题四"></a>这是标题四</h3><h4 id="这是标题四四"><a href="#这是标题四四" class="headerlink" title="这是标题四四"></a>这是标题四四</h4><pre><code>#
#
#
#
#
#
#
</code></pre>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq之Batch模式</title>
    <url>/2022/04/25/rocketmq-zhi-batch-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;
    &lt;version&gt;4.9.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.producer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.springframework.stereotype.Component;

/**
 * @author 
 * @date 2021/10/20.
 */
@Slf4j
@Component
public class Producer &#123;
    private String producerGroup = &quot;please_rename_unique_group_name&quot;;
    private DefaultMQProducer producer;

    public Producer()&#123;
        //示例生产者
        producer = new DefaultMQProducer(producerGroup);
        //不开启vip通道 开通口端口会减2
        producer.setVipChannelEnabled(false);
        //绑定name server
        producer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        start();
    &#125;
    /**
     * 对象在使用之前必须要调用一次，只能初始化一次
     */
    public void start()&#123;
        try &#123;
            this.producer.start();
        &#125; catch (MQClientException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public DefaultMQProducer getProducer()&#123;
        return this.producer;
    &#125;
    /**
     * 一般在应用上下文，使用上下文监听器，进行关闭
     */
    public void shutdown()&#123;
        this.producer.shutdown();
    &#125;
&#125;
</code></pre>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.consumer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;

/**
 * @author 
 * @date 2021/10/20.
 */
@Slf4j
@Component
public class BatchConsumer &#123;

    /**
     * 消费者实体对象
     */
    private DefaultMQPushConsumer consumer;
    /**
     * 主题名称 主题一般是服务器设置好 而不能在代码里去新建topic（ 如果没有创建好，生产者往该主题发送消息 会报找不到topic错误）
     */
    public static final String TOPIC = &quot;TOPIC_BATCH_CONSUMER&quot;;
    /**
     * 消费者组
     */
    public static final String CONSUMER_GROUP = &quot;batch_group_name&quot;;
    /**
     * 通过构造函数 实例化对象
     */
    public BatchConsumer() throws MQClientException &#123;

        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
        consumer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        //消费模式:一个新的订阅组第一次启动从队列的最后位置开始消费 后续再启动接着上次消费的进度开始消费
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);
        //订阅主题和 标签（ * 代表所有标签)下信息
        consumer.subscribe(TOPIC, &quot;*&quot;);
        // //注册消费的监听 并在此监听中消费信息，并返回消费的状态信息
        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;
            // msgs中只收集同一个topic，同一个tag，并且key相同的message
            // 会把不同的消息分别放置到不同的队列中
            try &#123;
                for (Message msg : msgs) &#123;

                    //消费者获取消息 这里只输出 不做后面逻辑处理
                    String body = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);
                    log.info(&quot;Batch-Consumer-获取消息-主题topic为=&#123;&#125;, 消费消息为=&#123;&#125;&quot;, msg.getTopic(), body);
                &#125;
            &#125; catch (UnsupportedEncodingException e) &#123;
                e.printStackTrace();
                return ConsumeConcurrentlyStatus.RECONSUME_LATER;
            &#125;
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        &#125;);

        consumer.start();
        System.out.println(&quot;BatchConsumer消费者 启动成功=======&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.web;

import com.pengpeng.rocketmq.consumer.BatchConsumer;
import com.pengpeng.rocketmq.consumer.Consumer;
import com.pengpeng.rocketmq.producer.Producer;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.List;

/**
 * Describe:
 * Created by AlexP on 2022/4/25.
 */
@Slf4j
@RestController
@RequestMapping(&quot;/batch&quot;)
public class BatchController &#123;
    @Autowired
    private Producer producer;

    @RequestMapping(&quot;/batchProducer&quot;)
    public Object batchProducer() throws Exception &#123;
        List&lt;Message&gt; messages = new ArrayList&lt;&gt;();
        //总共发送五次消息
        for (int i = 0; i &lt; 20; i++) &#123;
            //创建生产信息
            Message message = new Message(BatchConsumer.TOPIC, &quot;BatchTagA&quot;, (&quot;Hello RocketMQ:&quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
            messages.add(message);
        &#125;
        //发送
        SendResult sendResult = producer.getProducer().send(messages);
        log.info(&quot;输出生产者信息=&#123;&#125;&quot;,sendResult);
        return &quot;成功&quot;;
    &#125;

    /**
     * 仅当您发送大批量时，复杂性才会增加，您可能不确定它是否超过大小限制（1MiB）。此时，您最好拆分列表
     * @return
     * @throws Exception
     */
    @RequestMapping(&quot;/splitterProducer&quot;)
    public Object splitterProducer() throws Exception &#123;
        List&lt;Message&gt; messages = new ArrayList&lt;&gt;();
        //总共发送五次消息
        for (int i = 0; i &lt; 20; i++) &#123;
            //创建生产信息
            Message message = new Message(BatchConsumer.TOPIC, &quot;BatchTagA&quot;, (&quot;Hello RocketMQ:&quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
            messages.add(message);
        &#125;
        //then you could split the large list into small ones:
        ListSplitter splitter = new ListSplitter(messages);
        while (splitter.hasNext()) &#123;
            try &#123;
                List&lt;Message&gt;  listItem = splitter.next();
                SendResult sendResult =producer.getProducer().send(listItem);
                log.info(&quot;输出生产者信息=&#123;&#125;&quot;,sendResult);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
                //handle the error
            &#125;
        &#125;
        return &quot;成功&quot;;
    &#125;
&#125;
</code></pre>
<h4 id="数据拆分工具"><a href="#数据拆分工具" class="headerlink" title="数据拆分工具"></a>数据拆分工具</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.web;

import org.apache.rocketmq.common.message.Message;

import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * Describe:
 * Created by AlexP on 2022/4/25.
 */
public class ListSplitter implements Iterator&lt;List&lt;Message&gt;&gt; &#123;
    private static final int SIZE_LIMIT = 1000 * 1000;
    private final List&lt;Message&gt; messages;
    private int currIndex;
    public ListSplitter(List&lt;Message&gt; messages) &#123;
        this.messages = messages;
    &#125;
    @Override public boolean hasNext() &#123;
        return currIndex &lt; messages.size();
    &#125;
    @Override public List&lt;Message&gt; next() &#123;
        int nextIndex = currIndex;
        int totalSize = 0;
        for (; nextIndex &lt; messages.size(); nextIndex++) &#123;
            Message message = messages.get(nextIndex);
            int tmpSize = message.getTopic().length() + message.getBody().length;
            Map&lt;String, String&gt; properties = message.getProperties();
            for (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;
                tmpSize += entry.getKey().length() + entry.getValue().length();
            &#125;
            //for log overhead
            tmpSize = tmpSize + 20;
            if (tmpSize &gt; SIZE_LIMIT) &#123;
                //it is unexpected that single message exceeds the SIZE_LIMIT
                //here just let it go, otherwise it will block the splitting process
                if (nextIndex - currIndex == 0) &#123;
                    //if the next sublist has no element, add this one and then break, otherwise just break
                    nextIndex++;
                &#125;
                break;
            &#125;
            if (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;
                break;
            &#125; else &#123;
                totalSize += tmpSize;
            &#125;

        &#125;
        List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);
        currIndex = nextIndex;
        return subList;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq之Filter模式</title>
    <url>/2022/04/25/rocketmq-zhi-filter-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;
    &lt;version&gt;4.9.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.producer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.springframework.stereotype.Component;

/**
 * @author 彭鹏
 * @date 2021/10/20.
 */
@Slf4j
@Component
public class FilterProducer &#123;
    private String producerGroup = &quot;filter_group_name&quot;;
    private DefaultMQProducer producer;

    public FilterProducer()&#123;
        //示例生产者
        producer = new DefaultMQProducer(producerGroup);
        //不开启vip通道 开通口端口会减2
        producer.setVipChannelEnabled(false);
        //绑定name server
        producer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        start();
    &#125;
    /**
     * 对象在使用之前必须要调用一次，只能初始化一次
     */
    public void start()&#123;
        try &#123;
            this.producer.start();
        &#125; catch (MQClientException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public DefaultMQProducer getProducer()&#123;
        return this.producer;
    &#125;
    /**
     * 一般在应用上下文，使用上下文监听器，进行关闭
     */
    public void shutdown()&#123;
        this.producer.shutdown();
    &#125;
&#125;
</code></pre>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.consumer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.MessageSelector;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;

/**
 * @author 
 * @date 2021/10/20.
 * borker服务需要配置 broker.conf   enablePropertyFilter=true
 */
@Slf4j
@Component
public class FilterConsumer &#123;

    /**
     * 消费者实体对象
     */
    private DefaultMQPushConsumer consumer;
    /**
     * 主题名称 主题一般是服务器设置好 而不能在代码里去新建topic（ 如果没有创建好，生产者往该主题发送消息 会报找不到topic错误）
     */
    public static final String TOPIC = &quot;TOPIC_FILTER_CONSUMER&quot;;
    /**
     * 消费者组
     */
    public static final String CONSUMER_GROUP = &quot;filter_group_name&quot;;
    /**
     * 通过构造函数 实例化对象
     */
    public FilterConsumer() throws MQClientException &#123;

        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
        consumer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        //消费模式:一个新的订阅组第一次启动从队列的最后位置开始消费 后续再启动接着上次消费的进度开始消费
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);
        // only subsribe messages have property a, also a &gt;=0 and a &lt;= 3 sql模式 默认Tag, *表示所有，|| 多个
        consumer.subscribe(TOPIC, MessageSelector.bySql(&quot;a between 0 and 3&quot;));
        // //注册消费的监听 并在此监听中消费信息，并返回消费的状态信息
        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;
            // msgs中只收集同一个topic，同一个tag，并且key相同的message
            // 会把不同的消息分别放置到不同的队列中
            try &#123;
                for (Message msg : msgs) &#123;

                    //消费者获取消息 这里只输出 不做后面逻辑处理
                    String body = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);
                    log.info(&quot;FilterConsumer-获取消息-主题topic为=&#123;&#125;, 消费消息为=&#123;&#125;&quot;, msg.getTopic(), body);
                &#125;
            &#125; catch (UnsupportedEncodingException e) &#123;
                e.printStackTrace();
                return ConsumeConcurrentlyStatus.RECONSUME_LATER;
            &#125;
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        &#125;);

        consumer.start();
        System.out.println(&quot;FilterConsumer消费者 启动成功=======&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.web;

import com.pengpeng.rocketmq.consumer.FilterConsumer;
import com.pengpeng.rocketmq.producer.FilterProducer;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author  
 * @date 2021/10/25.
 */
@Slf4j
@RestController
@RequestMapping(&quot;/filter&quot;)
public class FilterController &#123;

    @Autowired
    private FilterProducer producer;

    @RequestMapping(&quot;/filterProducer&quot;)
    public Object filterProducer() throws Exception &#123;
        int totalMessagesToSend = 20;
        for (int i = 0; i &lt; totalMessagesToSend; i++) &#123;
            Message msg = new Message(FilterConsumer.TOPIC,
                    &quot;filter1&quot;,
                    (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET)
            );
            // Set some properties.
            msg.putUserProperty(&quot;a&quot;, String.valueOf(i));
            // Send the message
            SendResult sendResult = producer.getProducer().send(msg);
            System.out.printf(&quot;%s%n&quot;, sendResult);
        &#125;
        return &quot;成功&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq之Order模式</title>
    <url>/2022/04/25/rocketmq-zhi-order-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;
    &lt;version&gt;4.9.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.producer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.springframework.stereotype.Component;

/**
 * @author 
 * @date 2021/10/25.
 */
@Slf4j
@Component
public class OrderedProducer &#123;
    private String producerGroup = &quot;ordered_group_name&quot;;
    private DefaultMQProducer producer;

    public OrderedProducer()&#123;
        //示例生产者
        producer = new DefaultMQProducer(producerGroup);
        //不开启vip通道 开通口端口会减2
        producer.setVipChannelEnabled(false);
        //绑定name server
        producer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        start();
    &#125;
    /**
     * 对象在使用之前必须要调用一次，只能初始化一次
     */
    public void start()&#123;
        try &#123;
            this.producer.start();
        &#125; catch (MQClientException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public DefaultMQProducer getProducer()&#123;
        return this.producer;
    &#125;
    /**
     * 一般在应用上下文，使用上下文监听器，进行关闭
     */
    public void shutdown()&#123;
        this.producer.shutdown();
    &#125;
&#125;
</code></pre>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.consumer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;
import org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageExt;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;

/**
 * @author 
 * @date 2021/10/25.
 */
@Slf4j
@Component
public class OrderedConsumer &#123;

    /**
     * 消费者实体对象
     */
    private DefaultMQPushConsumer consumer;
    /**
     * 消费者组
     */
    public static final String CONSUMER_GROUP = &quot;ordered_group_name&quot;;

    public static final String TOPIC = &quot;TOPIC_ORDERED_CONSUMER&quot;;
    /**
     * 通过构造函数 实例化对象
     */
    public OrderedConsumer() throws MQClientException &#123;

        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
        consumer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        //消费模式:一个新的订阅组第一次启动从队列的最后位置开始消费 后续再启动接着上次消费的进度开始消费
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
        //订阅主题和 标签（ * 代表所有标签)下信息
        consumer.subscribe(TOPIC, &quot;TagB || TagC || TagD|| TagE || TagF&quot;);
        // //注册消费的监听 并在此监听中消费信息，并返回消费的状态信息
        consumer.registerMessageListener(new MessageListenerOrderly() &#123;
            AtomicLong consumeTimes = new AtomicLong(0);
            @SneakyThrows
            @Override
            public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,
                                                       ConsumeOrderlyContext context) &#123;
                context.setAutoCommit(true);
                for (Message msg : msgs) &#123;
                    //消费者获取消息 这里只输出 不做后面逻辑处理
                    String body = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);
                    log.info(&quot;OrderConsumer-获取消息-主题topic为=&#123;&#125;, 消费消息为=&#123;&#125;&quot;, msg.getTopic(), body);
                &#125;
                this.consumeTimes.incrementAndGet();
                if ((this.consumeTimes.get() % 2) == 0) &#123;
                    return ConsumeOrderlyStatus.SUCCESS;
                &#125; else if ((this.consumeTimes.get() % 3) == 0) &#123;
                    return ConsumeOrderlyStatus.ROLLBACK;
                &#125; else if ((this.consumeTimes.get() % 4) == 0) &#123;
                    return ConsumeOrderlyStatus.COMMIT;
                &#125; else if ((this.consumeTimes.get() % 5) == 0) &#123;
                    context.setSuspendCurrentQueueTimeMillis(3000);
                    return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;
                &#125;
                return ConsumeOrderlyStatus.SUCCESS;

            &#125;
        &#125;);

        consumer.start();
        System.out.println(&quot;OrderedConsumer消费者 启动成功=======&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.web;

import com.pengpeng.rocketmq.consumer.OrderedConsumer;
import com.pengpeng.rocketmq.producer.OrderedProducer;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.producer.MessageQueueSelector;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageQueue;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * @author 彭鹏 顺序消息
 * @date 2021/10/25.
 */
@Slf4j
@RestController
@RequestMapping(&quot;/ordered&quot;)
public class OrderedController &#123;

    @Autowired
    private OrderedProducer producer;

    @RequestMapping(&quot;/orderedProducer&quot;)
    public Object orderedProducer() throws Exception &#123;
        String[] tags = new String[] &#123;&quot;TagB&quot;, &quot;TagC&quot;, &quot;TagD&quot;, &quot;TagE&quot;, &quot;TagF&quot;&#125;;
        for (int i = 1; i &lt; 21; i++) &#123;
            int orderId = i % 5;
            //Create a message instance, specifying topic, tag and message body.
            Message msg = new Message(OrderedConsumer.TOPIC, tags[i % tags.length], &quot;KEY&quot; + i,
                    (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
            /**
             * 1、消息对象
             * 2、消息队列的选择器
             * 3、选择队列的业务标识（orderId）
             */
            SendResult sendResult = producer.getProducer().send(msg, new MessageQueueSelector() &#123;
                /**
                 *
                 * @param mqs 队列集合
                 * @param msg 消息对象
                 * @param arg 业务标识参数 orderId
                 * @return
                 */
                @Override
                public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;
                    Integer id = (Integer) arg;
                    int index = id % mqs.size();
                    return mqs.get(index);
                &#125;
            &#125;, orderId);

            System.out.printf(&quot;%s%n&quot;, sendResult);
        &#125;
        return &quot;成功&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq之Schedule模式</title>
    <url>/2022/04/25/rocketmq-zhi-schedule-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;
    &lt;version&gt;4.9.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.producer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.springframework.stereotype.Component;

/**
 * @author 
 * @date 2021/10/20.
 */
@Slf4j
@Component
public class ScheduleProducer &#123;
    private String producerGroup = &quot;schedule_group_name&quot;;
    private DefaultMQProducer producer;

    public ScheduleProducer()&#123;
        //示例生产者
        producer = new DefaultMQProducer(producerGroup);
        //不开启vip通道 开通口端口会减2
        producer.setVipChannelEnabled(false);
        //绑定name server
        producer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        start();
    &#125;
    /**
     * 对象在使用之前必须要调用一次，只能初始化一次
     */
    public void start()&#123;
        try &#123;
            this.producer.start();
        &#125; catch (MQClientException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public DefaultMQProducer getProducer()&#123;
        return this.producer;
    &#125;
    /**
     * 一般在应用上下文，使用上下文监听器，进行关闭
     */
    public void shutdown()&#123;
        this.producer.shutdown();
    &#125;
&#125;
</code></pre>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.consumer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.MessageExt;
import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.stereotype.Component;

import java.util.List;

/**
 * @author 
 * @date 2021/10/25.
 */
@Slf4j
@Component
public class ScheduleConsumer &#123;
    /**
     * 消费者实体对象
     */
    private DefaultMQPushConsumer consumer;
    /**
     * 主题名称 主题一般是服务器设置好 而不能在代码里去新建topic（ 如果没有创建好，生产者往该主题发送消息 会报找不到topic错误）
     */
    public static final String TOPIC = &quot;TOPIC_SCHEDULE_CONSUMER&quot;;
    /**
     * 消费者组
     */
    public static final String CONSUMER_GROUP = &quot;schedule_group_name&quot;;

    /**
     * 通过构造函数 实例化对象
     */
    public ScheduleConsumer() throws MQClientException &#123;
        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
        consumer.setNamesrvAddr(JmsConfig.NAME_SERVER);

        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);

        consumer.subscribe(TOPIC, &quot;SCHEDULE1 || SCHEDULE2 || SCHEDULE3&quot;);

        consumer.registerMessageListener(new MessageListenerConcurrently() &#123;
            @SneakyThrows
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context) &#123;
                for (MessageExt msg : messages) &#123;
                    // Print approximate delay time period
                    String body = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);
                    log.info(&quot;ScheduleConsumer-获取消息-主题topic为=&#123;&#125;, 消费消息为=&#123;&#125;, 消息id=&#123;&#125;,&#123;&#125;ms&quot;,
                            msg.getTopic(), body,msg.getMsgId(),(System.currentTimeMillis() - msg.getStoreTimestamp()));
                &#125;
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            &#125;
        &#125;);

        consumer.start();
        System.out.println(&quot;ScheduledConsumer 消费者 启动成功=======&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.web;

import com.pengpeng.rocketmq.consumer.ScheduleConsumer;
import com.pengpeng.rocketmq.producer.OrderedProducer;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * @author 彭鹏 顺序消息
 * @date 2021/10/25.
 */
@Slf4j
@RestController
@RequestMapping(&quot;/schedule&quot;)
public class ScheduleController &#123;

    @Autowired
    private OrderedProducer producer;

    @RequestMapping(&quot;/scheduleProducer&quot;)
    public Object scheduleProducer() throws Exception &#123;
        int totalMessagesToSend = 20;
        for (int i = 0; i &lt; totalMessagesToSend; i++) &#123;
            Message message = new Message(ScheduleConsumer.TOPIC,&quot;SCHEDULE1&quot;, (&quot;Hello scheduled message &quot; + i).getBytes());

            /*
            *  delivered
            *  1s  5s  10s 30s 1m  2m  3m  4m  5m  6m  7m  8m  9m  10m 20m 30m 1h  2h
            *  1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18
            * */
            // This message will be delivered to consumer 10 seconds later.
            message.setDelayTimeLevel(3);
            // Send the message
            SendResult sendResult = producer.getProducer().send(message);
            System.out.printf(&quot;%s%n&quot;, sendResult);
        &#125;
        return &quot;成功&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq之事务模式</title>
    <url>/2022/04/25/rocketmq-zhi-shi-wu-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;
    &lt;version&gt;4.9.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.producer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.apache.rocketmq.client.producer.TransactionListener;
import org.apache.rocketmq.client.producer.TransactionMQProducer;
import org.springframework.stereotype.Component;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @author 
 * @date 2021/10/20.
 */
@Slf4j
@Component
public class TransactionProducer &#123;
    private String producerGroup = &quot;transaction_group_name&quot;;
    private TransactionMQProducer producer;

    public TransactionProducer()&#123;
        TransactionListener transactionListener = new TransactionListenerImpl();
        producer = new TransactionMQProducer(producerGroup);
        ExecutorService executorService = new ThreadPoolExecutor(2, 5, 100, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2000), new ThreadFactory() &#123;
            @Override
            public Thread newThread(Runnable r) &#123;
                Thread thread = new Thread(r);
                thread.setName(&quot;client-transaction-msg-check-thread&quot;);
                return thread;
            &#125;
        &#125;);

        producer.setExecutorService(executorService);
        //添加事务监听器
        producer.setTransactionListener(transactionListener);
        start();
    &#125;
    /**
     * 对象在使用之前必须要调用一次，只能初始化一次
     */
    public void start()&#123;
        try &#123;
            this.producer.start();
        &#125; catch (MQClientException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public DefaultMQProducer getProducer()&#123;
        return this.producer;
    &#125;
    /**
     * 一般在应用上下文，使用上下文监听器，进行关闭
     */
    public void shutdown()&#123;
        this.producer.shutdown();
    &#125;
&#125;
</code></pre>
<h4 id="事务监听"><a href="#事务监听" class="headerlink" title="事务监听"></a>事务监听</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.producer;

import org.apache.rocketmq.client.producer.LocalTransactionState;
import org.apache.rocketmq.client.producer.TransactionListener;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageExt;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * @author 
 * @date 2021/10/26.
 */
public class TransactionListenerImpl implements TransactionListener &#123;
    private AtomicInteger transactionIndex = new AtomicInteger(0);

    private ConcurrentHashMap&lt;String, Integer&gt; localTrans = new ConcurrentHashMap&lt;&gt;();

    /**
    * 在该方法中执行本地事务
    * @param msg
    * @param arg
    * @return
    */
    @Override
    public LocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;
        int value = transactionIndex.getAndIncrement();
        int status = value % 3;
        localTrans.put(msg.getTransactionId(), status);
        return LocalTransactionState.UNKNOW;
    &#125;
    /**
    * 该方法是MQ进行消息事务状态回查
    * @param msg
    * @return
    */
    @Override
    public LocalTransactionState checkLocalTransaction(MessageExt msg) &#123;
        Integer status = localTrans.get(msg.getTransactionId());
        if (null != status) &#123;
            switch (status) &#123;
                case 0:
                    return LocalTransactionState.UNKNOW;
                case 1:
                    return LocalTransactionState.COMMIT_MESSAGE;
                case 2:
                    return LocalTransactionState.ROLLBACK_MESSAGE;
            &#125;
        &#125;
        return LocalTransactionState.COMMIT_MESSAGE;
    &#125;
&#125;
</code></pre>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.consumer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;

/**
 * @author 
 * @date 2021/10/20.
 */
@Slf4j
@Component
public class TransactionConsumer &#123;

    /**
     * 消费者实体对象
     */
    private DefaultMQPushConsumer consumer;
    /**
     * 主题名称 主题一般是服务器设置好 而不能在代码里去新建topic（ 如果没有创建好，生产者往该主题发送消息 会报找不到topic错误）
     */
    public static final String TOPIC = &quot;TOPIC_TANSACTION_CONSUMER&quot;;
    /**
     * 消费者组
     */
    public static final String CONSUMER_GROUP = &quot;transaction_group_name&quot;;
    /**
     * 通过构造函数 实例化对象
     */
    public TransactionConsumer() throws MQClientException &#123;

        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
        consumer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        //消费模式:一个新的订阅组第一次启动从队列的最后位置开始消费 后续再启动接着上次消费的进度开始消费
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);
        //订阅主题和 标签（ * 代表所有标签)下信息
        consumer.subscribe(TOPIC, &quot;*&quot;);
        // //注册消费的监听 并在此监听中消费信息，并返回消费的状态信息
        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;
            // msgs中只收集同一个topic，同一个tag，并且key相同的message
            // 会把不同的消息分别放置到不同的队列中
            try &#123;
                for (Message msg : msgs) &#123;

                    //消费者获取消息 这里只输出 不做后面逻辑处理
                    String body = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);
                    log.info(&quot;TransactionConsumer-获取消息-主题topic为=&#123;&#125;, 消费消息为=&#123;&#125;&quot;, msg.getTopic(), body);
                &#125;
            &#125; catch (UnsupportedEncodingException e) &#123;
                e.printStackTrace();
                return ConsumeConcurrentlyStatus.RECONSUME_LATER;
            &#125;
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        &#125;);

        consumer.start();
        System.out.println(&quot;TransactionConsumer消费者 启动成功=======&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.web;

import com.pengpeng.rocketmq.consumer.TransactionConsumer;
import com.pengpeng.rocketmq.producer.TransactionProducer;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.UnsupportedEncodingException;

/**
 * @author  顺序消息
 * @date 2021/10/25.
 */
@Slf4j
@RestController
@RequestMapping(&quot;/transaction&quot;)
public class TransactionController &#123;

    @Autowired
    private TransactionProducer producer;

    @RequestMapping(&quot;/transactionProducer&quot;)
    public Object transactionProducer() throws Exception &#123;
        String[] tags = new String[] &#123;&quot;TagA&quot;, &quot;TagB&quot;, &quot;TagC&quot;, &quot;TagD&quot;, &quot;TagE&quot;&#125;;
        for (int i = 0; i &lt; 10; i++) &#123;
            try &#123;
                Message msg =
                        new Message(TransactionConsumer.TOPIC, tags[i % tags.length], &quot;KEY&quot; + i,
                                (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
                SendResult sendResult = producer.getProducer().sendMessageInTransaction(msg, null);
                System.out.printf(&quot;%s%n&quot;, sendResult);

                Thread.sleep(10);
            &#125; catch (MQClientException | UnsupportedEncodingException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        for (int i = 0; i &lt; 100000; i++) &#123;
            Thread.sleep(1000);
        &#125;
        return &quot;成功&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq之广播模式</title>
    <url>/2022/04/25/rocketmq-zhi-guang-bo-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;
    &lt;version&gt;4.9.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.producer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.springframework.stereotype.Component;

/**
 * @author 
 * @date 2021/10/25.
 */
@Slf4j
@Component
public class BroadcastProducer &#123;
    private String producerGroup = &quot;broadcast_group_name&quot;;
    private DefaultMQProducer producer;

    public BroadcastProducer()&#123;
        //示例生产者
        producer = new DefaultMQProducer(producerGroup);
        //不开启vip通道 开通口端口会减2
        producer.setVipChannelEnabled(false);
        //绑定name server
        producer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        start();
    &#125;
    /**
     * 对象在使用之前必须要调用一次，只能初始化一次
     */
    public void start()&#123;
        try &#123;
            this.producer.start();
        &#125; catch (MQClientException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public DefaultMQProducer getProducer()&#123;
        return this.producer;
    &#125;
    /**
     * 一般在应用上下文，使用上下文监听器，进行关闭
     */
    public void shutdown()&#123;
        this.producer.shutdown();
    &#125;
&#125;
</code></pre>
<h4 id="消费者1"><a href="#消费者1" class="headerlink" title="消费者1"></a>消费者1</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.consumer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageExt;
import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;
import java.util.List;


/**
 * @author 
 * @date 2021/10/25.
 * 广播需要多个消费者
 */
@Slf4j
@Component
public class BroadcastConsumer &#123;
    /**
     * 消费者实体对象
     */
    private DefaultMQPushConsumer consumer;
    /**
     * 主题名称 主题一般是服务器设置好 而不能在代码里去新建topic（ 如果没有创建好，生产者往该主题发送消息 会报找不到topic错误）
     */
    public static final String TOPIC = &quot;TOPIC_BROADCAST_CONSUMER&quot;;
    /**
     * 消费者组
     */
    public static final String CONSUMER_GROUP = &quot;broadcast_group_name&quot;;

    /**
     * 通过构造函数 实例化对象
     */
    public BroadcastConsumer() throws MQClientException &#123;
        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
        consumer.setNamesrvAddr(JmsConfig.NAME_SERVER);

        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
       //设置消费模式：负载均衡|广播模式(默认负载均衡)
        consumer.setMessageModel(MessageModel.BROADCASTING);

        consumer.subscribe(TOPIC, &quot;Broadcast1 || Broadcast3 || Broadcast5&quot;);

        consumer.registerMessageListener(new MessageListenerConcurrently() &#123;

            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,
                                                            ConsumeConcurrentlyContext context) &#123;
                try &#123;
                    for (Message msg : msgs) &#123;

                        //消费者获取消息 这里只输出 不做后面逻辑处理
                        String body = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);
                        log.info(&quot;BroadcastConsumer-获取消息-主题topic为=&#123;&#125;, 消费消息为=&#123;&#125;&quot;, msg.getTopic(), body);
                    &#125;
                &#125; catch (UnsupportedEncodingException e) &#123;
                    e.printStackTrace();
                    return ConsumeConcurrentlyStatus.RECONSUME_LATER;
                &#125;
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            &#125;
        &#125;);

        consumer.start();
        System.out.println(&quot;BroadcastConsumer消费者 启动成功=======&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="消费者2"><a href="#消费者2" class="headerlink" title="消费者2"></a>消费者2</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.consumer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageExt;
import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;
import java.util.List;


/**
 * @author 
 * @date 2021/10/25.
 */
@Slf4j
@Component
public class BroadcastConsumer2 &#123;
    /**
     * 消费者实体对象
     */
    private DefaultMQPushConsumer consumer;
    /**
     * 主题名称 主题一般是服务器设置好 而不能在代码里去新建topic（ 如果没有创建好，生产者往该主题发送消息 会报找不到topic错误）
     */
    public static final String TOPIC = &quot;TOPIC_BROADCAST_CONSUMER&quot;;
    /**
     * 消费者组
     */
    public static final String CONSUMER_GROUP = &quot;broadcast_group_name2&quot;;

    /**
     * 通过构造函数 实例化对象
     */
    public BroadcastConsumer2() throws MQClientException &#123;
        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
        consumer.setNamesrvAddr(JmsConfig.NAME_SERVER);

        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
        //设置消费模式：负载均衡|广播模式(默认负载均衡)
        consumer.setMessageModel(MessageModel.BROADCASTING);

        consumer.subscribe(TOPIC, &quot;Broadcast1 || Broadcast2 || Broadcast3&quot;);

        consumer.registerMessageListener(new MessageListenerConcurrently() &#123;

            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,
                                                            ConsumeConcurrentlyContext context) &#123;
                try &#123;
                    for (Message msg : msgs) &#123;

                        //消费者获取消息 这里只输出 不做后面逻辑处理
                        String body = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);
                        log.info(&quot;BroadcastConsumer2-获取消息-主题topic为=&#123;&#125;, 消费消息为=&#123;&#125;&quot;, msg.getTopic(), body);
                    &#125;
                &#125; catch (UnsupportedEncodingException e) &#123;
                    e.printStackTrace();
                    return ConsumeConcurrentlyStatus.RECONSUME_LATER;
                &#125;
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            &#125;
        &#125;);

        consumer.start();
        System.out.println(&quot;BroadcastConsumer2消费者 启动成功=======&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.web;

import com.pengpeng.rocketmq.consumer.BroadcastConsumer;
import com.pengpeng.rocketmq.producer.BroadcastProducer;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


/**
 * @author 彭鹏  广播消息
 * @date 2021/10/25.
 */
@Slf4j
@RestController
@RequestMapping(&quot;/broadcast&quot;)
public class BroadcastController &#123;

    @Autowired
    private BroadcastProducer producer;

    @RequestMapping(&quot;/broadcastProducer&quot;)
    public Object broadcastProducer() throws Exception &#123;
        for (int i = 0; i &lt; 15; i++) &#123;
            Message msg = new Message(BroadcastConsumer.TOPIC,
                    &quot;Broadcast1&quot;,
                    &quot;OrderID111&quot;,
                    &quot;Hello world&quot;.getBytes(RemotingHelper.DEFAULT_CHARSET));
            SendResult sendResult = producer.getProducer().send(msg);
            System.out.printf(&quot;%s%n&quot;, sendResult);
        &#125;
        Thread.sleep(5000);
        return &quot;成功&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq快速入门</title>
    <url>/2022/04/25/rocketmq-kuai-su-ru-men/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="prettyprint">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;
    &lt;version&gt;4.9.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="提供者"><a href="#提供者" class="headerlink" title="提供者"></a>提供者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.producer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.springframework.stereotype.Component;

/**
 * @author 
 * @date 2021/10/20.
 */
@Slf4j
@Component
public class Producer &#123;
    private String producerGroup = &quot;please_rename_unique_group_name&quot;;
    private DefaultMQProducer producer;

    public Producer()&#123;
        //示例生产者
        producer = new DefaultMQProducer(producerGroup);
        //不开启vip通道 开通口端口会减2
        producer.setVipChannelEnabled(false);
        //绑定name server
        producer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        start();
    &#125;
    /**
     * 对象在使用之前必须要调用一次，只能初始化一次
     */
    public void start()&#123;
        try &#123;
            this.producer.start();
        &#125; catch (MQClientException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public DefaultMQProducer getProducer()&#123;
        return this.producer;
    &#125;
    /**
     * 一般在应用上下文，使用上下文监听器，进行关闭
     */
    public void shutdown()&#123;
        this.producer.shutdown();
    &#125;
&#125;
</code></pre>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.consumer;

import com.pengpeng.rocketmq.config.JmsConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;

/**
 * @author 
 * @date 2021/10/20.
 */
@Slf4j
@Component
public class Consumer &#123;

    /**
     * 消费者实体对象
     */
    private DefaultMQPushConsumer consumer;
    /**
     * 主题名称 主题一般是服务器设置好 而不能在代码里去新建topic（ 如果没有创建好，生产者往该主题发送消息 会报找不到topic错误）
     */
    public static final String TOPIC = &quot;TOPIC_CONSUMER&quot;;
    /**
     * 消费者组
     */
    public static final String CONSUMER_GROUP = &quot;please_rename_unique_group_name&quot;;
    /**
     * 通过构造函数 实例化对象
     */
    public Consumer() throws MQClientException &#123;

        consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);
        consumer.setNamesrvAddr(JmsConfig.NAME_SERVER);
        //消费模式:一个新的订阅组第一次启动从队列的最后位置开始消费 后续再启动接着上次消费的进度开始消费
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);
        //订阅主题和 标签（ * 代表所有标签)下信息
        consumer.subscribe(TOPIC, &quot;*&quot;);
        // //注册消费的监听 并在此监听中消费信息，并返回消费的状态信息
        consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -&gt; &#123;
            // msgs中只收集同一个topic，同一个tag，并且key相同的message
            // 会把不同的消息分别放置到不同的队列中
            try &#123;
                for (Message msg : msgs) &#123;

                    //消费者获取消息 这里只输出 不做后面逻辑处理
                    String body = new String(msg.getBody(), RemotingHelper.DEFAULT_CHARSET);
                    log.info(&quot;Consumer-获取消息-主题topic为=&#123;&#125;, 消费消息为=&#123;&#125;&quot;, msg.getTopic(), body);
                &#125;
            &#125; catch (UnsupportedEncodingException e) &#123;
                e.printStackTrace();
                return ConsumeConcurrentlyStatus.RECONSUME_LATER;
            &#125;
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        &#125;);

        consumer.start();
        System.out.println(&quot;Consumer消费者 启动成功=======&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="prettyprint">package com.pengpeng.rocketmq.web;

import com.pengpeng.rocketmq.consumer.Consumer;
import com.pengpeng.rocketmq.producer.Producer;
import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.producer.SendCallback;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.concurrent.CountDownLatch;

/**
 * @author 
 * @date 2021/10/20.
 */
@Slf4j
@RestController
@RequestMapping(&quot;/test&quot;)
public class Controller &#123;

    @Autowired
    private Producer producer;

    /**
     * 可靠的同步传输广泛应用于大量场景，如重要通知消息、短信通知、短信营销系统等。
     * @return
     * @throws Exception
     */
    @RequestMapping(&quot;/syncProducer&quot;)
    public Object syncProducer() throws Exception &#123;
        //总共发送五次消息
        for (int i = 0; i &lt; 20; i++) &#123;
            //创建生产信息
            Message message = new Message(Consumer.TOPIC, &quot;TagA&quot;, (&quot;Hello RocketMQ:&quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
            //发送
            SendResult sendResult = producer.getProducer().send(message);
            log.info(&quot;输出生产者信息=&#123;&#125;&quot;,sendResult);
        &#125;
        return &quot;成功&quot;;
    &#125;

    /**
     * 异步传输通常用于响应时间敏感型业务场景。
     * @return
     * @throws Exception
     */
    @RequestMapping(&quot;/asyncProducer&quot;)
    public Object callback() throws Exception &#123;
        //总共发送五次消息
        int messageCount = 20;
        final CountDownLatch countDownLatch = new CountDownLatch(messageCount);
        for (int i = 0;i&lt;messageCount;i++) &#123;
            try &#123;

                final int index = i;
                //创建生产信息
                Message message = new Message(Consumer.TOPIC, &quot;TagA&quot;, &quot;OrderID188&quot;, (&quot;Hello World&quot;).getBytes(RemotingHelper.DEFAULT_CHARSET));
                //发送
                producer.getProducer().send(message, new SendCallback() &#123;
                    @Override
                    public void onSuccess(SendResult sendResult) &#123;
                        countDownLatch.countDown();
                        System.out.printf(&quot;%-10d OK %s %n&quot;, index, sendResult.getMsgId());
                    &#125;

                    @Override
                    public void onException(Throwable e) &#123;
                        countDownLatch.countDown();
                        System.out.printf(&quot;%-10d Exception %s %n&quot;, index, e);
                        e.printStackTrace();
                    &#125;
                &#125;);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        return &quot;成功&quot;;
    &#125;

    /**
     * 单向传输用于需要中等可靠性的情况，例如日志收集。
     * @return
     * @throws Exception
     */
    @RequestMapping(&quot;/onewayProducer&quot;)
    public Object onewayProducer() throws Exception &#123;
        //总共发送五次消息
        for (int i = 0; i &lt; 20; i++) &#123;
            //创建生产信息
            Message message = new Message(Consumer.TOPIC, &quot;TagA&quot;, (&quot;Hello RocketMQ:&quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
            //发送
            producer.getProducer().sendOneway(message);
        &#125;
        Thread.sleep(5000);
        return &quot;成功&quot;;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7安装kafka</title>
    <url>/2022/04/26/centos7-an-zhuang-kafka/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="download"><a href="#download" class="headerlink" title="download"></a>download</h4><p><a href="https://kafka.apache.org/downloads">Apache Kafka</a></p>
<p><a href="https://dlcdn.apache.org/kafka/3.1.0/kafka_2.12-3.1.0.tgz"><strong>https://dlcdn.apache.org/kafka/3.1.0/kafka_2.12-3.1.0.tgz</strong></a></p>
<h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><pre><code class="prettyprint">tar -zxvf kafka_2.12-3.1.0.tgz -C /opt/module/
</code></pre>
<h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><pre><code class="prettyprint">cd /opt/module/kafka/config
vim server.properties
vim zookeeper.properties
</code></pre>
<h5 id="修改server-properties"><a href="#修改server-properties" class="headerlink" title="修改server.properties"></a>修改server.properties</h5><pre><code class="prettyprint">#存储数据文件夹
log.dirs=/opt/module/kafka/datas
#如果集群要修改broker.id数字不重复
#broker.id=0
#集群后面改成集群配置
#zookeeper.connect=localhost:2181/kafka
</code></pre>
<h5 id="修改zookeeper-properties"><a href="#修改zookeeper-properties" class="headerlink" title="修改zookeeper.properties"></a>修改zookeeper.properties</h5><pre><code class="prettyprint">#存储数据文件夹
dataDir=/opt/module/kafka/zookeeper
</code></pre>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><pre><code class="prettyprint">cd /opt/module/kafka/bin
#先启动zookeeper
./zookeeper-server-start.sh ../config/zookeeper.properties
</code></pre>
<p>打开新的窗口启动kafka</p>
<pre><code class="prettyprint">cd /opt/module/kafka/bin
#先启动zookeeper
./kafkar-server-start.sh ../config/server.properties
</code></pre>
<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>先关闭kafka再关闭zookeeper</p>
<pre><code class="prettyprint">cd /opt/module/kafka/bin
./kafkar-server-stop.sh
./zookeeper-server-stop.sh
</code></pre>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><h5 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h5><pre><code class="prettyprint">--bootstrap-server &lt;String: server toconnect to&gt; 连接的 Kafka Broker 主机名称和端口号。
--topic &lt;String: topic&gt; 操作的 topic 名称。
--create 创建主题。
--delete 删除主题。
--alter 修改主题。
--list 查看所有主题。
--describe 查看主题详细描述。
--partitions &lt;Integer: # of partitions&gt; 设置分区数。
--replication-factor&lt;Integer: replication factor&gt; 设置分区副本。
--config &lt;String: name=value&gt; 更新系统默认的配置。
</code></pre>
<h5 id="–create-–topic"><a href="#–create-–topic" class="headerlink" title="–create –topic"></a>–create –topic</h5><pre><code class="prettyprint">cd /opt/module/kafka/bin
#集群需要设置分区
./kafka-topics.sh --create --topic first --bootstrap-server localhost:9092
</code></pre>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7安装rabbitmq</title>
    <url>/2022/04/28/centos7-an-zhuang-rabbitmq/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>安装rabbitmq需要erlang环境，推荐使用rabbitmq封装的erlang的rpm包</p>
<ul>
<li>rabbitmq软件包</li>
</ul>
<p><a href="https://www.rabbitmq.com/download.html">Downloading and Installing RabbitMQ — RabbitMQ</a></p>
<p>选择你的系统对应的安装（我的是centos7）</p>
<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428215438858.png" class="asset-class" title="image-20220428215438858">

<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428215547092.png" class="asset-class" title="image-20220428215547092">

<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428215617098.png" class="asset-class" title="image-20220428215617098">

<ul>
<li><p>erlang包</p>
<p>先找到适应版本</p>
<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428215802459.png" class="asset-class" title="image-20220428215802459"></li>
</ul>
<p>再到下载rabbitmq页面找到依赖</p>
<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428220212284.png" class="asset-class" title="image-20220428220212284">

<p>选择去仓库下载 支持的erlang</p>
<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428220427026.png" class="asset-class" title="image-20220428220427026">

<p>去github下载</p>
<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428220536750.png" class="asset-class" title="image-20220428220536750">

<p>选择自己需要的</p>
<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428220619925.png" class="asset-class" title="image-20220428220619925">

<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>将<a href="https://github.com/rabbitmq/erlang-rpm/releases/download/v23.3.4.11/erlang-23.3.4.11-1.el7.x86_64.rpm">erlang-23.3.4.11-1.el7.x86_64.rpm</a>上传到服务器</p>
<p>将<a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.9.16/rabbitmq-server-3.9.16-1.el8.noarch.rpm">rabbitmq-server-3.9.16-1.el8.noarch.rpm</a>上传到服务器</p>
<pre><code class="prettyprint">rpm -ivh erlang-23.3.4.11-1.el7.x86_64.rpm
yum install socat -y
rpm -ivh rabbitmq-server-3.9.16-1.el8.noarch.rpm

#启动 
systemctl start rabbitmq-server
#停止 
systemctl stop rabbitmq-server
#重启 
systemctl restart rabbitmq-server
#状态 
systemctl status rabbitmq-server
#开机启动
chkconfig rabbitmq-server on
#开启web管理插件
rabbitmq-plugin enable rabbitmq_management
#关闭web管理插件
rabbitmq-plugin disable rabbitmq_management
</code></pre>
<h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428221219387.png" class="asset-class" title="image-20220428221219387">

<p>默认账号密码guest无法登录</p>
<h5 id="新建账号"><a href="#新建账号" class="headerlink" title="新建账号"></a>新建账号</h5><pre><code class="prettyprint"># 设置用户
rabbitmqctl add_user admin admin
# 设置用户角色
rabbitmqctl set_user_tags admin administrator
# 设置用户权限
set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;
rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
# 查看所有用户
rabbitmqctl list_users
# 关闭应用的命令为
rabbitmqctl stop_app
# 清除的命令为
rabbitmqctl reset
# 重新启动命令为
rabbitmqctl start_app
</code></pre>
<img src="/2022/04/28/centos7-an-zhuang-rabbitmq/image-20220428221729109.png" class="asset-class" title="image-20220428221729109">

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>开启防火墙或者开放端口</li>
<li>如果时云服务器还需要开放安全组</li>
</ul>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq</title>
    <url>/2022/04/29/rabbitmq/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> <a href="%E5%B0%9A%E7%A1%85%E8%B0%B7_%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ_%E8%AF%BE%E4%BB%B6.pdf">尚硅谷_消息中间件RabbitMQ_课件.pdf</a> </p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq交换机direct</title>
    <url>/2022/05/02/rabbitmq-jiao-huan-ji-direct/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="直接模式"><a href="#直接模式" class="headerlink" title="直接模式"></a>直接模式</h4><ul>
<li>同一个交换机根据绑定的路由键消费信息</li>
</ul>
<h4 id="创建信道"><a href="#创建信道" class="headerlink" title="创建信道"></a>创建信道</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.utils;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rocpenghua.rabbitmq.config.JmsConfig;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/4/29.
 */
public class RabbitmqUtils &#123;
    public static Channel getChannel() throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(JmsConfig.HOST);
        factory.setUsername(JmsConfig.USERNAME);
        factory.setPassword(JmsConfig.PASSWORD);
        //创建链接
        Connection connection = factory.newConnection();
        //获取信道
        Channel channel = connection.createChannel();
        return channel;
    &#125;
&#125;
</code></pre>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.six;

import com.rabbitmq.client.Channel;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class DirectLog &#123;
    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();

        Map&lt;String,String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;info&quot;,&quot;这是个info消息&quot;);
        map.put(&quot;warning&quot;,&quot;这是个warning消息&quot;);
        map.put(&quot;error&quot;,&quot;这是个error消息&quot;);
        for(Map.Entry&lt;String, String&gt; entry:map.entrySet())&#123;
            channel.basicPublish(EXCHANGE_NAME, entry.getKey(), null, entry.getValue().getBytes(StandardCharsets.UTF_8));
            System.out.println(&quot;生产者发出消息：&quot; + entry.getValue());
        &#125;


    &#125;
&#125;
</code></pre>
<h4 id="消费者1"><a href="#消费者1" class="headerlink" title="消费者1"></a>消费者1</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.six;

import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class ReceiveLogsDirect01 &#123;
    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;
    private static final String EXCHANGE_TYPE = &quot;direct&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        //声明一个交换机
        channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);
        //声明一个队列
        String queueName = &quot;console&quot;;
        channel.queueDeclare(queueName,false,false,false,null);
        /*
         * 绑定交换机和队列
         */
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;info&quot;);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;warning&quot;);
        System.out.println(&quot;等待接收消息，把接收到的消息打印在屏幕上。。。。。。&quot;);
        //接受消息
        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;
            System.out.println(&quot;ReceiveLogsDirect01 控制台打印接收到的消息：&quot; + new String(message.getBody(), StandardCharsets.UTF_8));
        &#125;;
        //消费者取消消息的回调
        CancelCallback cancelCallback = consumerTag -&gt; &#123;&#125;;
        channel.basicConsume(queueName, true, deliverCallback, cancelCallback);
    &#125;
&#125;
</code></pre>
<h4 id="消费者2"><a href="#消费者2" class="headerlink" title="消费者2"></a>消费者2</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.six;

import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class ReceiveLogsDirect02 &#123;
    private static final String EXCHANGE_NAME = &quot;direct_log&quot;;
    private static final String EXCHANGE_TYPE = &quot;direct&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        //声明一个交换机
        channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);
        //声明一个队列
        String queueName = &quot;disk&quot;;
        channel.queueDeclare(queueName,false,false,false,null);
        /*
         * 绑定交换机和队列
         */
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;error&quot;);
        System.out.println(&quot;等待接收消息，把接收到的消息打印在屏幕上。。。。。。&quot;);
        //接受消息
        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;
            System.out.println(&quot;ReceiveLogsDirect02 控制台打印接收到的消息：&quot; + new String(message.getBody(), StandardCharsets.UTF_8));
        &#125;;
        //消费者取消消息的回调
        CancelCallback cancelCallback = consumerTag -&gt; &#123;&#125;;
        channel.basicConsume(queueName, true, deliverCallback, cancelCallback);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq交换机fanout</title>
    <url>/2022/05/02/rabbitmq-jiao-huan-ji-fanout/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><ul>
<li>所有的绑定该交换机，路由键的消费者都能消费信息</li>
</ul>
<h4 id="创建信道"><a href="#创建信道" class="headerlink" title="创建信道"></a>创建信道</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.utils;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rocpenghua.rabbitmq.config.JmsConfig;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/4/29.
 */
public class RabbitmqUtils &#123;
    public static Channel getChannel() throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(JmsConfig.HOST);
        factory.setUsername(JmsConfig.USERNAME);
        factory.setPassword(JmsConfig.PASSWORD);
        //创建链接
        Connection connection = factory.newConnection();
        //获取信道
        Channel channel = connection.createChannel();
        return channel;
    &#125;
&#125;
</code></pre>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.five;

import com.rabbitmq.client.Channel;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class EmitLog &#123;
    private static final String EXCHANGE_NAME = &quot;log&quot;;
    private static final String EXCHANGE_TYPE = &quot;fanout&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);

        Scanner scanner = new Scanner(System.in);

        while (scanner.hasNext()) &#123;
            String message = scanner.next();
            channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes(StandardCharsets.UTF_8));
            System.out.println(&quot;生产者发出消息：&quot; + message);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="消费者1"><a href="#消费者1" class="headerlink" title="消费者1"></a>消费者1</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.five;

import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * Describe: 消息接受
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class ReceiveLogs01 &#123;
    private static final String EXCHANGE_NAME = &quot;log&quot;;
    private static final String EXCHANGE_TYPE = &quot;fanout&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        //声明一个交换机
        channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);
        //声明一个临时队列,队列名称随机,当消费者断开连接，队列自动删除
        String queueName = channel.queueDeclare().getQueue();
        /*
         * 绑定交换机和队列
         */
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;);
        System.out.println(&quot;等待接收消息，把接收到的消息打印在屏幕上。。。。。。&quot;);
        //接受消息
        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;
            System.out.println(&quot;ReceiveLogs01控制台打印接收到的消息：&quot; + new String(message.getBody(), StandardCharsets.UTF_8));
        &#125;;
        //消费者取消消息的回调
        CancelCallback cancelCallback = consumerTag -&gt; &#123;&#125;;
        channel.basicConsume(queueName, true, deliverCallback, cancelCallback);
    &#125;
&#125;
</code></pre>
<h4 id="消费者2"><a href="#消费者2" class="headerlink" title="消费者2"></a>消费者2</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.five;

import com.rabbitmq.client.CancelCallback;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * Describe: 消息接受
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class ReceiveLogs02 &#123;
    private static final String EXCHANGE_NAME = &quot;log&quot;;
    private static final String EXCHANGE_TYPE = &quot;fanout&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        //声明一个交换机
        channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);
        //声明一个临时队列,队列名称随机,当消费者断开连接，队列自动删除
        String queueName = channel.queueDeclare().getQueue();
        /*
         * 绑定交换机和队列
         */
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;);
        System.out.println(&quot;等待接收消息，把接收到的消息打印在屏幕上。。。。。。&quot;);
        //接受消息
        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;
            System.out.println(&quot;ReceiveLogs02控制台打印接收到的消息：&quot; + new String(message.getBody(), StandardCharsets.UTF_8));
        &#125;;
        //消费者取消消息的回调
        CancelCallback cancelCallback = consumerTag -&gt; &#123;&#125;;
        channel.basicConsume(queueName, true, deliverCallback, cancelCallback);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq交换机topics</title>
    <url>/2022/05/02/rabbitmq-jiao-huan-ji-topics/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="主题模式"><a href="#主题模式" class="headerlink" title="主题模式"></a>主题模式</h4><ul>
<li>根据路由键的匹配规则消费信息<ul>
<li><code>*(星号)</code>可以代替一个单词 <ul>
<li><code>*.demo.*</code>：匹配中间为<code>demo</code>的3个单词字符串路由键</li>
<li><code>*.*.demo</code>：匹配以<code>demo</code>结尾的3个单词字符串路由键</li>
</ul>
</li>
<li><code>#(井号)</code>可以替代零个或多个单词<ul>
<li><code>demo.#</code>：匹配以<code>demo</code>开头的多个单词</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="创建信道"><a href="#创建信道" class="headerlink" title="创建信道"></a>创建信道</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.utils;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rocpenghua.rabbitmq.config.JmsConfig;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/4/29.
 */
public class RabbitmqUtils &#123;
    public static Channel getChannel() throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(JmsConfig.HOST);
        factory.setUsername(JmsConfig.USERNAME);
        factory.setPassword(JmsConfig.PASSWORD);
        //创建链接
        Connection connection = factory.newConnection();
        //获取信道
        Channel channel = connection.createChannel();
        return channel;
    &#125;
&#125;
</code></pre>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.seven;

import com.rabbitmq.client.Channel;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class EmitLogTopic &#123;
    private static final String EXCHANGE_NAME = &quot;topic_log&quot;;
    private static final String EXCHANGE_TYPE = &quot;topic&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);
        /*
         * Q1--&gt;绑定的是
         *  中间带 orange 带 3 个单词的字符串(*.orange.*)
         * Q2--&gt;绑定的是
         *  最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)
         *  第一个单词是 lazy 的多个单词(lazy.#)
         *
         */
        Map&lt;String, String&gt; bindingKeyMap = new HashMap&lt;&gt;();
        bindingKeyMap.put(&quot;quick.orange.rabbit&quot;, &quot;被队列 Q1Q2 接收到&quot;);
        bindingKeyMap.put(&quot;lazy.orange.elephant&quot;, &quot;被队列 Q1Q2 接收到&quot;);
        bindingKeyMap.put(&quot;quick.orange.fox&quot;, &quot;被队列 Q1 接收到&quot;);
        bindingKeyMap.put(&quot;lazy.brown.fox&quot;, &quot;被队列 Q2 接收到&quot;);
        bindingKeyMap.put(&quot;lazy.pink.rabbit&quot;, &quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;);
        bindingKeyMap.put(&quot;quick.brown.fox&quot;, &quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;);
        bindingKeyMap.put(&quot;quick.orange.male.rabbit&quot;, &quot;是四个单词不匹配任何绑定会被丢弃&quot;);
        bindingKeyMap.put(&quot;lazy.orange.male.rabbit&quot;, &quot;是四个单词但匹配 Q2&quot;);

        for (Map.Entry&lt;String, String&gt; entry : bindingKeyMap.entrySet()) &#123;
            String message = entry.getValue();
            channel.basicPublish(EXCHANGE_NAME, entry.getKey(), null, message.getBytes(StandardCharsets.UTF_8));
            System.out.println(&quot;生产者发出消息：&quot; + message);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="消费者1"><a href="#消费者1" class="headerlink" title="消费者1"></a>消费者1</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.seven;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class ReceiveLogsTopic01 &#123;
    private static final String EXCHANGE_NAME = &quot;topic_log&quot;;
    private static final String EXCHANGE_TYPE = &quot;topic&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);
        //声明一个队列
        String queueName = &quot;Q1&quot;;
        channel.queueDeclare(queueName, false, false, false, null);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;*.orange.*&quot;);

        System.out.println(queueName + &quot;等待消息接收。。。。。。&quot;);
        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;
            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);
            System.out.println(&quot;接受队列：&quot; + queueName + &quot;绑定键：&quot; + delivery.getEnvelope().getRoutingKey() + &quot;,消息：&quot; + message);
        &#125;;
        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; &#123;
        &#125;);
    &#125;
&#125;
</code></pre>
<h4 id="消费者2"><a href="#消费者2" class="headerlink" title="消费者2"></a>消费者2</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.seven;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/1.
 */
public class ReceiveLogsTopic02 &#123;
    private static final String EXCHANGE_NAME = &quot;topic_log&quot;;
    private static final String EXCHANGE_TYPE = &quot;topic&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE);
        //声明一个队列
        String queueName = &quot;Q2&quot;;
        channel.queueDeclare(queueName, false, false, false, null);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;*.*.rabbit&quot;);
        channel.queueBind(queueName, EXCHANGE_NAME, &quot;lazy.#&quot;);

        System.out.println(queueName + &quot;等待消息接收。。。。。。&quot;);
        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;
            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);
            System.out.println(&quot;接受队列：&quot; + queueName + &quot;绑定键：&quot; + delivery.getEnvelope().getRoutingKey() + &quot;,消息：&quot; + message);
        &#125;;
        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; &#123;
        &#125;);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq死信队列</title>
    <url>/2022/05/02/rabbitmq-si-xin-dui-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="死信队列产生的几种方式"><a href="#死信队列产生的几种方式" class="headerlink" title="死信队列产生的几种方式"></a>死信队列产生的几种方式</h4><ul>
<li><p>过期时间</p>
<ul>
<li><p>队列声明扩展参数设置过期时间</p>
<pre><code class="prettyprint">Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
arguments.put(&quot;x-message-ttl&quot;,10000);
//正常队列设置死信交换机
arguments.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE);
//设置死信RoutingKey
arguments.put(&quot;x-dead-letter-routing-key&quot;, DEAD_ROUTING_KEY);
channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);
</code></pre>
</li>
<li><p>发送消息设置过期时间</p>
<pre><code class="prettyprint">AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build();
channel.basicPublish(NORMAL_EXCHANGE,NORMAL_ROUTING_KEY,properties,message.getBytes(StandardCharsets.UTF_8));
</code></pre>
</li>
</ul>
</li>
<li><p>队列长度</p>
<ul>
<li><p>队列声明扩展参数设置队列最大长度</p>
<pre><code class="prettyprint">Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
arguments.put(&quot;x-max-length&quot;,6);
//正常队列设置死信交换机
arguments.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE);
//设置死信RoutingKey
arguments.put(&quot;x-dead-letter-routing-key&quot;, DEAD_ROUTING_KEY);
channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);
</code></pre>
</li>
</ul>
</li>
<li><p>消费拒绝</p>
<ul>
<li><p>消息接收时拒绝策略</p>
<pre><code class="prettyprint">DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;
    String msg = new String(message.getBody(), StandardCharsets.UTF_8);
    if(&quot;info5&quot;.equals(msg))&#123;
        System.out.println(&quot;Consumer01 接收的消息是:&quot; + msg+&quot;---此消息时被C1拒绝的&quot;);
        /*
                 *  消息拒绝 死信队列
                 * 1、被拒绝的消息标签
                 * 2、是否放回原队列
                 */
        channel.basicReject(message.getEnvelope().getDeliveryTag(),false);
    &#125;else &#123;
        System.out.println(&quot;Consumer01 接收的消息是:&quot; + msg);
        //消息确认
        channel.basicAck(message.getEnvelope().getDeliveryTag(),false);
    &#125;
&#125;;
//测试死信队列 应答ack为false 手动应答
channel.basicConsume(NORMAL_QUEUE, false, deliverCallback, consumerTag -&gt; &#123;
&#125;);
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><h5 id="创建信道"><a href="#创建信道" class="headerlink" title="创建信道"></a>创建信道</h5><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.utils;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rocpenghua.rabbitmq.config.JmsConfig;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/4/29.
 */
public class RabbitmqUtils &#123;
    public static Channel getChannel() throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(JmsConfig.HOST);
        factory.setUsername(JmsConfig.USERNAME);
        factory.setPassword(JmsConfig.PASSWORD);
        //创建链接
        Connection connection = factory.newConnection();
        //获取信道
        Channel channel = connection.createChannel();
        return channel;
    &#125;
&#125;
</code></pre>
<h5 id="消费者1（声明交换机和队列绑定）"><a href="#消费者1（声明交换机和队列绑定）" class="headerlink" title="消费者1（声明交换机和队列绑定）"></a>消费者1（声明交换机和队列绑定）</h5><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.eight;

import com.rabbitmq.client.BuiltinExchangeType;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeoutException;

/**
 * Describe: 死信队列实战
 * 消费者1
 *
 * @author RocPengHua
 * @date 2022/5/2.
 */
public class Consumer01 &#123;
    /**
     * 普通交换机
     */
    private static final String NORMAL_EXCHANGE = &quot;normal_exchange&quot;;

    /**
     * 普通队列
     */
    private static final String NORMAL_QUEUE = &quot;normal_queue&quot;;

    /**
     * 普通RoutingKey
     */
    private static final String NORMAL_ROUTING_KEY = &quot;zhangsan&quot;;

    /**
     * 死信交换机
     */
    private static final String DEAD_EXCHANGE = &quot;dead_exchange&quot;;

    /**
     * 死信队列
     */
    private static final String DEAD_QUEUE = &quot;dead_queue&quot;;

    /**
     * 死信RoutingKey
     */
    private static final String DEAD_ROUTING_KEY = &quot;lisi&quot;;


    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        //声明死信和普通交换机 类型为direct
        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);
        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);
        //声明普通队列
        Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
        //过期时间(发送时候设置)
//        arguments.put(&quot;x-message-ttl&quot;,10000);

        //正常队列设置死信交换机
        arguments.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE);
        //设置死信RoutingKey
        arguments.put(&quot;x-dead-letter-routing-key&quot;, DEAD_ROUTING_KEY);
        //设置普通队列的长度的限制 测试死信队列
//        arguments.put(&quot;x-max-length&quot;,6);

        channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);

        //声明死信队列
        channel.queueDeclare(DEAD_QUEUE, false, false, false, null);
        //绑定普通的交换机与普通队列
        channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, NORMAL_ROUTING_KEY);
        //绑定死信的交换机与死信队列
        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, DEAD_ROUTING_KEY);
        System.out.println(&quot;Consumer01 等待接收消息。。。。&quot;);
        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;
            String msg = new String(message.getBody(), StandardCharsets.UTF_8);
            if(&quot;info5&quot;.equals(msg))&#123;
                System.out.println(&quot;Consumer01 接收的消息是:&quot; + msg+&quot;---此消息时被C1拒绝的&quot;);
                /*
                 *  消息拒绝 死信队列
                 * 1、被拒绝的消息标签
                 * 2、是否放回原队列
                 */
                channel.basicReject(message.getEnvelope().getDeliveryTag(),false);
            &#125;else &#123;
                System.out.println(&quot;Consumer01 接收的消息是:&quot; + msg);
                //消息确认
                channel.basicAck(message.getEnvelope().getDeliveryTag(),false);
            &#125;
        &#125;;
        //测试死信队列 应答ack为false 手动应答
        channel.basicConsume(NORMAL_QUEUE, false, deliverCallback, consumerTag -&gt; &#123;
        &#125;);
    &#125;
&#125;
</code></pre>
<h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.eight;

import com.rabbitmq.client.AMQP;
import com.rabbitmq.client.Channel;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * Describe: 死信队列生产者
 *
 * @author RocPengHua
 * @date 2022/5/2.
 */
public class Producer &#123;
    /**
     * 普通交换机
     */
    private static final String NORMAL_EXCHANGE = &quot;normal_exchange&quot;;
    /**
     * 普通RoutingKey
     */
    private static final String NORMAL_ROUTING_KEY = &quot;zhangsan&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();
        //发送死信消息 设置 ttl time to live  单位ms
//        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build();
        //发送死信消息 测试队列长度
        AMQP.BasicProperties properties = null;
        for (int i = 1; i &lt; 11; i++) &#123;
            String message = &quot;info&quot; + i;
            channel.basicPublish(NORMAL_EXCHANGE,NORMAL_ROUTING_KEY,properties,message.getBytes(StandardCharsets.UTF_8));
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="消费者2（消费死信队列）"><a href="#消费者2（消费死信队列）" class="headerlink" title="消费者2（消费死信队列）"></a>消费者2（消费死信队列）</h5><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.eight;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;
import com.rocpenghua.rabbitmq.utils.RabbitmqUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/2.
 */
public class Consumer02 &#123;
    /**
     * 死信交换机
     */
    private static final String DEAD_EXCHANGE = &quot;dead_exchange&quot;;

    /**
     * 死信队列
     */
    private static final String DEAD_QUEUE = &quot;dead_queue&quot;;

    /**
     * 死信RoutingKey
     */
    private static final String DEAD_ROUTING_KEY = &quot;lisi&quot;;

    public static void main(String[] args) throws IOException, TimeoutException &#123;
        Channel channel = RabbitmqUtils.getChannel();

        System.out.println(&quot;Consumer01 等待接收消息。。。。&quot;);
        DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;
            System.out.println(&quot;Consumer02 接收的消息是:&quot; + new String(message.getBody(), StandardCharsets.UTF_8));
        &#125;;
        channel.basicConsume(DEAD_QUEUE, true, deliverCallback, consumerTag -&gt; &#123;
        &#125;);
    &#125;
&#125;
</code></pre>
<h5 id="注：每一次测试重新声明队列时先删除旧的"><a href="#注：每一次测试重新声明队列时先删除旧的" class="headerlink" title="注：每一次测试重新声明队列时先删除旧的"></a>注：每一次测试重新声明队列时先删除旧的</h5>]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq消息确认模式</title>
    <url>/2022/05/02/rabbitmq-xiao-xi-que-ren-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="消息确认几种模式"><a href="#消息确认几种模式" class="headerlink" title="消息确认几种模式"></a>消息确认几种模式</h4><ul>
<li>单个确认<ul>
<li>发送一个消息确认一次</li>
</ul>
</li>
<li>批量确认<ul>
<li>发送多个消息确认一次</li>
</ul>
</li>
<li>异步批量确认<ul>
<li>添加消息确认监听器</li>
</ul>
</li>
</ul>
<h4 id="创建信道"><a href="#创建信道" class="headerlink" title="创建信道"></a>创建信道</h4><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.utils;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rocpenghua.rabbitmq.config.JmsConfig;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/4/29.
 */
public class RabbitmqUtils &#123;
    public static Channel getChannel() throws IOException, TimeoutException &#123;
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(JmsConfig.HOST);
        factory.setUsername(JmsConfig.USERNAME);
        factory.setPassword(JmsConfig.PASSWORD);
        //创建链接
        Connection connection = factory.newConnection();
        //获取信道
        Channel channel = connection.createChannel();
        return channel;
    &#125;
&#125;
</code></pre>
<h4 id="单个确认"><a href="#单个确认" class="headerlink" title="单个确认"></a>单个确认</h4><pre><code class="prettyprint">public static void publishMessageIndividually() throws IOException, TimeoutException, InterruptedException &#123;
    Channel channel = RabbitmqUtils.getChannel();
    //队列声明
    String queueName = UUID.randomUUID().toString();
    channel.queueDeclare(queueName, true, false, false, null);
    //开启发布确认
    channel.confirmSelect();

    long start = System.currentTimeMillis();

    //批量发消息
    for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123;
        String message = i + &quot;&quot;;
        channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes(StandardCharsets.UTF_8));
        //单个消息马上进行发布确认
        boolean flag = channel.waitForConfirms();
        if (flag) &#123;
            System.out.println(i + &quot;--消息发送成功&quot;);
        &#125;
    &#125;

    long end = System.currentTimeMillis();
    System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;个单独确认消息，耗时&quot; + (end - start) + &quot;ms&quot;);


&#125;
</code></pre>
<h4 id="批量确认"><a href="#批量确认" class="headerlink" title="批量确认"></a>批量确认</h4><pre><code class="prettyprint">public static void publishMessageBatch() throws IOException, TimeoutException, InterruptedException &#123;
    Channel channel = RabbitmqUtils.getChannel();
    //队列声明
    String queueName = UUID.randomUUID().toString();
    channel.queueDeclare(queueName, true, false, false, null);
    //开启发布确认
    channel.confirmSelect();

    long start = System.currentTimeMillis();

    //批量确认消息的大小(100条确认一次)
    int batchSize = 100;

    //批量发消息批量确认
    for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123;
        String message = i + &quot;&quot;;
        channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes(StandardCharsets.UTF_8));

        //判断达到100条消息的时候  批量确认一次
        if (i % batchSize == 99) &#123;
            channel.waitForConfirms();
        &#125;
    &#125;

    long end = System.currentTimeMillis();
    System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;个批量确认消息，耗时&quot; + (end - start) + &quot;ms&quot;);
&#125;
</code></pre>
<h4 id="异步批量确认"><a href="#异步批量确认" class="headerlink" title="异步批量确认"></a>异步批量确认</h4><pre><code class="prettyprint">public static void publishMessageAsync() throws IOException, TimeoutException &#123;
    Channel channel = RabbitmqUtils.getChannel();
    //队列声明
    String queueName = UUID.randomUUID().toString();
    channel.queueDeclare(queueName, true, false, false, null);
    //开启发布确认
    channel.confirmSelect();
    /*
         * 线程安全有序的一个哈希表 适用于高并发的情况下
         * 1、轻松的将序号和消息进行关联
         * 2、轻松的批量删除条目，只要给到序号
         * 3、支持高并发（多线程）
         */
    ConcurrentSkipListMap&lt;Long, String&gt; outStandingConfirms = new ConcurrentSkipListMap&lt;&gt;();

    /* 消息确认成功回调
         * 1.消息的标记
         * 2.是否批量确认
         */
    ConfirmCallback ackCallback = (deliveryTag, multiple) -&gt; &#123;
        //2、删除已经确认的消息 剩下就是未确认的消息
        if (multiple) &#123;
            ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outStandingConfirms.headMap(deliveryTag);
        &#125; else &#123;
            outStandingConfirms.remove(deliveryTag);
        &#125;
        System.out.println(&quot;确认的消息：&quot; + deliveryTag);
    &#125;;

    /* 消息确认失败回调
         * 1.消息的标记
         * 2.是否批量确认
         */
    ConfirmCallback nackCallback = (deliveryTag, multiple) -&gt; &#123;
        //3、打印未确认的消息
        String message = outStandingConfirms.get(deliveryTag);
        System.out.println(&quot;未确认的消息是：&quot; + message + &quot;----未确认的消息序号：&quot; + deliveryTag);
    &#125;;

    /*
         * 准备监听器 监听哪些消息成功了  哪些消息失败了   异步通知
         * 1.监听哪些消息成功
         * 2.监听哪些消息失败
         */
    channel.addConfirmListener(ackCallback, nackCallback);
    long start = System.currentTimeMillis();
    //批量发送消息
    for (int i = 0; i &lt; MESSAGE_COUNT; i++) &#123;
        String message = &quot;消息&quot; + i;
        channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes(StandardCharsets.UTF_8));

        //1、记录所有发送的消息
        outStandingConfirms.put(channel.getNextPublishSeqNo(), message);
    &#125;

    long end = System.currentTimeMillis();
    System.out.println(&quot;发布&quot; + MESSAGE_COUNT + &quot;个异步发布确认消息，耗时&quot; + (end - start) + &quot;ms&quot;);
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq队列声明扩展参数说明</title>
    <url>/2022/05/02/rabbitmq-dui-lie-sheng-ming-kuo-zhan-can-shu-shuo-ming/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="queueDeclare"><a href="#queueDeclare" class="headerlink" title="queueDeclare"></a>queueDeclare</h4><p>声明队列</p>
<pre><code>Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete,
                             Map&lt;String, Object&gt; arguments) throws IOException;
</code></pre>
<ul>
<li>queue：队列名称</li>
<li>durable：是否持久化</li>
<li>exclusive：排外<ul>
<li>当前定义的队列connection中的channel是共享的，其他的connection是访问不到的<br>当conneciton.close的时候，queue被删除</li>
</ul>
</li>
<li>autoDelete：自动删除<ul>
<li>当前最后一个consumer断开之后，autoDelete队列</li>
</ul>
</li>
<li>arguments：rabbitmq扩展参数</li>
</ul>
<h5 id="rabbitmq扩展参数"><a href="#rabbitmq扩展参数" class="headerlink" title="rabbitmq扩展参数"></a>rabbitmq扩展参数</h5><ul>
<li><p><code>x-message-ttl</code>消息过期时间设置</p>
<p>标识队列中的所有消息的过期时间</p>
<p>可以再消息发送时指定消息过期时间</p>
<pre><code class="prettyprint">//10s过期时间
AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build();
channel.basicPublish(NORMAL_EXCHANGE,NORMAL_ROUTING_KEY,properties,message.getBytes(StandardCharsets.UTF_8));
</code></pre>
</li>
<li><p><code>x-expires</code>自动删除时间</p>
</li>
<li><p><code>x-overflow</code></p>
<ul>
<li>设置‎<a href="https://www.rabbitmq.com/maxlength.html#overflow-behaviour">‎队列溢出行为‎</a>‎。这决定了当达到队列的最大长度时，消息会发生什么情况。有效值为 或 。仲裁队列类型仅支持 和 。‎<code>drop-head``reject-publish``reject-publish-dlx``drop-head``reject-publish</code></li>
</ul>
</li>
<li><p><code>x-single-active-consumer</code></p>
<ul>
<li>如果设置，请确保一次只有一个消费者从队列中消费，并在活动消费者被取消或死亡时故障转移到另一个已注册的使用者。</li>
</ul>
</li>
<li><p><code>x-max-length</code>最大队列长度</p>
</li>
<li><p><code>x-max-length-bytes</code>最大大小</p>
</li>
<li><p><code>x-dead-letter-exchange</code></p>
<ul>
<li>消息被拒绝或者过期的时候设置的交换机</li>
</ul>
</li>
<li><p><code>x-dead-letter-routing-key</code></p>
<ul>
<li>在消息为死信时要使用的可选替换路由键。如果未设置，则将使用邮件的原始路由键。</li>
</ul>
</li>
<li><p><code>x-max-priority</code>队列优先级</p>
</li>
<li><p><code>x-queue-mode=lazy</code></p>
<ul>
<li>将队列设置为延迟模式，在磁盘上保留尽可能多的消息以减少RAM使用量;如果未设置，队列将保留内存中缓存，以尽可能快地传递消息。‎</li>
</ul>
</li>
<li><p><code>x-queue-master-locator</code></p>
<ul>
<li>‎将队列设置为主位置模式，确定在节点群集上声明队列主节点时所依据的规则。‎</li>
</ul>
</li>
</ul>
<pre><code class="prettyprint">Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();
args.put(&quot;x-message-ttl&quot;,10000);
args.put(&quot;x-expires&quot;,10000);
args.put(&quot;x-dead-letter-exchange&quot;, DEAD_EXCHANGE);
args.put(&quot;x-dead-letter-routing-key&quot;, DEAD_ROUTING_KEY);
args.put(&quot;x-max-length&quot;,6);
args.put(&quot;x-max-length-bytes&quot;,2048);
args.put(&quot;x-max-priority&quot;,10);
channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);
</code></pre>
<h4 id="QueueDeclareNoWait"><a href="#QueueDeclareNoWait" class="headerlink" title="QueueDeclareNoWait"></a>QueueDeclareNoWait</h4><p>声明队列，不等待队列创建结果，异步</p>
<h4 id="QueueDeclarePassive"><a href="#QueueDeclarePassive" class="headerlink" title="QueueDeclarePassive"></a>QueueDeclarePassive</h4><p>消极的声明创建，判断队列是否存在，不存在报错</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq插件rabbitmq_delayed_message_exchange实现延迟队列</title>
    <url>/2022/05/03/rabbitmq-cha-jian-rabbitmq-delayed-message-exchange-shi-xian-yan-chi-dui-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>在使用死信队列实现延迟队列效果时，RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列， 如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行</p>
<img src="/2022/05/03/rabbitmq-cha-jian-rabbitmq-delayed-message-exchange-shi-xian-yan-chi-dui-lie/image-20220503194822388.png" class="asset-class" title="image-20220503194822388"></li>
</ul>
<h4 id="download"><a href="#download" class="headerlink" title="download"></a>download</h4><h5 id="插件下载"><a href="#插件下载" class="headerlink" title="插件下载"></a>插件下载</h5><ul>
<li><a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></li>
</ul>
 <img src="/2022/05/03/rabbitmq-cha-jian-rabbitmq-delayed-message-exchange-shi-xian-yan-chi-dui-lie/image-20220503193505947.png" class="asset-class" title="image-20220503193505947">

<img src="/2022/05/03/rabbitmq-cha-jian-rabbitmq-delayed-message-exchange-shi-xian-yan-chi-dui-lie/image-20220503193710704.png" class="asset-class" title="image-20220503193710704">

<h5 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h5><pre><code class="prettyprint">#上传插件到 /usr/lib/rabbitmq/lib/rabbitmq_server-3.9.16/plugins
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
systemctl restart rabbitmq-server
</code></pre>
<h5 id="验证成功"><a href="#验证成功" class="headerlink" title="验证成功"></a>验证成功</h5><p>查看Exchanges的选择类型是否存在<code>x-delayed-message</code></p>
<img src="/2022/05/03/rabbitmq-cha-jian-rabbitmq-delayed-message-exchange-shi-xian-yan-chi-dui-lie/image-20220503194138103.png" class="asset-class" title="image-20220503194138103">

<h4 id="延迟队列使用"><a href="#延迟队列使用" class="headerlink" title="延迟队列使用"></a>延迟队列使用</h4><h5 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h5><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.springbootrabbitmq.config;

import org.springframework.amqp.core.*;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

/**
 * Describe:
 *
 * @author RocPengHua
 * @date 2022/5/3.
 */
@Configuration
public class DelayedQueueConfig &#123;
    /**
     * 队列
     */
    public static final String DELAYED_QUEUE_NAME = &quot;delayed.queue&quot;;
    /**
     * 交换机
     */
    public static final String DELAYED_EXCHANGE_NAME = &quot;delayed.exchange&quot;;
    /**
     * RoutingKey
     */
    public static final String DELAYED_ROUTING_KEY = &quot;delayed.routingkey&quot;;

    /**
     * 声明自定义交换机（x-delayed-message）
     */
    @Bean
    public CustomExchange delayedExchange() &#123;
        Map&lt;String,Object&gt; args = new HashMap&lt;&gt;();
        args.put(&quot;x-delayed-type&quot;,&quot;direct&quot;);
        /*
         * 1、交换机名称
         * 2、交换机类型
         * 3、是否持久化
         * 4、是否自动删除
         */
        return new CustomExchange(DELAYED_EXCHANGE_NAME, &quot;x-delayed-message&quot;, true, false, args);
    &#125;

    /**
     * 队列声明
     */
    @Bean
    public Queue delayedQueue() &#123;
        return QueueBuilder.durable(DELAYED_QUEUE_NAME).build();
    &#125;

    /**
     * 绑定队列和交换机
     */
    @Bean
    public Binding delayedQueueBindingDelayedExchange(@Qualifier(&quot;delayedQueue&quot;) Queue delayedQueue,
                                                      @Qualifier(&quot;delayedExchange&quot;) CustomExchange delayedExchange)&#123;
       return BindingBuilder.bind(delayedQueue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();
    &#125;
&#125;
</code></pre>
<h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.springbootrabbitmq.consumer;

import com.rabbitmq.client.Channel;
import com.rocpenghua.rabbitmq.springbootrabbitmq.config.DelayedQueueConfig;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;
import java.util.Date;

/**
 * Describe:
 * 消费者 基于插件的延迟消息
 * @author RocPengHua
 * @date 2022/5/3.
 */
@Component
@Slf4j
public class DelayQueueConsumer &#123;
    //监听消息

    @RabbitListener(queues = DelayedQueueConfig.DELAYED_QUEUE_NAME)
    public void receiveDelayQueue(Message message, Channel channel) &#123;
        String msg = new String(message.getBody(), StandardCharsets.UTF_8);
        log.info(&quot;当前时间：&#123;&#125;，收到延迟队列的消息：&#123;&#125;&quot;, new Date().toString(), msg);
    &#125;
&#125;
</code></pre>
<h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><pre><code class="prettyprint">package com.rocpenghua.rabbitmq.springbootrabbitmq.consumer;

import com.rabbitmq.client.Channel;
import com.rocpenghua.rabbitmq.springbootrabbitmq.config.DelayedQueueConfig;
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;
import java.util.Date;

/**
 * Describe:
 * 消费者 基于插件的延迟消息
 * @author RocPengHua
 * @date 2022/5/3.
 */
@Component
@Slf4j
public class DelayQueueConsumer &#123;
    //监听消息

    @RabbitListener(queues = DelayedQueueConfig.DELAYED_QUEUE_NAME)
    public void receiveDelayQueue(Message message, Channel channel) &#123;
        String msg = new String(message.getBody(), StandardCharsets.UTF_8);
        log.info(&quot;当前时间：&#123;&#125;，收到延迟队列的消息：&#123;&#125;&quot;, new Date().toString(), msg);
    &#125;
&#125;
</code></pre>
<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><img src="/2022/05/03/rabbitmq-cha-jian-rabbitmq-delayed-message-exchange-shi-xian-yan-chi-dui-lie/image-20220503194656205.png" class="asset-class" title="image-20220503194656205">
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq集群搭建</title>
    <url>/2022/05/06/rabbitmq-ji-qun-da-jian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="rabbitmq安装"><a href="#rabbitmq安装" class="headerlink" title="rabbitmq安装"></a>rabbitmq安装</h4><p><a href="https://rocpenghua.gitee.io/2022/04/28/centos7-an-zhuang-rabbitmq/">centos7安装rabbitmq | 小鹏驿站 (gitee.io)</a></p>
<h4 id="集群环境准备"><a href="#集群环境准备" class="headerlink" title="集群环境准备"></a>集群环境准备</h4><ul>
<li><p>准备三台虚拟机，修改hostname</p>
<pre><code class="prettyprint">vim /etc/hostname
#分别命名node1,node2,node3
</code></pre>
<p>修改之后重启虚拟机<code>reboot</code>命令或者直接操作<code>vmware</code></p>
</li>
<li><p>修改各节点的hosts,让哥哥节点能互相识别</p>
<pre><code class="prettyprint">vim /etc/hosts
</code></pre>
<p>配置如下：</p>
<pre><code class="prettyprint">192.168.101.125 node1
192.168.101.129 node2
192.168.101.128 node3
</code></pre>
</li>
<li><p>确保各个节点erlang的cokkie一样,将node1中<code>.erlang.cookie</code>拷贝过去</p>
<pre><code class="prettyprint">scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/.erlang.cookie
scp /var/lib/rabbitmq/.erlang.cookie root@node3:/var/lib/rabbitmq/.erlang.cookie
</code></pre>
</li>
</ul>
<h4 id="集群命令"><a href="#集群命令" class="headerlink" title="集群命令"></a>集群命令</h4><h5 id="启动rabbitmq服务"><a href="#启动rabbitmq服务" class="headerlink" title="启动rabbitmq服务"></a>启动rabbitmq服务</h5><ul>
<li><p>node1</p>
<pre><code class="prettyprint">rabbitmq-server -detached
#停止（rabbitmqctl stop 会将Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务）
rabbitmqctl stop_app
#重置
rabbitmqctl reset
#启动
rabbitmqctl start_app
</code></pre>
</li>
<li><p>node2</p>
<pre><code class="prettyprint">rabbitmq-server -detached
#停止（rabbitmqctl stop 会将Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务）
rabbitmqctl stop_app
#重置
rabbitmqctl reset
#集群方式加入node1
rabbitmqctl join_cluster rabbit@node1
#启动
rabbitmqctl start_app
</code></pre>
</li>
<li><p>node3</p>
<pre><code class="prettyprint">rabbitmq-server -detached
#停止（rabbitmqctl stop 会将Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务）
rabbitmqctl stop_app
#重置
rabbitmqctl reset
#集群方式加入node2,也可以加入node1
rabbitmqctl join_cluster rabbit@node2
#启动
rabbitmqctl start_app
</code></pre>
</li>
</ul>
<h5 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h5><pre><code class="prettyprint">rabbitmqctl cluster_status
</code></pre>
<img src="/2022/05/06/rabbitmq-ji-qun-da-jian/image-20220506204436347.png" class="asset-class" title="image-20220506204436347">

<h5 id="重新创建并设置用户"><a href="#重新创建并设置用户" class="headerlink" title="重新创建并设置用户"></a>重新创建并设置用户</h5><ul>
<li><p>创建账号</p>
<pre><code class="prettyprint">rabbitmqctl add_user admin admin
</code></pre>
</li>
<li><p>设置用户超级管理员角色</p>
<pre><code class="prettyprint">rabbitmqctl set_user_tags admin administrator
</code></pre>
</li>
<li><p>设置用户权限</p>
<pre><code class="prettyprint">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
</code></pre>
</li>
</ul>
<img src="/2022/05/06/rabbitmq-ji-qun-da-jian/image-20220506204513466.png" class="asset-class" title="image-20220506204513466">

<h5 id="解除集群节点"><a href="#解除集群节点" class="headerlink" title="解除集群节点"></a>解除集群节点</h5><pre><code class="prettyprint">#在node2 node3 执行
rabbitmqctl stop_app
rabbitmqctl reset
rabbitmqctl start_app
rabbitmqctl cluster_status
#node1上面执行
rabbitmqctl forget_cluster_node rabbit@node2
</code></pre>
<h4 id="集群模式下镜像队列配置"><a href="#集群模式下镜像队列配置" class="headerlink" title="集群模式下镜像队列配置"></a>集群模式下镜像队列配置</h4><img src="/2022/05/06/rabbitmq-ji-qun-da-jian/image-20220506210406153.png" class="asset-class" title="image-20220506210406153">

<ul>
<li>Name：策略名称</li>
<li>Pattern：正则匹配规则</li>
<li>Apply to：应用于<ul>
<li><code>Exchanges and queues</code>：交换机和队列</li>
<li><code>Exchanges</code>：交换机</li>
<li><code>Queues</code>：队列</li>
</ul>
</li>
<li>Priority：优先级，默认0</li>
<li>Definition：自定义配置<ul>
<li><code>ha-mode</code><ul>
<li><code>all</code>集群所有节点</li>
<li><code>exactly</code>集群中部分节点，需要配合<code>ha-params</code>使用</li>
</ul>
</li>
<li><code>ha-params</code>：镜像的节点个数</li>
<li><code>ha-sync-mode</code><ul>
<li><code>automatic</code>：自动</li>
<li><code>manual</code>：手动</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/2022/05/06/rabbitmq-ji-qun-da-jian/image-20220506211201527.png" class="asset-class" title="image-20220506211201527">
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq集群搭建</title>
    <url>/2022/05/10/rocketmq-ji-qun-da-jian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="rocketmq下载安装"><a href="#rocketmq下载安装" class="headerlink" title="rocketmq下载安装"></a>rocketmq下载安装</h3><p><a href="https://rocpenghua.gitee.io/2022/04/23/centos7-shou-dong-an-zhuang-rocketmq/">centos7手动安装rocketmq | 小鹏驿站 (gitee.io)</a></p>
<h3 id="集群模式配置"><a href="#集群模式配置" class="headerlink" title="集群模式配置"></a>集群模式配置</h3><h4 id="集群搭建介绍"><a href="#集群搭建介绍" class="headerlink" title="集群搭建介绍"></a>集群搭建介绍</h4><ul>
<li>本次采用两台虚拟机，<code>192.168.101.132:MASTER1/SLAVE2</code>,<code>192.168.101.131:MASTER2/SLAVE1</code></li>
<li>使用<code>2m-2s-sync</code>配置下的配置文件</li>
</ul>
<h4 id="HOST配置-在两台虚拟机中修改"><a href="#HOST配置-在两台虚拟机中修改" class="headerlink" title="HOST配置(在两台虚拟机中修改)"></a>HOST配置(在两台虚拟机中修改)</h4><pre><code class="prettyprint">vim /etc/hosts
</code></pre>
<ul>
<li>配置文件如下</li>
</ul>
<pre><code class="prettyprint">192.168.101.132 rocketmq-nameserver1
192.168.101.131 rocketmq-nameserver2
192.168.101.132 rocketmq-master1
192.168.101.132 rocketmq-slave2
192.168.101.131 rocketmq-master2
192.168.101.131 rocketmq-slave1
</code></pre>
<ul>
<li>确保两台机器通信（可以关闭防火墙或者开放端口）</li>
</ul>
<h4 id="环境变量配置-在两台虚拟机中修改"><a href="#环境变量配置-在两台虚拟机中修改" class="headerlink" title="环境变量配置(在两台虚拟机中修改)"></a>环境变量配置(在两台虚拟机中修改)</h4><pre><code class="prettyprint">vim /etc/profile
</code></pre>
<ul>
<li>在最后加入如下配置</li>
</ul>
<pre><code class="prettyprint">#ROCKETMQ_HOME
ROCKETMQ_HOME=/opt/module/rocketmq
PATH=$PATH:$ROCKETMQ_HOME/bin
export PATH ROCKETMQ_HOME PATH
</code></pre>
<ul>
<li>使配置生效</li>
</ul>
<pre><code class="prettyprint">source /etc/profile
</code></pre>
<h4 id="创建消息存储位置"><a href="#创建消息存储位置" class="headerlink" title="创建消息存储位置"></a>创建消息存储位置</h4><pre><code class="prettyprint">#主
mkdir /opt/module/rocketmq/store
mkdir /opt/module/rocketmq/store/commitlog
mkdir /opt/module/rocketmq/store/consumequeue
mkdir /opt/module/rocketmq/store/index
#拷贝一份作为从节点的配置
cp -r /opt/module/rocketmq/store /opt/module/rocketmq/store-slave
</code></pre>
<h4 id="修改broker配置文件"><a href="#修改broker配置文件" class="headerlink" title="修改broker配置文件"></a>修改broker配置文件</h4><h5 id="MASTER1-192-168-101-132"><a href="#MASTER1-192-168-101-132" class="headerlink" title="MASTER1(192.168.101.132)"></a>MASTER1(192.168.101.132)</h5><pre><code class="prettyprint">vim /opt/module/rocketmq/conf/2m-2s-sync/broker-a.properties
</code></pre>
<p>修改配置如下：</p>
<pre><code class="prettyprint">#所属集群名字
brokerClusterName=rocketmq-cluster
#broker名字，注意此处不同的配置文件填写的不一样
brokerName=broker-a
#0 表示 Master，&gt;0 表示 Slave
brokerId=0
#nameServer地址，分号分割
namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876
#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数
defaultTopicQueueNums=4
#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭
autoCreateTopicEnable=true
#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭
autoCreateSubscriptionGroup=true
#Broker 对外服务的监听端口
listenPort=10911
#删除文件时间点，默认凌晨 4点
deleteWhen=04
#文件保留时间，默认 48 小时
fileReservedTime=120
#commitLog每个文件的大小默认1G
mapedFileSizeCommitLog=1073741824
#ConsumeQueue每个文件默认存30W条，根据业务情况调整
mapedFileSizeConsumeQueue=300000
#destroyMapedFileIntervalForcibly=120000
#redeleteHangedFileInterval=120000
#检测物理文件磁盘空间
diskMaxUsedSpaceRatio=88
#存储路径
storePathRootDir=/opt/module/rocketmq/store
#commitLog 存储路径
storePathCommitLog=/opt/module/rocketmq/store/commitlog
#消费队列存储路径存储路径
storePathConsumeQueue=/opt/module/rocketmq/store/consumequeue
#消息索引存储路径
storePathIndex=/opt/module/rocketmq/store/index
#checkpoint 文件存储路径
storeCheckpoint=/opt/module/rocketmq/store/checkpoint
#abort 文件存储路径
abortFile=/opt/module/rocketmq/store/abort
#限制的消息大小
maxMessageSize=65536
#flushCommitLogLeastPages=4
#flushConsumeQueueLeastPages=2
#flushCommitLogThoroughInterval=10000
#flushConsumeQueueThoroughInterval=60000
#Broker 的角色
#- ASYNC_MASTER 异步复制Master
#- SYNC_MASTER 同步双写Master
#- SLAVE
brokerRole=SYNC_MASTER
#刷盘方式
#- ASYNC_FLUSH 异步刷盘
#- SYNC_FLUSH 同步刷盘
flushDiskType=SYNC_FLUSH
#checkTransactionMessageEnable=false
#发消息线程池数量
#sendMessageThreadPoolNums=128
#拉消息线程池数量
#pullMessageThreadPoolNums=128
</code></pre>
<h5 id="SLAVE2-192-168-101-132"><a href="#SLAVE2-192-168-101-132" class="headerlink" title="SLAVE2(192.168.101.132)"></a>SLAVE2(192.168.101.132)</h5><pre><code class="prettyprint">vim /opt/module/rocketmq/conf/2m-2s-sync/broker-b-s.properties
</code></pre>
<p>修改配置如下：</p>
<pre><code class="prettyprint">#所属集群名字
brokerClusterName=rocketmq-cluster
#broker名字，注意此处不同的配置文件填写的不一样
brokerName=broker-b
#0 表示 Master，&gt;0 表示 Slave
brokerId=1
#nameServer地址，分号分割
namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876
#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数
defaultTopicQueueNums=4
#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭
autoCreateTopicEnable=true
#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭
autoCreateSubscriptionGroup=true
#Broker 对外服务的监听端口
listenPort=11011
#删除文件时间点，默认凌晨 4点
deleteWhen=04
#文件保留时间，默认 48 小时
fileReservedTime=120
#commitLog每个文件的大小默认1G
mapedFileSizeCommitLog=1073741824
#ConsumeQueue每个文件默认存30W条，根据业务情况调整
mapedFileSizeConsumeQueue=300000
#destroyMapedFileIntervalForcibly=120000
#redeleteHangedFileInterval=120000
#检测物理文件磁盘空间
diskMaxUsedSpaceRatio=88
#存储路径
storePathRootDir=/opt/module/rocketmq/store-slave
#commitLog 存储路径
storePathCommitLog=/opt/module/rocketmq/store-slave/commitlog
#消费队列存储路径存储路径
storePathConsumeQueue=/opt/module/rocketmq/store-slave/consumequeue
#消息索引存储路径
storePathIndex=/opt/module/rocketmq/store-slave/index
#checkpoint 文件存储路径
storeCheckpoint=/opt/module/rocketmq/store-slave/checkpoint
#abort 文件存储路径
abortFile=/opt/module/rocketmq/store-slave/abort
#限制的消息大小
maxMessageSize=65536
#flushCommitLogLeastPages=4
#flushConsumeQueueLeastPages=2
#flushCommitLogThoroughInterval=10000
#flushConsumeQueueThoroughInterval=60000
#Broker 的角色
#- ASYNC_MASTER 异步复制Master
#- SYNC_MASTER 同步双写Master
#- SLAVE
brokerRole=SLAVE
#刷盘方式
#- ASYNC_FLUSH 异步刷盘
#- SYNC_FLUSH 同步刷盘
flushDiskType=ASYNC_FLUSH
#checkTransactionMessageEnable=false
#发消息线程池数量
#sendMessageThreadPoolNums=128
#拉消息线程池数量
#pullMessageThreadPoolNums=128
</code></pre>
<h5 id="MASTER2-192-168-101-131"><a href="#MASTER2-192-168-101-131" class="headerlink" title="MASTER2(192.168.101.131)"></a>MASTER2(192.168.101.131)</h5><pre><code class="prettyprint">vim /opt/module/rocketmq/conf/2m-2s-sync/broker-b.properties
</code></pre>
<p>修改配置如下：</p>
<pre><code class="prettyprint">#所属集群名字
brokerClusterName=rocketmq-cluster
#broker名字，注意此处不同的配置文件填写的不一样
brokerName=broker-b
#0 表示 Master，&gt;0 表示 Slave
brokerId=0
#nameServer地址，分号分割
namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876
#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数
defaultTopicQueueNums=4
#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭
autoCreateTopicEnable=true
#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭
autoCreateSubscriptionGroup=true
#Broker 对外服务的监听端口
listenPort=10911
#删除文件时间点，默认凌晨 4点
deleteWhen=04
#文件保留时间，默认 48 小时
fileReservedTime=120
#commitLog每个文件的大小默认1G
mapedFileSizeCommitLog=1073741824
#ConsumeQueue每个文件默认存30W条，根据业务情况调整
mapedFileSizeConsumeQueue=300000
#destroyMapedFileIntervalForcibly=120000
#redeleteHangedFileInterval=120000
#检测物理文件磁盘空间
diskMaxUsedSpaceRatio=88
#存储路径
storePathRootDir=/opt/module/rocketmq/store
#commitLog 存储路径
storePathCommitLog=/opt/module/rocketmq/store/commitlog
#消费队列存储路径存储路径
storePathConsumeQueue=/opt/module/rocketmq/store/consumequeue
#消息索引存储路径
storePathIndex=/opt/module/rocketmq/store/index
#checkpoint 文件存储路径
storeCheckpoint=/opt/module/rocketmq/store/checkpoint
#abort 文件存储路径
abortFile=/opt/module/rocketmq/store/abort
#限制的消息大小
maxMessageSize=65536
#flushCommitLogLeastPages=4
#flushConsumeQueueLeastPages=2
#flushCommitLogThoroughInterval=10000
#flushConsumeQueueThoroughInterval=60000
#Broker 的角色
#- ASYNC_MASTER 异步复制Master
#- SYNC_MASTER 同步双写Master
#- SLAVE
brokerRole=SYNC_MASTER
#刷盘方式
#- ASYNC_FLUSH 异步刷盘
#- SYNC_FLUSH 同步刷盘
flushDiskType=SYNC_FLUSH
#checkTransactionMessageEnable=false
#发消息线程池数量
#sendMessageThreadPoolNums=128
#拉消息线程池数量
#pullMessageThreadPoolNums=128
</code></pre>
<h5 id="SLAVE1-192-168-101-131"><a href="#SLAVE1-192-168-101-131" class="headerlink" title="SLAVE1(192.168.101.131)"></a>SLAVE1(192.168.101.131)</h5><pre><code class="prettyprint">vim /opt/module/rocketmq/conf/2m-2s-sync/broker-a-s.properties
</code></pre>
<p>修改配置如下：</p>
<pre><code class="prettyprint">#所属集群名字
brokerClusterName=rocketmq-cluster
#broker名字，注意此处不同的配置文件填写的不一样
brokerName=broker-a
#0 表示 Master，&gt;0 表示 Slave
brokerId=1
#nameServer地址，分号分割
namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876
#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数
defaultTopicQueueNums=4
#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭
autoCreateTopicEnable=true
#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭
autoCreateSubscriptionGroup=true
#Broker 对外服务的监听端口
listenPort=11011
#删除文件时间点，默认凌晨 4点
deleteWhen=04
#文件保留时间，默认 48 小时
fileReservedTime=120
#commitLog每个文件的大小默认1G
mapedFileSizeCommitLog=1073741824
#ConsumeQueue每个文件默认存30W条，根据业务情况调整
mapedFileSizeConsumeQueue=300000
#destroyMapedFileIntervalForcibly=120000
#redeleteHangedFileInterval=120000
#检测物理文件磁盘空间
diskMaxUsedSpaceRatio=88
#存储路径
storePathRootDir=/opt/module/rocketmq/store-slave
#commitLog 存储路径
storePathCommitLog=/opt/module/rocketmq/store-slave/commitlog
#消费队列存储路径存储路径
storePathConsumeQueue=/opt/module/rocketmq/store-slave/consumequeue
#消息索引存储路径
storePathIndex=/opt/module/rocketmq/store-slave/index
#checkpoint 文件存储路径
storeCheckpoint=/opt/module/rocketmq/store-slave/checkpoint
#abort 文件存储路径
abortFile=/opt/module/rocketmq/store-slave/abort
#限制的消息大小
maxMessageSize=65536
#flushCommitLogLeastPages=4
#flushConsumeQueueLeastPages=2
#flushCommitLogThoroughInterval=10000
#flushConsumeQueueThoroughInterval=60000
#Broker 的角色
#- ASYNC_MASTER 异步复制Master
#- SYNC_MASTER 同步双写Master
#- SLAVE
brokerRole=SLAVE
#刷盘方式
#- ASYNC_FLUSH 异步刷盘
#- SYNC_FLUSH 同步刷盘
flushDiskType=ASYNC_FLUSH
#checkTransactionMessageEnable=false
#发消息线程池数量
#sendMessageThreadPoolNums=128
#拉消息线程池数量
#pullMessageThreadPoolNums=128
</code></pre>
<h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><h4 id="启动NameServer集群"><a href="#启动NameServer集群" class="headerlink" title="启动NameServer集群"></a>启动NameServer集群</h4><ul>
<li>分别在<code>192.168.101.132</code>,<code>192.168.101.131</code>执行如下命令</li>
</ul>
<pre><code class="prettyprint">cd /opt/module/rocketmq/bin
sh mqnamesrv &amp;
</code></pre>
<h4 id="启动broker集群"><a href="#启动broker集群" class="headerlink" title="启动broker集群"></a>启动broker集群</h4><ul>
<li>在<code>192.168.101.132</code>启动MASTER1和SLAVE2</li>
</ul>
<pre><code class="prettyprint">cd /opt/module/rocketmq/bin
#启动MASTER1
sh mqbroker -c ../conf/2m-2s-sync/broker-a.properties &amp;
#启动SLAVE2
sh mqbroker -c ../conf/2m-2s-sync/broker-b-s.properties &amp;
</code></pre>
<ul>
<li>在<code>192.168.101.131</code>启动MASTER2和SLAVE1</li>
</ul>
<pre><code class="prettyprint">cd /opt/module/rocketmq/bin
#启动MASTER2
sh mqbroker -c ../conf/2m-2s-sync/broker-b.properties &amp;
#启动SLAVE1
sh mqbroker -c ../conf/2m-2s-sync/broker-a-s.properties &amp;
</code></pre>
<h3 id="验证启动成功"><a href="#验证启动成功" class="headerlink" title="验证启动成功"></a>验证启动成功</h3><h4 id="使用jps查看状态"><a href="#使用jps查看状态" class="headerlink" title="使用jps查看状态"></a>使用jps查看状态</h4><pre><code class="prettyprint">jps
</code></pre>
<img src="/2022/05/10/rocketmq-ji-qun-da-jian/image-20220510205542048.png" class="asset-class" title="image-20220510205542048">

<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><pre><code class="prettyprint"># 查看nameServer日志
tail -500f /opt/module/rabbitmq/logs/rocketmqlogs/namesrv.log
# 查看broker日志
tail -500f /opt/module/rabbitmq/logs/rocketmqlogs/broker.log
</code></pre>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>旧版本主从节点storePath可以在同一个路径下，新版本需要两个不同路径</li>
</ul>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>maven小知识</title>
    <url>/2022/05/11/maven-xiao-zhi-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="打印依赖树"><a href="#打印依赖树" class="headerlink" title="打印依赖树"></a>打印依赖树</h4><pre><code class="prettyprint">#在pom目录下执行
mvn dependency:tree &gt;&gt; tree.txt
</code></pre>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>rocketmq源码调试环境搭建</title>
    <url>/2022/05/15/rocketmq-yuan-ma-diao-shi-huan-jing-da-jian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="download"><a href="#download" class="headerlink" title="download"></a>download</h4><p><a href="https://dlcdn.apache.org/rocketmq/4.9.3/rocketmq-all-4.9.3-source-release.zip">官网源码地址</a></p>
<p><a href="https://github.com/apache/rocketmq">github源码地址</a></p>
<h4 id="目录结构说明"><a href="#目录结构说明" class="headerlink" title="目录结构说明"></a>目录结构说明</h4><ul>
<li>broker: broker 模块（broke 启动进程） </li>
<li>client ：消息客户端，包含消息生产者、消息消费者相关类 </li>
<li>common ：公共包 </li>
<li>dev ：开发者信息（非源代码） </li>
<li>distribution ：部署实例文件夹（非源代码） </li>
<li>example: RocketMQ 例代码 </li>
<li>filter ：消息过滤相关基础类</li>
<li>filtersrv：消息过滤服务器实现相关类（Filter启动进程）</li>
<li>logappender：日志实现相关类</li>
<li>namesrv：NameServer实现相关类（NameServer启动进程）</li>
<li>openmessageing：消息开放标准</li>
<li>remoting：远程通信模块，给予Netty</li>
<li>srcutil：服务工具类</li>
<li>store：消息存储实现相关类</li>
<li>style：checkstyle相关实现</li>
<li>test：测试相关类</li>
<li>tools：工具类，监控命令相关实现类</li>
</ul>
<h4 id="导入ide开发工具"><a href="#导入ide开发工具" class="headerlink" title="导入ide开发工具"></a>导入ide开发工具</h4><img src="/2022/05/15/rocketmq-yuan-ma-diao-shi-huan-jing-da-jian/image-20220515182156550.png" class="asset-class" title="image-20220515182156550">

<h5 id="执行安装脚本"><a href="#执行安装脚本" class="headerlink" title="执行安装脚本"></a>执行安装脚本</h5><pre><code class="prettyprint">mvn clean install -Dmaven.test.skip=true
</code></pre>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ul>
<li><p>在根目录下创建conf文件夹</p>
</li>
<li><p>拷贝<code>distribution</code>目录下<code>broker.conf</code>和<code>logback_broker.xml</code>和<code>logback_namesrv.xml</code></p>
<ul>
<li><code>broker.conf</code>配置broker启动配置i文件</li>
<li><code>logback_broker.xml</code> broker日志配置</li>
<li><code>logback_namesrv.xml</code> namesrv日志配置</li>
</ul>
</li>
<li><p>修改<code>broker.conf</code>配置</p>
<pre><code class="prettyprint"># Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the &quot;License&quot;); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
brokerClusterName = DefaultCluster
brokerName = broker-a
brokerId = 0
# namesrvAddr地址
namesrvAddr=127.0.0.1:9876
deleteWhen = 04
fileReservedTime = 48
brokerRole = ASYNC_MASTER
flushDiskType = ASYNC_FLUSH
autoCreateTopicEnable=true

# 存储路径
storePathRootDir=E:\\code\\rocketmq\\data\\rocketmq\\dataDir
# commitLog路径
storePathCommitLog=E:\\code\\rocketmq\\data\\rocketmq\\dataDir\\commitlog
# 消息队列存储路径
storePathConsumeQueue=E:\\code\\rocketmq\\data\\rocketmq\\dataDir\\consumequeue
# 消息索引存储路径
storePathIndex=E:\\code\\rocketmq\\data\\rocketmq\\dataDir\\index
# checkpoint文件路径
storeCheckpoint=E:\\code\\rocketmq\\data\\rocketmq\\dataDir\\checkpoint
# abort文件存储路径
abortFile=E:\\code\\rocketmq\\data\\rocketmq\\dataDir\\abort
</code></pre>
</li>
</ul>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><ul>
<li><p><code>namesrv</code>启动</p>
<ul>
<li>需要配置ROCKETMQ_HOME环境，<code>ROCKETMQ_HOME=E:\code\rocketmq\rocketmq-all-4.9.3</code></li>
</ul>
<img src="/2022/05/15/rocketmq-yuan-ma-diao-shi-huan-jing-da-jian/image-20220515182558374.png" class="asset-class" title="image-20220515182558374">

<ul>
<li>执行<code>namesrv</code>工程下面的<code>org.apache.rocketmq.namesrv.NamesrvStartup#main</code>方法启动</li>
</ul>
<img src="/2022/05/15/rocketmq-yuan-ma-diao-shi-huan-jing-da-jian/image-20220515182844276.png" class="asset-class" title="image-20220515182844276">
</li>
<li><p><code>broker</code>启动配置</p>
<ul>
<li><p>需要配置ROCKETMQ_HOME环境，<code>ROCKETMQ_HOME=E:\code\rocketmq\rocketmq-all-4.9.3</code></p>
</li>
<li><p>指定conf路径启动 <code>-c E:\code\rocketmq\rocketmq-all-4.9.3\conf\broker.conf</code></p>
</li>
</ul>
<img src="/2022/05/15/rocketmq-yuan-ma-diao-shi-huan-jing-da-jian/image-20220515183024715.png" class="asset-class" title="image-20220515183024715">

<ul>
<li>执行<code>broker</code>工程下面的<code>org.apache.rocketmq.broker.BrokerStartup#main</code>方法</li>
</ul>
<img src="/2022/05/15/rocketmq-yuan-ma-diao-shi-huan-jing-da-jian/image-20220515183148021.png" class="asset-class" title="image-20220515183148021"></li>
</ul>
<h5 id="测试org-apache-rocketmq-example-quickstart"><a href="#测试org-apache-rocketmq-example-quickstart" class="headerlink" title="测试org.apache.rocketmq.example.quickstart"></a>测试<code>org.apache.rocketmq.example.quickstart</code></h5><ul>
<li><p>生产者</p>
<pre><code class="prettyprint">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.rocketmq.example.quickstart;

import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;

/**
 * This class demonstrates how to send messages to brokers using provided &#123;@link DefaultMQProducer&#125;.
 */
public class Producer &#123;
    public static void main(String[] args) throws MQClientException, InterruptedException &#123;

        /*
         * Instantiate with a producer group name.
         */
        DefaultMQProducer producer = new DefaultMQProducer(&quot;please_rename_unique_group_name&quot;);
        producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);
        /*
         * Specify name server addresses.
         * &lt;p/&gt;
         *
         * Alternatively, you may specify name server addresses via exporting environmental variable: NAMESRV_ADDR
         * &lt;pre&gt;
         * &#123;@code
         * producer.setNamesrvAddr(&quot;name-server1-ip:9876;name-server2-ip:9876&quot;);
         * &#125;
         * &lt;/pre&gt;
         */

        /*
         * Launch the instance.
         */
        producer.start();

        for (int i = 0; i &lt; 10; i++) &#123;
            try &#123;

                /*
                 * Create a message instance, specifying topic, tag and message body.
                 */
                Message msg = new Message(&quot;TopicTest&quot; /* Topic */,
                    &quot;TagA&quot; /* Tag */,
                    (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */
                );

                /*
                 * Call send message to deliver message to one of brokers.
                 */
                SendResult sendResult = producer.send(msg);
                /*
                 * There are different ways to send message, if you don&#39;t care about the send result,you can use this way
                 * &#123;@code
                 * producer.sendOneway(msg);
                 * &#125;
                 */

                /*
                 * if you want to get the send result in a synchronize way, you can use this send method
                 * &#123;@code
                 * SendResult sendResult = producer.send(msg);
                 * System.out.printf(&quot;%s%n&quot;, sendResult);
                 * &#125;
                 */

                /*
                 * if you want to get the send result in a asynchronize way, you can use this send method
                 * &#123;@code
                 *
                 *  producer.send(msg, new SendCallback() &#123;
                 *  @Override
                 *  public void onSuccess(SendResult sendResult) &#123;
                 *      // do something
                 *  &#125;
                 *
                 *  @Override
                 *  public void onException(Throwable e) &#123;
                 *      // do something
                 *  &#125;
                 *&#125;);
                 *
                 *&#125;
                 */

                System.out.printf(&quot;%s%n&quot;, sendResult);
            &#125; catch (Exception e) &#123;
                e.printStackTrace();
                Thread.sleep(1000);
            &#125;
        &#125;

        /*
         * Shut down once the producer instance is not longer in use.
         */
        producer.shutdown();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<img src="/2022/05/15/rocketmq-yuan-ma-diao-shi-huan-jing-da-jian/image-20220515183358912.png" class="asset-class" title="image-20220515183358912">

<ul>
<li>消费者</li>
</ul>
<pre><code class="prettyprint">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.rocketmq.example.quickstart;

import java.util.List;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.message.MessageExt;

/**
 * This example shows how to subscribe and consume messages using providing &#123;@link DefaultMQPushConsumer&#125;.
 */
public class Consumer &#123;

    public static void main(String[] args) throws InterruptedException, MQClientException &#123;

        /*
         * Instantiate with specified consumer group name.
         */
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;please_rename_unique_group_name_4&quot;);
        consumer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);
        /*
         * Specify name server addresses.
         * &lt;p/&gt;
         *
         * Alternatively, you may specify name server addresses via exporting environmental variable: NAMESRV_ADDR
         * &lt;pre&gt;
         * &#123;@code
         * consumer.setNamesrvAddr(&quot;name-server1-ip:9876;name-server2-ip:9876&quot;);
         * &#125;
         * &lt;/pre&gt;
         */

        /*
         * Specify where to start in case the specific consumer group is a brand-new one.
         */
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);

        /*
         * Subscribe one more topic to consume.
         */
        consumer.subscribe(&quot;TopicTest&quot;, &quot;*&quot;);

        /*
         *  Register callback to execute on arrival of messages fetched from brokers.
         */
        consumer.registerMessageListener(new MessageListenerConcurrently() &#123;

            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,
                ConsumeConcurrentlyContext context) &#123;
                System.out.printf(&quot;%s Receive New Messages: %s %n&quot;, Thread.currentThread().getName(), msgs);
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            &#125;
        &#125;);

        /*
         *  Launch the consumer instance.
         */
        consumer.start();

        System.out.printf(&quot;Consumer Started.%n&quot;);
    &#125;
&#125;
</code></pre>
<img src="/2022/05/15/rocketmq-yuan-ma-diao-shi-huan-jing-da-jian/image-20220515183513129.png" class="asset-class" title="image-20220515183513129">

]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>javac编译找不到同包下面的类</title>
    <url>/2022/05/19/javac-bian-yi-zhao-bu-dao-tong-bao-xia-mian-de-lei/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>目录结构</li>
</ul>
<img src="/2022/05/19/javac-bian-yi-zhao-bu-dao-tong-bao-xia-mian-de-lei/image-20220519221633534.png" class="asset-class" title="image-20220519221633534">

<ul>
<li><p><code>MovingAverageTest</code>类中有依赖<code>MovingAverage</code>这时如果在jvm目录下执行命令</p>
<pre><code class="prettyprint">javac MovingAverageTest.java
</code></pre>
<p>会出现找不到类的错误</p>
</li>
</ul>
<p>​		<img src="/2022/05/19/javac-bian-yi-zhao-bu-dao-tong-bao-xia-mian-de-lei/image-20220519221958178.png" class="asset-class" title="image-20220519221958178"></p>
<ul>
<li><p>这时需要在包根目录<code>E:\code\java\jike\src\main\java\</code>下执行</p>
<pre><code class="prettyprint">javac com/rocpenghua/jvm/MovingAverageTest.java
</code></pre>
<img src="/2022/05/19/javac-bian-yi-zhao-bu-dao-tong-bao-xia-mian-de-lei/image-20220519222203897.png" class="asset-class" title="image-20220519222203897">
</li>
<li><p><code>javap</code>可以查看字节码</p>
<pre><code class="prettyprint">javap -c com.rocpenghua.jvm/MovingAverageTest
#详细信息
javap -c -verbose com.rocpenghua.jvm/MovingAverageTest
</code></pre>
</li>
</ul>
<img src="/2022/05/19/javac-bian-yi-zhao-bu-dao-tong-bao-xia-mian-de-lei/image-20220519222345324.png" class="asset-class" title="image-20220519222345324">

<img src="/2022/05/19/javac-bian-yi-zhao-bu-dao-tong-bao-xia-mian-de-lei/image-20220519222431144.png" class="asset-class" title="image-20220519222431144">
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>prettyprint</title>
    <url>/2022/05/28/prettyprint/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code class="prettyprint">public class PrettyPrint &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;Hello World！&quot;)
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>mysql主从配置</title>
    <url>/2022/06/03/mysql-zhu-cong-pei-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="主节点配置"><a href="#主节点配置" class="headerlink" title="主节点配置"></a>主节点配置</h3><pre><code class="prettyprint">#登录主节点
E:\tools\database\mysql-8.0.11-winx64-1\bin&gt;mysql -uroot
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 12
Server version: 8.0.11 MySQL Community Server - GPL

Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.

mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.00 sec)

mysql&gt; CREATE USER &#39;rep1&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;
Query OK, 0 rows affected (0.11 sec)
mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &#39;rep1&#39;@&#39;%&#39;;
Query OK, 0 rows affected (0.06 sec)

mysql&gt; flush privileges;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; show master status;
+---------------+----------+--------------+------------------+-------------------+
| File          | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+---------------+----------+--------------+------------------+-------------------+
| binlog.000001 |     2283 |              |                  |                   |
+---------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
</code></pre>
<h3 id="配置从节点"><a href="#配置从节点" class="headerlink" title="配置从节点"></a>配置从节点</h3><pre><code class="prettyprint">mysql&gt; CHANGE MASTER TO
         MASTER_HOST=&#39;localhost&#39;,
         MASTER_PORT=3306,
         MASTER_USER=&#39;rep1&#39;,
         MASTER_PASSWORD=&#39;123456&#39;,
         MASTER_LOG_FILE=&#39;binlog.000001&#39;,
         MASTER_LOG_POS=2283;
Query OK, 0 rows affected, 1 warning (0.28 sec)
mysql&gt; start slave;
mysql&gt; show slave status\G;
</code></pre>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>mysql事务</title>
    <url>/2022/06/03/mysql-shi-wu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h1><ul>
<li><p>原子性(Atomicity)：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。（针对于操作层面）</p>
</li>
<li><p>一致性(Consistent) ：在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性。（针对于数据层面）</p>
</li>
<li><p>隔离性(Isolation) ：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。</p>
</li>
<li><p>持久性(Durable) ：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。</p>
</li>
</ul>
<h1 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h1><ul>
<li><p>更新丢失或者脏写(Lost Update)：当两个事务或者多个事务对同一条数据做更新时，后面提交的数据会覆盖前面的写数据；</p>
</li>
<li><p>脏读（Dirty Reads）：事务A读取到了还未提交事务B的数据；</p>
</li>
<li><p>不可重复读（Non-Repeatable Reads）：事务A和事务B同时begin时，事务B先提交了，事务A读取到了事务B已提交的数据；</p>
</li>
<li><p>幻读（Phantom Reads）：事务A和事务B同时begin时，事务B先提交了，事务A读取到了事务B已提交的新增数据；</p>
</li>
</ul>
<h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><img src="/2022/06/03/mysql-shi-wu/12776164-7c040c7df6900659.png" class="asset-class" title="img">

<h1 id="MVCC机制"><a href="#MVCC机制" class="headerlink" title="MVCC机制"></a>MVCC机制</h1><p>读已提交和可重复读都是用了MVCC（Multi-Version Concurrency Control）机制；</p>
<p>首先mysql会为每一行数据，多维护trx_id（事务id，一般是自增的）和roll_pointer（回滚指针，上一个版本的指针）；再会维护一个undo日志，每当数据有更新时，先把历史版本数据写入undo日志，便于以后回滚；</p>
<img src="/2022/06/03/mysql-shi-wu/12776164-9399ca1bbd0143fe.png" class="asset-class" title="img">

<p><code>undo日志结构</code></p>
<p>MVCC机制：在事务开启后，第一个查询语句执行之前，会把当前数据库存在的未提交事务放在一个readView集合中，获取一个当前数据库最大的事务id（max_id）；再从readView中选出最小的事务id（min_id）;因为事务是自增的；所以当事务开启后，查询到的数据</p>
<ul>
<li><p>如果trx_id的版本号小于min_id则说明当前这个版本号肯定是在我这个事务开启前已提交的，则是可见的，可以查询出来的数据；</p>
</li>
<li><p>如果大于min_id且小于max_id，则需要去看是否在readView集合中，如果在该集合中，则该事务未提交，则是不可见的，需要根据roll_pointer去查找上个版本的数据，直到查找到复核规则的数据；</p>
</li>
<li><p>如果是大于max_id，因为事务id是自增的，则该事务肯定是我查询之后才插入的数据，所以该数据是不可见的，则需要查找上个版本数据，直到查找到复核规则的数据；</p>
</li>
</ul>
<p>mysql默认使用可重复读（RR）级别，是上述规则；当使用读已提交，区别在于，每次查询语句都会生成一个当前的readView；</p>
<p>链接：<a href="https://www.jianshu.com/p/142e7ee32b86">https://www.jianshu.com/p/142e7ee32b86</a></p>
]]></content>
      <categories>
        <category>数据</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql索引</title>
    <url>/2022/06/03/mysql-suo-yin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="何为索引？有什么作用？"><a href="#何为索引？有什么作用？" class="headerlink" title="何为索引？有什么作用？"></a>何为索引？有什么作用？</h1><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong><br> 索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<h1 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h1><p><strong>优点</strong> ：</p>
<ul>
<li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p>
<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>
<h1 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h1><h2 id="Hash表-amp-B-树"><a href="#Hash表-amp-B-树" class="headerlink" title="Hash表 &amp; B+树"></a>Hash表 &amp; B+树</h2><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p>
<p><strong>为何能够通过 key 快速取出 value呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 value 对应的 index，找到了 index 也就找到了对应的 value。</p>
<pre><code class="prettyprint">hash = hashfunc(key)
index = hash % array_size
</code></pre>
<img src="/2022/06/03/mysql-suo-yin/webp-165425733052856.webp" class="asset-class" title="img">

<p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了红黑树。</p>
<img src="/2022/06/03/mysql-suo-yin/webp-165425731577354.webp" class="asset-class" title="img">

<p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。<br> 既然哈希表这么快，<strong>为什么MySQL 没有使用其作为索引的数据结构呢？</strong><br> <strong>1.Hash 冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。<br> <strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p>
<p>试想一种情况:</p>
<pre><code class="prettyprint">SELECT * FROM tb1 WHERE id &lt; 500;Copy to clipboardErrorCopied
</code></pre>
<p>在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。</p>
<h2 id="B-树-amp-B-树"><a href="#B-树-amp-B-树" class="headerlink" title="B 树&amp; B+树"></a>B 树&amp; B+树</h2><p>B 树全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p>
<p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p>
<p><strong>B 树&amp; B+树两者有何异同呢？</strong></p>
<ul>
<li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
<img src="/2022/06/03/mysql-suo-yin/webp-165425730431552.webp" class="asset-class" title="img">

<p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p>
<p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p>
<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<h1 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h1><h2 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h2><p>数据表的主键列使用的就是主键索引。<br> 一张数据表有只能有一个主键，并且主键不能为 null，不能重复。<br> 在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p>
<h2 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h2><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong><br> 唯一索引，普通索引，前缀索引等索引属于二级索引。<br> <strong>PS:不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</strong></p>
<ol>
<li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li>
<li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li>
<li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>
</ol>
<p>二级索引: </p>
<img src="/2022/06/03/mysql-suo-yin/webp-165425728778950.webp" class="asset-class" title="img">

<h1 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h1><h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p>
<p>在 Mysql 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<h3 id="聚集索引的优点"><a href="#聚集索引的优点" class="headerlink" title="聚集索引的优点"></a>聚集索引的优点</h3><p>聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>
<h3 id="聚集索引的缺点"><a href="#聚集索引的缺点" class="headerlink" title="聚集索引的缺点"></a>聚集索引的缺点</h3><ol>
<li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ol>
<h2 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h2><p><strong>非聚集索引即索引结构和数据分开存放的索引。</strong></p>
<p><strong>二级索引属于非聚集索引。</strong></p>
<blockquote>
<p>MYISAM 引擎的表的.MYI 文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。</p>
<p><strong>非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p>
</blockquote>
<h3 id="非聚集索引的优点"><a href="#非聚集索引的优点" class="headerlink" title="非聚集索引的优点"></a>非聚集索引的优点</h3><p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>
<h3 id="非聚集索引的缺点"><a href="#非聚集索引的缺点" class="headerlink" title="非聚集索引的缺点"></a>非聚集索引的缺点</h3><ol>
<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ol>
<p>这是 MySQL 的表的文件截图:</p>
<img src="/2022/06/03/mysql-suo-yin/webp-165425727549748.webp" class="asset-class" title="img">

<p>聚集索引和非聚集索引:</p>
<img src="/2022/06/03/mysql-suo-yin/webp-165425725894946.webp" class="asset-class" title="img">

<h2 id="非聚集索引一定回表查询吗-覆盖索引"><a href="#非聚集索引一定回表查询吗-覆盖索引" class="headerlink" title="非聚集索引一定回表查询吗(覆盖索引)?"></a>非聚集索引一定回表查询吗(覆盖索引)?</h2><p><strong>非聚集索引不一定回表查询。</strong></p>
<blockquote>
<p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p>
</blockquote>
<pre><code class="prettyprint"> SELECT name FROM table WHERE name=&#39;guang19&#39;;
</code></pre>
<blockquote>
<p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p>
</blockquote>
<p><strong>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表， 因为它的主键索引的叶子节点存放的是指针。但是如果 SQL 查的就是主键呢?</strong></p>
<pre><code class="prettyprint">SELECT id FROM table WHERE id=1;
</code></pre>
<p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p>
<h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。</strong></p>
<blockquote>
<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p>
</blockquote>
<p>覆盖索引: </p>
<img src="/2022/06/03/mysql-suo-yin/webp-165425722617344.webp" class="asset-class" title="img">

<h1 id="创建索引的注意事项"><a href="#创建索引的注意事项" class="headerlink" title="创建索引的注意事项"></a>创建索引的注意事项</h1><p><strong>1.选择合适的字段创建索引：</strong></p>
<ul>
<li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>
<li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li>
<li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>
<li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>
</ul>
<p><strong>2.被频繁更新的字段应该慎重建立索引。</strong></p>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<p><strong>3.尽可能的考虑建立联合索引而不是单列索引。</strong></p>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<p><strong>4.注意避免冗余索引</strong> 。</p>
<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<h1 id="使用索引的一些建议"><a href="#使用索引的一些建议" class="headerlink" title="使用索引的一些建议"></a>使用索引的一些建议</h1><ul>
<li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li>
<li>避免 where 子句中对字段施加函数，这会造成无法命中索引。</li>
<li>在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li>
<li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</li>
<li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li>
</ul>
<h1 id="MySQL-如何为表字段添加索引？"><a href="#MySQL-如何为表字段添加索引？" class="headerlink" title="MySQL 如何为表字段添加索引？"></a>MySQL 如何为表字段添加索引？</h1><p>1.添加 PRIMARY KEY（主键索引）</p>
<pre><code class="prettyprint">ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` )
</code></pre>
<p>2.添加 UNIQUE(唯一索引)</p>
<pre><code class="prettyprint">ALTER TABLE `table_name` ADD UNIQUE ( `column` )
</code></pre>
<p>3.添加 INDEX(普通索引)</p>
<pre><code class="prettyprint">ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
</code></pre>
<p>4.添加 FULLTEXT(全文索引)</p>
<pre><code class="prettyprint">ALTER TABLE `table_name` ADD FULLTEXT ( `column`)
</code></pre>
<p>5.添加多列索引</p>
<pre><code class="prettyprint">ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
</code></pre>
<p>链接：<a href="https://www.jianshu.com/p/e54074fe91d8">https://www.jianshu.com/p/e54074fe91d8</a></p>
]]></content>
      <categories>
        <category>数据</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql锁机制</title>
    <url>/2022/06/03/mysql-suo-ji-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="表级锁、行级锁、页级锁"><a href="#表级锁、行级锁、页级锁" class="headerlink" title="表级锁、行级锁、页级锁"></a>表级锁、行级锁、页级锁</h2><p>数据库锁定机制简单来说，就是<strong>数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则</strong>。</p>
<p>MySQL数据库由于其自身架构的特点，存在多种数据存储引擎，每种存储引擎的锁定机制都是为各自所面对的特定场景而优化设计，所以各存储引擎的锁定机制也有较大区别。</p>
<p>MySQL各存储引擎使用了三种类型（级别）的锁定机制：<code>表级锁定</code>，<code>行级锁定</code>和<code>页级锁定</code>。</p>
<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。</p>
<p>当然，<strong>锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发度大打折扣</strong>。</p>
<p>使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。</p>
<h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><p>行级锁定最大的特点就是<strong>锁定对象的颗粒度很小</strong>，由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。</p>
<p>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。</p>
<p><strong>由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁</strong>。</p>
<p><code>使用行级锁定的主要是InnoDB存储引擎</code>。</p>
<h4 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h4><p>页级锁定是MySQL中比较独特的一种锁定级别。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。</p>
<p>使用页级锁定的主要是BerkeleyDB存储引擎。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总的来说，MySQL这3种锁的特性可大致归纳如下：</p>
<p><code>表级锁</code>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；<br><code>行级锁</code>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；<br><code>页面锁</code>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>
<h2 id="共享锁、排它锁"><a href="#共享锁、排它锁" class="headerlink" title="共享锁、排它锁"></a>共享锁、排它锁</h2><p>InnoDB 实现了标准的<strong>行级锁</strong>，包括两种：<strong>共享锁</strong>（简称 s 锁）、<strong>排它锁</strong>（简称 x 锁）。</p>
<p>对于共享锁而言，对当前行加<strong>共享锁</strong>，不会阻塞其他事务对同一行的读请求，但会阻塞对同一行的写请求。只有当读锁释放后，才会执行其它事物的写操作。</p>
<p>对于排它锁而言，会阻塞其他事务对同一行的读和写操作，只有当写锁释放后，才会执行其它事务的读写操作。</p>
<img src="/2022/06/03/mysql-suo-ji-zhi/webp-165424398243024.webp" class="asset-class" title="img">

<p>简而言之，就是<code>读锁会阻塞写(X)，但是不会堵塞读(S)。而写锁则会把读(S)和写(X)都堵塞</code></p>
<p>对于InnoDB 在RR(MySQL默认隔离级别) 而言，对于 update、delete 和 insert 语句， 会自动给涉及数据集加排它锁（X）；</p>
<p>对于普通 select 语句，innodb 不会加任何锁。如果想在select操作的时候加上 S锁 或者 X锁，需要我们手动加锁。</p>
<pre><code class="prettyprint">-- 加共享锁（S）
select * from table_name where ... lock in share mode

-- 加排它锁（X)
select * from table_name where ... for update
</code></pre>
<p>用 <strong>select… in share mode</strong> 获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行 update 或者 delete 操作。</p>
<p>但是如果当前事务也需要对该记录进行更新操作,则有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用 <strong>select… for update</strong> 方式获得排他锁。</p>
<h2 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h2><h4 id="记录锁（Record-Locks）"><a href="#记录锁（Record-Locks）" class="headerlink" title="记录锁（Record Locks）"></a>记录锁（Record Locks）</h4><p>记录锁其实很好理解，对表中的记录加锁，叫做记录锁，简称行锁。比如</p>
<pre><code class="prettyprint">SELECT * FROM `test` WHERE `id`=1 FOR UPDATE;
</code></pre>
<p>它会在 id&#x3D;1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id&#x3D;1 这一行。</p>
<p>需要注意的是：</p>
<ul>
<li><strong>id 列必须为唯一索引列或主键列</strong>，否则上述语句加的锁就会变成临键锁(有关临键锁下面会讲)。</li>
<li><strong>同时查询语句必须为精准匹配（&#x3D;）</strong>，不能为 &gt;、&lt;、like等，否则也会退化成临键锁。</li>
</ul>
<p>其他实现</p>
<p>在通过 <strong>主键索引</strong> 与 <strong>唯一索引</strong> 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：</p>
<pre><code class="prettyprint">-- id 列为主键列或唯一索引列 
UPDATE SET age = 50 WHERE id = 1;
</code></pre>
<p><strong>记录锁是锁住记录，锁住索引记录，而不是真正的数据记录</strong>.</p>
<p>如果要锁的列没有索引，进行全表记录加锁</p>
<p><code>记录锁也是排它(X)锁</code>,所以会阻塞其他事务对其<strong>插入、更新、删除</strong>。</p>
<h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h2><h4 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h4><p>间隙锁 是 <strong>Innodb 在 RR(可重复读) 隔离级别</strong> 下为了解决<code>幻读问题</code>时引入的锁机制。<strong>间隙锁是innodb中行锁的一种</strong>。</p>
<p>请务必牢记：<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据</strong>。</p>
<p>举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101，下面的SQL：</p>
<pre><code class="prettyprint">  SELECT * FROM emp WHERE empid &gt; 100 FOR UPDATE
</code></pre>
<p>当我们用条件检索数据，并请求共享或排他锁时，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p>
<p>这个时候如果你插入empid等于102的数据的，如果那边事物还没有提交，那你就会处于等待状态，无法插入数据。</p>
<h2 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h2><h4 id="临键锁（Next-Key-Locks）"><a href="#临键锁（Next-Key-Locks）" class="headerlink" title="临键锁（Next-Key Locks）"></a>临键锁（Next-Key Locks）</h4><p><strong>Next-key锁是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁</strong>。</p>
<p>也可以理解为一种特殊的<strong>间隙锁</strong>。通过<strong>临建锁</strong>可以解决<code>幻读</code>的问题。 每个数据行上的<strong>非唯一索引列</strong>上都会存在一把<strong>临键锁</strong>，当某个事务持有该数据行的<strong>临键锁</strong>时，会锁住一段<strong>左开右闭区间</strong>的数据。需要强调的一点是，InnoDB 中<strong>行级锁</strong>是基于索引实现的，<strong>临键锁</strong>只与<strong>非唯一索引列</strong>有关，在<code>唯一索引列（包括主键列）上不存在临键锁</code>。</p>
<p>假设有如下表：</p>
<p><strong>InnoDB</strong>，<strong>RR隔离级别</strong>：id主键, age 普通索引</p>
<img src="/2022/06/03/mysql-suo-ji-zhi/webp-165424396374222.webp" class="asset-class" title="img">

<p>该表中 age 列潜在的临键锁有：<br> (-∞, 10],<br> (10, 24],<br> (24, 32],<br> (32, 45],<br> (45, +∞],<br> 在事务 A 中执行如下命令：</p>
<pre><code class="prettyprint">-- 根据非唯一索引列 UPDATE 某条记录 
UPDATE table SET name = Vladimir WHERE age = 24; 
-- 或根据非唯一索引列 锁住某条记录 
SELECT * FROM table WHERE age = 24 FOR UPDATE; 
</code></pre>
<p>不管执行了上述 SQL 中的哪一句，之后如果在事务 B 中执行以下命令，则该命令会被阻塞：</p>
<pre><code class="prettyprint">INSERT INTO table VALUES(100, 26, &#39;tianqi&#39;); 
</code></pre>
<p>很明显，事务 A 在对 age 为 24 的列进行 UPDATE 操作的同时，也获取了 (24, 32] 这个区间内的临键锁。</p>
<p><code>总结</code></p>
<p>这里对 <strong>记录锁</strong>、<strong>间隙锁</strong>、<strong>临键锁</strong> 做一个总结</p>
<ul>
<li><strong>InnoDB</strong> 中的<strong>行锁</strong>的实现依赖于<strong>索引</strong>，一旦某个加锁操作没有使用到索引，那么该锁就会退化为<code>表锁</code>。</li>
<li><strong>记录锁</strong>存在于包括<strong>主键索引</strong>在内的<strong>唯一索引</strong>中，锁定单条索引记录。</li>
<li><strong>间隙锁</strong>存在于<strong>非唯一索引</strong>中，锁定<strong>开区间</strong>范围内的一段间隔，它是基于<strong>临键锁</strong>实现的。</li>
<li><strong>临键锁</strong>存在于<strong>非唯一索引</strong>中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的<strong>间隙锁</strong>，锁定一段<strong>左开右闭</strong>的索引区间。</li>
</ul>
<h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><h4 id="意向锁-1"><a href="#意向锁-1" class="headerlink" title="意向锁"></a>意向锁</h4><p>意向锁又分为 <code>意向共享锁（IS）</code>和 <code>意向排他锁（IX）</code></p>
<ul>
<li><strong>意向共享(IS)锁</strong>：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</li>
</ul>
<pre><code class="prettyprint">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 
SELECT column FROM table ... LOCK IN SHARE MODE;
</code></pre>
<ul>
<li><strong>意向排他(IX)锁</strong>：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</li>
</ul>
<pre><code class="prettyprint"> -- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。
 SELECT column FROM table ... FOR UPDATE;
</code></pre>
<p>首先我们要明白四点</p>
<ul>
<li>意向共享锁（IS）和 意向排他锁（IX）都是<strong>表锁</strong>。</li>
<li>意向锁是一种 <strong>不与行级锁冲突的表级锁</strong>，这一点非常重要。</li>
<li>意向锁是 InnoDB 自动加的， 不需用户干预。</li>
<li>意向锁是在 InnoDB 下存在的内部锁，对于MyISAM 而言 没有意向锁之说。</li>
</ul>
<p>这里就会有疑惑，既然前面已经有了共享锁（S锁）、排它锁（X锁）。那么为什么需要引入意向锁呢？它能解决什么问题呢？</p>
<p>我们可以理解 意向锁 存在的目的就是 为了让 <code>InnoDB 中的行锁和表锁更高效的共存</code>。</p>
<p>为什么这么说，我们来举一个例子。</p>
<p>下面有一张表 <strong>InnoDB RR隔离级别 id是主键</strong></p>
<img src="/2022/06/03/mysql-suo-ji-zhi/webp-165424393096220.webp" class="asset-class" title="img">

<p>事务 A 获取了<strong>某一行的排他锁</strong>，并未提交：</p>
<pre><code class="prettyprint">SELECT * FROM users WHERE id = 6 FOR UPDATE; 
</code></pre>
<p>事务 B 想要获取users表的<strong>表锁</strong>：</p>
<pre><code class="prettyprint">LOCK TABLES users READ; 
</code></pre>
<p>因为共享锁与排他锁互斥，所以事务 B 在视图对 users 表加共享锁的时候，必须保证：</p>
<ul>
<li>当前没有其他事务持有 users 表的排他锁。</li>
<li>当前没有其他事务持有 users 表中任意一行的排他锁 。</li>
</ul>
<p>为了检测是否满足第二个条件，事务 B 必须在确保users表不存在任何<strong>排他锁</strong>的前提下，去检测表中的<strong>每一行是否存在排他锁</strong>。很明显这是一个效率很差的做法，但是有了<strong>意向锁</strong>之后，情况就不一样了：事务B只要看表上有没有意向共享锁，有则说明表中有些行被<strong>共享行锁</strong>锁住了，因此，事务B申请表的写锁会被阻塞。这样是不是就高效多了。</p>
<p>这也解释就应该清楚，为什么有意向锁这个东西存在了。</p>
<p>我们可以举个生活中的例子，再来理解下为什么需要存在意向锁。</p>
<p>打个比方，就像有个游乐场，很多小朋友进去玩，看门大爷如果要下班锁游乐场的门(<strong>加表锁</strong>)，他必须确保每个角落都要去检查一遍，确保每个小朋友都离开了(<strong>释放行锁</strong>)，才可以锁门。</p>
<p>假设锁门是件频繁发生的事情，大爷就会非常崩溃。那大爷想了一个办法，每个小朋友进入，就把自己的名字写在本子上，小朋友离开，就把自己的名字划掉，那大爷就能方便掌握有没有小朋友在游乐场里，不必每个角落都去寻找一遍。例子中的“小本子”，就是<strong>意向锁</strong>，他记录的信息并不精细，他只是提醒大爷，有人在屋里。</p>
<p>这里我们再来看下 共享(S)锁、排他(X)锁、意向共享锁（IS）、意向排他锁（IX）的兼容性</p>
<img src="/2022/06/03/mysql-suo-ji-zhi/webp-165424391917018.webp" class="asset-class" title="img">

<p>可以看出 <strong>意向锁之间是互相兼容的</strong>.那你存在的意义是啥？</p>
<p>意向锁不会为难意向锁。也不会为难行级排他(X)&#x2F;共享(X)锁,它的存在是为难<code>表级</code>排他(X)&#x2F;共享(X)锁。</p>
<img src="/2022/06/03/mysql-suo-ji-zhi/webp-165424390759316.webp" class="asset-class" title="img">

<p><code>注意</code><strong>这里的排他(X)&#x2F;共享(S)锁指的都是表锁！意向锁不会与行级的共享&#x2F;排他锁互斥！</strong> 行级别的X和S按照上面的兼容性规则即可。</p>
<p>意向锁与意向锁之间永远是兼容的，因为当你不论加行级的X锁或S锁，都会自动获取表级的IX锁或者IS锁。也就是你有10个事务，对不同的10行加了行级X锁，那么这个时候就存在10个IX锁。</p>
<p>这10个IX存在的目的是啥呢，就是假如这个时候有个事务，想对整个表加排它X锁,那它不需要遍历每一行是否存在S或X锁，而是看有没有存在意向锁，只要存在一个意向锁，那这个事务就加不了表级排它X锁，要等上面10个IX全部释放才行。</p>
<h2 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h2><h4 id="插入意向锁-1"><a href="#插入意向锁-1" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>在讲解插入意向锁之前，先来思考一个问题</p>
<p>下面有张表 id主键，age普通索引</p>
<p>首先<strong>事务 A</strong> 插入了一行数据，并且没有 <strong>commit</strong>：</p>
<img src="/2022/06/03/mysql-suo-ji-zhi/webp-165424389093414.webp" class="asset-class" title="img">

<pre><code class="prettyprint">INSERT INTO users SELECT 4, &#39;Bill&#39;, 15; 
</code></pre>
<p>随后<strong>事务 B</strong> 试图插入一行数据：</p>
<pre><code class="prettyprint">INSERT INTO users SELECT 5, &#39;Louis&#39;, 16; 
</code></pre>
<p>请问：</p>
<p>1、事务A使用了什么锁？</p>
<p>2、 <strong>事务 B</strong> 是否会被<strong>事务 A</strong> 阻塞？</p>
<p><strong>插入意向锁</strong>是在插入一条记录行前，由 <strong>INSERT</strong> 操作产生的一种<code>间隙锁</code>。</p>
<p>该锁用以表示插入<strong>意向</strong>，当多个事务在<strong>同一区间</strong>（gap）插入<strong>位置不同</strong>的多条数据时，事务之间<strong>不需要互相等待</strong>。</p>
<p>假设存在两条值分别为 4 和 7 的记录，两个不同的事务分别试图插入值为 5 和 6 的两条记录，每个事务在获取插入行上独占的（排他）锁前，都会获取（4，7）之间的<strong>间隙锁</strong>，但是因为数据行之间并不冲突，所以两个事务之间并<strong>不会产生冲突</strong>（阻塞等待）。</p>
<p>总结来说，<strong>插入意向锁</strong> 的特性可以分成两部分：</p>
<ul>
<li>插入意向锁是一种特殊的<strong>间隙锁</strong> —— 间隙锁可以锁定<strong>开区间</strong>内的部分记录。</li>
<li>插入意向锁之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身（<strong>主键</strong>、<strong>唯一索引</strong>）不冲突，那么事务之间就不会出现<strong>冲突等待</strong>。</li>
</ul>
<p>需要强调的是，虽然<strong>插入意向锁</strong>中含有<strong>意向锁</strong>三个字，但是它并不属于<strong>意向锁</strong>而属于<strong>间隙锁</strong>，因为<strong>意向锁</strong>是<strong>表锁</strong>而<code>插入意向锁是行锁</code>。</p>
<p>现在我们可以回答开头的问题了：</p>
<p>1、 使用<strong>插入意向锁</strong>与<strong>记录锁</strong>。<br> 2、<strong>事务 A</strong> 不会阻塞<strong>事务 B</strong>。</p>
<p>为什么不用间隙锁</p>
<p>如果只是使用普通的<strong>间隙锁</strong>会怎么样呢？我们在看事务A,其实它一共获取了3把锁</p>
<ul>
<li>id 为 4 的记录行的<strong>记录锁</strong>。</li>
<li>age 区间在（10，15）的<strong>间隙锁</strong>。</li>
<li>age 区间在（15，20）的<strong>间隙锁</strong>。</li>
</ul>
<p>最终，<strong>事务 A</strong> 插入了该行数据，并锁住了（10，20）这个区间。</p>
<p>随后<strong>事务 B</strong> 试图插入一行数据：</p>
<pre><code class="prettyprint">INSERT INTO users SELECT 5, &#39;Louis&#39;, 16; 
</code></pre>
<p>因为 16 位于（15，20）区间内，而该区间内又存在一把<strong>间隙锁</strong>，所以<strong>事务 B</strong> 别说想申请自己的<strong>间隙锁</strong>了，它甚至不能获取该行的<strong>记录锁</strong>，自然只能乖乖的等待 <strong>事务 A</strong>结束，才能执行插入操作。<br> 很明显，这样做事务之间将会频发陷入<strong>阻塞等待</strong>，<strong>插入的并发性</strong>非常之差。这时如果我们再去回想我们刚刚讲过的<strong>插入意向锁</strong>，就不难发现它是如何优雅的解决了<strong>并发插入</strong>的问题。</p>
<p><code>总结</code></p>
<ul>
<li><p>InnoDB在RR的事务隔离级别下，使用插入意向锁来<strong>控制和解决并发插入</strong>。</p>
</li>
<li><p>插入意向锁是一种特殊的<strong>间隙锁</strong>。</p>
</li>
<li><p>插入意向锁在锁定区间相同但记录行本身不冲突的情况下<strong>互不排斥</strong>。</p>
<p>链接：<a href="https://www.jianshu.com/p/478bc84a7721">https://www.jianshu.com/p/478bc84a7721</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>锁机制</tag>
      </tags>
  </entry>
  <entry>
    <title>win10安装两个mysql</title>
    <url>/2022/06/03/win10-an-zhuang-liang-ge-mysql/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><a href="https://downloads.mysql.com/archives/community/">MySQL :: Download MySQL Community Server (Archived Versions)</a></p>
<blockquote>
<p>下载免安装版本，解压至两个文件夹</p>
</blockquote>
<ul>
<li><p>mysql-8.0.11-winx64-1</p>
</li>
<li><p>mysql-8.0.11-winx64-2</p>
</li>
</ul>
<blockquote>
<p>分别在两个文件夹下新建<code>my.ini</code>文件</p>
</blockquote>
<ul>
<li>mysql-8.0.11-winx64-1&#x2F;my.ini</li>
</ul>
<pre><code class="prettyprint">[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8mb4
#---------分割线----------
[mysqld]
# 设置3306端口
port=3306
#服务id
server-id=1
# 设置mysql的安装目录
basedir=E:\\tools\\database\\mysql-8.0.11-winx64-1
# 设置mysql数据库的数据的存放目录
datadir=E:\\tools\\database\\mysql-8.0.11-winx64-1\\data
# 允许最大连接数
max_connections=200
# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统
max_connect_errors=10
# 服务端使用的字符集默认为 UTF8 More Byte 4
character-set-server=utf8mb4
# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
# 默认使用“mysql_native_password”插件认证
default_authentication_plugin=mysql_native_password
#不区分大小写
lower_case_table_names = 1
#数据库过大导入问题
max_allowed_packet=500M
wait_timeout=288000
interactive_timeout = 288000
#---------分割线----------
[client]
# 设置mysql客户端连接服务端时默认使用的端口
port=3306
default-character-set=utf8mb4
</code></pre>
<ul>
<li>mysql-8.0.11-winx64-2&#x2F;my.ini</li>
</ul>
<pre><code class="prettyprint">[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8mb4
#---------分割线----------
[mysqld]
# 设置3306端口
port=3316
#服务id
server-id=2
# 设置mysql的安装目录
basedir=E:\\tools\\database\\mysql-8.0.11-winx64-2
# 设置mysql数据库的数据的存放目录
datadir=E:\\tools\\database\\mysql-8.0.11-winx64-2\\data
# 允许最大连接数
max_connections=200
# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统
max_connect_errors=10
# 服务端使用的字符集默认为 UTF8 More Byte 4
character-set-server=utf8mb4
# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
# 默认使用“mysql_native_password”插件认证
default_authentication_plugin=mysql_native_password
#不区分大小写
lower_case_table_names = 1
#数据库过大导入问题
max_allowed_packet=500M
wait_timeout=288000
interactive_timeout = 288000
#---------分割线----------
[client]
# 设置mysql客户端连接服务端时默认使用的端口
port=3316
default-character-set=utf8mb4
</code></pre>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用管理员身份打开cmd</p>
<p>进入到mysql免安装bin目录下</p>
<h4 id="无密码模式"><a href="#无密码模式" class="headerlink" title="无密码模式"></a>无密码模式</h4><ul>
<li>在mysql-1下执行脚本</li>
</ul>
<pre><code class="prettyprint">mysqld install mysql1
mysqld --initialize-insecure --console
net start mysql1
#如有安装失败需要先删除data文件夹再安装
#进入mysql
mysql -uroot
</code></pre>
<ul>
<li>在mysql-1下执行脚本</li>
</ul>
<pre><code class="prettyprint">mysqld install mysql2
mysqld --initialize-insecure --console
net start mysql2
#如有安装失败需要先删除data文件夹再安装
#进入mysql
mysql -P3316 -uroot
</code></pre>
<h4 id="带密码安装"><a href="#带密码安装" class="headerlink" title="带密码安装"></a>带密码安装</h4><ul>
<li>在mysql-1下执行脚本</li>
</ul>
<pre><code class="prettyprint">mysqld install mysql1
#默认root，user可以不用指定，打印密码需要记住
mysqld --initialize --user=root --console
net start mysql1
#如有安装失败需要先删除data文件夹再安装
#进入mysql
mysql -uroot -p
#输入密码
**************
ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;;
create user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;root&#39;;
grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; with grant option;
flush privileges;
</code></pre>
<ul>
<li>在mysql-1下执行脚本</li>
</ul>
<pre><code class="prettyprint">mysqld install mysql2
#默认root，user可以不用指定，打印密码需要记住
mysqld --initialize --user=root --console
net start mysql2
#如有安装失败需要先删除data文件夹再安装
#进入mysql
mysql -uroot -p
#输入密码
**************
ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;;
create user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;root&#39;;
grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; with grant option;
flush privileges;
</code></pre>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>雪花算法（SnowFlake）</title>
    <url>/2022/06/03/xue-hua-suan-fa-snowflake/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p>SnowFlake算法生成id的结果是一个64bit大小的整数，它的结构如下图：</p>
</blockquote>
<img src="/2022/06/03/xue-hua-suan-fa-snowflake/webp.webp" class="asset-class" title="img">

<ul>
<li><p>1bit，不用，因为二进制中最高位是符号位，1表示负数，0表示正数。生成的id一般都是用整数，所以最高位固定为0。</p>
</li>
<li><p>41bit时间戳，毫秒级。可以表示的数值范围是 （2^41-1），转换成单位年则是69年。</p>
</li>
<li><p>10bit工作机器ID，用来表示工作机器的ID，包括5位<code>datacenterId</code>(机房id)和5位<code>workerId</code>(机器id)。</p>
</li>
<li><p>12bit序列号，用来记录同毫秒内产生的不同id，12位可以表示的最大整数为4095，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号。</p>
</li>
</ul>
<blockquote>
<p>由于在Java中64bit的整数是long类型，所以在Java中SnowFlake算法生成的id就是long来存储的。</p>
</blockquote>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><pre><code class="prettyprint">package dataStructure;

/**
 * @author RocPengHua
 * @program algorithmic-problems
 * @description 雪花算法
 * @date 2022年06月03日 20:46
 */

public class IdWorker &#123;

    //因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。

    /**
     * 机器ID  2进制5位  32位减掉1位 31个
     */
    private long workerId;
    /**
     * 机房ID 2进制5位  32位减掉1位 31个
     */
    private long datacenterId;

    /**
     * 代表一毫秒内生成的多个id的最新序号  12位 4096 -1 = 4095 个
     */
    private long sequence;
    /**
     * 设置一个时间初始值    2^41 - 1   差不多可以用69年
     */
    private long twepoch = 1585644268888L;
    /**
     * 5位的机器id
     */
    private long workerIdBits = 5L;
    /**
     * 5位的机房id
     */
    private long datacenterIdBits = 5L;
    /**
     * 每毫秒内产生的id数 2 的 12次方
     */
    private long sequenceBits = 12L;
    /**
     * 这个是二进制运算，就是5 bit最多只能有31个数字，也就是说机器id最多只能是32以内
     * -1L ^ (-1L &lt;&lt; workerIdBits);
     */
    private long maxWorkerId = ~(-1L &lt;&lt; workerIdBits);
    /**
     * 这个是一个意思，就是5 bit最多只能有31个数字，机房id最多只能是32以内
     * -1L ^ (-1L &lt;&lt; datacenterIdBits);
     */
    private long maxDatacenterId = ~(-1L &lt;&lt; datacenterIdBits);

    private long workerIdShift = sequenceBits;
    private long datacenterIdShift = sequenceBits + workerIdBits;
    private long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;
    /**
     * -1L ^ (-1L &lt;&lt; sequenceBits);
     */
    private long sequenceMask = ~(-1L &lt;&lt; sequenceBits);
    /**
     * 记录产生时间毫秒数，判断是否是同1毫秒
     */
    private long lastTimestamp = -1L;

    public long getWorkerId() &#123;
        return workerId;
    &#125;

    public long getDatacenterId() &#123;
        return datacenterId;
    &#125;

    public long getTimestamp() &#123;
        return System.currentTimeMillis();
    &#125;


    public IdWorker(long workerId, long datacenterId, long sequence) &#123;

        // 检查机房id和机器id是否超过31 不能小于0
        if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123;
            throw new IllegalArgumentException(
                    String.format(&quot;worker Id can&#39;t be greater than %d or less than 0&quot;, maxWorkerId));
        &#125;

        if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123;

            throw new IllegalArgumentException(
                    String.format(&quot;datacenter Id can&#39;t be greater than %d or less than 0&quot;, maxDatacenterId));
        &#125;
        this.workerId = workerId;
        this.datacenterId = datacenterId;
        this.sequence = sequence;
    &#125;

    // 这个是核心方法，通过调用nextId()方法，让当前这台机器上的snowflake算法程序生成一个全局唯一的id
    public synchronized long nextId() &#123;
        // 这儿就是获取当前时间戳，单位是毫秒
        long timestamp = timeGen();
        if (timestamp &lt; lastTimestamp) &#123;

            System.err.printf(
                    &quot;clock is moving backwards. Rejecting requests until %d.&quot;, lastTimestamp);
            throw new RuntimeException(
                    String.format(&quot;Clock moved backwards. Refusing to generate id for %d milliseconds&quot;,
                            lastTimestamp - timestamp));
        &#125;

        // 下面是说假设在同一个毫秒内，又发送了一个请求生成一个id
        // 这个时候就得把seqence序号给递增1，最多就是4096
        if (lastTimestamp == timestamp) &#123;

            // 这个意思是说一个毫秒内最多只能有4096个数字，无论你传递多少进来，
            //这个位运算保证始终就是在4096这个范围内，避免你自己传递个sequence超过了4096这个范围
            sequence = (sequence + 1) &amp; sequenceMask;
            //当某一毫秒的时间，产生的id数 超过4095，系统会进入等待，直到下一毫秒，系统继续产生ID
            if (sequence == 0) &#123;
                timestamp = tilNextMillis(lastTimestamp);
            &#125;

        &#125; else &#123;
            sequence = 0;
        &#125;
        // 这儿记录一下最近一次生成id的时间戳，单位是毫秒
        lastTimestamp = timestamp;
        // 这儿就是最核心的二进制位运算操作，生成一个64bit的id
        // 先将当前时间戳左移，放到41 bit那儿；将机房id左移放到5 bit那儿；将机器id左移放到5 bit那儿；将序号放最后12 bit
        // 最后拼接起来成一个64 bit的二进制数字，转换成10进制就是个long型
        return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) |
                (datacenterId &lt;&lt; datacenterIdShift) |
                (workerId &lt;&lt; workerIdShift) | sequence;
    &#125;

    /**
     * 当某一毫秒的时间，产生的id数 超过4095，系统会进入等待，直到下一毫秒，系统继续产生ID
     *
     * @param lastTimestamp
     * @return
     */
    private long tilNextMillis(long lastTimestamp) &#123;

        long timestamp = timeGen();

        while (timestamp &lt;= lastTimestamp) &#123;
            timestamp = timeGen();
        &#125;
        return timestamp;
    &#125;

    //获取当前时间戳
    private long timeGen() &#123;
        return System.currentTimeMillis();
    &#125;

    /**
     * main 测试类
     *
     * @param args
     */
    public static void main(String[] args) &#123;
        System.out.println(1 &amp; 4596);
        System.out.println(2 &amp; 4596);
        System.out.println(6 &amp; 4596);
        System.out.println(6 &amp; 4596);
        System.out.println(6 &amp; 4596);
        System.out.println(6 &amp; 4596);
        IdWorker worker = new IdWorker(1, 1, 1);
        for (int i = 0; i &lt; 22; i++) &#123;
            System.out.println(worker.nextId());
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>SnowFlake算法的优点：</p>
</blockquote>
<ul>
<li><p>高性能高可用：生成时不依赖于数据库，完全在内存中生成。</p>
</li>
<li><p>容量大：每秒中能生成数百万的自增ID。</p>
</li>
<li><p>ID自增：存入数据库中，索引效率高。</p>
</li>
</ul>
<blockquote>
<p> SnowFlake算法的缺点：</p>
</blockquote>
<p>依赖与系统时间的一致性，如果系统时间被回调，或者改变，可能会造成id冲突或者重复。</p>
<p>实际中我们的机房并没有那么多，我们可以改进改算法，将10bit的机器id优化，成业务表或者和我们系统相关的业务。</p>
<h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><p>雪花算法产生的长整数的精度可能超过javascript能表达的精度，这会导致js获取的id与雪花算法算出来的id不一致，如雪花算法得到的是36594866121080832，但是因为javascript丢失精度后只获取到36594866121080830， 这会导致对数据的所有操作都失效。</p>
<p>解决办法：后端的语言获取到雪花算法的id后将其转换为String类型，这样js也会当做字符串来处理，就不会丢失精度了。</p>
<p>链接：<a href="http://events.jianshu.io/p/5769966ff5fc">http://events.jianshu.io/p/5769966ff5fc</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>git clone Filename too long</title>
    <url>/2022/06/04/git-clone-filename-too-long/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题（windows）"><a href="#问题（windows）" class="headerlink" title="问题（windows）"></a>问题（windows）</h3><pre><code class="prettyprint">error: unable to create file examples/shardingsphere-jdbc-example/mixed-feature-example/sharding-readwrite-splitting-example/sharding-readwrite-splitting-raw-jdbc-example/src/main/java/org/apache/shardingsphere/example/sharding/readwrite/splitting/raw/ShardingReadwriteSplittingRawJavaConfigurationExample.java: Filename too long
error: unable to create file examples/shardingsphere-jdbc-example/mixed-feature-example/sharding-readwrite-splitting-example/sharding-readwrite-splitting-raw-jdbc-example/src/main/java/org/apache/shardingsphere/example/sharding/readwrite/splitting/raw/ShardingReadwriteSplittingRawJavaRangeConfigurationExample.java: Filename too long
error: unable to create file examples/shardingsphere-jdbc-example/mixed-feature-example/sharding-readwrite-splitting-example/sharding-readwrite-splitting-raw-jdbc-example/src/main/java/org/apache/shardingsphere/example/sharding/readwrite/splitting/raw/ShardingReadwriteSplittingRawYamlConfigurationExample.java: Filename too long
error: unable to create file examples/shardingsphere-jdbc-example/mixed-feature-example/sharding-readwrite-splitting-example/sharding-readwrite-splitting-raw-jdbc-example/src/main/java/org/apache/shardingsphere/example/sharding/readwrite/splitting/raw/ShardingReadwriteSplittingRawYamlRangeConfigurationExample.java: Filename too long
fatal: cannot create directory at &#39;examples/shardingsphere-jdbc-example/mixed-feature-example/sharding-readwrite-splitting-example/sharding-readwrite-splitting-raw-jdbc-example/src/main/java/org/apache/shardingsphere/example/sharding/readwrite/splitting/raw/config&#39;: Filename too long
</code></pre>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><blockquote>
<p>管理员打开<code>cmd</code></p>
</blockquote>
<pre><code> git config --system core.longpaths true
</code></pre>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux定时git pull</title>
    <url>/2022/06/05/linux-ding-shi-git-pull/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="编辑git-pull脚本"><a href="#编辑git-pull脚本" class="headerlink" title="编辑git pull脚本"></a>编辑git pull脚本</h3><pre><code class="prettyprint">#!/bin/bash

cd /usr/local/nginx/html/RocPengHua
git pull
</code></pre>
<h3 id="给脚本权限"><a href="#给脚本权限" class="headerlink" title="给脚本权限"></a>给脚本权限</h3><pre><code class="prettyprint">chmod 777 task.sh
</code></pre>
<h3 id="编辑crontab定时任务"><a href="#编辑crontab定时任务" class="headerlink" title="编辑crontab定时任务"></a>编辑crontab定时任务</h3><pre><code class="prettyprint">#新建
crontab -e
#查看
crontab -l
</code></pre>
<h4 id="编辑定时任务内容"><a href="#编辑定时任务内容" class="headerlink" title="编辑定时任务内容"></a>编辑定时任务内容</h4><pre><code class="prettyprint">#每隔两分钟，7点到23点执行
*/2 7-23 * * * sh /usr/local/nginx/html/task.sh
</code></pre>
<h3 id="重启定时任务"><a href="#重启定时任务" class="headerlink" title="重启定时任务"></a>重启定时任务</h3><pre><code class="prettyprint">systemctl restart crond #重启定时任务
systemctl reload crond #重新加载
</code></pre>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><pre><code class="prettyprint">tailf /val/log/cron
</code></pre>
<ul>
<li>日志记录</li>
</ul>
<blockquote>
<p>Jun  5 10:50:01 iZm5e198ia3o66a6om8gf3Z CROND[31499]: (root) CMD (sh &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;task.sh)<br>Jun  5 10:50:01 iZm5e198ia3o66a6om8gf3Z CROND[31497]: (root) MAIL (mailed 69 bytes of output but got status 0x004b#012)<br>Jun  5 10:52:01 iZm5e198ia3o66a6om8gf3Z CROND[31607]: (root) CMD (sh &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;task.sh)<br>Jun  5 10:52:01 iZm5e198ia3o66a6om8gf3Z CROND[31606]: (root) MAIL (mailed 69 bytes of output but got status 0x004b#012)<br>Jun  5 10:54:01 iZm5e198ia3o66a6om8gf3Z CROND[31711]: (root) CMD (sh &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;task.sh)<br>Jun  5 10:54:01 iZm5e198ia3o66a6om8gf3Z CROND[31710]: (root) MAIL (mailed 69 bytes of output but got status 0x004b#012)<br>Jun  5 10:56:01 iZm5e198ia3o66a6om8gf3Z CROND[31818]: (root) CMD (sh &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;task.sh)<br>Jun  5 10:56:01 iZm5e198ia3o66a6om8gf3Z CROND[31817]: (root) MAIL (mailed 69 bytes of output but got status 0x004b#012)</p>
</blockquote>
<h4 id="mailed-69-bytes-of-output-but-got-status-0x004b-012"><a href="#mailed-69-bytes-of-output-but-got-status-0x004b-012" class="headerlink" title="mailed 69 bytes of output but got status 0x004b#012"></a>mailed 69 bytes of output but got status 0x004b#012</h4><ul>
<li><p>问题修改</p>
<ul>
<li>修改 &#x2F;etc&#x2F;postfix&#x2F;main.cf 文件</li>
</ul>
<pre><code class="prettyprint">#打开all
inet_interfaces = all
#inet_interfaces = $myhostname
#inet_interfaces = $myhostname, localhost
#注释localhost
#inet_interfaces = localhost
</code></pre>
<ul>
<li><code>service postfix start</code></li>
</ul>
</li>
</ul>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><pre><code class="prettyprint">#查看服务状态
systemctl status crond
#启动
systemctl start crond
#停止
systemctl stop crond
#重启
systemctl restart crond
#重新加载
systemctl reload crond
#开机启动crontab服务
systemctl start crond
</code></pre>
<h3 id="cron说明"><a href="#cron说明" class="headerlink" title="cron说明"></a>cron说明</h3><blockquote>
<p>第一列：分minute (0 - 59)<br>第二列：时hour (0 - 23)<br>第三列：日day of month (1 - 31)<br>第四列：月month (1 - 12)<br>第五列：周day of week (0 - 6)<br>第六列：要执行的任务命令或程序</p>
</blockquote>
<ul>
<li><p>表示的 每或每一 的意思<br> <code>00 23 * * * sh /usr/local/nginx/html/task.sh</code> 每天23点00分执行任务</p>
</li>
<li><p>连续区间 1-10</p>
<ul>
<li><code>00 8-23 * * * sh /usr/local/nginx/html/task.sh</code> 每天8点至23点，每小时执行任务</li>
<li><code>00 1,2,3,4,8 * * * sh /usr/local/nginx/html/task.sh</code> 每天1点、2点、3点、4点、8点执行任务</li>
<li><code>*/10 *  * * * sh /usr/local/nginx/html/task.sh </code>每隔10分钟执行一次任务</li>
<li><code>30 */6 * * * sh /usr/local/nginx/html/task.sh </code>每隔6小时的30分执行任务</li>
<li><code>30 8-12/2 * * * sh /usr/local/nginx/html/task.sh</code> 每天8点至12点，每隔2小时的30分执行任务</li>
<li><code>45 4 1,10,22 * * sh /usr/local/nginx/html/task.sh </code>每月1号、10号、22号4点45分执行任务</li>
<li><code>10 1 * * 6,0 sh /usr/local/nginx/html/task.sh </code>每周六周日1点10执行任务</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>CRON表达式例子</title>
    <url>/2021/09/13/cron-biao-da-shi-li-zi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>*/5 * * * * ? 每隔5秒执行一次
 0 */1 * * * ? 每隔1分钟执行一次
 0 0 5-15 * * ? 每天5-15点整点触发
 0 0/3 * * * ? 每三分钟触发一次
 0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 
 0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发
 0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
 0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时
 0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 
 
 0 0 12 ? * WED 表示每个星期三中午12点
 0 0 17 ? * TUES,THUR,SAT 每周二、四、六下午五点
 0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 
 0 15 10 ? * MON-FRI 周一至周五的上午10:15触发
 0 0 23 L * ? 每月最后一天23点执行一次
 0 15 10 L * ? 每月最后一日的上午10:15触发 
 0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 
 0 15 10 * * ? 2005 2005年的每天上午10:15触发 
 0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 
 0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发


&quot;30 * * * * ?&quot; 每半分钟触发任务
&quot;30 10 * * * ?&quot; 每小时的10分30秒触发任务
&quot;30 10 1 * * ?&quot; 每天1点10分30秒触发任务
&quot;30 10 1 20 * ?&quot; 每月20号1点10分30秒触发任务
&quot;30 10 1 20 10 ? *&quot; 每年10月20号1点10分30秒触发任务
&quot;30 10 1 20 10 ? 2011&quot; 2011年10月20号1点10分30秒触发任务
&quot;30 10 1 ? 10 * 2011&quot; 2011年10月每天1点10分30秒触发任务
&quot;30 10 1 ? 10 SUN 2011&quot; 2011年10月每周日1点10分30秒触发任务
&quot;15,30,45 * * * * ?&quot; 每15秒，30秒，45秒时触发任务
&quot;15-45 * * * * ?&quot; 15到45秒内，每秒都触发任务
&quot;15/5 * * * * ?&quot; 每分钟的每15秒开始触发，每隔5秒触发一次
&quot;15-30/5 * * * * ?&quot; 每分钟的15秒到30秒之间开始触发，每隔5秒触发一次
&quot;0 0/3 * * * ?&quot; 每小时的第0分0秒开始，每三分钟触发一次
&quot;0 15 10 ? * MON-FRI&quot; 星期一到星期五的10点15分0秒触发任务
&quot;0 15 10 L * ?&quot; 每个月最后一天的10点15分0秒触发任务
&quot;0 15 10 LW * ?&quot; 每个月最后一个工作日的10点15分0秒触发任务
&quot;0 15 10 ? * 5L&quot; 每个月最后一个星期四的10点15分0秒触发任务
&quot;0 15 10 ? * 5#3&quot; 每个月第三周的星期四的10点15分0秒触发任务
</code></pre>
]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
  </entry>
  <entry>
    <title>Centos7安装mysql8</title>
    <url>/2021/11/14/centos7-an-zhuang-mysql8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li>下载 MySQL 所需要的安装包<code>https://dev.mysql.com/downloads/mysql/</code></li>
<li>Select Operating System: 选择 Red Hat ，CentOS 是基于红帽的，Select OS Version: 选择 linux 7</li>
<li>选择 RPM Bundle 点击 Download</li>
<li><code>rpm -qa | grep mariadb</code> 命令查看 mariadb 的安装包</li>
<li><code>rpm -e mariadb-libs-5.5.56-2.el7.x86_64 --nodeps</code> 命令装卸 mariadb</li>
<li><code>rpm -qa | grep mariadb</code> 命令再次查看 mariadb 的安装包</li>
</ol>
<p>7.<code>tar -xvf mysql-8.0.11-1.el7.x86_64.rpm-bundle.tar</code>  命令解压 tar 包<br>8. <code>yum localinstall *.rpm</code> 安装所有rpm包<br>9. <code>rpm -qa | grep mysql</code> 命令查看 mysql 的安装包<br>10. 通过以下命令，完成对 mysql 数据库的初始化和相关配置</p>
<pre><code class="prettyprint">mysqld --initialize;
chown mysql:mysql /var/lib/mysql -R;
systemctl start mysqld.service;
systemctl  enable mysqld;
</code></pre>
<ol start="11">
<li>通过 cat &#x2F;var&#x2F;log&#x2F;mysqld.log | grep password 命令查看数据库的密码</li>
<li>通过 mysql -uroot -p 敲回车键进入数据库登陆界面</li>
<li>输入刚刚查到的密码，进行数据库的登陆，复制粘贴就行，MySQL 的登陆密码也是不显示的</li>
<li>通过 <code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;;</code> 命令来修改密码（复杂点）</li>
<li>通过 exit; 命令退出 MySQL，然后通过新密码再次登陆</li>
<li>通过以下命令，进行远程访问的授权<pre><code class="prettyprint">create user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;root&#39;;
grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; with grant option;
flush privileges;
</code></pre>
</li>
<li>通过 <code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39; PASSWORD EXPIRE NEVER;</code> 命令修改加密规则，MySql8.0 版本 和 5.0 的加密规则不一样，而现在的可视化工具只支持旧的加密方式。</li>
<li>通过 <code>flush privileges;</code> 命令刷新修该后的权限</li>
<li>通过 exit; 命令退出 MySQL</li>
<li>通过以下命令，关闭 firewall<pre><code class="prettyprint">systemctl stop firewalld.service;
systemctl disable firewalld.service;
systemctl mask firewalld.service;
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Controller注入Service出现空指针情况</title>
    <url>/2022/04/15/controller-zhu-ru-service-chu-xian-kong-zhi-zhen-qing-kuang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="第一种情况（注入没有使用注解-Autowired-Resource）"><a href="#第一种情况（注入没有使用注解-Autowired-Resource）" class="headerlink" title="第一种情况（注入没有使用注解@Autowired,@Resource）"></a>第一种情况（注入没有使用注解<code>@Autowired</code>,<code>@Resource</code>）</h4><pre><code class="prettyprint">public class TestController &#123;
    private ITestService testService
&#125;
</code></pre>
<p>解决方式</p>
<ol>
<li>增加注入注解</li>
</ol>
<pre><code class="prettyprint">public class TestController &#123;
    @Autowired
    private ITestService testService
&#125;
</code></pre>
<ol>
<li>使用构造方法注入(或者set方法注入)</li>
</ol>
<pre><code class="prettyprint">public class TestController &#123;
    private final ITestService testService;
    public TestController(ITestService testService)&#123;
         this.testService = testService;
    &#125;
&#125;
</code></pre>
<h4 id="第二种情况（service实现类没有-Service注解）加上注解就行"><a href="#第二种情况（service实现类没有-Service注解）加上注解就行" class="headerlink" title="第二种情况（service实现类没有@Service注解）加上注解就行"></a>第二种情况（service实现类没有@Service注解）加上注解就行</h4><h4 id="第三种情况（包扫描没有扫描到），配置扫描路径"><a href="#第三种情况（包扫描没有扫描到），配置扫描路径" class="headerlink" title="第三种情况（包扫描没有扫描到），配置扫描路径"></a>第三种情况（包扫描没有扫描到），配置扫描路径</h4><h4 id="第四种情况（最难发现的问题，在controller类中使用-Value从配置文件中获取数据，而配置文件却没有配置）"><a href="#第四种情况（最难发现的问题，在controller类中使用-Value从配置文件中获取数据，而配置文件却没有配置）" class="headerlink" title="第四种情况（最难发现的问题，在controller类中使用@Value从配置文件中获取数据，而配置文件却没有配置）"></a>第四种情况（最难发现的问题，在controller类中使用@Value从配置文件中获取数据，而配置文件却没有配置）</h4><pre><code class="prettyprint">public class TestController &#123;
    @Value(&quot;$&#123;prop.test&#125;&quot;)
    @Autowired
    private ITestService testService
&#125;
</code></pre>
<p>解决方法：<br>1、在配置文件中加上配置<br>2、给与默认值</p>
<pre><code class="prettyprint">public class TestController &#123;
    @Value(&quot;$&#123;prop.test:&#125;&quot;)
    @Autowired
    private ITestService testService
&#125;
</code></pre>
<img src="/2022/04/15/controller-zhu-ru-service-chu-xian-kong-zhi-zhen-qing-kuang/4.jpg" class="asset-class" title="(6).jpg">
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 安装部署RabbitMQ</title>
    <url>/2021/10/16/docker-an-zhuang-bu-shu-rabbitmq/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>这里注意获取镜像的时候要获取management版本的，不要获取last版本的，management版本的才带有管理界面。</code></p>
<h3 id="1、查询镜像"><a href="#1、查询镜像" class="headerlink" title="1、查询镜像"></a>1、查询镜像</h3><p><code>docker search rabbitmq:management</code></p>
<h3 id="2、获取镜像"><a href="#2、获取镜像" class="headerlink" title="2、获取镜像"></a>2、获取镜像</h3><p><code>docker pull rabbitmq:management</code></p>
<h3 id="3、运行镜像"><a href="#3、运行镜像" class="headerlink" title="3、运行镜像"></a>3、运行镜像</h3><p><code>docker run -d -p 5672:5672 -p 15672:15672 --name rabbitmq rabbitmq:management</code></p>
<p>访问管理界面的地址就是 http:&#x2F;&#x2F;[宿主机IP]:15672，可以使用默认的账户登录，用户名和密码都guest</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 部署 Halo</title>
    <url>/2021/10/16/docker-bu-shu-halo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="使用-Docker-镜像"><a href="#使用-Docker-镜像" class="headerlink" title="使用 Docker 镜像#"></a>使用 Docker 镜像#</h4><p>Halo 在 Docker Hub 上发布的镜像为 halohub&#x2F;halo</p>
<h4 id="创建工作目录"><a href="#创建工作目录" class="headerlink" title="创建工作目录"></a>创建工作目录</h4><p><code>mkdir ~/.halo &amp;&amp; cd ~/.halo</code><br>下载示例配置文件到工作目录<br><code>wget https://dl.halo.run/config/application-template.yaml -O ./application.yaml</code><br>编辑配置文件，配置数据库或者端口等，如需配置请参考参考配置<br><code>vim application.yaml</code><br>拉取最新的 Halo 镜像<br><code>docker pull halohub/halo:1.4.12</code><br>INFO<br>查看最新版本镜像：<code>https://hub.docker.com/r/halohub/halo</code> ，我们推荐使用具体版本号的镜像，但也提供了 latest 标签的镜像，它始终是最新的。</p>
<p>创建容器<br><code>docker run -it -d --name halo -p 8090:8090 -v ~/.halo:/root/.halo --restart=unless-stopped halohub/halo:1.4.12</code></p>
<pre><code class="-it：">-d： 后台运行容器
--name： 为容器指定一个名称
-p： 端口映射，格式为 主机(宿主)端口:容器端口 ，可在 application.yaml 配置。
-v： 工作目录映射。形式为：-v 宿主机路径:/root/.halo，后者不能修改。
--restart： 建议设置为 unless-stopped，在 Docker 启动的时候自动启动 Halo 容器。
</code></pre>
<p>打开 <a href="http://ip:端口号">http://ip:端口号</a> 即可看到安装引导界面。<br>TIP<br>如果需要配置域名访问，建议先配置好反向代理以及域名解析再进行初始化。如果通过 <a href="http://ip:端口号">http://ip:端口号</a> 的形式无法访问，请到服务器厂商后台将运行的端口号添加到安全组，如果服务器使用了 Linux 面板，请检查此 Linux 面板是否有还有安全组配置，需要同样将端口号添加到安全组。</p>
<p>反向代理#<br>你可以在下面的反向代理软件中任选一项，我们假设你已经安装好了其中一项，并对其的基本操作有一定了解。如果你对 Nginx 不熟悉，我们推荐使用 OneinStack 来管理 Nginx。</p>
<pre><code class="prettyprint#">upstream halo &#123;
  server 127.0.0.1:8090;
&#125;
server &#123;
  listen 80;
  listen [::]:80;
  server_name www.yourdomain.com;
  client_max_body_size 1024m;
  location / &#123;
    proxy_pass http://halo;
    proxy_set_header HOST $host;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  &#125;
&#125;
</code></pre>
<p>以上配置都可以在 <a href="https://github.com/halo-dev/halo-common">https://github.com/halo-dev/halo-common</a> 找到。</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker中安装并配置redis</title>
    <url>/2021/10/16/docker-zhong-an-zhuang-bing-pei-zhi-redis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、找到一个合适的docker的redis的版本"><a href="#一、找到一个合适的docker的redis的版本" class="headerlink" title="一、找到一个合适的docker的redis的版本"></a>一、找到一个合适的docker的redis的版本</h3><p>可以去docker hub中去找一下</p>
<p><a href="https://hub.docker.com/_/redis?tab=tags">https://hub.docker.com/_/redis?tab=tags</a></p>
<h3 id="二、使用docker安装redis"><a href="#二、使用docker安装redis" class="headerlink" title="二、使用docker安装redis"></a>二、使用docker安装redis</h3><p>docker pull redis</p>
<p>安装好之后使用docker images即可查看</p>
<p>docker images</p>
<h3 id="三、准备redis的配置文件"><a href="#三、准备redis的配置文件" class="headerlink" title="三、准备redis的配置文件"></a>三、准备redis的配置文件</h3><p>因为需要redis的配置文件，这里最好还是去redis的官方去下载一个redis使用里面的配置文件即可</p>
<p>redis中文官方网站：<a href="http://www.redis.cn/download.html">http://www.redis.cn/download.html</a></p>
<p>下载后解压出来：</p>
<p>这个redis.conf文件就是咱们需要的，为了保险，还是拷贝一下，做个备份。</p>
<h3 id="四、配置redis-conf配置文件"><a href="#四、配置redis-conf配置文件" class="headerlink" title="四、配置redis.conf配置文件"></a>四、配置redis.conf配置文件</h3><p>修改redis.conf配置文件：<br>主要配置的如下：</p>
<pre><code>bind 127.0.0.1 #注释掉这部分，使redis可以外部访问
daemonize no#用守护线程的方式启动
requirepass 你的密码#给redis设置密码
appendonly yes#redis持久化　　默认是no
tcp-keepalive 300 #防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300
</code></pre>
<h3 id="五、创建本地与docker映射的目录，即本地存放的位置"><a href="#五、创建本地与docker映射的目录，即本地存放的位置" class="headerlink" title="五、创建本地与docker映射的目录，即本地存放的位置"></a>五、创建本地与docker映射的目录，即本地存放的位置</h3><p>创建本地存放redis的位置;</p>
<p>可以自定义，因为我的docker的一些配置文件都是存放在&#x2F;data目录下面的，所以我依然在&#x2F;data目录下创建一个redis目录，这样是为了方便后期管理</p>
<p>mkdir &#x2F;data&#x2F;redis<br>mkdir &#x2F;data&#x2F;redis&#x2F;data</p>
<p>把配置文件拷贝到刚才创建好的文件里</p>
<p>因为我本身就是Linux操作系统，所以我可以直接拷贝过去，如果你是windows的话，可能需要使用ftp拷贝过去，或者直接复制内容，然后粘贴过去。</p>
<p>cp -p redis.conf &#x2F;data&#x2F;redis&#x2F;</p>
<h3 id="六、启动docker-redis"><a href="#六、启动docker-redis" class="headerlink" title="六、启动docker redis"></a>六、启动docker redis</h3><p>启动：</p>
<pre><code>docker run -p 6379:6379 --name redis -v /data/redis/redis.conf:/etc/redis/redis.conf  -v /data/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes
</code></pre>
<p>参数解释：</p>
<pre><code>-p 6379:6379:把容器内的6379端口映射到宿主机6379端口
-v /data/redis/redis.conf:/etc/redis/redis.conf：把宿主机配置好的redis.conf放到容器内的这个位置中
-v /data/redis/data:/data：把redis持久化的数据在宿主机内显示，做数据备份
redis-server /etc/redis/redis.conf：这个是关键配置，让redis不是无配置启动，而是按照这个redis.conf的配置启动
–appendonly yes：redis启动后数据持久化
</code></pre>
<h3 id="七、查看是否启动成功"><a href="#七、查看是否启动成功" class="headerlink" title="七、查看是否启动成功"></a>七、查看是否启动成功</h3><p>查看是否成功启动：sudo docker ps</p>
<p>可以查看一下日志：sudo docker logs redis</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装MySQL8.0</title>
    <url>/2021/10/16/docker-an-zhuang-mysql8-0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>CentOS 7.5<br>Docker 1.13.1<br>MySQL 8.0.16</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h5><p>默认拉取最新版本的镜像</p>
<p><code>pull mysql</code><br>如果要指定版本，使用下面的命令</p>
<p><code>docker pull mysql:8.0.16</code><br>创建数据目录和配置文件<br>在宿主机创建放置mysql的配置文件的目录和数据目录，并且进行授权</p>
<p><code>mkdir -p /usr/mysql/conf /usr/mysql/data</code></p>
<p><code>chmod -R 755 /usr/mysql/</code><br>创建配置文件<br>在上面创建的配置文件目录&#x2F;usr&#x2F;mysql&#x2F;conf下创建MySQL的配置文件my.cnf</p>
<p><code>vim /usr/mysql/conf/my.cnf</code><br>添加以下内容到上述创建的配置文件中</p>
<pre><code class="[client]">
#socket = /usr/mysql/mysqld.sock

default-character-set = utf8mb4

[mysqld]

#pid-file        = /var/run/mysqld/mysqld.pid

#socket          = /var/run/mysqld/mysqld.sock

#datadir         = /var/lib/mysql

#socket = /usr/mysql/mysqld.sock

#pid-file = /usr/mysql/mysqld.pid

datadir = /usr/mysql/data

character_set_server = utf8mb4

collation_server = utf8mb4_bin

secure-file-priv= NULL

# Disabling symbolic-links is recommended to prevent assorted security risks

symbolic-links=0

# Custom config should go here

!includedir /etc/mysql/conf.d/
</code></pre>
<p>启动创建容器</p>
<pre><code>docker run --restart=unless-stopped -d --name mysql -v /usr/mysql/conf/my.cnf:/etc/mysql/my.cnf -v 
/usr/mysql/data:/var/lib/mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql
</code></pre>
<p>参数解释：</p>
<pre><code>-v : 挂载宿主机目录和 docker容器中的目录，前面是宿主机目录，后面是容器内部目录

-d : 后台运行容器

-p 映射容器端口号和宿主机端口号

-e 环境参数，MYSQL_ROOT_PASSWORD设置root用户的密码
</code></pre>
<p>执行上述命令后，执行查询容器的命令就可以看到创建的mysql容器</p>
<p><code>docker ps -a</code></p>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>上述虽然安装好了mysql，但是使用远程的Navicat连接时提示错误，不能正确连接mysql，此时需要修改按照下面说的步骤修改一下mysql的密码模式以及主机等内容才可以。</p>
<p>修改mysql密码以及可访问主机</p>
<pre><code>#进入容器内部
docker exec -it mysql /bin/bash`
连接mysql
mysql -uroot -p`
使用mysql库
mysql&gt; use mysql`
修改访问主机以及密码等，设置为所有主机可访问
mysql&gt; ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;
</code></pre>
<p>注意：</p>
<p>mysql_native_password，mysql8.x版本必须使用这种模式，否则navicate无法正确连接</p>
<p>刷新<br>$ mysql&gt; flush privileges<br>经过以上步骤，再次远程使用Navicat连接数据库时就可以正常连接了。</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装nacos</title>
    <url>/2021/10/16/docker-an-zhuang-nacos/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-拉取镜像"><a href="#1-拉取镜像" class="headerlink" title="1. 拉取镜像"></a>1. 拉取镜像</h4><p><code>docker pull nacos/nacos-server</code></p>
<h4 id="2-启动"><a href="#2-启动" class="headerlink" title="2. 启动"></a>2. 启动</h4><p><code>docker run -d -p 8848:8848 \ --name nacos \ --env MODE=standalone \ --env SPRING_DATASOURCE_PLATFORM=mysql \ --env MYSQL_SERVICE_HOST=127.0.0.1 \ --env MYSQL_SERVICE_PORT=3306 \ --env MYSQL_SERVICE_DB_NAME=nacos_config \ --env MYSQL_SERVICE_USER=root \ --env MYSQL_SERVICE_PASSWORD=root \ nacos/nacos-server</code></p>
<h4 id="3-查看"><a href="#3-查看" class="headerlink" title="3. 查看"></a>3. 查看</h4><p><code>docker ps -a</code></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装rocketmq</title>
    <url>/2021/10/19/docker-an-zhuang-rocketmq/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><pre><code class="prettyprint"># 查询镜像
docker search rocketmq
# 查询镜像版本
curl https://registry.hub.docker.com/v1/repositories/foxiswho/rocketmq/tags \
| tr -d &#39;[\[\]&quot; ]&#39; | tr &#39;&#125;&#39; &#39;\n&#39; \
| awk -F: -v image=&#39;foxiswho/rocketmq&#39; &#39;&#123;if(NR!=NF &amp;&amp; $3 != &quot;&quot;)&#123;printf(&quot;%s:%s\n&quot;,image,$3)&#125;&#125;&#39;

# 拉取镜像
docker pull foxiswho/rocketmq:server-4.7.0
docker pull foxiswho/rocketmq:broker-4.7.0
</code></pre>
<h4 id="创建数据挂载目录-x2F-文件"><a href="#创建数据挂载目录-x2F-文件" class="headerlink" title="创建数据挂载目录&#x2F;文件"></a>创建数据挂载目录&#x2F;文件</h4><pre><code class="prettyprint">mkdir -p /usr/local/rocketmq/rmqserver01/logs
mkdir -p /usr/local/rocketmq/rmqserver01/store
mkdir -p /usr/local/rocketmq/rmqbroker01/logs
mkdir -p /usr/local/rocketmq/rmqbroker01/store
mkdir -p /usr/local/rocketmq/rmqbroker01/conf


vim /usr/local/rocketmq/rmqbroker01/conf/broker.conf
</code></pre>
<h4 id="配置broker-conf"><a href="#配置broker-conf" class="headerlink" title="配置broker.conf"></a>配置broker.conf</h4><pre><code class="prettyprint">brokerIP1=47.105.140.253
# 支持过滤
enablePropertyFilter=true
</code></pre>
<h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><pre><code class="prettyprint"># 运行server
docker run -d -p 9876:9876 --name rmqserver  \
 -v /usr/local/rocketmq/rmqserver01/logs:/opt/logs \
 -v /usr/local/rocketmq/rmqserver01/store:/opt/store \
 foxiswho/rocketmq:server-4.7.0
# 运行broker
docker run -d -p 10911:10911 -p 10909:10909 \
 --name rmqbroker --link rmqserver:namesrv \
 -e &quot;NAMESRV_ADDR=namesrv:9876&quot; -e &quot;JAVA_OPTS=-Duser.home=/opt&quot; \
 -e &quot;JAVA_OPT_EXT=-server -Xms128m -Xmx128m&quot; \
 -v /usr/local/rocketmq/rmqbroker01/conf/broker.conf:/etc/rocketmq/broker.conf \
 -v /usr/local/rocketmq/rmqbroker01/logs:/opt/logs \
 -v /usr/local/rocketmq/rmqbroker01/store:/opt/store \
 foxiswho/rocketmq:broker-4.7.0
</code></pre>
<h4 id="部署Rocketmq管理UI工具"><a href="#部署Rocketmq管理UI工具" class="headerlink" title="部署Rocketmq管理UI工具"></a>部署Rocketmq管理UI工具</h4><pre><code class="prettyprint"># 查询镜像
docker search rocketmq-console-ng

# 查询镜像版本
curl https://registry.hub.docker.com/v1/repositories/styletang/rocketmq-console-ng/tags \
| tr -d &#39;[\[\]&quot; ]&#39; | tr &#39;&#125;&#39; &#39;\n&#39; \
| awk -F: -v image=&#39;styletang/rocketmq-console-ng&#39; &#39;&#123;if(NR!=NF &amp;&amp; $3 != &quot;&quot;)&#123;printf(&quot;%s:%s\n&quot;,image,$3)&#125;&#125;&#39;

docker pull styletang/rocketmq-console-ng:1.0.0

# 运行镜像
docker run -d --name rmqconsole -p 8180:8080 --link rmqserver:namesrv\
 -e &quot;JAVA_OPTS=-Drocketmq.namesrv.addr=namesrv:9876\
 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot;\
 -t styletang/rocketmq-console-ng:1.0.0
</code></pre>
<h4 id="访问前端UI"><a href="#访问前端UI" class="headerlink" title="访问前端UI"></a>访问前端UI</h4><p><a href="http://ip:8180/">http://ip:8180</a></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA配置注释</title>
    <url>/2021/11/26/idea-pei-zhi-zhu-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一、类注释</p>
<ul>
<li>打开<code>serrings --&gt; Editor --&gt; File and Code Template</code>点击右边的Class,添加注释</li>
</ul>
<pre><code class="prettyprint">/**
 * @author jitwxs
 * @date $&#123;YEAR&#125;年$&#123;MONTH&#125;月$&#123;DAY&#125;日 $&#123;TIME&#125;
 */
</code></pre>
<p>二、方法注释</p>
<ul>
<li><p>打开<code>serrings --&gt; Editor --&gt; Live Template</code></p>
</li>
<li><p>先新增Template group（如：define）</p>
</li>
<li><p>选中新增的group(如：define)</p>
</li>
<li><p>修改该模板的 Abbreviation、Description 和 Template text<br>  Abbreviation：*<br>  Description :方法注释<br>  Template text：</p>
</li>
</ul>
<pre><code class="prettyprint">/**
 * @Description 
 * @Author pengp
 * @Date $date$ $time$$param$ $return$
 */
</code></pre>
<ul>
<li><p>选择No applicable contexts yet(Define)，选择java</p>
</li>
<li><p>点击 Edit variables 配置自定义参数<code>$date$ $time$$param$ $return$</code></p>
</li>
</ul>
<pre><code class="prettyprint">date：date()
time：time()
param：groovyScript(&quot;def result = &#39;&#39;;def params = \&quot;$&#123;_1&#125;\&quot;.replaceAll(&#39;[\\\\[|\\\\]|\\\\s]&#39;, &#39;&#39;).split(&#39;,&#39;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;if(params[i] != &#39;&#39;)result+=&#39;* @param &#39; + params[i] + ((i &lt; params.size() - 1) ? &#39;\\r\\n &#39; : &#39;&#39;)&#125;; return result == &#39;&#39; ? null : &#39;\\r\\n &#39; + result&quot;, methodParameters())
return：groovyScript(&quot;return \&quot;$&#123;_1&#125;\&quot; == &#39;void&#39; ? null : &#39;\\r\\n * @return &#39; + \&quot;$&#123;_1&#125;\&quot;&quot;, methodReturnType())
</code></pre>
]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/2021/10/16/docker-chang-yong-ming-ling/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1、Docker容器信息"><a href="#1、Docker容器信息" class="headerlink" title="1、Docker容器信息"></a>1、Docker容器信息</h4><pre><code>##查看docker容器版本
docker version
##查看docker容器信息
docker info
##查看docker容器帮助
docker --help
</code></pre>
<h4 id="2、镜像操作"><a href="#2、镜像操作" class="headerlink" title="2、镜像操作"></a>2、镜像操作</h4><p>提示：对于镜像的操作可使用镜像名、镜像长ID和短ID。</p>
<h5 id="2-1、镜像查看"><a href="#2-1、镜像查看" class="headerlink" title="2.1、镜像查看"></a>2.1、镜像查看</h5><pre><code>##列出本地images
docker images
##含中间映像层
docker images -a


##只显示镜像ID
docker images -q
##含中间映像层
docker images -qa   


##显示镜像摘要信息(DIGEST列)
docker images --digests
##显示镜像完整信息
docker images --no-trunc


##显示指定镜像的历史创建；参数：-H 镜像大小和日期，默认为true；--no-trunc  显示完整的提交记录；-q  仅列出提交记录ID
docker history -H redis
</code></pre>
<h5 id="2-2、镜像搜索"><a href="#2-2、镜像搜索" class="headerlink" title="2.2、镜像搜索"></a>2.2、镜像搜索</h5><pre><code>##搜索仓库MySQL镜像
docker search mysql
##--filter=stars=600：只显示 starts&gt;=600 的镜像
docker search --filter=stars=600 mysql
##--no-trunc 显示镜像完整 DESCRIPTION 描述
docker search --no-trunc mysql
##--automated ：只列出 AUTOMATED=OK 的镜像
docker search  --automated mysql
</code></pre>
<h5 id="2-3-镜像版本查看"><a href="#2-3-镜像版本查看" class="headerlink" title="2.3 镜像版本查看"></a>2.3 镜像版本查看</h5><pre><code>curl https://registry.hub.docker.com/v1/repositories/seataio/seata-server/tags \
| tr -d &#39;[\[\]&quot; ]&#39; | tr &#39;&#125;&#39; &#39;\n&#39; \
| awk -F: -v image=&#39;seataio/seata-server&#39; &#39;&#123;if(NR!=NF &amp;&amp; $3 != &quot;&quot;)&#123;printf(&quot;%s:%s\n&quot;,image,$3)&#125;&#125;&#39;
</code></pre>
<h5 id="2-4、镜像下载"><a href="#2-4、镜像下载" class="headerlink" title="2.4、镜像下载"></a>2.4、镜像下载</h5><pre><code>##下载Redis官方最新镜像，相当于：docker pull redis:latest
docker pull redis
##下载仓库所有Redis镜像
docker pull -a redis
##下载私人仓库镜像
docker pull bitnami/redis
</code></pre>
<h5 id="2-5、镜像删除"><a href="#2-5、镜像删除" class="headerlink" title="2.5、镜像删除"></a>2.5、镜像删除</h5><pre><code>##单个镜像删除，相当于：docker rmi redis:latest
docker rmi redis
##强制删除(针对基于镜像有运行的容器进程)
docker rmi -f redis
##多个镜像删除，不同镜像间以空格间隔
docker rmi -f redis tomcat nginx
##删除本地全部镜像
docker rmi -f $(docker images -q)
</code></pre>
<h5 id="2-6、镜像构建"><a href="#2-6、镜像构建" class="headerlink" title="2.6、镜像构建"></a>2.6、镜像构建</h5><pre><code>##（1）编写dockerfile
cd /docker/dockerfile
vim mycentos
##（2）构建docker镜像
docker build -f /docker/dockerfile/mycentos -t mycentos:1.1
</code></pre>
<h4 id="3、容器操作"><a href="#3、容器操作" class="headerlink" title="3、容器操作"></a>3、容器操作</h4><p>提示：对于容器的操作可使用CONTAINER ID 或 NAMES。</p>
<h5 id="3-1、容器启动"><a href="#3-1、容器启动" class="headerlink" title="3.1、容器启动"></a>3.1、容器启动</h5><pre><code>##新建并启动容器，参数：-i  以交互模式运行容器；-t  为容器重新分配一个伪输入终端；--name  为容器指定一个名称
docker run -i -t --name mycentos
##后台启动容器，参数：-d  已守护方式启动容器
docker run -d mycentos
注意：此时使用&quot;docker ps -a&quot;会发现容器已经退出。这是docker的机制：要使Docker容器后台运行，就必须有一个前台进程。解决方案：将你要运行的程序以前台进程的形式运行。

##启动一个或多个已经被停止的容器
docker start redis
##重启容器
docker restart redis
</code></pre>
<h5 id="3-2、容器进程"><a href="#3-2、容器进程" class="headerlink" title="3.2、容器进程"></a>3.2、容器进程</h5><pre><code>##top支持 ps 命令参数，格式：docker top [OPTIONS] CONTAINER [ps OPTIONS]
##列出redis容器中运行进程
docker top redis
##查看所有运行容器的进程信息
for i in  `docker ps |grep Up|awk &#39;&#123;print $1&#125;&#39;`;do echo \ &amp;&amp;docker top $i; done
</code></pre>
<h5 id="3-3、容器日志"><a href="#3-3、容器日志" class="headerlink" title="3.3、容器日志"></a>3.3、容器日志</h5><pre><code>##查看redis容器日志，默认参数
docker logs rabbitmq
##查看redis容器日志，参数：-f  跟踪日志输出；-t   显示时间戳；--tail  仅列出最新N条容器日志；
docker logs -f -t --tail=20 redis
##查看容器redis从2019年05月21日后的最新10条日志。
docker logs --since=&quot;2019-05-21&quot; --tail=10 redis
</code></pre>
<h5 id="3-4、容器的进入与退出"><a href="#3-4、容器的进入与退出" class="headerlink" title="3.4、容器的进入与退出"></a>3.4、容器的进入与退出</h5><pre><code>##使用run方式在创建时进入
docker run -it centos /bin/bash
##关闭容器并退出
exit
##仅退出容器，不关闭
快捷键：Ctrl + P + Q
##直接进入centos 容器启动命令的终端，不会启动新进程，多个attach连接共享容器屏幕，参数：--sig-proxy=false  确保CTRL-D或CTRL-C不会关闭容器
docker attach --sig-proxy=false centos 
##在 centos 容器中打开新的交互模式终端，可以启动新进程，参数：-i  即使没有附加也保持STDIN 打开；-t  分配一个伪终端
docker exec -i -t  centos /bin/bash
##以交互模式在容器中执行命令，结果返回到当前终端屏幕
docker exec -i -t centos ls -l /tmp
##以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端
docker exec -d centos  touch cache.txt 
</code></pre>
<h5 id="3-5、查看容器"><a href="#3-5、查看容器" class="headerlink" title="3.5、查看容器"></a>3.5、查看容器</h5><pre><code>##查看正在运行的容器
docker ps
##查看正在运行的容器的ID
docker ps -q
##查看正在运行+历史运行过的容器
docker ps -a
##显示运行容器总文件大小
docker ps -s



##显示最近创建容器
docker ps -l
##显示最近创建的3个容器
docker ps -n 3
##不截断输出
docker ps --no-trunc 


##获取镜像redis的元信息
docker inspect redis
##获取正在运行的容器redis的 IP
docker inspect --format=&#39;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#39; redis
</code></pre>
<h5 id="3-6、容器的停止与删除"><a href="#3-6、容器的停止与删除" class="headerlink" title="3.6、容器的停止与删除"></a>3.6、容器的停止与删除</h5><pre><code>##停止一个运行中的容器
docker stop redis
##杀掉一个运行中的容器
docker kill redis
##删除一个已停止的容器
docker rm redis
##删除一个运行中的容器
docker rm -f redis
##删除多个容器
docker rm -f $(docker ps -a -q)
docker ps -a -q | xargs docker rm
  -l 移除容器间的网络连接，连接名为 db
docker rm -l db 
  -v 删除容器，并删除容器挂载的数据卷
docker rm -v redis
</code></pre>
<h5 id="3-7、生成镜像"><a href="#3-7、生成镜像" class="headerlink" title="3.7、生成镜像"></a>3.7、生成镜像</h5><pre><code>##基于当前redis容器创建一个新的镜像；参数：-a 提交的镜像作者；-c 使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停
docker commit -a=&quot;DeepInThought&quot; -m=&quot;my redis&quot; [redis容器ID]  myredis:v1.1
</code></pre>
<h5 id="3-8、容器与主机间的数据拷贝"><a href="#3-8、容器与主机间的数据拷贝" class="headerlink" title="3.8、容器与主机间的数据拷贝"></a>3.8、容器与主机间的数据拷贝</h5><pre><code>##将rabbitmq容器中的文件copy至本地路径
docker cp rabbitmq:/[container_path] [local_path]
##将主机文件copy至rabbitmq容器
docker cp [local_path] rabbitmq:/[container_path]/
##将主机文件copy至rabbitmq容器，目录重命名为[container_path]（注意与非重命名copy的区别）
docker cp [local_path] rabbitmq:/[container_path]
</code></pre>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis常用命令</title>
    <url>/2021/10/20/redis-chang-yong-ming-ling/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="五种基本数据结构"><a href="#五种基本数据结构" class="headerlink" title="五种基本数据结构"></a>五种基本数据结构</h3><h4 id="字符串-（String）"><a href="#字符串-（String）" class="headerlink" title="字符串 （String）"></a>字符串 （String）</h4><p>字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这意味着该类型可以接受任何格式的数据，如JPEG图像数据或json对象描述信息等。在Redis中字符串类型的value最多可以容纳的数据长度是512M。</p>
<p>常用命令：</p>
<ul>
<li>set key value 设置值</li>
<li>get key 获取值</li>
<li>getset 将给定的值设置进去，并返回旧值</li>
<li>mget key1 key2… 获取一个或多个key的值</li>
<li>setnx key value 当key不存在时才设置值(redis实现分布式锁)</li>
<li>incr key 将key存储的值+1</li>
<li>incrby key increment 将 key 所储存的值加上给定的增量值（increment）</li>
<li>decr key 将key存储的值-1</li>
<li>decrby key increment 将 key 所储存的值减去给定的增量值（increment）</li>
<li>strlen key 返回key所存储的字符串的长度</li>
</ul>
<h4 id="散列（hash）"><a href="#散列（hash）" class="headerlink" title="散列（hash）"></a>散列（hash）</h4><p>Redis中Hash类型可以看成句又String key和String value的map容器。所以该类型非常适合存储对象的信息。</p>
<p>常用命令：</p>
<ul>
<li>hset key field value</li>
<li>hget key field</li>
<li>hmset key field1 value1 [field2 value2 ] 同时set多个field值</li>
<li>hmget key field1 [field2]</li>
<li>hgetall key 获取key的所有值</li>
<li>hincrby key field increment 给指定的key的field增加给定的增量值(increment)</li>
<li>hkeys key 获取某个key的所有field</li>
<li>hvals key 获取某个key的所有value</li>
<li>hlen key 获取hash表中字段的数量</li>
<li>hexists key field 查看hash表中的字段是否存在</li>
<li>hdel key field1 [field2] 删除一个或多个hash表字段</li>
</ul>
<h4 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h4><p>在Redis中，List类型是按照插入顺序排序的字符串链表。和数据库结构中的普通链表一样，可以在头部和尾部添加新的元素。在插入时如果键不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也会被从数据库中删除。</p>
<p>常用命令：</p>
<ul>
<li>lpush key value1 [value2] 将一个值或多个值插入到列表头部</li>
<li>rpush key value1 [value2] 将一个值或多个值插入到列表尾部</li>
<li>lrange key start stop 获取列表指定范围的元素</li>
<li>lpop key 移出并获取列表中的第一个元素</li>
<li>rpop key 移出并获取列表中的最后一个元素</li>
<li>blpop key1 [key2 ] timeout 阻塞性的移出并获取列表的第一个元素，如果没有元素就会阻塞到超时或有元素为止</li>
<li>brpop key1 [key2 ] timeout 阻塞性的移出并获取列表的最后一个元素，如果没有元素就会阻塞到超时或有元素为止</li>
<li>lindex key index 通过索引位置获取列表中的元素</li>
<li>llen key 获取列表长度</li>
<li>lset key index value 通过索引位置设置值</li>
<li>ltrim key start stop 对一个列表进行修剪，只保留指定区间的元素，区间外的都删除掉</li>
</ul>
<h4 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h4><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。集合中最大的成员数为 2^32 - 1</p>
<p>常用命令：</p>
<ul>
<li>sadd key member1 [member2] 向集合中添加元素</li>
<li>scard key 获取集合的成员数</li>
<li>sdiff key1 [key2] 返回第一个集合与其他集合之间的差异</li>
<li>sinter key1 [key2] 返回给定所有集合的交集</li>
<li>sunion key1 [key2] 返回给定集合的并集</li>
<li>sismember key member 判断member元素是否是集合中的成员</li>
<li>smembers key 返回集合中所有成员</li>
<li>spop key 移除并返回集中中的一个随机元素</li>
<li>srandmember key [count] 返回集合中一个或多个随机数</li>
<li>srem key member1 [member2] 移除集合中一个或多个成员</li>
</ul>
<h4 id="有序集合（sorted-set）"><a href="#有序集合（sorted-set）" class="headerlink" title="有序集合（sorted set）"></a>有序集合（sorted set）</h4><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>常用命令：</p>
<ul>
<li>zadd key score1 member1 [score2 member2] 向有序集合中添加一个或多个成员，或更新已有成员的分数</li>
<li>zcard key 获取有序集合中的成员数量</li>
<li>zrange key start end [withscores] 通过索引区间返回有序集合中的成员</li>
<li>zrevrange key start stop [WITHSCORES] 通过索引区间返回有序集合中的成员，分数从高到低</li>
<li>zrangebyscore key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员</li>
<li>zrevrangebyscore key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员，分数由高到低排序</li>
<li>zrem key member [member …] 移除</li>
<li>zremrangebyrank key start stop 移除给定排名区间的所有成员</li>
<li>zremrangebyscore key min max 移除给定分数区间的所有成员</li>
<li>zscore key member 返回有序集合中成员的分数</li>
</ul>
<h3 id="三种高级数据结构"><a href="#三种高级数据结构" class="headerlink" title="三种高级数据结构"></a>三种高级数据结构</h3><h4 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h4><ul>
<li>Bitmaps：setbit&#x2F;getbit&#x2F;bitop&#x2F;bitcount&#x2F;bitpos bitmaps不是一个真实的数据结构。而是String类型上的一组面向bit操作的集合。由于 strings是二进制安全的blob，并且它们的最大长度是512m，所以bitmaps能最大设置 2^32个不同的bit。</li>
</ul>
<h4 id="Hyperloglogs"><a href="#Hyperloglogs" class="headerlink" title="Hyperloglogs"></a>Hyperloglogs</h4><ul>
<li>Hyperloglogs：pfadd&#x2F;pfcount&#x2F;pfmerge 在redis的实现中，您使用标准错误小于1％的估计度量结束。这个算法的神奇在于不再 需要与需要统计的项相对应的内存，取而代之，使用的内存一直恒定不变。最坏的情况 下只需要12k，就可以计算接近2^64个不同元素的基数。</li>
</ul>
<h4 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h4><ul>
<li>GEO：geoadd&#x2F;geohash&#x2F;geopos&#x2F;geodist&#x2F;georadius&#x2F;georadiusbymember Redis的GEO特性在 Redis3.2版本中推出，这个功能可以将用户给定的地理位置（经 度和纬度）信息储存起来，并对这些信息进行操作。</li>
</ul>
<h3 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h3><pre><code class="prettyprint">#-a * 密码认证
redis-benchmark -a * -n 100000 -c 32 -t SET,GET,INCR,HSET,LPUSH,MSET -q
redis-benchmark -a * -n 100000 -c 32
</code></pre>
<h3 id="前置命令"><a href="#前置命令" class="headerlink" title="前置命令"></a>前置命令</h3><ul>
<li>查看状态：<code>ping</code></li>
<li>查看当前数据库中key的数量：<code>dbsize</code></li>
<li>选择数据库：<code>select 2</code></li>
<li>删除当前数据库数据：<code>flushdb</code></li>
<li>删除所有数据库数据：<code>flushall</code></li>
<li>退出：<code>exit或quit</code></li>
<li>显示所有key：<code>keys *</code><ul>
<li><code>keys *i</code>：显示以<code>i</code>结尾的key</li>
<li><code>keys j?</code>：匹配以<code>j</code>开头的两个字符的key</li>
</ul>
</li>
<li>判断是否存在：<code>exists key</code></li>
<li>设置key的存活时间：<code>expire key seconds</code>(单位秒)</li>
<li>查看key的存活时间：<code>ttl key</code></li>
<li>获取key所存数据类型：<code>type key</code></li>
<li>删除key：<code>del key</code></li>
<li>备份：<code>sava</code></li>
<li>异步备份：<code>bgsave</code></li>
</ul>
<h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><ul>
<li>消息发布：<code>publish key message</code></li>
<li>消息订阅：<code>subscribe key</code></li>
</ul>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ul>
<li>获取锁–单个原子性操作 <code>SET lock 1 NX PX 30000</code> (毫秒)</li>
<li>释放锁–lua脚本-保证原子性+单线程，从而具有事务性</li>
</ul>
<pre><code class="prettyprint">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then
    return redis.call(&quot;del&quot;,KEYS[1])
else
    return 0
end
</code></pre>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><pre><code class="prettyprint">#实现乐观锁,watch只能在客户端开启事务之前执行
watch key
#开启事务
multi
#命令入队列，会返回QUEUED
#执行事务，开启watch之后如果当前key被其他客户端修改，返回nil,如果没有返回ok
exec
#取消事务
discard
</code></pre>
<blockquote>
<p>java代码</p>
</blockquote>
<pre><code class="prettyprint">import redis.clients.jedis.Jedis;
import redis.clients.jedis.Transaction;
 
public class TransactionExample &#123;
    public static void main(String[] args) &#123;
        // 创建 Redis 连接
        Jedis jedis = new Jedis(&quot;xxx.xxx.xxx.xxx&quot;, 6379);
        // 设置 Redis 密码
        jedis.auth(&quot;xxx&quot;);
        // 设置键值
        jedis.set(&quot;k&quot;, &quot;v&quot;);
        // 开启监视 watch
        jedis.watch(&quot;k&quot;);
        // 开始事务
        Transaction tx = jedis.multi();
        // 命令入列
        tx.set(&quot;k&quot;, &quot;v2&quot;);
        // 执行事务
        tx.exec();
        System.out.println(jedis.get(&quot;k&quot;));
        jedis.close();
    &#125;
&#125;
</code></pre>
<h3 id="redis管道（pipeline）"><a href="#redis管道（pipeline）" class="headerlink" title="redis管道（pipeline）"></a>redis管道（pipeline）</h3><blockquote>
<p> 管道的作用就是可以让客户端一次性发送多个请求，将所有的命令都放在一个缓冲区中最后一次性将所有命令打包发送到服务端。</p>
<p>管道的作用就是降低我们与redis交互的网络开销，原本每次请求都需要建立一次连接，而现在将多次请求打包只需要建立一次连接。</p>
<p>当然也不是打包的请求越多越好，因为redis必须要将所有的请求的结果进行缓存，请求越多所消耗的内存也自然越多。</p>
<p>管道是不具备原子性的，有可能打包的多个命令中执行过程中有某一条请求执行失败，那也不会影响其他的命令继续执行的</p>
</blockquote>
<h4 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h4><pre><code class="prettyprint">public static void main(String[] args) &#123;
    JedisPoolConfig config = new JedisPoolConfig();
    config.setMaxTotal(20);
    config.setMaxIdle(10);
    config.setMinIdle(5);

    JedisPool jedisPool = new JedisPool(config, &quot;127.0.0.1&quot;, 6379, 3000, null);
    Jedis jedis = jedisPool.getResource();
    Pipeline pl = jedis.pipelined();
    for (int i = 0; i &lt; 10; i++) &#123;
        pl.incr(&quot;pipelineKey&quot;);
        pl.set(&quot;data&quot; + i, &quot;data&quot;);
    &#125;
    List&lt;Object&gt; results = pl.syncAndReturnAll();
    System.out.println(results);
&#125;
</code></pre>
<h4 id="lua脚本-具备管道和事务，原子操作"><a href="#lua脚本-具备管道和事务，原子操作" class="headerlink" title="lua脚本(具备管道和事务，原子操作)"></a>lua脚本(具备管道和事务，原子操作)</h4><ul>
<li>Lua脚本具备了Pipeline和事务的功能。在管道的基础上添加了原子操作，保证管道中的请求要么都成功要么都失败。</li>
<li>具备了管道的优点 ”减少网络开销“和原子性操作，redis会将整个脚本当作一个整体来执行。</li>
<li>替代了redis的事务功能，redis的自身事务可用性并不是很高，一般我们在开发中都是使用lua脚本保证事务。</li>
<li>EVAL命令如： EVAL script numkeys key [key …] arg [arg …]</li>
<li>script：是Lua脚本，</li>
<li>numkeys参数用于指定键名参数的个数。</li>
<li>键名参数 key [key …] 表示在脚本中所用到的那些Redis键(key)，这些键名参数可以在 Lua中通过全局变量KEYS数组，用1为基址的形式访问( KEYS[1] ， KEYS[2] )。</li>
<li>附加参数 arg [arg …] ，可以在Lua中通过全局变量ARGV数组访问， 访问的形式和KEYS变量类似( ARGV[1] 、 ARGV[2] )。</li>
<li>如： eval “return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}” 2 key1 key2 first second。</li>
<li>在 Lua 脚本中，可以使用redis.call()函数来执行命令。</li>
</ul>
<pre><code class="prettyprint">public static void main(String[] args) &#123;
    JedisPoolConfig config = new JedisPoolConfig();
    config.setMaxTotal(20);
    config.setMaxIdle(10);
    config.setMinIdle(5);

    JedisPool jedisPool = new JedisPool(config, &quot;127.0.0.1&quot;, 6379, 3000, null);
    Jedis jedis = jedisPool.getResource();

    jedis.set(&quot;coupon_size&quot;, &quot;10&quot;);//初始化优惠券的数量
    String script = &quot; local count = redis.call(&#39;get&#39;, KEYS[1]) &quot; //获取coupon_size数量
        + &quot; local a = tonumber(count) &quot;     //将券数量转为数值
        + &quot; local b = tonumber(ARGV[1]) &quot;   //将传入的领券数量转入数值
        + &quot; if a &gt;= b then &quot;                //如果券数量大于要领取的数量
        + &quot; redis.call(&#39;set&#39;, KEYS[1], a‐b) &quot;   //进行券数量扣减
        + &quot; return 1 &quot;                          //扣减成功，返回：1 
        + &quot; end &quot;                               
        + &quot; return 0 &quot;;                         //否则返回：0
    Object obj = jedis.eval(script, //脚本
                            Arrays.asList(&quot;coupon_size&quot;),   //键值 
                            Arrays.asList(&quot;10&quot;));           //附加值
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>centos初始化安装</title>
    <url>/2022/04/07/centos-chu-shi-hua-an-zhuang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="安装ifconfig"><a href="#安装ifconfig" class="headerlink" title="安装ifconfig"></a>安装ifconfig</h4><pre><code class="prettyprint">yum search ifconfig # 查看ifconfig命令包
yum install net-tools.x86_64 # 安装
</code></pre>
<h4 id="安装vim"><a href="#安装vim" class="headerlink" title="安装vim"></a>安装vim</h4><pre><code class="prettyprint">yum -y install vim
</code></pre>
<h4 id="安装wget"><a href="#安装wget" class="headerlink" title="安装wget"></a>安装wget</h4><pre><code class="prettyprint">yum -y install wget
</code></pre>
<h4 id="nginx初始化环境"><a href="#nginx初始化环境" class="headerlink" title="nginx初始化环境"></a>nginx初始化环境</h4><h5 id="GCC编译器"><a href="#GCC编译器" class="headerlink" title="GCC编译器"></a>GCC编译器</h5><p>Nginx是使用C语言编写的程序，因此想要运行Nginx就需要安装一个编译工具。GCC就是一个开源的编译器集合，用于处理各种各样的语言，其中就包含了C语言。</p>
<p>使用命令<code>yum install -y gcc</code>来安装</p>
<p>安装成功后，可以通过<code>gcc --version</code>来查看gcc是否安装成功</p>
<h5 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE"></a>PCRE</h5><p>Nginx在编译过程中需要使用到PCRE库（perl Compatible Regular Expressoin 兼容正则表达式库)，因为在Nginx的Rewrite模块和http核心模块都会使用到PCRE正则表达式语法。</p>
<p>可以使用命令<code>yum install -y pcre pcre-devel</code>来进行安装</p>
<p>安装成功后，可以通过<code>rpm -qa pcre pcre-devel</code>来查看是否安装成功</p>
<h5 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h5><p>zlib库提供了开发人员的压缩算法，在Nginx的各个模块中需要使用gzip压缩，所以我们也需要提前安装其库及源代码zlib和zlib-devel</p>
<p>可以使用命令<code>yum install -y zlib zlib-devel</code>来进行安装</p>
<p>安装成功后，可以通过<code>rpm -qa zlib zlib-devel</code>来查看是否安装成功</p>
<h5 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h5><p>OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包进行安全通信，并且避免被窃听。</p>
<p>SSL:Secure Sockets Layer安全套接协议的缩写，可以在Internet上提供秘密性传输，其目标是保证两个应用间通信的保密性和可靠性。在Nginx中，如果服务器需要提供安全网页时就需要用到OpenSSL库，所以我们需要对OpenSSL的库文件及它的开发安装包进行一个安装。</p>
<p>可以使用命令<code>yum install -y openssl openssl-devel</code>来进行安装</p>
<p>安装成功后，可以通过<code>rpm -qa openssl openssl-devel</code>来查看是否安装成功</p>
<p>上述命令，一个个来的话比较麻烦，我们也可以通过一条命令来进行安装</p>
<p><code>yum install -y gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel</code>进行全部安装。</p>
<h4 id="建议集合"><a href="#建议集合" class="headerlink" title="建议集合"></a>建议集合</h4><pre><code>yum -y install lshw pciutils gdisk system-storage-manager
yum -y install bash-completion zip unzip bzip2 tree tmpwatch pinfo man-pages
yum -y install vnano vim-enhanced tmux screen
yum -y install net-tools psmisclsof sysstat
yum -y install yum-plugin-security yum-utils createrepo
yum -y install get wget curl eliks lynx lftp mailx mutt reync 
yum -y install libaio make cmake gcc-c++ gcc zib zlib-devel open openssl-devel pcre pcre-devel
</code></pre>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>centos安装mysql5.7</title>
    <url>/2021/11/14/centos-an-zhuang-mysql5-7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>卸载CentOS7系统自带mariadb</p>
<p>查看系统自带的Mariadb<br>[root@CDH-141 ~]# rpm -qa|grep mariadb<br>mariadb-libs-5.5.44-2.el7.centos.x86_64<br>卸载系统自带的Mariadb<br>[root@CDH-141 ~]# rpm -e –nodeps mariadb-libs-5.5.442.el7.centos.x86_64<br>删除etc目录下的my.cnf ，一定要删掉，等下再重新建，之前我将就用这个文件，后面改配置各种不生效<br>[root@CDH-141 ~]# rm &#x2F;etc&#x2F;my.cnf</p>
<p>rpm -qa |grep -i mysql   查看yum 安装的所有mysql相关安装包。</p>
<p>yum remove mysql-community mysql-community-server mysql-community-libs mysql-community-common   依次删除</p>
<p>一定要删除干净 rpm -qa |grep -i mysql 后没有任何安装包。</p>
<p>然后 find &#x2F; -name mysql  查看mysql相关文件  rm -rf  文件或者文件夹目录路径</p>
<p>mysql5.7.20安装过程</p>
<p>1.下载mysql yum源文件并安装</p>
<p> 下载：wget <a href="http://repo.mysql.com/mysql57-community-release-el7-10.noarch.rpm">http://repo.mysql.com/mysql57-community-release-el7-10.noarch.rpm</a></p>
<p> 安装：rpm -Uvh mysql57-community-release-el7-10.noarch.rpm</p>
<p>2.安装mysql服务端需要等待一段时间</p>
<p>命令：yum install  -y  mysql-community-server</p>
<p>3.开启mysql</p>
<p>命令：service mysqld start</p>
<p>查看mysql是否启动命令：service mysqld status</p>
<p>4.进入mysql 修改密码</p>
<p>查看初始密码命令：grep “password” &#x2F;var&#x2F;log&#x2F;mysqld.log</p>
<p>登录 <code>mysql -uroot -p</code></p>
<p>修改密码过于简单会报错</p>
<p>这一错误其实与validate_password_policy值的设置有关</p>
<p>validate_password_policy值默认为1，即MEDIUM，所以刚开始设置的密码必须符合长度要求，且必须含有数字，小写或大写字母，特殊字符</p>
<p>如果我们只是做为测试用而不需要如此复杂的密码，可使用如下方式修改validate_password_policy值</p>
<p>命令：<code>set global validate_password_policy=0;</code></p>
<p>密码的最小长度由validate_password_length值决定，validate_password_length参数默认为8</p>
<p>修改长度命令：<code>set global validate_password_length=4;</code></p>
<p>修改密码命令：<code>SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;root&#39;);</code></p>
<p>配置mysql远程链接：<br><code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;root&#39; WITH GRANT OPTION;</code></p>
<p>刷新权限： flush privileges;</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose安装</title>
    <url>/2021/11/20/docker-compose-an-zhuang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下载<br>我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：<a href="https://github.com/docker/compose/releases%E3%80%82">https://github.com/docker/compose/releases。</a></p>
<p><code>docker-compose-linux-x86_64</code><br>改名<br><code>mv  docker-compose-linux-x86_64 /usr/local/bin/docker-compose</code><br>赋权<br> <code>chmod +x /usr/local/bin/docker-compose</code><br>创建软链：<br><code>ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</code><br>测试是否安装成功：<br> <code>docker-compose --version</code></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose搭建zookeeper集群</title>
    <url>/2021/10/21/docker-compose-da-jian-zookeeper-ji-qun/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h4><p><a href="https://github.com/docker/compose/releases%E4%B8%8B%E8%BD%BD">https://github.com/docker/compose/releases下载</a><br><code>docker-compose-linux-x86_64</code></p>
<pre><code class="prettyprint"># 拷贝文件
cp docker-compose-linux-x86_64 /usr/local/bin/docker-compose
# 授权
chmod +x /usr/local/bin/docker-compose
# 查看版本
docker-compose --version
</code></pre>
<h4 id="安装zookeeper集群"><a href="#安装zookeeper集群" class="headerlink" title="安装zookeeper集群"></a>安装zookeeper集群</h4><pre><code># 创建文件存放路径
mkdir -p /usr/local/zookeeper
mkdir -p /usr/local/zookeeper/zk1/data
mkdir -p /usr/local/zookeeper/zk1/datalog
mkdir -p /usr/local/zookeeper/zk2/data
mkdir -p /usr/local/zookeeper/zk2/datalog
mkdir -p /usr/local/zookeeper/zk3/data
mkdir -p /usr/local/zookeeper/zk3/datalog
</code></pre>
<p>在对应的data文件夹下创建myid文件 文件内容分别是1,2,3</p>
<p>在<code>/usr/local/zookeeper</code>文件夹下创建<code>docker-compose.yml</code>文件[zookeeper版本3.7.0]</p>
<pre><code class="prettyprint">version: &#39;3.7&#39;

# 给zk集群配置一个网络，网络名为zk-net
networks:
  zk-net:
    name: zk-net

# 配置zk集群的
# container services下的每一个子配置都对应一个zk节点的docker container
services:
  zk1:
    # docker container所使用的docker image
    image: zookeeper:3.7.0
    hostname: zk1
    container_name: zk1
    # 配置docker container和宿主机的端口映射
    ports:
      - 2181:2181
      - 8081:8080
    # 配置docker container的环境变量
    environment:
      # 当前zk实例的id
      ZOO_MY_ID: 1
      # 整个zk集群的机器、端口列表
      ZOO_SERVERS: server.1=0.0.0.0:2888:3888;2181 server.2=zk2:2888:3888;2181 server.3=zk3:2888:3888;2181
    # 将docker container上的路径挂载到宿主机上 实现宿主机和docker container的数据共享
    volumes:
      - /usr/local/zookeeper/zk1/data:/data
      - /usr/local/zookeeper/zk1/datalog:/datalog
    # 当前docker container加入名为zk-net的隔离网络
    networks:
      - zk-net

  zk2:
    image: zookeeper:3.7.0
    hostname: zk2
    container_name: zk2
    ports:
      - 2182:2181
      - 8082:8080
    environment:
      ZOO_MY_ID: 2
      ZOO_SERVERS: server.1=zk1:2888:3888;2181 server.2=0.0.0.0:2888:3888;2181 server.3=zk3:2888:3888;2181
    volumes:
      - /usr/local/zookeeper/zk2/data:/data
      - /usr/local/zookeeper/zk2/datalog:/datalog
    networks:
      - zk-net

  zk3:
    image: zookeeper:3.7.0
    hostname: zk3
    container_name: zk3
    ports:
      - 2183:2181
      - 8083:8080
    environment:
      ZOO_MY_ID: 3
      ZOO_SERVERS: server.1=zk1:2888:3888;2181 server.2=zk2:2888:3888;2181 server.3=0.0.0.0:2888:3888;2181
    volumes:
      - /usr/local/zookeeper/zk3/data:/data
      - /usr/local/zookeeper/zk3/datalog:/datalog
    networks:
      - zk-net
</code></pre>
<p>在<code>docker-compose.yml</code>所在目录下启动</p>
<pre><code># 启动
docker-compose up
# 后台启动
docker-compose up -d
# 停止
docker-compose stop
# 删除
docker-compose rm
# 停止并删除
docker-compose down
# 重启
docker-compose restart
# 查看容器
docker-compose ps
</code></pre>
<p>查看zookeeper状态</p>
<pre><code># 进入容器
docker exec -it zk1 /bin/bash
#查看状态
./bin/zkServer.sh status
</code></pre>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compsoe安装kafka</title>
    <url>/2021/10/26/docker-compsoe-an-zhuang-kafka/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><pre><code class="prettyprint">version: &#39;3&#39;
services:
  zookeeper:
    image: wurstmeister/zookeeper
    container_name: zookeeper
    restart: always
    ports:
      - 2181:2181

  kafka:
    image: wurstmeister/kafka
    container_name: kafka
    ports:
      - 9092:9092
    environment:
      KAFKA_ADVERTISED_HOST_NAME: kafka
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
    restart: always
    volumes:
      - ./docker.sock:/var/run/docker.sock
</code></pre>
<h4 id="运行kafka镜像"><a href="#运行kafka镜像" class="headerlink" title="运行kafka镜像"></a>运行kafka镜像</h4><pre><code class="prettyprint">docker-compose up
docker-compose up -d
</code></pre>
<h4 id="验证kafka"><a href="#验证kafka" class="headerlink" title="验证kafka"></a>验证kafka</h4><pre><code class="prettyprint">docker exec -it kafka /bin/bash
</code></pre>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装dubbo-admin</title>
    <url>/2021/10/27/docker-an-zhuang-dubbo-admin/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><pre><code>docker pull apache/dubbo-admin
</code></pre>
<h4 id="安装zookeeper"><a href="#安装zookeeper" class="headerlink" title="安装zookeeper"></a>安装zookeeper</h4><p><a href="http://47.105.140.253:8090/archives/docker-compose-da-jian-zookeeper-ji-qun">docker-compose搭建zookeeper集群</a></p>
<h4 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h4><pre><code>docker run -d \
--name dubbo-admin \
-v /usr/local/dubbo/data:/data \
-p 9600:8080 \
-e admin.registry.address=zookeeper://47.105.140.253:2181,47.105.140.253:2182,47.105.140.253:2183 \
-e admin.config-center=zookeeper://47.105.140.253:2181,47.105.140.253:2182,47.105.140.253:2183 \
-e admin.metadata-report.address=zookeeper://47.105.140.253:2181,47.105.140.253:2182,47.105.140.253:2183 \
--restart=always \
docker.io/apache/dubbo-admin
</code></pre>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><a href="http://47.105.140.253:9600/">dubbo-admin</a> 账号root&#x2F;root</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装nginx</title>
    <url>/2021/10/28/docker-an-zhuang-nginx/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h5><pre><code class="prettyprint"># 查询镜像
docker search nginx
# 查询镜像版本
curl https://registry.hub.docker.com/v1/repositories/nginx/tags \
| tr -d &#39;[\[\]&quot; ]&#39; | tr &#39;&#125;&#39; &#39;\n&#39; \
| awk -F: -v image=&#39;nginx&#39; &#39;&#123;if(NR!=NF &amp;&amp; $3 != &quot;&quot;)&#123;printf(&quot;%s:%s\n&quot;,image,$3)&#125;&#125;&#39;
# 拉取镜像
docker pull nginx
</code></pre>
<h5 id="创建挂载目录"><a href="#创建挂载目录" class="headerlink" title="创建挂载目录"></a>创建挂载目录</h5><pre><code class="prettyprint">mkdir -p /usr/local/nginx/conf
mkdir -p /usr/local/nginx/html
mkdir -p /usr/local/nginx/logs
</code></pre>
<h5 id="进入conf-新建nginx-conf"><a href="#进入conf-新建nginx-conf" class="headerlink" title="进入conf,新建nginx.conf"></a>进入conf,新建nginx.conf</h5><pre><code class="prettyprint">
#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events &#123;
    worker_connections  1024;
&#125;


http &#123;
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;
    upstream halo &#123;
        server 47.105.140.253:8090;
    &#125;
    server &#123;
        listen       80;
        listen [::]:80
        server_name  www.pengp.store;
        client_max_body_size 1024m;
        location / &#123;
            proxy_pass http://halo;
            proxy_set_header HOST $host;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_buffering off;
            proxy_redirect off;
            proxy_read_timeout 120;
            proxy_connect_timeout 600;
        &#125;
        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html &#123;
            root   html;
        &#125;

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ &#123;
        #    proxy_pass   http://127.0.0.1;
        #&#125;

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ &#123;
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #&#125;

        # deny access to .htaccess files, if Apache&#39;s document root
        # concurs with nginx&#39;s one
        #
        #location ~ /\.ht &#123;
        #    deny  all;
        #&#125;
    &#125;


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server &#123;
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / &#123;
    #        root   html;
    #        index  index.html index.htm;
    #    &#125;
    #&#125;


    # HTTPS server
    #
    #server &#123;
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / &#123;
    #        root   html;
    #        index  index.html index.htm;
    #    &#125;
    #&#125;

&#125;
</code></pre>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><pre><code class="prettyprint">docker run --name nginx -d -p 80:80 -v /usr/local/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /usr/local/nginx/html:/etc/nginx/html -v /usr/local/nginx/logs:/var/log/nginx nginx
</code></pre>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql小技巧</title>
    <url>/2022/04/07/mysql-xiao-ji-qiao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1、this-is-incompatible-with-sql-mode-x3D-only-full-group-by"><a href="#1、this-is-incompatible-with-sql-mode-x3D-only-full-group-by" class="headerlink" title="1、this is incompatible with sql_mode&#x3D;only_full_group_by"></a>1、this is incompatible with sql_mode&#x3D;only_full_group_by</h3><pre><code class="prettyprint">--  mysql 7、8问题
SELECT @@global.sql_mode  
--结果
&#39;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;
--修改方式
SET @@global.sql_mode = &#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;
</code></pre>
<h3 id="2、日期获取"><a href="#2、日期获取" class="headerlink" title="2、日期获取"></a>2、日期获取</h3><pre><code class="prettyprint">SELECT @num:=@num+1 num,DATE_FORMAT(ADDDATE(&#39;2018-06-10&#39;, INTERVAL @num DAY),&#39;%Y-%m-%d&#39;) AS DATE
FROM pt_code,(SELECT @num:=0) t WHERE ADDDATE(&#39;2018-06-10&#39;, INTERVAL @num DAY) &lt;= DATE_FORMAT(CURDATE(),&#39;%Y-%m-%d&#39;)
LIMIT 0,30
</code></pre>
<h3 id="3、转化成数字排序"><a href="#3、转化成数字排序" class="headerlink" title="3、转化成数字排序"></a>3、转化成数字排序</h3><pre><code class="prettyprint">ORDER BY CAST(DATA1 AS SIGNED)
</code></pre>
<h3 id="4、CSV文件导入数据"><a href="#4、CSV文件导入数据" class="headerlink" title="4、CSV文件导入数据"></a>4、CSV文件导入数据</h3><pre><code class="prettyprint">LOAD DATA LOCAL INFILE 
    &#39;C:\\Users\\Administrator\\Desktop\\AAA.csv&#39;
    INTO TABLE `blog`.`k_lrp`
FIELDS ESCAPED BY &#39;\\&#39;  
TERMINATED BY &#39;,&#39;   
ENCLOSED BY &#39;&quot;&#39;  
LINES TERMINATED BY   &#39;\r\n&#39;  
(`LRP_ID`, `ORG_NO`, `YM`, `X_VALUE`, `DATA_OPER_TIME`, `DATA_OPER_TYPE`,`Y_VAULE`)
</code></pre>
<h3 id="5、前2个月"><a href="#5、前2个月" class="headerlink" title="5、前2个月"></a>5、前2个月</h3><pre><code class="prettyprint">SELECT 
  DATE_FORMAT(
    DATE_ADD(
      STR_TO_DATE(CONCAT(&#39;20201210&#39;, &#39;01&#39;), &#39;%Y%m%d&#39;),
      INTERVAL (1 - CAST(k.rn AS SIGNED INTEGER)) MONTH
    ),
    &#39;%Y%m&#39;
  ) stat_cycle 
FROM
  (SELECT 
    @rn := @rn + 1 rn 
  FROM
    pt_code g,
    (SELECT 
      @rn := 0) f 
  LIMIT 0, 31) k 
WHERE k.rn &lt;= 12 
</code></pre>
<h3 id="6、前30天数据"><a href="#6、前30天数据" class="headerlink" title="6、前30天数据"></a>6、前30天数据</h3><pre><code class="prettyprint">--不包含当天
SELECT @num:=@num+1 num,DATE_FORMAT(ADDDATE(&#39;20201210&#39;, INTERVAL -@num DAY),&#39;%Y%m%d&#39;) AS stat_cycle
FROM pt_code,(SELECT @num:=0) t
LIMIT 0,30
--包含当天
SELECT @num:=@num+1 num,DATE_FORMAT(ADDDATE(&#39;20201210&#39;, INTERVAL 1-@num DAY),&#39;%Y%m%d&#39;) AS stat_cycle
FROM pt_code,(SELECT @num:=0) t
LIMIT 0,30
</code></pre>
]]></content>
      <categories>
        <category>数据</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置https</title>
    <url>/2022/04/06/nginx-pei-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="linux先安装nginx"><a href="#linux先安装nginx" class="headerlink" title="linux先安装nginx"></a>linux先安装nginx</h4><h5 id="安装gcc-c-编译器"><a href="#安装gcc-c-编译器" class="headerlink" title="安装gcc-c++编译器"></a>安装gcc-c++编译器</h5><pre><code class="prettyprint">yum install gcc-c++
yum install -y openssl openssl-devel
</code></pre>
<h5 id="再安装pcre包"><a href="#再安装pcre包" class="headerlink" title="再安装pcre包"></a>再安装pcre包</h5><pre><code class="prettyprint">yum install -y pcre pcre-devel
</code></pre>
<h5 id="安装zlib包"><a href="#安装zlib包" class="headerlink" title="安装zlib包"></a>安装zlib包</h5><pre><code class="prettyprint">yum install -y zlib zlib-devel
</code></pre>
<h5 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h5><pre><code class="prettyprint"># 创建文件夹
mkdir /usr/local/nginx
# 下载
wget https://nginx.org/download/nginx-1.19.9.tar.gz
# 解压并进入
tar -zxvf nginx-1.19.9.tar.gz
cd nginx-1.19.9
# 使用默认配置
./configure
# 编译安装
make
make install
# 查找安装路径并启动
whereis nginx
./nginx
#查看启动成功
ps -ef | grep nginx
</code></pre>
<h4 id="获取ssl证书"><a href="#获取ssl证书" class="headerlink" title="获取ssl证书"></a>获取ssl证书</h4><ol>
<li><p>阿里云搜索<code>ssl</code><br><img src="/images/upload/2022/04/image-6126ceaeb4124eab9b756943f856157a.png" alt="image.png"></p>
</li>
<li><p>选择免费版（注意需要有自己的域名）</p>
</li>
<li><p>下载nginx版<br><img src="/images/upload/2022/04/image-67be79a34bd74f4f864fd13a15df385c.png" alt="image.png"><br><img src="/images/upload/2022/04/image-4ca21e25058a4549953467875478d351.png" alt="image.png"></p>
<h4 id="nginx的ssl模块安装"><a href="#nginx的ssl模块安装" class="headerlink" title="nginx的ssl模块安装"></a>nginx的ssl模块安装</h4><pre><code class="prettyprint"># 确认是否安装ssl模块,进入sbin目录
./nginx -V
# 查看是否存在 --with-http_ssl_module， 如果存在可以跳过此步骤，如若不存在进入/usr/local/nginx/nginx-1.19.9 目录执行以下命令
./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module
# 然后执行make，切记不要make install
make
# 找到objs目录下的面nginx替换到sbin目录下
cp /usr/local/nginx/nginx-1.19.9/objs/nginx /usr/local/nginx/sbin/nginx
# 进入sbin查看
./nginx -V
</code></pre>
<p><img src="/images/upload/2022/04/image-d70d33f8323a4e71b5eed842b8d06c2f.png" alt="image.png"></p>
<h4 id="配置ssl"><a href="#配置ssl" class="headerlink" title="配置ssl"></a>配置<code>ssl</code></h4><pre><code class="prettyprint">server &#123;
#监听443端口
 listen 443;
 #你的域名
 server_name www.pengp.store; 
 ssl on;
 #ssl证书的pem文件路径
 ssl_certificate  /root/card/7560621_www.pengp.store.pem;
 #ssl证书的key文件路径
 ssl_certificate_key /root/card/7560621_www.pengp.store.key;
 location / &#123;
  proxy_pass  http://公网地址:项目端口号;
 &#125;
&#125;
server &#123;
 listen 80;
 server_name www.pengp.store;
 #将请求转成https
 rewrite ^(.*)$ https://$host$1 permanent;
&#125;
</code></pre>
<p><img src="/images/upload/2022/04/image-61e99890b55a4b9c95e2f7804aa9e5f1.png" alt="image.png"></p>
<h4 id="nginx配置systemctl服务"><a href="#nginx配置systemctl服务" class="headerlink" title="nginx配置systemctl服务"></a>nginx配置systemctl服务</h4><pre><code class="prettyprint">vim /usr/lib/systemd/system/nginx.service
</code></pre>
</li>
</ol>
<p>[Unit]<br>Description&#x3D;nginx - web server<br>After&#x3D;network.target remote-fs.target nss-lookup.target<br>[Service]<br>Type&#x3D;forking<br>PIDFile&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid<br>ExecStartPre&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -t -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf<br>ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf<br>ExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload<br>ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s stop<br>ExecQuit&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s quit<br>PrivateTmp&#x3D;true<br>[Install]<br>WantedBy&#x3D;multi-user.target</p>
<h1 id="重新加载系统服务"><a href="#重新加载系统服务" class="headerlink" title="重新加载系统服务"></a>重新加载系统服务</h1><p>systemctl daemon-reload</p>
<h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>systemctl start nginx.service</p>
<h1 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h1><p>systemctl enable nginx.servic</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nvm安装多版本node</title>
    <url>/2022/04/14/nvm-an-zhuang-duo-ban-ben-node/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="nvm下载"><a href="#nvm下载" class="headerlink" title="nvm下载"></a>nvm下载</h4><p><code>https://github.com/coreybutler/nvm-windows/releases</code></p>
<p><img src="https://img-blog.csdnimg.cn/6e3fcc0b10c9400aa6e598901b8b3c1e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5L2g6IS45LiK5pyJQlVH,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="nvm安装"><a href="#nvm安装" class="headerlink" title="nvm安装"></a>nvm安装</h4><p>解压到任意位置，安装是尽量使用管理员操作，关闭360</p>
<h4 id="修改镜像地址-nvm安装目录setting-txt"><a href="#修改镜像地址-nvm安装目录setting-txt" class="headerlink" title="修改镜像地址 nvm安装目录setting.txt"></a>修改镜像地址 nvm安装目录<code>setting.txt</code></h4><pre><code class="prettyprint">node_mirror: https://npm.taobao.org/mirrors/node/
npm_mirror: https://npm.taobao.org/mirrors/npm/
</code></pre>
<h4 id="查看可以安装的node"><a href="#查看可以安装的node" class="headerlink" title="查看可以安装的node"></a>查看可以安装的node</h4><p><code>nvm list available</code> [<a href="https://nodejs.org/en/download/releases/">Previous Releases | Node.js (nodejs.org)</a>]</p>
<h4 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h4><p><code>nvm install 版本号</code>（本人hexo使用12.14.1，node14版本会出现空白页）</p>
<h4 id="使用node"><a href="#使用node" class="headerlink" title="使用node"></a>使用node</h4><p><code>nvm use node</code>(注意使用管理员启动cmd执行命令)</p>
<h4 id="卸载node"><a href="#卸载node" class="headerlink" title="卸载node"></a>卸载node</h4><p><code>nvm uninstall 需要删除的版本</code></p>
<h4 id="配置cnpm"><a href="#配置cnpm" class="headerlink" title="配置cnpm"></a>配置cnpm</h4><p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>windows编辑生成的shell脚本在linux执行问题调整</title>
    <url>/2021/10/30/windows-bian-ji-sheng-cheng-de-shell-jiao-ben-zai-linux-zhi-xing-wen-ti-diao-zheng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li>打开shell脚本</li>
<li>vim file.sh</li>
<li>shift+: 打开命令行</li>
<li>输入 set ff 查看 发现显示 dos</li>
<li>输入 set ff&#x3D;unix</li>
</ol>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle小技巧</title>
    <url>/2022/04/07/oracle-xiao-ji-qiao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1、megre-into"><a href="#1、megre-into" class="headerlink" title="1、megre into"></a>1、megre into</h3><pre><code class="prettyprint">MERGE INTO table1 T1
        USING (SELECT  &#39;&#39; cloumn 
                 FROM DUAL) T2
        ON (T1.cloumn      = T2.cloumn)
        WHEN MATCHED THEN
          UPDATE
             SET T1.cloumn1      = T2.cloumn1
        WHEN NOT MATCHED THEN
        insert
          (cloumn1)
        values
          (T2.cloumn1)
</code></pre>
<h3 id="2、连续前几周连续的周日期数据-2019W14-2019W25"><a href="#2、连续前几周连续的周日期数据-2019W14-2019W25" class="headerlink" title="2、连续前几周连续的周日期数据(2019W14-2019W25)"></a>2、连续前几周连续的周日期数据(2019W14-2019W25)</h3><pre><code class="prettyprint">select to_char(t.statCycle, &#39;yyyyMMdd&#39;) statCycleDay,
       to_char(t.statCycle, &#39;yyyy&#39;) || &#39;W&#39; || to_char(t.statCycle, &#39;WW&#39;) statCycle
  from (select Rownum rn,
               (trunc(to_date(&#39;20190622&#39;, &#39;yyyyMMdd&#39;) + Rownum - 7 * 12,
                      &#39;dd&#39;)) statCycle
          from dual
        connect by rownum &lt;= 7 * 12) t
 where t.rn / 7 = cast(t.rn / 7 as int)
 order by t.rn
</code></pre>
<h3 id="3、获取前几天的天日期数据"><a href="#3、获取前几天的天日期数据" class="headerlink" title="3、获取前几天的天日期数据"></a>3、获取前几天的天日期数据</h3><pre><code class="prettyprint">select Rownum rn,
       to_char((trunc(to_date(&#39;20190622&#39;, &#39;yyyyMMdd&#39;) + Rownum - 12, &#39;dd&#39;)),
               &#39;yyyyMMdd&#39;) statCycle
  from dual
connect by rownum &lt;= 12
</code></pre>
<h3 id="4、获取前几个月的月日期数据"><a href="#4、获取前几个月的月日期数据" class="headerlink" title="4、获取前几个月的月日期数据"></a>4、获取前几个月的月日期数据</h3><pre><code class="prettyprint">select k.stat_cycle statCycle
  from (select t.stat_cycle, rownum rn
          from (select to_char(to_date(&#39;201906&#39;, &#39;yyyyMM&#39;), &#39;yyyy&#39;) - 1 ||
                       lpad(level, 2, 0) stat_cycle
                  from dual
                 start with level = 0
                connect by level &lt;= 12
                union all
                select to_char(to_date(&#39;201906&#39;, &#39;yyyyMM&#39;), &#39;yyyy&#39;) ||
                       lpad(level, 2, 0) stat_cycle
                  from dual
                connect by level &lt;=
                           to_char(to_date(&#39;201906&#39;, &#39;yyyyMM&#39;), &#39;MM&#39;)) t) k
 where k.rn &gt; to_char(to_date(&#39;201906&#39;, &#39;yyyyMM&#39;), &#39;MM&#39;)
</code></pre>
<h3 id="5、获取最近24小时数据"><a href="#5、获取最近24小时数据" class="headerlink" title="5、获取最近24小时数据"></a>5、获取最近24小时数据</h3><pre><code class="prettyprint">select Rownum, trunc(sysdate, &#39;hh&#39;) + rownum / 24 past24
  from dual
connect by rownum &lt;= 24
</code></pre>
<h3 id="6、字符串’aaa-bbb-ccc’转表数据’aaa’-’bbb’-’ccc’"><a href="#6、字符串’aaa-bbb-ccc’转表数据’aaa’-’bbb’-’ccc’" class="headerlink" title="6、字符串’aaa,bbb,ccc’转表数据’aaa’,’bbb’,’ccc’"></a>6、字符串’aaa,bbb,ccc’转表数据’aaa’,’bbb’,’ccc’</h3><pre><code class="prettyprint">select regexp_substr(&#39;aaa,bbb,ccc&#39;, &#39;[^,]+&#39;, 1, level)
  from dual
connect by level &lt;=
           length(&#39;aaa,bbb,ccc&#39;) - length(replace(&#39;aaa,bbb,ccc&#39;, &#39;,&#39;)) + 1
</code></pre>
<h3 id="7、Oracle中rank-over-dense-rank-row-number-的区别"><a href="#7、Oracle中rank-over-dense-rank-row-number-的区别" class="headerlink" title="7、Oracle中rank() over, dense_rank(), row_number() 的区别"></a>7、Oracle中rank() over, dense_rank(), row_number() 的区别</h3><pre><code class="prettyprint">--1. rank over ()可以实现对学生排名，特点是成绩相同的两名是并列，如下1 2 2 4 5
select name,
      course,
      rank() over(partition by course order by score desc) as rank
  from student;
--2. dense_rank()和rank over()很像，但学生成绩并列后并不会空出并列所占的名次，如下1 2 2 3 4
 
select name,
      course,
      dense_rank() over(partition by course order by score desc) as rank
  from student;
--3. row_number这个函数不需要考虑是否并列，那怕根据条件查询出来的数值相同也会进行连续排名
select name,
      course,
      row_number() over(partition by course order by score desc) as rank
  from student;
</code></pre>
<h3 id="8、group-by-与-partition-by-区别"><a href="#8、group-by-与-partition-by-区别" class="headerlink" title="8、group by 与 partition by 区别"></a>8、group by 与 partition by 区别</h3><pre><code class="prettyprint">1. partition by用于给结果集进行分区。
2. partition by和group by有何区别？
partition by只是将原始数据进行名次排列(记录数不变)
group by是对原始数据进行聚合统计(记录数可能变少, 每组返回一条)
3. 使用rank over()的时候，空值是最大的，如果排序字段为null, 可能造成null字段排在最前面，影响排序结果。
可以这样： rank over(partition by course order by score desc nulls last)
</code></pre>
<h3 id="9、DDL"><a href="#9、DDL" class="headerlink" title="9、DDL"></a>9、DDL</h3><pre><code class="prettyprint">--修改字段类型
ALTER TABLE ADDRESS MODIFY COLUMN CITY CHAR(30);
--修改字段长度
ALTER TABLE ADDRESS MODIFY COLUMN CITY VARCHAR(32);
--新增字段
ALTER TABLE ADDRESS ADD (CITY VARCHAR2(256));
-- 给字段添加注释
COMMENT ON COLUMN ADDRESS.CITY
  IS &#39;发帖人联系方式&#39;;
</code></pre>
<h3 id="10、plsq注册码"><a href="#10、plsq注册码" class="headerlink" title="10、plsq注册码"></a>10、plsq注册码</h3><ul>
<li>Product Code：4t46t6vydkvsxekkvf3fjnpzy5wbuhphqz</li>
<li>serial Number：601769</li>
<li>password：xs374ca</li>
</ul>
<h3 id="11、行转列"><a href="#11、行转列" class="headerlink" title="11、行转列"></a>11、行转列</h3><p><code>LISTAGG*(BUY,&#39;,&#39;) WITHIN GROUP(ORDER BY BUY DESC)</code></p>
<h3 id="12、根据某一个字段排序获取序号"><a href="#12、根据某一个字段排序获取序号" class="headerlink" title="12、根据某一个字段排序获取序号"></a>12、根据某一个字段排序获取序号</h3><p><code>ROW_NUMBER() OVER(PARTITION BY A.org_no ORDER BY a.det_id DESC) rowflag</code></p>
<h3 id="13、根据某一个字段获取数量"><a href="#13、根据某一个字段获取数量" class="headerlink" title="13、根据某一个字段获取数量"></a>13、根据某一个字段获取数量</h3><p><code>count(*) over(partition by A.field) coutflag</code></p>
<h3 id="14、数据库赋权"><a href="#14、数据库赋权" class="headerlink" title="14、数据库赋权"></a>14、数据库赋权</h3><p><code>Grant select on db1.table to db2</code></p>
]]></content>
      <categories>
        <category>数据</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>安全问题整改</title>
    <url>/2022/04/07/an-quan-wen-ti-zheng-gai/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1、心脏滴血安全问题"><a href="#1、心脏滴血安全问题" class="headerlink" title="1、心脏滴血安全问题"></a>1、心脏滴血安全问题</h2><p>​	就是把openssl版本换成了1.0.1g，然后重新编译了Nginx</p>
<h2 id="2、加密会话（SSL-）Cookie-中缺少-Secure"><a href="#2、加密会话（SSL-）Cookie-中缺少-Secure" class="headerlink" title="2、加密会话（SSL ）Cookie  中缺少 Secure"></a>2、加密会话（SSL ）Cookie  中缺少 Secure</h2><p>​	web.xml 配置</p>
<pre><code class="prettyprint">&lt;session-config&gt;
    &lt;cookie-config&gt;
        &lt;secure&gt;true&lt;/secure&gt;
    &lt;/cookie-config&gt;
&lt;/session-config&gt;
</code></pre>
<h2 id="3、X-Frame-Options"><a href="#3、X-Frame-Options" class="headerlink" title="3、X-Frame-Options"></a>3、X-Frame-Options</h2><p>​	过滤器xml配置</p>
<pre><code class="prettyprint">&lt;filter&gt;
    &lt;filter-name&gt;xFrameOptionFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;XFrameOptionFilter&lt;/filter-class&gt;
    &lt;async-supported&gt;true&lt;/async-supported&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;xFrameOptionFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<p>​	过滤器java</p>
<pre><code class="prettyprint">HttpServletResponse response=(HttpServletResponse) rep;
    response.addHeader(&quot;x-frame-options&quot;,&quot;SAMEORIGIN&quot;);
    chain.doFilter(req, response);
</code></pre>
<h2 id="4、存储性xss攻击（前端解决方法）"><a href="#4、存储性xss攻击（前端解决方法）" class="headerlink" title="4、存储性xss攻击（前端解决方法）"></a>4、存储性xss攻击（前端解决方法）</h2><p>​	xss.js路径&lt;C:\Users\Administrator\Desktop\work\xss.js&gt;</p>
<p>​	引入xss.js    调用filterXSS方法</p>
<h2 id="5、启用了不安全的HTTP方法（OPTIONS）"><a href="#5、启用了不安全的HTTP方法（OPTIONS）" class="headerlink" title="5、启用了不安全的HTTP方法（OPTIONS）"></a>5、启用了不安全的HTTP方法（OPTIONS）</h2><p>​	 在web.xml添加</p>
<pre><code class="prettyprint">&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
        &lt;web-resource-name&gt;HttpMethod&lt;/web-resource-name&gt;
        &lt;description&gt;HttpMethod&lt;/description&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
        &lt;http-method&gt;PUT&lt;/http-method&gt;
        &lt;http-method&gt;DELETE&lt;/http-method&gt;
        &lt;http-method&gt;HEAD&lt;/http-method&gt; 
        &lt;http-method&gt;OPTIONS&lt;/http-method&gt;
        &lt;http-method&gt;TRACE&lt;/http-method&gt;
        &lt;http-method&gt;PATH&lt;/http-method&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;&lt;/auth-constraint&gt;
&lt;/security-constraint&gt;
</code></pre>
<h2 id="6、错误信息泄露中间件版本信息。-web-xml配置错误页面（poseidon）"><a href="#6、错误信息泄露中间件版本信息。-web-xml配置错误页面（poseidon）" class="headerlink" title="6、错误信息泄露中间件版本信息。  web.xml配置错误页面（poseidon）"></a>6、错误信息泄露中间件版本信息。  web.xml配置错误页面（poseidon）</h2><pre><code class="prettyprint">&lt;error-page&gt;  
&lt;error-code&gt;400&lt;/error-code&gt;  
&lt;location&gt;/error/error.html&lt;/location&gt;  
&lt;/error-page&gt; 
</code></pre>
<h2 id="7、网站存在样例-x2F-说明文件"><a href="#7、网站存在样例-x2F-说明文件" class="headerlink" title="7、网站存在样例&#x2F;说明文件"></a>7、网站存在样例&#x2F;说明文件</h2><p>​	删除wepapps&#x2F;docs</p>
<h2 id="8、jsp转码安全漏洞"><a href="#8、jsp转码安全漏洞" class="headerlink" title="8、jsp转码安全漏洞"></a>8、jsp转码安全漏洞</h2><p>​	&lt;%&#x3D;ESAPI.encoder().encodeForJavaScript(String.valueOf(request.getParameter(“mapTool”)))%&gt;</p>
<h2 id="9、Fortify-fix-for-XML-External-Entity-Injection"><a href="#9、Fortify-fix-for-XML-External-Entity-Injection" class="headerlink" title="9、Fortify fix for XML External Entity Injection"></a>9、Fortify fix for XML External Entity Injection</h2><h4 id="1）、TransformerFactory-trfactory-x3D-TransformerFactory-newInstance"><a href="#1）、TransformerFactory-trfactory-x3D-TransformerFactory-newInstance" class="headerlink" title="1）、TransformerFactory trfactory &#x3D; TransformerFactory.newInstance();"></a>1）、TransformerFactory trfactory &#x3D; TransformerFactory.newInstance();</h4><pre><code class="prettyprint">//TransformerFactory trfactory = TransformerFactory.newInstance(); 
//使用以下实现类替换
TransformerFactoryImpl transformerFactoryImpl = new TransformerFactoryImpl();
Transformer transformer = transformerFactoryImpl.newTransformer();
</code></pre>
<h4 id="2）、DocumentBuilder-x3D-x3D-gt-parse-is"><a href="#2）、DocumentBuilder-x3D-x3D-gt-parse-is" class="headerlink" title="2）、DocumentBuilder &#x3D;&#x3D;&gt;parse(is);"></a>2）、DocumentBuilder &#x3D;&#x3D;&gt;parse(is);</h4><pre><code class="prettyprint">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        
        
String FEATURE = null;
try &#123;
    FEATURE = &quot;http://apache.org/xml/features/disallow-doctype-decl&quot;;
    dbf.setFeature(FEATURE, true);
    FEATURE = &quot;http://xml.org/sax/features/external-general-entities&quot;;
    dbf.setFeature(FEATURE, false);
    FEATURE = &quot;http://xml.org/sax/features/external-parameter-entities&quot;;
    dbf.setFeature(FEATURE, false);
    FEATURE = &quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;;
    dbf.setFeature(FEATURE, false);
    dbf.setXIncludeAware(false);
    dbf.setExpandEntityReferences(false);
&#125; catch (Exception e) &#123;
    e.printStackTrace();
&#125;


DocumentBuilder builder = dbf.newDocumentBuilder();
InputSource is = new InputSource();
is.setCharacterStream(new StringReader(filterXXE(xml)));
Document doc = builder.parse(is);
</code></pre>
<p>参考：<a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.md">https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.md</a></p>
<h2 id="10、Random随机数问题"><a href="#10、Random随机数问题" class="headerlink" title="10、Random随机数问题"></a>10、Random随机数问题</h2><pre><code class="prettyprint">private SecureRandom random() throws NoSuchAlgorithmException&#123;
    return SecureRandom.getInstance(&quot;SHA1PRNG&quot;);
&#125;
//使用SecureRandom替换Random
</code></pre>
<h2 id="11、Header-Manipulation"><a href="#11、Header-Manipulation" class="headerlink" title="11、Header Manipulation"></a>11、Header Manipulation</h2><pre><code class="prettyprint">//response.addHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot; + fileOrgnName);
//将文件名过滤
public String filterFileName(String filename)&#123;
    String regex = &quot;[`~!@#$%^&amp;*()\\+\\=\\&#123;&#125;|:\&quot;?&gt;&lt;【】\\/r\\/n]&quot;;
    Pattern pa = Pattern.compile(regex);
    Matcher ma = pa.matcher(filename);
    if(ma.find())&#123;
        filename = ma.replaceAll(&quot;&quot;);
    &#125;
    return filename;
&#125;
response.addHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot; + filterFileName(fileOrgnName));
</code></pre>
<h2 id="12、Access-Control-Database"><a href="#12、Access-Control-Database" class="headerlink" title="12、Access Control:Database"></a>12、Access Control:Database</h2><p>单字符串 <code>StringEscapeUtils.escapeSql(）</code>转义<br>对象可以使用JSON转化</p>
<pre><code class="prettyprint">import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class JSONUtils &#123;
    private static final ObjectMapper MAPPER = new ObjectMapper();
    public static &lt;T&gt; List&lt;T&gt; jsonToList(String jsonText,Class&lt;T&gt; clazz) &#123;
        try &#123;
            return MAPPER.readValue(jsonText, new TypeReference&lt;List&lt;T&gt;&gt;() &#123;&#125;);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return new ArrayList&lt;&gt;();
    &#125;
    public static &lt;T&gt; String listToJson(List&lt;T&gt; list,Class&lt;T&gt; clazz)&#123;
        try &#123;
            return MAPPER.writeValueAsString(list);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return &quot;&quot;;
    &#125;
    
    public static Map jsonToMap(String jsonText)&#123;
        try &#123;
            return MAPPER.readValue(jsonText, Map.class);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return new HashMap();
    &#125;
    public static Map jsonToMapArr(String jsonText,String key)&#123;
        try &#123;
            Map map = MAPPER.readValue(jsonText, Map.class);
            String[] keys = key.split(&quot;,&quot;);
            for (String k:keys)&#123;
                map.put(k,((List&lt;?&gt;)map.get(k)).toArray(new String[((List&lt;?&gt;)map.get(k)).size()]));
            &#125;
            return map;
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return new HashMap();
    &#125;
    
    public static String mapToJson(Map map)&#123;
        try &#123;
            return MAPPER.writeValueAsString(map);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return &quot;&quot;;
    &#125;

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T jsonToObject(String jsonText,Class&lt;T&gt; clazz) &#123;
        try &#123;
            return MAPPER.readValue(jsonText, clazz);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;
    public static &lt;T&gt; String ObjectToJson(T t,Class&lt;T&gt; clazz)&#123;
        try &#123;
            return MAPPER.writeValueAsString(t);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return &quot;&quot;;
    &#125;
    
    public static Object getMapValueByKey(Map&lt;String,Object&gt; param,String str)&#123;
        return param.get(str) == null?&quot;&quot;:param.get(str);
    &#125;
&#125;
</code></pre>
<h2 id="13、Formula-Injection-Input-Validation-and-Representation-Data-Flow"><a href="#13、Formula-Injection-Input-Validation-and-Representation-Data-Flow" class="headerlink" title="13、Formula Injection (Input Validation and Representation, Data Flow)"></a>13、Formula Injection (Input Validation and Representation, Data Flow)</h2><p>导出excel时用bos.write会出现</p>
<pre><code>is = DataDealUtil.dataToInputStram(tableName, tableUnit, tableData, tableTitle,cellWidth != null?cellWidth:6,cellHeight != null?cellHeight:12);
            // 璁剧疆response鍙傛暟锛屽彲浠ユ墦寮�涓嬭浇椤甸潰
            response.reset();
            response.setContentType(&quot;application/vnd.ms-excel;charset=utf-8&quot;);

            tableName = URLEncoder.encode(tableName, &quot;utf-8&quot;);
            response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot; + tableName + &quot;.xls&quot;);

            ServletOutputStream out = response.getOutputStream();
            bis = new BufferedInputStream(is);
            bos = new BufferedOutputStream(out);

            byte[] buff = new byte[2048];
            int bytesRead; // Simple read/write loop.

            while (-1 != (bytesRead = bis.read(buff, 0, buff.length))) &#123;
                bos.write(buff, 0, bytesRead);
            &#125;
</code></pre>
<p>修改方式：直接使用HSSFWorkbook.write</p>
<pre><code>workbook = DataDealUtil.dataToInputStram(tableName, tableUnit, tableData, tableTitle,cellWidth != null?cellWidth:6,cellHeight != null?cellHeight:12);
            // 设置response参数，可以打开下载页面
            response.reset();
            response.setContentType(&quot;application/vnd.ms-excel;charset=utf-8&quot;);

            tableName = URLEncoder.encode(tableName, &quot;utf-8&quot;);
            response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot; + tableName + &quot;.xls&quot;);
            output = response.getOutputStream();
            workbook.write(output);
</code></pre>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序构建npm问题</title>
    <url>/2022/04/05/wei-xin-xiao-cheng-xu-gou-jian-npm-wen-ti/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li><code>npm init -y</code> 生成<code>package.json</code></li>
<li>修改 <code>project.config.json</code> 中<code>packNpmManually</code> 为false</li>
<li><code>npm install &quot;需要下载的包&quot;</code></li>
<li>npm构建</li>
<li>如果没有生成<code>miniprogram_npm</code> 就再<code>npm init -y</code></li>
</ol>
]]></content>
      <categories>
        <category>微信</category>
      </categories>
  </entry>
  <entry>
    <title>浅谈领域驱动和MVC模式在应用开发上的区别</title>
    <url>/2021/10/09/qian-tan-ling-yu-qu-dong-he-mvc-mo-shi-zai-ying-yong-kai-fa-shang-de-qu-bie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>概述<br>MVC：在传统B&#x2F;S开发模式下几乎都是使用MVC架构模式，MVC把javaweb开发分为三个模块，模型（Model）、视图（View）和控制器（Controller）<br>DDD(领域驱动)：在分布式微服务项目开发中，软件应用开发发不可能是一步到位，在业务开发之前需要大量的知识梳理，然后进行设计，其后才是开发。然而在收集材料，知识整理过程中，肯定会形成摸个领域知识，而后根据领域知识驱动软件设计，这就是DDD（Domain-Driven Design 领域驱动设计）的基本概念</li>
<li>开发</li>
</ul>
<p>MVC:</p>
<ol>
<li><p>模型<code>Model</code>：<br>Model制定业务逻辑，处理需求核心功能并且反馈处理后数据结果。<br>Model层返回的数据根据需求的不同有不同的可能，这样一个Model能为多个View提供数据。由于应用于Model的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。 </p>
</li>
<li><p>视图<code>View</code>：<br>View是用户看到并与之交互的界面，负责处理界面的变化。<br>MVC一个大的好处是它能为你的应用程序处理很多不同的视图。在View中其实没有真正的处理发生业务，作为视图来讲，它只是作为一种输出数据并允许用户操纵的方式。 </p>
</li>
<li><p>控制器<code>Controller</code>：<br>Controller接受用户的输入并调用Model和View去完成用户的需求。<br>Controller本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个Model构件去处理请求，然后用确定用哪个View来显示Model处理返回的数据。</p>
</li>
</ol>
<p>DDD：</p>
<ol>
<li><p>应用层<code>application</code><br> 应用服务位于应用层。用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装。<br>应用层的服务包括应用服务和领域事件相关服务。<br>应用服务可对微服务内的领域服务以及微服务外的应用服务进行组合和编排，或者对基础层如文件、缓存等数据直接操作形成应用服务，对外提供粗粒度的服务。<br>领域事件服务包括两类：领域事件的发布和订阅。通过事件总线和消息队列实现异步数据传输，实现微服务之间的解耦。</p>
</li>
<li><p>领域层<code>domain</code><br> 领域服务位于领域层，为完成领域中跨实体或值对象的操作转换而封装的服务，领域服务以与实体和值对象相同的方式参与实施过程。<br>领域服务对同一个实体的一个或多个方法进行组合和封装，或对多个不同实体的操作进行组合或编排，对外暴露成领域服务。领域服务封装了核心的业务逻辑。实体自身的行为在实体类内部实现，向上封装成领域服务暴露。<br>为隐藏领域层的业务逻辑实现，所有领域方法和服务等均须通过领域服务对外暴露。<br>为实现微服务内聚合之间的解耦，原则上禁止跨聚合的领域服务调用和跨聚合的数据相互关联。</p>
</li>
<li><p>基础层<code>infrastructrue</code><br> 基础服务位于基础层。为各层提供资源服务（如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务逻辑的影响。<br>基础服务主要为仓储服务，通过依赖反转的方式为各层提供基础资源服务，领域服务和应用服务调用仓储服务接口，利用仓储实现持久化数据对象或直接访问基础资源。</p>
</li>
<li><p>接口层<code>interfaces</code><br> 接口服务位于用户接口层，用于处理用户发送的Restful请求和解析用户输入的配置文件等，并将信息传递给应用层。<br><img src="/upload/2021/10/QQ%E5%9B%BE%E7%89%8720211011143247-f34e856e0c2b458fad315349343cb5d9.png" alt="QQ图片20211011143247.png"></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>若依学习-验证码</title>
    <url>/2021/08/31/ruo-yi-xue-xi-yan-zheng-ma/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h3><pre><code class="prettyprint">&lt;properties&gt;
    &lt;anji-plus.version&gt;1.2.4&lt;/anji-plus.version&gt;
&lt;/properties&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.github.anji-plus&lt;/groupId&gt;
    &lt;artifactId&gt;captcha-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;$&#123;anji-plus.version&#125;&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>在captcha-spring-boot-starter-1.2.4.jar下面有两个接口用于获取验证码和校验验证码<br><code>/captcha/get</code><br><code>/captcha/check</code><br><code>/captcha/verify</code></p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="vue校验使用路径prettyprint-components-verifition"><a href="#vue校验使用路径prettyprint-components-verifition" class="headerlink" title="vue校验使用路径prettyprint/components/verifition"></a>vue校验使用路径<code>prettyprint/components/verifition</code></h3><p><code>Verify.vue</code> 是主页面，<br>  <code>Verify/VerifySlide.vue</code> 滑动验证码	<br>  <code>Verify/VerifyPoints.vue</code> 点击文字验证码	</p>
<p><a href="https://captcha.anji-plus.com/#/" title="https://captcha.anji-plus.com/#/">AJ-Captcha在线体验</a>  <a href="https://captcha.anji-plus.com/#/">https://captcha.anji-plus.com/#/</a></p>
]]></content>
      <categories>
        <category>若依</category>
      </categories>
  </entry>
  <entry>
    <title>解决mapper.xml不在resources下面无法编译的问题</title>
    <url>/2021/11/11/jie-jue-mapper-xml-bu-zai-resources-xia-mian-wu-fa-bian-yi-de-wen-ti/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在pom.xml增加<code>&lt;build&gt;</code>配置</p>
<pre><code class="prettyprint">&lt;!-- 构建配置 --&gt;
    &lt;build&gt;
        &lt;!-- 配置资源目录, 主要解决idea无法将代码中的mapper.xml编译的问题  --&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/java&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
            &lt;/resource&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/resources&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.*&lt;/include&gt;
                &lt;/includes&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
    &lt;/build&gt;
</code></pre>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
  </entry>
  <entry>
    <title>算法可视化地址</title>
    <url>/2021/10/11/suan-fa-ke-shi-hua-di-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a><br><a href="https://algorithm-visualizer.org/">https://algorithm-visualizer.org/</a></p>
<div class="aplayer-box" data-url='http://www.ytmp3.cn/down/51689.mp3' data-name='你一定要幸福' data-artist='简弘亦' data-cover='http://img.ytmp3.cn/image/52.jpg' data-lrc='http://img.ytmp3.cn/image/52..lrc' data-lrcType='3' ></div>

]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
  </entry>
  <entry>
    <title>记一次dubbo获取服务接口问题</title>
    <url>/2022/03/30/ji-yi-ci-dubbo-huo-qu-fu-wu-jie-kou-wen-ti/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li>新版本程序使用旧版本zk导致，服务存在但是新增接口方法不存在</li>
<li>清理zk数据，未重启服务导致所有服务不存在</li>
<li>重启服务解决问题<br>ps:zk如果宕机会取本地缓存，但是没有宕机，服务数据不存在就会找不到对应的服务及接口</li>
</ol>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
  </entry>
  <entry>
    <title>阿里云服务器安装Docker</title>
    <url>/2021/10/16/a-li-yun-fu-wu-qi-an-zhuang-dockerr/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在阿里云服务器上安装Docker，服务器的系统是CentOS 7.6，</p>
<p>所以可以看官方Docker安装文档：<a href="https://docs.docker.com/install/linux/docker-ce/centos/">https://docs.docker.com/install/linux/docker-ce/centos/</a></p>
<p>从阅读官网来看，首先若是没有较旧的Docker版本只需3步就可以完成Dockers的安装；但是有旧版本的话，需要先卸载旧版本</p>
<pre><code class="prettyprint">yum remove docker \
              docker-client \
              docker-client-latest \
              docker-common \
              docker-latest \
              docker-latest-logrotate \
              docker-logrotate \
              docker-engine
</code></pre>
<p>无旧版本时(3步)</p>
<p>1.安装所需的软件包</p>
<pre><code class="prettyprint">yum install -y yum-utils \
  device-mapper-persistent-data \
  lvm2
</code></pre>
<p>2.配置阿里云Docker Yum源(个人觉的好)</p>
<pre><code class="prettyprint">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre>
<p>3.安装最新版本的Docker</p>
<pre><code class="prettyprint">yum install docker-ce docker-ce-cli containerd.io
</code></pre>
<p>这样之后就OK了，执行启动Docker的命令：systemctl start docker，然后走一波，完美！！</p>
<p>注，重要的事情说三遍。大多数人的执行完第二步后，会出现以下错误 <code>Loaded plugins: fastestmirror</code><br>解决方法如下：<br>1、</p>
<pre><code class="prettyprint">vi  /etc/yum/pluginconf.d/fastestmirror.conf
</code></pre>
<pre><code class="prettyprint">enabled=0    //由 1 改成0 ，禁用该插件
verbose=0
always_print_best_host = true
socket_timeout=3
#  Relative paths are relative to the cachedir (and so works for users as well
# as root).
hostfilepath=timedhosts.txt
maxhostfileage=10
maxthreads=15
#exclude=.gov, facebook
#include_only=.nl,.de,.uk,.ie
</code></pre>
<p>2、</p>
<pre><code class="prettyprint">vi /etc/yum.conf
</code></pre>
<pre><code class="prettyprint">[main]
cachedir=/var/cache/yum/$basearch/$releasever
keepcache=0
debuglevel=2
logfile=/var/log/yum.log
exactarch=1
obsoletes=1
gpgcheck=1
plugins=1 #将plugins的值修改为0
installonly_limit=5
</code></pre>
<p>3、</p>
<pre><code class="prettyprint">yum clean dbcache
</code></pre>
<p>之后重新执行配置源和安装命令即可。</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm学习</title>
    <url>/2022/05/21/jvm-xue-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li><p><code>jps</code>查看java进程</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521214845003.png" class="asset-class" title="image-20220521214845003">
</li>
<li><p><code>jstat</code>查看jvm内部gc相关信息</p>
<ul>
<li><p><code>jstat -gc 5048 1000 1000</code></p>
<ul>
<li>S0C：0号存活区的当前容量，单位kb</li>
<li>S1C：1号存活区的当前容量，单位kb</li>
<li>S0U：0号存活区的使用量，单位kb</li>
<li>S1U：1号存活区的使用量，单位kb</li>
<li>EC：Eden区，新生代的当前容量，单位kb</li>
<li>EU：Eden区，新生代的使用量，单位kb</li>
<li>OC：Old区，老年代的当前容量，单位kb</li>
<li>OU：Old区，老年代的使用量，单位kb</li>
<li>MC：元数据区的当前容量，单位kb</li>
<li>MU：元数据区的使用量，单位kb</li>
<li>CCSC：压缩class空间容量，单位kb</li>
<li>CCSU：压缩class空间使用量，单位kb</li>
<li>YGC：年轻代FC的次数</li>
<li>YGCT：年轻代GC消耗的总时间</li>
<li>FGC：Full GC的次数</li>
<li>FGCT：Full GC消耗的时间</li>
<li>GCT：垃圾收集消耗的总时间</li>
</ul>
<img src="/2022/05/21/jvm-xue-xi/image-20220521215543036.png" class="asset-class" title="image-20220521215543036">
</li>
<li><p><code>jstat -gcutil 5048 1000 1000</code></p>
<ul>
<li>S0：0号存活区的百分百使用率，0%是因为S0,S1随时有一个是空的</li>
<li>S1：1号存活区的百分百使用率</li>
<li>E：Eden区，新生代百分比使用率</li>
<li>O：Old区，老年代百分比使用率</li>
<li>M：元数据区百分比使用率</li>
<li>CCS：压缩class空间（Compressed class space）的百分比使用率</li>
<li>YGC：年轻代FC的次数</li>
<li>YGCT：年轻代GC消耗的总时间</li>
<li>FGC：Full GC的次数</li>
<li>FGCT：Full GC消耗的时间</li>
<li>GCT：垃圾收集消耗的总时间</li>
</ul>
<img src="/2022/05/21/jvm-xue-xi/image-20220521215214755.png" class="asset-class" title="image-20220521215214755"></li>
</ul>
</li>
<li><p><code>jmap</code>查看heap或类占用空间统计</p>
<ul>
<li><p><code>jmap -heap 5048</code></p>
<ul>
<li>JDK8默认使用<code>Parallel GC</code>线程数为物理机cpu处理器个数（8）</li>
<li>默认最大堆内存<code>MaxHeapSize</code>为物理机的1&#x2F;4</li>
<li>默认堆内存为物理机的1&#x2F;64</li>
<li>最大年轻代<code>MaxNewSize</code>为堆内存的1&#x2F;3</li>
<li>年轻代老年代比例为2</li>
<li>E区和S区比例为8</li>
<li>压缩class空间<code>CompressedClassSpaceSize</code>堆1&#x2F;4</li>
<li>最大元数据空间<code>MaxMetaspaceSize</code>,jdk8之后使用的时物理内存</li>
<li><code>G1HeapRegionSize</code> G1 GC是存在</li>
</ul>
<img src="/2022/05/21/jvm-xue-xi/image-20220521220545424.png" class="asset-class" title="image-20220521220545424">
</li>
<li><p><code>jmap -histo 5048</code>查看那些类占用的空间最多</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521221754253.png" class="asset-class" title="image-20220521221754253">
</li>
<li><p><code>jmap -dump:format=b,file=5048.hprof</code>Dump堆内存</p>
</li>
</ul>
</li>
<li><p><code>jstack</code>查看线程信息</p>
<ul>
<li><p><code>jstack -l 5048</code>长列表模式. 将线程相关的 locks 信息一起输出， 比如持有的锁，等待的锁。</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521221935294.png" class="asset-class" title="image-20220521221935294"></li>
</ul>
</li>
<li><p><code>jcmd</code>执行jvm相关分析命令</p>
<ul>
<li><p><code>jcmd 5048 help</code>查看当前进程有哪些命令</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521222209216.png" class="asset-class" title="image-20220521222209216">
</li>
<li><p><code>jcmd 5048 VM.version </code>jvm版本信息</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521222239451.png" class="asset-class" title="image-20220521222239451">
</li>
<li><p><code>jcmd 5048 VM.flags </code>java进程参数</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521222327043.png" class="asset-class" title="image-20220521222327043">
</li>
<li><p><code>jcmd 5048 VM.command_line </code> 命令行</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521222352234.png" class="asset-class" title="image-20220521222352234">
</li>
<li><p><code>jcmd 5048 VM.system_properties </code>系统参数</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521222450042.png" class="asset-class" title="image-20220521222450042">
</li>
<li><p><code>jcmd 5048 Thread.print </code>运行线程类似&#96;jstack -l 5048</p>
</li>
<li><p><code>jcmd 5048 GC.class_histogram </code>类似<code>jmap -histo 5048</code></p>
</li>
<li><p><code>jcmd 5048 GC.heap_info</code></p>
<img src="/2022/05/21/jvm-xue-xi/image-20220521222624101.png" class="asset-class" title="image-20220521222624101"></li>
</ul>
</li>
</ul>
<h3 id="图形化工具"><a href="#图形化工具" class="headerlink" title="图形化工具"></a>图形化工具</h3><ul>
<li><code>jconsole</code></li>
<li><code>jvisualvm</code></li>
<li><code>jmc</code></li>
<li><code>VisualGC</code>：idea插件</li>
</ul>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><h4 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h4><ul>
<li><p>标记清除算法（Mark and Sweep）Parallel GC和CMSGC的基本原理</p>
<ul>
<li><p>Marking（标记）: 遍历所有的可达对象，并在 本地内存(native)中分门别类记下</p>
</li>
<li><p>Sweeping（清除）: 这一步保证了，不可达对象 所占用的内存，在之后进行内存分配时可以重用</p>
</li>
</ul>
</li>
<li><p>标记-复制算法(Mark-Copy)</p>
</li>
<li><p>标记-清除-整理算法(Mark-Sweep-Compact)</p>
</li>
</ul>
<h4 id="GC收集器"><a href="#GC收集器" class="headerlink" title="GC收集器"></a>GC收集器</h4><h5 id="串行GC-Serial-GC"><a href="#串行GC-Serial-GC" class="headerlink" title="串行GC(Serial GC)"></a>串行GC(Serial GC)</h5><ul>
<li><code>-XX:+UseSerialGC</code>：配置使用串行化GC</li>
<li>串行 GC 对年轻代使用 mark-copy（标记-复制） 算法，对老年代使用 mark-sweep-compact （标记-清除-整理）算法</li>
<li>两者都是单线程的垃圾收集器，不能进行并行处理，所以都会触发全线暂停（STW），停止所有的应用线程</li>
<li>因此这种GC算法不能充分利用多核 CPU。不管有多少CPU 内核，JVM 在垃圾收集时都只能使用单个核心</li>
<li>CPU 利用率高，暂停时间长。简单粗暴，就像老式的电脑，动不动就卡死</li>
<li>只适合几百 MB 堆内存的 JVM，而且是单核 CPU 时比较有用</li>
<li><code>-XX:+UseParNewGC</code>改进版本的Serial GC,配置CMS使用</li>
</ul>
<h5 id="并行GC-Parallel-GC"><a href="#并行GC-Parallel-GC" class="headerlink" title="并行GC(Parallel GC)"></a>并行GC(Parallel GC)</h5><ul>
<li>使用命令<ul>
<li>-XX:+UseParallelGC</li>
<li>-XX:+UseParallelOldGC</li>
<li>-XX:+UseParallelGC -XX:+UseParallelOldGC</li>
</ul>
</li>
<li>年轻代和老年代的垃圾回收都会触发 STW 事件</li>
<li>在年轻代使用 标记-复制（mark-copy）算法，在老年代使用 标记-清除-整理（mark-sweepcompact）算法</li>
<li><code>-XX:ParallelGCThreads=N</code>来指定GC线程数，默认CPU核心数</li>
<li>并行垃圾收集器适用于多核服务器，主要目标是<code>增加吞吐量</code>。因为对系统资源的有效使用，能达到 更高的吞吐量<ul>
<li>在 GC 期间，所有 CPU 内核都在并行清理垃圾，所以总暂停时间更短</li>
<li>在两次 GC 周期的间隔期，没有 GC 线程在运行，不会消耗任何系统资源</li>
</ul>
</li>
</ul>
<h5 id="CMS-GC"><a href="#CMS-GC" class="headerlink" title="CMS GC"></a>CMS GC</h5><ul>
<li><code>-XX:+UseConcMarkSweepGC</code></li>
<li>其对年轻代采用并行 STW 方式的 mark-copy (标记-复制)算法，对老年代主要使用并发 marksweep (标记-清除)算法</li>
<li>CMS GC 的设计目标是避免在老年代垃圾收集时出现长时间的卡顿<ul>
<li>不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收</li>
<li>在 mark-and-sweep （标记-清除） 阶段的大部分工作和应用线程一起并发执行</li>
</ul>
</li>
<li>如果服务器是多核 CPU，并且主要调优目标是<code>降低 GC 停顿导致的系统延迟</code>，那么使用 CMS 是 个很明智的选择。进行老年代的并发回收时，可能会伴随着多次年轻代的 minor GC</li>
<li>CMS GC六个阶段<ul>
<li>Initial Mark（初始标记）<ul>
<li>这个阶段伴随着 STW 暂停。初始标记的目标是标记所有的根对象，包括根对象直接引用的对象，以及被年轻代中 所有存活对象所引用的对象（老年代单独回收）。</li>
</ul>
</li>
<li>Concurrent Mark（并发标记）<ul>
<li>在此阶段，CMS GC 遍历老年代，标记所有的存活对象， 从前一阶段 “Initial Mark” 找到的根对象开始算起。 “并 发标记”阶段，就是与应用程序同时运行，不用暂停的阶段</li>
</ul>
</li>
<li>Concurrent Preclean（并发预清理）<ul>
<li>此阶段同样是与应用线程并发执行的，不需要停止应用线 程。 因为前一阶段【并发标记】与程序并发运行，可能 有一些引用关系已经发生了改变。如果在并发标记过程中 引用关系发生了变化，JVM 会通过“Card（卡片）”的方 式将发生了改变的区域标记为“脏”区，这就是所谓的 卡片 标记（Card Marking）</li>
</ul>
</li>
<li>Final Remark（最终标记）<ul>
<li>最终标记阶段是此次 GC 事件中的第二次（也是最后一 次）STW 停顿。本阶段的目标是完成老年代中所有存活 对象的标记. 因为之前的预清理阶段是并发执行的，有可 能 GC 线程跟不上应用程序的修改速度。所以需要一次 STW 暂停来处理各种复杂的情况。 通常 CMS 会尝试在年轻代尽可能空的情况下执行 Final  Remark 阶段，以免连续触发多次 STW 事件</li>
</ul>
</li>
<li>Concurrent Sweep（并发清除）<ul>
<li>此阶段与应用程序并发执行，不需要 STW 停顿。JVM 在此 阶段删除不再使用的对象，并回收他们占用的内存空间</li>
</ul>
</li>
<li>Concurrent Reset（并发重置）<ul>
<li>此阶段与应用程序并发执行，重置 CMS 算法相关的内部 数据，为下一次 GC 循环做准备</li>
</ul>
</li>
</ul>
</li>
<li>CMS 垃圾收集器在减少停顿时间上做了很多复杂而有用的工作，用于垃圾回收的并发线程执 行的同时，并不需要暂停应用线程。 当然， CMS 也有一些缺点，其中最大的问题就是老年代内存碎片问题（因为不压缩），在某些情况 下 GC 会造成不可预测的暂停时间，特别是堆 内存较大的情况下</li>
</ul>
<h5 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h5><ul>
<li><p><code>-XX:+UseG1GC</code></p>
</li>
<li><p>G1 的全称是 Garbage -First，意为垃圾优先，哪 一块的垃圾最多就优先清理它</p>
</li>
<li><p>G1 GC 最主要的设计目标是：将 STW 停顿的时间 和分布，变成可预期且可配置的</p>
</li>
<li><p>G1 GC 是一款软实时垃圾收集器，可以为 其设置某项特定的性能指标。为了达成可预期停顿 时间的指标，G1 GC 有一些独特的实现</p>
<ul>
<li>堆不再分成年轻代和老年代，而是划分为多 个（通常是 2048 个）可以存放对象的 小块堆区域 (smaller heap regions)</li>
<li>每个小块，可能一会被 定义成 Eden 区，一会被指定为 Survivor区或者 Old 区</li>
<li>所有的 Eden 区和 Survivor 区合起来就是年轻代，所有的 Old 区拼在一起那 就是老年代</li>
<li>这样划分之后，使得 G1 不必每次都去收集整 个堆空间，而是以增量的方式来进行处理:  每 次只处理一部分内存块，称为此次 GC 的回收 集(collection set)。每次 GC 暂停都会收集所 有年轻代的内存块，但一般只包含部分老年代 的内存块</li>
</ul>
</li>
<li><p>G1 的另一项创新是，在并发阶段估算每个小 堆块存活对象的总数。构建回收集的原则是： 垃圾最多的小块会被优先收集。这也是 G1  名 称的由来</p>
</li>
<li><p>G1 GC –配置参数</p>
<ul>
<li><code>-XX:+UseG1GC</code>：启用 G1 GC； </li>
<li><code>-XX:G1NewSizePercent</code>：初始年轻代占整个 Java Heap 的大小，默认值为 5%； </li>
<li><code>-XX:G1MaxNewSizePercent</code>：最大年轻代占整个 Java Heap 的大小，默认值为 60%； </li>
<li><code>-XX:G1HeapRegionSize</code>：设置每个 Region 的大小，单位 MB，需要为 1，2，4，8，16，32 中的某个值，默 认是堆内存的 1&#x2F;2000。如果这个值设置比较大，那么大对象就可以进入 Region 了。 </li>
<li><code>-XX:ConcGCThreads</code>：与 Java 应用一起执行的 GC 线程数量，默认是 Java 线程的 1&#x2F;4，减少这个参数的数值可 能会提升并行回收的效率，提高系统内部吞吐量。如果这个数值过低，参与回收垃圾的线程不足，也会导致并行回 收机制耗时加长。 </li>
<li><code>-XX:+InitiatingHeapOccupancyPercent</code>（简称 IHOP）：G1 内部并行回收循环启动的阈值，默认为 Java Heap 的 45%。这个可以理解为老年代使用大于等于 45% 的时候，JVM 会启动垃圾回收。这个值非常重要，它决定了在 什么时间启动老年代的并行回收。 </li>
<li><code>-XX:G1HeapWastePercent</code>：G1停止回收的最小内存大小，默认是堆大小的 5%。GC 会收集所有的 Region 中 的对象，但是如果下降到了 5%，就会停下来不再收集了。就是说，不必每次回收就把所有的垃圾都处理完，可以 遗留少量的下次处理，这样也降低了单次消耗的时间。 </li>
<li><code>-XX:G1MixedGCCountTarget</code>：设置并行循环之后需要有多少个混合 GC 启动，默认值是 8 个。老年代 Region的回收时间通常比年轻代的收集时间要长一些，所以如果混合收集器比较多，可以允许G1延长老年代的收集时间</li>
<li><code>-XX:+G1PrintRegionLivenessInfo</code>：这个参数需要和 <code>-XX:+UnlockDiagnosticVMOptions</code> 配合启动，打印 JVM 的调试信 息，每个 Region 里的对象存活信息。 </li>
<li><code>-XX:G1ReservePercent</code>：G1 为了保留一些空间用于年代之间的提升，默认值是堆空间的 10%。因为大量执行回收的地方在 年轻代（存活时间较短），所以如果你的应用里面有比较大的堆内存空间、比较多的大对象存活，这里需要保留一些内存。</li>
<li><code>-XX:+G1SummarizeRSetStats</code>：这也是一个 VM 的调试信息。如果启用，会在 VM 退出的时候打印出 Rsets 的详细总结信 息。如果启用 </li>
<li><code>-XX:G1SummaryRSetStatsPeriod</code>： 参数，就会阶段性地打印 Rsets 信息。 </li>
<li><code>-XX:+G1TraceConcRefinement</code>：这个也是一个 VM 的调试信息，如果启用，并行回收阶段的日志就会被详细打印出来。 </li>
<li><code>-XX:+GCTimeRatio</code>：这个参数就是计算花在 Java 应用线程上和花在 GC 线程上的时间比率，默认是 9，跟新生代内存的分 配比例一致。这个参数主要的目的是让用户可以控制花在应用上的时间，G1 的计算公式是 100&#x2F;（1+GCTimeRatio）。这样 如果参数设置为 9，则最多 10% 的时间会花在 GC 工作上面。Parallel GC 的默认值是 99，表示 1% 的时间被用在 GC 上面， 这是因为 Parallel GC 贯穿整个 GC，而 G1 则根据 Region 来进行划分，不需要全局性扫描整个内存堆。 </li>
<li><code>-XX:+UseStringDeduplication</code>：手动开启 Java String 对象的去重工作，这个是 JDK8u20 版本之后新增的参数，主要用于 相同 String 避免重复申请内存，节约 Region 的使用。 -XX：MaxGCPauseMills：预期 G1 每次执行 GC 操作的暂停时间，单位是毫秒，默认值是 200 毫秒，G1 会尽量保证控制在 这个范围内</li>
</ul>
</li>
<li><p>G1 GC的处理步骤</p>
<ul>
<li><p>年轻代模式转移暂停（Evacuation Pause）</p>
<ul>
<li>G1 GC 会通过前面一段时间的运行情况来不断的调整自己的回收策略和行为，以此来比较稳定地控制 暂停时间。在应用程序刚启动时，G1 还没有采集到什么足够的信息，这时候就处于初始的 fullyyoung 模式。当年轻代空间用满后，应用线程会被暂停，年轻代内存块中的存活对象被拷贝到存活 区。如果还没有存活区，则任意选择一部分空闲的内存块作为存活区</li>
</ul>
</li>
<li><p>并发标记（Concurrent Marking）</p>
<ul>
<li><p>G1 并发标记的过程与 CMS 基本上是一样的。G1 的并发标记通过 Snapshot-At-The-Beginning（起始 快照）的方式，在标记阶段开始时记下所有的存活对象。即使在标记的同时又有一些变成了垃圾。通过 对象的存活信息，可以构建出每个小堆块的存活状态，以便回收集能高效地进行选择，这些信息在接下来的阶段会用来执行老年代区域的垃圾收集</p>
</li>
<li><p>有两种情况时可以并发执行</p>
<ul>
<li>如果在标记阶段确定某个小堆块中没有存活对象，只包含垃圾</li>
<li>在 STW 转移暂停期间，同时包含垃圾和存活对象的老年代小堆块</li>
</ul>
</li>
<li><p>处理</p>
<ul>
<li>Initial Mark（初始标记）<ul>
<li>此阶段标记所有从 GC 根对象直接可达的对象</li>
</ul>
</li>
<li>Root Region Scan（Root区扫描）<ul>
<li>此阶段标记所有从 “根区域” 可达的存活对象。根区域包括：非空的区域，以及在标记过程中不得不收集的区域</li>
</ul>
</li>
<li>Concurrent Mark（并发标记）<ul>
<li>此阶段和 CMS 的并发标记阶段非常类似：只遍历对象图，并在一个特殊的位图中标记能访问到的对象</li>
</ul>
</li>
<li>Remark（再次标记）<ul>
<li>这是一次 STW 停顿(因为不是并发的阶段)，以完成标记过程。 G1 收集器会短暂地停止应用线程， 停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标记开始时未被标记的存活对象</li>
</ul>
</li>
<li>Cleanup（清理）<ul>
<li>清理阶段为即将到来的转移阶段做准备，统计小堆块中所有存活的对象，并将小堆块进行排序，以提升 GC 的效率，维护并发标记的内部状态。 所有不包含存活对象的小堆块在此阶段都被回收了。有一部分任务是并发 的：例如空堆区的回收，还有大部分的存活率计算。此阶段也需要一个短暂的 STW 暂停</li>
</ul>
</li>
</ul>
</li>
<li><p>转移暂停: 混合模式（Evacuation Pause (mixed)）</p>
<ul>
<li><p>并发标记完成之后，G1将执行一次混合收集（mixed collection），就是不只清理年轻代，还将一部 分老年代区域也加入到 回收集 中。混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历 史数据会影响混合模式的启动时机。比如，假若在老年代中可以并发地腾出很多的小堆块，就没有必 要启动混合模式</p>
<p>因此，在并发标记与混合转移暂停之间，很可能会存在多次 young 模式的转移暂停</p>
<p>具体添加到回收集的老年代小堆块的大小及顺序，也是基于许多规则来判定的。其中包括指定的软实 时性能指标，存活性，以及在并发标记期间收集的 GC 效率等数据，外加一些可配置的 JVM 选项。混 合收集的过程，很大程度上和前面的 fully-young gc 是一样的</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>G1 GC 注意事项</p>
<ul>
<li><p>某些情况下 G1 触发了 Full GC，这时 G1 会退化使用 Serial 收集器来完成垃圾的清理工作， 它仅仅使用单线程来完成 GC 工作，GC 暂停时间将达到秒级别的</p>
<ul>
<li><p>并发模式失败</p>
<p>G1 启动标记周期，但在 Mix GC 之前，老年代就被填满，这时候 G1 会放弃标记周期。解决办法：增加堆大小，或者调整周期（例如增加线程数<code>-XX:ConcGCThreads</code>）</p>
</li>
<li><p>晋升失败</p>
<p>没有足够的内存供存活对象或晋升对象使用，由此触发了 Full GC(to-space exhausted&#x2F;to-space overflow）</p>
<ul>
<li>解决方法<ol>
<li>增加 <code>–XX:G1ReservePercent</code> 选项的值（并相应增加总的堆大小）增加预留内存量</li>
<li>通过减少 <code>–XX:InitiatingHeapOccupancyPercent</code> 提前启动标记周期</li>
<li>也可以通过增加 <code>–XX:ConcGCThreads</code> 选项的值来增加并行标记线程的数目</li>
</ol>
</li>
</ul>
</li>
<li><p>巨型对象分配失败</p>
<p>当巨型对象找不到合适的空间进行分配时，就会启动 Full GC，来释放空间</p>
<ul>
<li>解决方法：增加内存或者增大 <code>-XX:G1HeapRegionSize</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="各个GC对比图"><a href="#各个GC对比图" class="headerlink" title="各个GC对比图"></a>各个GC对比图</h5><p>​	<img src="/2022/05/21/jvm-xue-xi/image-20220521230335965.png" class="asset-class" title="image-20220521230335965"></p>
<h5 id="常用GC组合"><a href="#常用GC组合" class="headerlink" title="常用GC组合"></a>常用GC组合</h5><ul>
<li>Serial+Serial Old 实现单线程的低延迟 垃圾回收机制</li>
<li>ParNew+CMS，实现多线程的低延迟垃 圾回收机制</li>
<li>Parallel Scavenge和Parallel  Scavenge Old，实现多线程的高吞吐量垃圾 回收机制</li>
</ul>
<h5 id="如何选择正确GC"><a href="#如何选择正确GC" class="headerlink" title="如何选择正确GC"></a>如何选择正确GC</h5><ul>
<li>如果系统考虑吞吐优先，CPU 资源都用来最大程度处理业务，用 Parallel GC</li>
<li>如果系统考虑低延迟有限，每次 GC 时间尽量短，用 CMS GC</li>
<li>如果系统内存堆较大，同时希望整体来看平均 GC 时间可控，使用 G1 GC<ul>
<li>一般 4G 以上，算是比较大，用 G1 的性价比较高</li>
<li>一般超过 8G，比如 16G-64G 内存，非常推荐使用 G1 GC</li>
</ul>
</li>
</ul>
<h5 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h5><ul>
<li>JDK11之后支持</li>
<li><code>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx16g</code></li>
<li>ZGC主要特点<ul>
<li>GC 最大停顿时间不超过 10ms</li>
<li>堆内存支持范围广，小至几百 MB 的堆空间，大至 4TB 的超大堆 内存（JDK13 升至 16TB）</li>
<li>与 G1 相比，应用吞吐量下降不超过 15%</li>
<li>通过着色指针和读屏障，实现几乎全部的并发执行，几毫 秒级别的延迟，线性可扩展</li>
</ul>
</li>
</ul>
<h5 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h5><ul>
<li><code>-XX:+UnlockExperimentalVMOptions - XX:+UseShenandoahGC -Xmx16g</code></li>
</ul>
<p>可以看出 GC 算法和实现的演进路线</p>
<ol>
<li>串行 -&gt; 并行: 重复利用多核 CPU 的优势，大幅降低 GC 暂停时间，提升吞吐量</li>
<li>并行 -&gt; 并发： 不只开多个 GC 线程并行回收，还将GC操作拆分为多个步骤，让很多繁重的任务和应用线程一起并 发执行，减少了单次 GC 暂停持续的时间，这能有效降低业务系统的延迟</li>
<li>CMS -&gt; G1： G1 可以说是在 CMS 基础上进行迭代和优化开发出来的，划分为多个小堆块进行增量回收，这样就更 进一步地降低了单次 GC 暂停的时间</li>
<li>G1 -&gt; ZGC:：ZGC 号称无停顿垃圾收集器，这又是一次极大的改进。ZGC 和 G1 有一些相似的地方，但是底层的算法 和思想又有了全新的突破</li>
</ol>
<h3 id="Parallel-GC、CMS-GC、G1-GC"><a href="#Parallel-GC、CMS-GC、G1-GC" class="headerlink" title="Parallel GC、CMS GC、G1 GC"></a>Parallel GC、CMS GC、G1 GC</h3><img src="/2022/05/21/jvm-xue-xi/image-20220521231711959.png" class="asset-class" title="image-20220521231711959">

<h3 id="GC日志查看命令"><a href="#GC日志查看命令" class="headerlink" title="GC日志查看命令"></a>GC日志查看命令</h3><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><pre><code class="prettyprint">package com.rocpenghua.gc;

import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.LongAdder;

/**
 * Describe:
 * 演示GC日志生成
 *
 * @author RocPengHua
 * @date 2022/5/22.
 */
public class GCLogAnalysis &#123;
    private static Random random = new Random();

    public static void main(String[] args) &#123;
        //当前毫秒时间戳
        long startMillis = System.currentTimeMillis();
        //持续运行毫秒数
        long timeOutMillis = TimeUnit.SECONDS.toMillis(1);
        //结束时间戳
        long endMillis = startMillis + timeOutMillis;

        LongAdder counter = new LongAdder();
        System.out.println(&quot;正在执行&quot;);
        //缓存一部分对象；进入老年代
        int cacheSize = 2000;
        Object[] cachedGarbage = new Object[cacheSize];
        //在此时间范围内持续循环
        while (System.currentTimeMillis() &lt; endMillis) &#123;
            //生成垃圾对象
            Object garbage = generateGarbage(100 * 1024);
            counter.increment();
            int randomIndex = random.nextInt(2 * cacheSize);
            if (randomIndex &lt; cacheSize) &#123;
                cachedGarbage[randomIndex] = garbage;
            &#125;
        &#125;
        System.out.println(&quot;执行结束！共生成对象次数：&quot; + counter.longValue());
    &#125;

    private static Object generateGarbage(int max) &#123;
        int randomSize = random.nextInt(max);
        int type = randomSize % 4;
        Object result = null;
        switch (type) &#123;
            case 0:
                result = new int[randomSize];
                break;
            case 1:
                result = new byte[randomSize];
                break;
            case 2:
                result = new double[randomSize];
            default:
                StringBuilder builder = new StringBuilder();
                String randomString = &quot;randomString-Anything&quot;;
                while (builder.length() &lt; randomSize) &#123;
                    builder.append(randomString);
                    builder.append(max);
                    builder.append(randomSize);
                &#125;
                result = builder.toString();
                break;

        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<ul>
<li><p><code>java -XX:+PrintGCDetails com.rocpenghua.gc.GCLogAnalysis</code>：打印GC详细信息</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220522105901086.png" class="asset-class" title="image-20220522105901086">
</li>
<li><p><code>java -XX:+PrintGC com.rocpenghua.gc.GCLogAnalysis</code>：打印GC信息</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220522110044459.png" class="asset-class" title="image-20220522110044459">
</li>
<li><p><code>java -Xloggc:com.rocpenghua.gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps com.rocpenghua.gc.GCLogAnalysis</code>：GC信息保存到日志</p>
</li>
<li><p><code>java -Xmx128m -XX:+PrintGCDetails com.rocpenghua.gc.GCLogAnalysis</code>：指定最大堆</p>
<ul>
<li><p>堆内存太小GC次数变多</p>
<p>​	1.<img src="/2022/05/21/jvm-xue-xi/image-20220522110158184.png" class="asset-class" title="image-20220522110158184"></p>
<p>​	2.<img src="/2022/05/21/jvm-xue-xi/image-20220522110213797.png" class="asset-class" title="image-20220522110213797"></p>
<p>​	3.<img src="/2022/05/21/jvm-xue-xi/image-20220522110228153.png" class="asset-class" title="image-20220522110228153"></p>
</li>
</ul>
</li>
<li><p><code>java -XX:+UseSerialGC -Xms512m -Xmx512m -Xloggc:gc.UseSerialGC.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps com.rocpenghua.gc.GCLogAnalysis</code>：使用串行GC记录日志</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220522110317985.png" class="asset-class" title="image-20220522110317985">
</li>
<li><p><code>java -XX:+UseParallelGC -Xms512m -Xmx512m -XX:+PrintGCDetails -XX:+PrintGCDateStamps com.rocpenghua.gc.GCLogAnalysis</code>：使用并行GC</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220522110340790.png" class="asset-class" title="image-20220522110340790">
</li>
<li><p><code>java -XX:+UseConcMarkSweepGC -Xms512m -Xmx512m -XX:+PrintGCDetails -XX:+PrintGCDateStamps com.rocpenghua.gc.GCLogAnalysis</code>：使用CMS GC</p>
<p>1.<img src="/2022/05/21/jvm-xue-xi/image-20220522110411696.png" class="asset-class" title="image-20220522110411696"></p>
<p>​	2.<img src="/2022/05/21/jvm-xue-xi/image-20220522110436211.png" class="asset-class" title="image-20220522110436211"></p>
<p>​	3.CMS GC 六个阶段</p>
<img src="/2022/05/21/jvm-xue-xi/image-20220522110533123.png" class="asset-class" title="image-20220522110533123">
</li>
<li><p><code>java -XX:+UseG1GC -Xms512m -Xmx512m -XX:+PrintGCDetails -XX:+PrintGCDateStamps com.rocpenghua.gc.GCLogAnalysis</code>：使用G1 GC</p>
<p>​	1.<img src="/2022/05/21/jvm-xue-xi/image-20220522110617225.png" class="asset-class" title="image-20220522110617225"></p>
<p>​	2.<img src="/2022/05/21/jvm-xue-xi/image-20220522110632399.png" class="asset-class" title="image-20220522110632399"></p>
<p>​	3.<img src="/2022/05/21/jvm-xue-xi/image-20220522110827654.png" class="asset-class" title="image-20220522110827654"></p>
<p>​	4.<img src="/2022/05/21/jvm-xue-xi/image-20220522110844810.png" class="asset-class" title="image-20220522110844810"></p>
<p>​	5.<img src="/2022/05/21/jvm-xue-xi/image-20220522110901768.png" class="asset-class" title="image-20220522110901768"></p>
</li>
<li><p><code>java -XX:+UseG1GC -Xms512m -Xmx512m -XX:+PrintGC -XX:+PrintGCDateStamps com.rocpenghua.gc.GCLogAnalysis</code>：使用G1 GC</p>
<p>​	1.<img src="/2022/05/21/jvm-xue-xi/image-20220522110926764.png" class="asset-class" title="image-20220522110926764"></p>
</li>
</ul>
<p>2.<img src="/2022/05/21/jvm-xue-xi/image-20220522110949162.png" class="asset-class" title="image-20220522110949162"></p>
<h3 id="GC配置参数"><a href="#GC配置参数" class="headerlink" title="GC配置参数"></a>GC配置参数</h3><ul>
<li><p>日志相关</p>
<ul>
<li><p><code>-XX:+PrintGC</code>：打印GC信息</p>
</li>
<li><p><code>-verbose:gc</code>：打印GC信息</p>
</li>
<li><p><code>-XX:+PrintGCDetails</code>：打印GC详细信息</p>
</li>
<li><p><code>-XX:+PrintGCDateStamps</code>：添加时间戳</p>
</li>
<li><p><code>-Xloggc:gc.UseSerialGC.log</code>：将GC记录日志文件</p>
</li>
<li><p><code>-XX:+TranceClassLoading</code>：监控类的加载情况</p>
</li>
</ul>
</li>
<li><p>堆参数分配</p>
<ul>
<li><code>-Xmx</code>：最大堆<code>-XX:MaxHeapSize</code></li>
<li><code>-Xms</code>：初始堆<code>-XX:InitialHeapSize</code></li>
<li><code>-Xmn</code>：新生代内存</li>
<li><code>-XX:NewRatio</code>：新生代和老年代的比值（默认1:2）2</li>
<li><code>-XX:SurvivorRatio</code>：年轻代和永久代（S0&#x2F;S1）的比值（默认8:1）8</li>
<li><code>-XX:NewSize</code>：年轻代的大小</li>
<li><code>-XX:MaxNewSize</code>：年轻代最大大小</li>
<li><code>-XX:OldSize</code>：老年代大小</li>
<li><code>-XX:MetaspaceSize</code>：方法区大小</li>
<li><code>-XX:MaxMetaspaceSize</code>：方法区最大大小</li>
</ul>
</li>
<li><p>GC</p>
<ul>
<li><code>-XX:+UseSerialGC</code>：串行GC</li>
<li><code>-XX:+UseParallelGC</code>：并行GC（新生代，吞吐量优先）</li>
<li><code>-XX:+UseParallelOldGC</code>：并行GC（老年代，吞吐量优先）</li>
<li><code>-XX:+UseConcMarkSweepGC</code>：CMS GC（老年代，延迟时间优先）<ul>
<li><code>-XX:ConcGCThreads</code>：CMS并非垃圾收集器使用的线程数量</li>
</ul>
</li>
<li><code>-XX:+UseG1GC</code>：G1 GC（新生代，老年代，延迟时间优先）<ul>
<li><code>-XX:G1HeapRegionSize</code>：设置每个region大小</li>
<li><code>-XX:G1HeapWastePercent</code>：允许的浪费堆空间的占比，默认10%</li>
<li><code>-XX:MaxGCPauseMillis</code>：G1最大停顿时间，默认200ms</li>
<li><code>XX:G1MixedGCLiveThresholdPercent</code>：混合垃圾回收周期中要包括的旧区域设置占用率阈值，默认65%</li>
<li><code>-XX:G1MixedGCCountTarget</code>：设置标记周期完成后，对存活数据上限为G1MixedGCLIveThresholdPercent 的旧区域执行混合垃圾回收的目标次数，默认8次</li>
<li><code>-XX:G1OldCSetRegionThresholdPercent=1</code>：描述Mixed GC时，Old Region被加入到CSet中，默认情况下，G1只把10%的Old Region加入到CSet中</li>
</ul>
</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li><code>-XX:+HeapDumpOnOutOfMemoryError</code>：启动堆内存溢出打印，OOM自动生成dump文件</li>
<li><code>-XX:HeapDumpPath=heap.hprof</code>：指定堆内存溢出打印目录</li>
<li><code>-Xss</code>：设置线程的堆栈大小</li>
<li><code>-XX:MaxTenuringThreshold</code>：提升老年代的最大临界值，默认15</li>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>：启动并发GC周期时堆内存使用占比，默认45%</li>
</ul>
</li>
</ul>
<h3 id="压测工具sb"><a href="#压测工具sb" class="headerlink" title="压测工具sb"></a>压测工具<code>sb</code></h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li>管理员打开powershell</li>
<li>执行命令</li>
</ul>
<pre><code class="prettyprint">Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))
</code></pre>
<ul>
<li>执行</li>
</ul>
<pre><code class="prettyprint">choco install superbenchmarker
</code></pre>
<ul>
<li>输入<code>sb</code>查看帮助文档</li>
</ul>
<pre><code class="prettyprint">sb
</code></pre>
<ul>
<li>测试</li>
</ul>
<pre><code class="prettyprint">#20并发60秒
sb -u &#39;http://localhost:8080/api/hello&#39; -c 20 -N 60
</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware下CentOS7最小化安装及配置</title>
    <url>/2021/11/14/vmware-xia-centos7-zui-xiao-hua-an-zhuang-ji-pei-zhi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://blog.csdn.net/hellboy0621/article/details/80392273">https://blog.csdn.net/hellboy0621/article/details/80392273</a></p>
<p>3、配置</p>
<p>3.1 配置网络</p>
<p>在最小化安装的CentOS7中，ifconfig是不能使用的，查看网卡信息的命令是</p>
<p>ip addr</p>
<p>其中“ens33”为网卡名称，修改IP地址等信息</p>
<p>vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33<br>根据实际情况修改内容：</p>
<p>TYPE&#x3D;Ethernet<br>PROXY_METHOD&#x3D;none<br>BROWSER_ONLY&#x3D;no<br>BOOTPROTO&#x3D;static #启用静态ip地址<br>DEFROUTE&#x3D;yes<br>IPV4_FAILURE_FATAL&#x3D;no<br>IPV6INIT&#x3D;yes<br>IPV6_AUTOCONF&#x3D;yes<br>IPV6_DEFROUTE&#x3D;yes<br>IPV6_FAILURE_FATAL&#x3D;no<br>IPV6_ADDR_GEN_MODE&#x3D;stable-privacy<br>NAME&#x3D;ens33<br>UUID&#x3D;8d497804-9ffa-4edc-951a-5ddd8d2ed504<br>DEVICE&#x3D;ens33<br>ONBOOT&#x3D;yes #自动启用网络连接<br>IPADDR0&#x3D;192.168.0.201 #IP地址<br>PREFIXO0&#x3D;24 #子网掩码<br>GATEWAY0&#x3D;192.168.0.1 #网关<br>DNS1&#x3D;192.168.0.1 #DNS<br>修改好后保存退出，并重启网络，测试网络是否连接正常：</p>
<p>[root@centos7 ~]# service network restart<br>Restarting network (via systemctl):                        [  OK  ]<br>[root@centos7 ~]# ping <a href="http://www.baidu.com/">www.baidu.com</a><br>PING <a href="http://www.a.shifen.com/">www.a.shifen.com</a> (220.181.111.188) 56(84) bytes of data.<br>64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq&#x3D;1 ttl&#x3D;55 time&#x3D;27.6 ms<br>64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq&#x3D;2 ttl&#x3D;55 time&#x3D;89.3 ms<br>64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq&#x3D;3 ttl&#x3D;55 time&#x3D;27.1 ms<br>64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq&#x3D;4 ttl&#x3D;55 time&#x3D;26.2 ms<br>^C<br>— <a href="http://www.a.shifen.com/">www.a.shifen.com</a> ping statistics —<br>4 packets transmitted, 4 received, 0% packet loss, time 3005ms<br>rtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 26.254&#x2F;42.606&#x2F;89.358&#x2F;26.997 ms<br>3.2 安装ifconfig命令</p>
<p>查看哪个组件包含了ifconfig命令</p>
<p>yum provides ifconfig<br>或<br>yum whatprovides ifconfig</p>
<p>ifconfig命令依赖于net-tools的，安装</p>
<p>yum install -y net-tools<br>3.3 安装vim编辑器</p>
<p>yum install -y vim-enhanced<br>3.4 安装wget</p>
<p>yum install -y wget<br>3.5 关闭SELinux</p>
<p>编辑SELinux配置文件</p>
<p>vim &#x2F;etc&#x2F;selinux&#x2F;config<br>注释掉2行代码，并在最后添加1行代码</p>
<p>#SELINUX&#x3D;enforcing<br>#SELINUXTYPE&#x3D;targeted<br>SELINUX&#x3D;disabled<br>保存并关闭，使设置启用，最好重启一下系统，也可以稍后重启</p>
<p>setenforce 0<br>3.6 关闭CentOS自带firewall防火墙，启用iptables</p>
<h1 id="停止firewall"><a href="#停止firewall" class="headerlink" title="停止firewall"></a>停止firewall</h1><p>[root@centos7 &#x2F;]# systemctl stop firewalld</p>
<h1 id="关闭firewall自动启动"><a href="#关闭firewall自动启动" class="headerlink" title="关闭firewall自动启动"></a>关闭firewall自动启动</h1><p>[root@centos7 &#x2F;]# systemctl disable firewalld.service<br>Removed symlink &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;firewalld.service.<br>Removed symlink &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;dbus-org.fedoraproject.FirewallD1.service.<br>安装iptables防火墙</p>
<p>yum install -y iptables-services<br>使用iptables默认配置文件，可以在此配置文件中增加规则</p>
<p>[root@centos7 ~]# vim &#x2F;etc&#x2F;sysconfig&#x2F;iptables</p>
<h1 id="sample-configuration-for-iptables-service"><a href="#sample-configuration-for-iptables-service" class="headerlink" title="sample configuration for iptables service"></a>sample configuration for iptables service</h1><h1 id="you-can-edit-this-manually-or-use-system-config-firewall"><a href="#you-can-edit-this-manually-or-use-system-config-firewall" class="headerlink" title="you can edit this manually or use system-config-firewall"></a>you can edit this manually or use system-config-firewall</h1><h1 id="please-do-not-ask-us-to-add-additional-ports-x2F-services-to-this-default-configuration"><a href="#please-do-not-ask-us-to-add-additional-ports-x2F-services-to-this-default-configuration" class="headerlink" title="please do not ask us to add additional ports&#x2F;services to this default configuration"></a>please do not ask us to add additional ports&#x2F;services to this default configuration</h1><p>*filter<br>:INPUT ACCEPT [0:0]<br>:FORWARD ACCEPT [0:0]<br>:OUTPUT ACCEPT [0:0]<br>-A INPUT -m state –state RELATED,ESTABLISHED -j ACCEPT<br>-A INPUT -p icmp -j ACCEPT<br>-A INPUT -i lo -j ACCEPT<br>-A INPUT -p tcp -m state –state NEW -m tcp –dport 22 -j ACCEPT<br>-A INPUT -j REJECT –reject-with icmp-host-prohibited<br>-A FORWARD -j REJECT –reject-with icmp-host-prohibited<br>COMMIT<br>重启iptables，并添加到开机自启项中，查看iptables状态</p>
<p>[root@centos7 ~]# systemctl restart iptables.service<br>[root@centos7 ~]# systemctl enable iptables.service<br>Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;basic.target.wants&#x2F;iptables.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;iptables.service.<br>[root@centos7 ~]# service iptables status<br>Redirecting to &#x2F;bin&#x2F;systemctl status iptables.service<br>● iptables.service - IPv4 firewall with iptables<br>   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;iptables.service; enabled; vendor preset: disabled)<br>   Active: active (exited) since Mon 2018-05-21 18:09:28 CST; 18s ago<br> Main PID: 1195 (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS)</p>
<p>May 21 18:09:27 centos7 systemd[1]: Starting IPv4 firewall with iptables…<br>May 21 18:09:28 centos7 iptables.init[1195]: iptables: Applying firewall rules: [  OK  ]<br>May 21 18:09:28 centos7 systemd[1]: Started IPv4 firewall with iptables.<br>3.7 配置国内yum源和epel源</p>
<p>3.7.1 配置yum源</p>
<p>1）新建文件夹，保存系统中原来的repo文件</p>
<p>[root@centos7 ~]# cd &#x2F;etc&#x2F;yum.repos.d&#x2F;<br>[root@centos7 yum.repos.d]# mkdir repo_bak<br>[root@centos7 yum.repos.d]# mv *.repo repo_bak&#x2F;<br>2）下载阿里云和网易对应系统的repo文件</p>
<p>[root@centos7 yum.repos.d]# wget <a href="http://mirrors.aliyun.com/repo/Centos-7.repo">http://mirrors.aliyun.com/repo/Centos-7.repo</a><br>[root@centos7 yum.repos.d]# wget <a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo">http://mirrors.163.com/.help/CentOS7-Base-163.repo</a><br>[root@centos7 yum.repos.d]# ll<br>total 8<br>-rw-r–r– 1 root root 1572 Dec  1  2016 CentOS7-Base-163.repo<br>-rw-r–r– 1 root root 2573 Nov 21  2014 Centos-7.repo<br>drwxr-xr-x 2 root root  187 May 21 18:25 repo_bak<br>3）清楚系统yum缓存，并生成新的yum缓存</p>
<p>[root@centos7 yum.repos.d]# yum clean all<br>Loaded plugins: fastestmirror<br>Repository base is listed more than once in the configuration<br>Repository updates is listed more than once in the configuration<br>Repository extras is listed more than once in the configuration<br>Repository centosplus is listed more than once in the configuration<br>Cleaning repos: base extras updates<br>Cleaning up everything<br>Maybe you want: rm -rf &#x2F;var&#x2F;cache&#x2F;yum, to also free up space taken by orphaned data from disabled or removed repos<br>Cleaning up list of fastest mirrors</p>
<p>[root@centos7 yum.repos.d]# yum makecache<br>Loaded plugins: fastestmirror<br>Repository base is listed more than once in the configuration<br>Repository updates is listed more than once in the configuration<br>Repository extras is listed more than once in the configuration<br>Repository centosplus is listed more than once in the configuration<br>Determining fastest mirrors<br>base                                                                                   | 3.6 kB  00:00:00<br>extras                                                                                 | 3.4 kB  00:00:00<br>updates                                                                                | 3.4 kB  00:00:00<br>(1&#x2F;12): base&#x2F;7&#x2F;x86_64&#x2F;group_gz                                                         | 166 kB  00:00:00<br>(2&#x2F;12): base&#x2F;7&#x2F;x86_64&#x2F;primary_db                                                       | 5.9 MB  00:00:01<br>(3&#x2F;12): extras&#x2F;7&#x2F;x86_64&#x2F;prestodelta                                                    |  47 kB  00:00:00<br>(4&#x2F;12): base&#x2F;7&#x2F;x86_64&#x2F;other_db                                                         | 2.5 MB  00:00:00<br>(5&#x2F;12): extras&#x2F;7&#x2F;x86_64&#x2F;primary_db                                                     | 143 kB  00:00:00<br>(6&#x2F;12): extras&#x2F;7&#x2F;x86_64&#x2F;filelists_db                                                   | 517 kB  00:00:00<br>(7&#x2F;12): extras&#x2F;7&#x2F;x86_64&#x2F;other_db                                                       |  91 kB  00:00:00<br>(8&#x2F;12): updates&#x2F;7&#x2F;x86_64&#x2F;prestodelta                                                   | 180 kB  00:00:00<br>(9&#x2F;12): updates&#x2F;7&#x2F;x86_64&#x2F;filelists_db                                                  | 875 kB  00:00:00<br>(10&#x2F;12): updates&#x2F;7&#x2F;x86_64&#x2F;other_db                                                     | 201 kB  00:00:00<br>(11&#x2F;12): updates&#x2F;7&#x2F;x86_64&#x2F;primary_db                                                   | 1.2 MB  00:00:00<br>(12&#x2F;12): base&#x2F;7&#x2F;x86_64&#x2F;filelists_db                                                    | 6.9 MB  00:00:04<br>Metadata Cache Created<br>3.7.2 配置epel源</p>
<p>1）安装epel-release，安装成功后，会自动生成epel.repo和epel-testing.repo两个文件</p>
<p>[root@centos7 yum.repos.d]# yum list | grep epel-release<br>Repository base is listed more than once in the configuration<br>Repository updates is listed more than once in the configuration<br>Repository extras is listed more than once in the configuration<br>Repository centosplus is listed more than once in the configuration<br>epel-release.noarch                         7-11                       extras</p>
<p>[root@centos7 yum.repos.d]# yum install -y epel-release<br>Loaded plugins: fastestmirror<br>Repository base is listed more than once in the configuration<br>Repository updates is listed more than once in the configuration<br>Repository extras is listed more than once in the configuration<br>Repository centosplus is listed more than once in the configuration<br>Loading mirror speeds from cached hostfile<br>Resolving Dependencies<br>–&gt; Running transaction check<br>—&gt; Package epel-release.noarch 0:7-11 will be installed<br>–&gt; Finished Dependency Resolution</p>
<p>Dependencies Resolved</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br> Package                       Arch                    Version                  Repository               Size<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>Installing:<br> epel-release                  noarch                  7-11                     extras                   15 k</p>
<h1 id="Transaction-Summary"><a href="#Transaction-Summary" class="headerlink" title="Transaction Summary"></a>Transaction Summary</h1><p>Install  1 Package</p>
<p>Total download size: 15 k<br>Installed size: 24 k<br>Downloading packages:<br>epel-release-7-11.noarch.rpm                                                           |  15 kB  00:00:00<br>Running transaction check<br>Running transaction test<br>Transaction test succeeded<br>Running transaction<br>  Installing : epel-release-7-11.noarch                                                                   1&#x2F;1<br>  Verifying  : epel-release-7-11.noarch                                                                   1&#x2F;1</p>
<p>Installed:<br>  epel-release.noarch 0:7-11</p>
<p>Complete!</p>
<p>[root@centos7 yum.repos.d]# ll<br>total 16<br>-rw-r–r– 1 root root 1572 Dec  1  2016 CentOS7-Base-163.repo<br>-rw-r–r– 1 root root 2573 Nov 21  2014 Centos-7.repo<br>-rw-r–r– 1 root root  951 Oct  3  2017 epel.repo<br>-rw-r–r– 1 root root 1050 Oct  3  2017 epel-testing.repo<br>drwxr-xr-x 2 root root  187 May 21 18:25 repo_bak<br>2）下载阿里云开源镜像的epel源文件</p>
<p>[root@centos7 yum.repos.d]# wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel-7.repo <a href="http://mirrors.aliyun.com/repo/epel-7.repo">http://mirrors.aliyun.com/repo/epel-7.repo</a><br>–2018-05-21 18:35:24–  <a href="http://mirrors.aliyun.com/repo/epel-7.repo">http://mirrors.aliyun.com/repo/epel-7.repo</a><br>Resolving mirrors.aliyun.com (mirrors.aliyun.com)… 1.81.1.230, 1.81.1.223, 1.81.1.224, …<br>Connecting to mirrors.aliyun.com (mirrors.aliyun.com)|1.81.1.230|:80… connected.<br>HTTP request sent, awaiting response… 200 OK<br>Length: 664 [application&#x2F;octet-stream]<br>Saving to: ‘&#x2F;etc&#x2F;yum.repos.d&#x2F;epel-7.repo’</p>
<p>100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;] 664         –.-K&#x2F;s   in 0s</p>
<p>2018-05-21 18:35:24 (148 MB&#x2F;s) - ‘&#x2F;etc&#x2F;yum.repos.d&#x2F;epel-7.repo’ saved [664&#x2F;664]</p>
<p>[root@centos7 yum.repos.d]# ll<br>total 20<br>-rw-r–r– 1 root root 1572 Dec  1  2016 CentOS7-Base-163.repo<br>-rw-r–r– 1 root root 2573 Nov 21  2014 Centos-7.repo<br>-rw-r–r– 1 root root  664 May 11 11:35 epel-7.repo<br>-rw-r–r– 1 root root  951 Oct  3  2017 epel.repo<br>-rw-r–r– 1 root root 1050 Oct  3  2017 epel-testing.repo<br>drwxr-xr-x 2 root root  187 May 21 18:25 repo_bak<br>3）再次清除系统yum缓存，并重新生成yum缓存</p>
<p>[root@centos7 yum.repos.d]# yum clean all<br>Loaded plugins: fastestmirror<br>Repository base is listed more than once in the configuration<br>Repository updates is listed more than once in the configuration<br>Repository extras is listed more than once in the configuration<br>Repository centosplus is listed more than once in the configuration<br>Repository epel is listed more than once in the configuration<br>Repository epel-debuginfo is listed more than once in the configuration<br>Repository epel-source is listed more than once in the configuration<br>Cleaning repos: base epel extras updates<br>Cleaning up everything<br>Maybe you want: rm -rf &#x2F;var&#x2F;cache&#x2F;yum, to also free up space taken by orphaned data from disabled or removed repos<br>Cleaning up list of fastest mirrors</p>
<p>[root@centos7 yum.repos.d]# yum makecache<br>Loaded plugins: fastestmirror<br>Repository base is listed more than once in the configuration<br>Repository updates is listed more than once in the configuration<br>Repository extras is listed more than once in the configuration<br>Repository centosplus is listed more than once in the configuration<br>Repository epel is listed more than once in the configuration<br>Repository epel-debuginfo is listed more than once in the configuration<br>Repository epel-source is listed more than once in the configuration<br>Determining fastest mirrors<br>base                                                                                   | 3.6 kB  00:00:00<br>epel                                                                                   | 4.7 kB  00:00:00<br>extras                                                                                 | 3.4 kB  00:00:00<br>updates                                                                                | 3.4 kB  00:00:00<br>(1&#x2F;18): base&#x2F;7&#x2F;x86_64&#x2F;group_gz                                                         | 166 kB  00:00:00<br>(2&#x2F;18): base&#x2F;7&#x2F;x86_64&#x2F;primary_db                                                       | 5.9 MB  00:00:01<br>(3&#x2F;18): base&#x2F;7&#x2F;x86_64&#x2F;other_db                                                         | 2.5 MB  00:00:00<br>(4&#x2F;18): epel&#x2F;x86_64&#x2F;group_gz                                                           |  88 kB  00:00:01<br>(5&#x2F;18): epel&#x2F;x86_64&#x2F;updateinfo                                                         | 923 kB  00:00:00<br>(6&#x2F;18): epel&#x2F;x86_64&#x2F;prestodelta                                                        | 2.8 kB  00:00:00<br>(7&#x2F;18): epel&#x2F;x86_64&#x2F;primary_db                                                         | 6.4 MB  00:00:02<br>(8&#x2F;18): epel&#x2F;x86_64&#x2F;filelists_db                                                       |  10 MB  00:00:03<br>(9&#x2F;18): extras&#x2F;7&#x2F;x86_64&#x2F;filelists_db                                                   | 517 kB  00:00:00<br>(10&#x2F;18): extras&#x2F;7&#x2F;x86_64&#x2F;primary_db                                                    | 143 kB  00:00:00<br>(11&#x2F;18): extras&#x2F;7&#x2F;x86_64&#x2F;other_db                                                      |  91 kB  00:00:00<br>(12&#x2F;18): extras&#x2F;7&#x2F;x86_64&#x2F;prestodelta                                                   |  47 kB  00:00:00<br>(13&#x2F;18): updates&#x2F;7&#x2F;x86_64&#x2F;prestodelta                                                  | 180 kB  00:00:00<br>(14&#x2F;18): updates&#x2F;7&#x2F;x86_64&#x2F;primary_db                                                   | 1.2 MB  00:00:00<br>(15&#x2F;18): updates&#x2F;7&#x2F;x86_64&#x2F;other_db                                                     | 201 kB  00:00:00<br>(16&#x2F;18): epel&#x2F;x86_64&#x2F;other_db                                                          | 3.1 MB  00:00:01<br>(17&#x2F;18): updates&#x2F;7&#x2F;x86_64&#x2F;filelists_db                                                 | 875 kB  00:00:00<br>(18&#x2F;18): base&#x2F;7&#x2F;x86_64&#x2F;filelists_db                                                    | 6.9 MB  00:00:09<br>Metadata Cache Created<br>3.7.3 查看系统可用的yum源和所有的yum源</p>
<p>[root@centos7 yum.repos.d]# yum repolist enabled<br>Loaded plugins: fastestmirror<br>Repository base is listed more than once in the configuration<br>Repository updates is listed more than once in the configuration<br>Repository extras is listed more than once in the configuration<br>Repository centosplus is listed more than once in the configuration<br>Repository epel is listed more than once in the configuration<br>Repository epel-debuginfo is listed more than once in the configuration<br>Repository epel-source is listed more than once in the configuration<br>Loading mirror speeds from cached hostfile<br>repo id                              repo name                                                          status<br>base&#x2F;7&#x2F;x86_64                        CentOS-7 - Base - 163.com                                           9,911<br>epel&#x2F;x86_64                          Extra Packages for Enterprise Linux 7 - x86_64                     12,542<br>extras&#x2F;7&#x2F;x86_64                      CentOS-7 - Extras - 163.com                                           291<br>updates&#x2F;7&#x2F;x86_64                     CentOS-7 - Updates - 163.com                                          539<br>repolist: 23,283<br>[root@centos7 yum.repos.d]#<br>[root@centos7 yum.repos.d]# yum repolist all<br>Loaded plugins: fastestmirror<br>Repository base is listed more than once in the configuration<br>Repository updates is listed more than once in the configuration<br>Repository extras is listed more than once in the configuration<br>Repository centosplus is listed more than once in the configuration<br>Repository epel is listed more than once in the configuration<br>Repository epel-debuginfo is listed more than once in the configuration<br>Repository epel-source is listed more than once in the configuration<br>Loading mirror speeds from cached hostfile<br>repo id                       repo name                                                        status<br>base&#x2F;7&#x2F;x86_64                 CentOS-7 - Base - 163.com                                        enabled:  9,911<br>centosplus&#x2F;7&#x2F;x86_64           CentOS-7 - Plus - 163.com                                        disabled<br>contrib&#x2F;7&#x2F;x86_64              CentOS-7 - Contrib - mirrors.aliyun.com                          disabled<br>epel&#x2F;x86_64                   Extra Packages for Enterprise Linux 7 - x86_64                   enabled: 12,542<br>epel-debuginfo&#x2F;x86_64         Extra Packages for Enterprise Linux 7 - x86_64 - Debug           disabled<br>epel-source                   Extra Packages for Enterprise Linux 7 - x86_64 - Source          disabled<br>epel-testing&#x2F;x86_64           Extra Packages for Enterprise Linux 7 - Testing - x86_64         disabled<br>epel-testing-debuginfo&#x2F;x86_64 Extra Packages for Enterprise Linux 7 - Testing - x86_64 - Debug disabled<br>epel-testing-source&#x2F;x86_64    Extra Packages for Enterprise Linux 7 - Testing - x86_64 - Sourc disabled<br>extras&#x2F;7&#x2F;x86_64               CentOS-7 - Extras - 163.com                                      enabled:    291<br>updates&#x2F;7&#x2F;x86_64              CentOS-7 - Updates - 163.com                                     enabled:    539<br>repolist: 23,283<br>3.8 修改hostname主机名</p>
<p>3.8.1 hostnamectl</p>
<p>[root@localhost ~]# hostnamectl<br>   Static hostname: localhost.localdomain<br>         Icon name: computer-vm<br>           Chassis: vm<br>        Machine ID: 8dbe281bfa3d4b3c9390c26f494db334<br>           Boot ID: b629ca855d3e4406ab886fe709d2f917<br>    Virtualization: vmware<br>  Operating System: CentOS Linux 7 (Core)<br>       CPE OS Name: cpe:&#x2F;o:centos:centos:7<br>            Kernel: Linux 3.10.0-514.el7.x86_64<br>      Architecture: x86-64<br>[root@localhost ~]# hostnamectl set-hostname CentOS<br>[root@localhost ~]# hostnamectl<br>   Static hostname: centos<br>   Pretty hostname: CentOS<br>         Icon name: computer-vm<br>           Chassis: vm<br>        Machine ID: 8dbe281bfa3d4b3c9390c26f494db334<br>           Boot ID: b629ca855d3e4406ab886fe709d2f917<br>    Virtualization: vmware<br>  Operating System: CentOS Linux 7 (Core)<br>       CPE OS Name: cpe:&#x2F;o:centos:centos:7<br>            Kernel: Linux 3.10.0-514.el7.x86_64<br>      Architecture: x86-64<br>[root@localhost ~]# hostname<br>centos<br>3.8.2 修改主机名文件</p>
<p>[root@localhost ~]# vi &#x2F;etc&#x2F;hostname</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式.md</title>
    <url>/2021/08/30/she-ji-mo-shi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="1-接口是什么？为什么要使用接口而不是直接使用具体类？"><a href="#1-接口是什么？为什么要使用接口而不是直接使用具体类？" class="headerlink" title="1.接口是什么？为什么要使用接口而不是直接使用具体类？"></a>1.接口是什么？为什么要使用接口而不是直接使用具体类？</h4><p>接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许写代码，以此来保证抽象，但是 Java 8 中你可以在接口声明静态的默认方法，这种方法是具体的。</p>
<h4 id="2-设计模式六大原则？"><a href="#2-设计模式六大原则？" class="headerlink" title="2.设计模式六大原则？"></a>2.设计模式六大原则？</h4><p>1、开闭原则（Open Close Principle）</p>
<p>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p>2、里氏代换原则（Liskov Substitution Principle）</p>
<p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p>
<p>3、依赖倒转原则（Dependence Inversion Principle）</p>
<p>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p>
<p>4、接口隔离原则（Interface Segregation Principle）</p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p>
<p>5、迪米特法则（最少知道原则）（Demeter Principle）</p>
<p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p>6、合成复用原则（Composite Reuse Principle）</p>
<p>原则是尽量使用合成&#x2F;聚合的方式，而不是使用继承</p>
<h4 id="3-Java怎么实现单例模式？"><a href="#3-Java怎么实现单例模式？" class="headerlink" title="3.Java怎么实现单例模式？"></a>3.Java怎么实现单例模式？</h4><ul>
<li>懒汉式：懒加载，线程不安全</li>
</ul>
<pre><code class="prettyprint">public class Singleton
&#123;
    private static Singleton singleton;

    private Singleton()
    &#123;
    &#125;

    public static Singleton getInstance()
    &#123;
        if (singleton == null)
            singleton = new Singleton();
        return singleton;
    &#125;
&#125;
</code></pre>
<ul>
<li>懒汉式线程安全版：同步效率低</li>
</ul>
<pre><code class="prettyprint">public class Singleton
&#123;
    private static Singleton singleton;

    private Singleton()
    &#123;
    &#125;

    public synchronized static Singleton getInstance()
    &#123;
        if (singleton == null)
            singleton = new Singleton();
        return singleton;
    &#125;
&#125;
</code></pre>
<ul>
<li>饿汉式：</li>
</ul>
<pre><code class="prettyprint">public class Singleton
&#123;
    private static Singleton singleton = new Singleton();

    private Singleton()
    &#123;
    &#125;

    public static Singleton getInstance()
    &#123;
        return singleton;
    &#125;
&#125;
</code></pre>
<ul>
<li>饿汉式变种：</li>
</ul>
<pre><code class="prettyprint">public class Singleton
&#123;
    private static Singleton singleton;
    static
    &#123;
        singleton = new Singleton();
    &#125;

    private Singleton()
    &#123;
    &#125;

    public static Singleton getInstance()
    &#123;
        return singleton;
    &#125;
&#125;
</code></pre>
<ul>
<li>静态内部类方式:利用 JVM 的加载机制，当使用到 SingletonHolder 才会进行初始化。</li>
</ul>
<pre><code class="prettyprint">public class Singleton
&#123;
    private Singleton()
    &#123;
    &#125;

    private static class SingletonHolder
    &#123;
        private static final Singleton singleton = new Singleton();
    &#125;

    public static Singleton getInstance()
    &#123;
        return SingletonHolder.singleton;
    &#125;
&#125;
</code></pre>
<ul>
<li>枚举：</li>
</ul>
<pre><code class="prettyprint">public enum Singletons
&#123;
    INSTANCE;
    // 此处表示单例对象里面的各种方法
    public void Method()
    &#123;
    &#125;
&#125;
</code></pre>
<ul>
<li>双重校验锁:</li>
</ul>
<pre><code class="prettyprint">public class Singleton
&#123;
    private volatile static Singleton singleton;

    private Singleton()
    &#123;
    &#125;

    public static Singleton getInstance()
    &#123;
        if (singleton == null)
        &#123;
            synchronized (Singleton.class)
            &#123;
                if (singleton == null)
                &#123;
                    singleton = new Singleton();
                &#125;
            &#125;
        &#125;
        return singleton;
    &#125;
&#125;
</code></pre>
<h4 id="4-什么是代理模式？什么是动态代理？Java中动态代理有哪些实现方式？"><a href="#4-什么是代理模式？什么是动态代理？Java中动态代理有哪些实现方式？" class="headerlink" title="4.什么是代理模式？什么是动态代理？Java中动态代理有哪些实现方式？"></a>4.什么是代理模式？什么是动态代理？Java中动态代理有哪些实现方式？</h4><p>详见：<a href="https://www.cnblogs.com/qlqwjy/p/7550609.html">https://www.cnblogs.com/qlqwjy/p/7550609.html</a></p>
<h4 id="5-设计模式的类型"><a href="#5-设计模式的类型" class="headerlink" title="5.设计模式的类型"></a>5.设计模式的类型</h4><p>根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">模式 &amp; 描述</th>
<th align="left">包括</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td>
<td align="left">工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern）</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">结构型模式 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>
<td align="left">适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern）</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">行为型模式 这些设计模式特别关注对象之间的通信。</td>
<td align="left">责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern）</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">J2EE 模式 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td>
<td align="left">MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern）</td>
</tr>
</tbody></table>
<h4 id="6-说说你所熟悉或听说过的-j2ee-中的几种常用模式"><a href="#6-说说你所熟悉或听说过的-j2ee-中的几种常用模式" class="headerlink" title="6.说说你所熟悉或听说过的 j2ee 中的几种常用模式?"></a>6.说说你所熟悉或听说过的 j2ee 中的几种常用模式?</h4><p>IO 流的装饰器模式，Web 过滤器的责任链模式，Spring 的单例模式和工厂模式，<br>Spring 中根据不同配置方式进行初始化的策略模式</p>
<h4 id="7-简述一下你了解的-Java-设计模式（总结）"><a href="#7-简述一下你了解的-Java-设计模式（总结）" class="headerlink" title="7.简述一下你了解的 Java 设计模式（总结）"></a>7.简述一下你了解的 Java 设计模式（总结）</h4><p>标星号的为常用设计模式</p>
<pre><code>★单例模式：保证某个类只能有一个唯一实例，并提供一个全局的访问点。
★简单工厂：一个工厂类根据传入的参数决定创建出那一种产品类的实例。
工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。
抽象工厂：创建一组相关或依赖对象族，比如创建一组配套的汉堡可乐鸡翅。
★建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造，最后再build。
★原型模式：通过复制现有的实例来创建新的实例，减少创建对象成本（字段需要复杂计算或者创建成本高）。
 
★适配器模式：将一个类的方法接口转换成我们希望的另外一个接口。
★组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。（无限层级的知识点树）
★装饰模式：动态的给对象添加新的功能。
★代理模式：为对象提供一个代理以增强对象内的方法。
亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象（Integer中的少量缓存）。
★外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。
桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化（比如插座和充电器，他们之间相插是固定的，
但是至于插座是插在220V还是110V，充电器是充手机还是pad可以自主选择）。
 
★模板方法模式：定义一个算法步骤，每个小步骤由子类各自实现。
解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。
★策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。
★状态模式：允许一个对象根据其内部状态改变而改变它的行为。
★观察者模式：被观测的对象发生改变时通知它的所有观察者。
备忘录模式：保存一个对象的某个状态，以便在适当的时候恢复对象。
中介者模式：许多对象利用中介者来进行交互，将网状的对象关系变为星状的（最少知识原则）。
命令模式：将命令请求封装为一个对象，可用于操作的撤销或重做。
访问者模式：某种物体的使用方式是不一样的，将不同的使用方式交给访问者，而不是给这个物体。（例如对铜的使用，造币厂
造硬币。雕刻厂造铜像，不应该把造硬币和造铜像的功能交给铜自己实现，这样才能解耦）
★责任链模式：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，
并且沿着这条链传递请求，直到有对象处理它为止。
迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。
</code></pre>
<h4 id="8-适配器模式是什么？什么时候使用？"><a href="#8-适配器模式是什么？什么时候使用？" class="headerlink" title="8.适配器模式是什么？什么时候使用？"></a>8.适配器模式是什么？什么时候使用？</h4><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。适配器模式提供对接口的转换。如果你的客户端使用某些接口，但是你有另外一些接口，你就可以写一个适配去来连接这些接口。</p>
<h4 id="9-适配器模式与装饰器模式有什么区别？"><a href="#9-适配器模式与装饰器模式有什么区别？" class="headerlink" title="9.适配器模式与装饰器模式有什么区别？"></a>9.适配器模式与装饰器模式有什么区别？</h4><p>虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。</p>
<p>装饰者模式：动态地将责任附加到对象上，若要扩展功能，装饰者模提供了比继承更有弹性的替代方案。<br>通俗的解释：装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。</p>
<p>适配器模式：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。<br>适配器模式有三种：类的适配器模式、对象的适配器模式、接口的适配器模式。<br>通俗的说法：适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。</p>
<p>举例如下：</p>
<p>1、适配器模式 </p>
<pre><code class="prettyprint">//file 为已定义好的文件流 
FileInputStream fileInput = new FileInputStream(file); 
InputStreamReader inputStreamReader = new InputStreamReader(fileInput);
</code></pre>
<p>以上就是适配器模式的体现，FileInputStream是字节流，而并没有字符流读取字符的一些api，因此通过InputStreamReader将其转为Reader子类，因此有了可以操作文本的文件方法。 </p>
<p>2、装饰者模式</p>
<p>BufferedReader bufferedReader&#x3D;new BufferedReader(inputStreamReader);构造了缓冲字符流，将FileInputStream字节流包装为BufferedReader过程就是装饰的过程，刚开始的字节流FileInputStream只有read一个字节的方法，包装为inputStreamReader后，就有了读取一个字符的功能，在包装为BufferedReader后，就拥有了read一行字符的功能。</p>
<h4 id="10-适配器模式和代理模式之间有什么不同？"><a href="#10-适配器模式和代理模式之间有什么不同？" class="headerlink" title="10.适配器模式和代理模式之间有什么不同？"></a>10.适配器模式和代理模式之间有什么不同？</h4><p>这个问题与前面的类似，适配器模式和代理模式的区别在于他们的意图不同。由于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。</p>
<h4 id="11-什么是模板方法模式？试举例说明。"><a href="#11-什么是模板方法模式？试举例说明。" class="headerlink" title="11.什么是模板方法模式？试举例说明。"></a>11.什么是模板方法模式？试举例说明。</h4><p>详见：<a href="https://www.cnblogs.com/adamjwh/p/10919149.html">https://www.cnblogs.com/adamjwh/p/10919149.html</a></p>
<h4 id="12-OOP中的组合、聚合和关联有什么区别？"><a href="#12-OOP中的组合、聚合和关联有什么区别？" class="headerlink" title="12.OOP中的组合、聚合和关联有什么区别？"></a>12.OOP中的组合、聚合和关联有什么区别？</h4><p>如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。</p>
<h4 id="13-给我一个符合开闭原则的设计模式的例子？"><a href="#13-给我一个符合开闭原则的设计模式的例子？" class="headerlink" title="13.给我一个符合开闭原则的设计模式的例子？"></a>13.给我一个符合开闭原则的设计模式的例子？</h4><p>开闭原则要求你的代码对扩展开放，对修改关闭。这个意思就是说，如果你想增加一个新的功能，你可以很容易的在不改变已测试过的代码的前提下增加新的代码。有好几个设计模式是基于开闭原则的，如策略模式，如果你需要一个新的策略，只需要实现接口，增加配置，不需要改变核心逻辑。一个正在工作的例子是 Collections.sort() 方法，这就是基于策略模式，遵循开闭原则的，你不需为新的对象修改 sort() 方法，你需要做的仅仅是实现你自己的 Comparator 接口。</p>
<h4 id="14-工厂模式与抽象工厂模式的区别？"><a href="#14-工厂模式与抽象工厂模式的区别？" class="headerlink" title="14.工厂模式与抽象工厂模式的区别？"></a>14.工厂模式与抽象工厂模式的区别？</h4><p>首先来看看这两者的定义区别：</p>
<p>工厂模式：定义一个用于创建对象的借口，让子类决定实例化哪一个类</p>
<p>抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类</p>
<p>​    个人觉得这个区别在于产品，如果产品单一，最合适用工厂模式，但是如果有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。再通俗深化理解下：工厂模式针对的是一个产品等级结构 ，抽象工厂模式针对的是面向多个产品等级结构的。</p>
<p>再来看看工厂方法模式与抽象工厂模式对比：</p>
<table>
<thead>
<tr>
<th>工厂方法模式</th>
<th>抽象工厂模式</th>
</tr>
</thead>
<tbody><tr>
<td>针对的是一个产品等级结构</td>
<td>针对的是面向多个产品等级结构</td>
</tr>
<tr>
<td>一个抽象产品类</td>
<td>多个抽象产品类</td>
</tr>
<tr>
<td>可以派生出多个具体产品类</td>
<td>每个抽象产品类可以派生出多个具体产品类</td>
</tr>
<tr>
<td>一个抽象工厂类，可以派生出多个具体工厂类</td>
<td>一个抽象工厂类，可以派生出多个具体工厂类</td>
</tr>
<tr>
<td>每个具体工厂类只能创建一个具体产品类的实例</td>
<td>每个具体工厂类可以创建多个具体产品类的实例</td>
</tr>
</tbody></table>
<h4 id="15-举出一个例子，在这种情况你会更倾向于使用抽象类，而不是接口？"><a href="#15-举出一个例子，在这种情况你会更倾向于使用抽象类，而不是接口？" class="headerlink" title="15.举出一个例子，在这种情况你会更倾向于使用抽象类，而不是接口？"></a>15.举出一个例子，在这种情况你会更倾向于使用抽象类，而不是接口？</h4><p>这是很常用但又是很难回答的设计面试问题。接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求。下面有几个点可以帮助你回答这个问题：</p>
<ol>
<li>在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。</li>
<li>如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。</li>
</ol>
<h4 id="16-Dubbo-源码使用了哪些设计模式？"><a href="#16-Dubbo-源码使用了哪些设计模式？" class="headerlink" title="16.Dubbo 源码使用了哪些设计模式？"></a>16.Dubbo 源码使用了哪些设计模式？</h4><p>责任链模式：责任链中的每个节点实现 Filter 接口，然后由 ProtocolFilterWrapper，将所有 Filter 串连起来。<br> Dubbo 的许多功能都是通过 Filter 扩展实现的，比如监控、日志、缓存、安全、telnet 以及 RPC 本身都是。</p>
<p>观察者模式：消费者在初始化的时候回调用 subscribe 方法，注册一个观察者，如果观察者引用的服务地址列表发生改变，<br> 就会通过 NotifyListener 通知消费者。</p>
<p>装饰器模式：比如 ProtocolFilterWrapper 类是对 Protocol 类的修饰。</p>
<p>工厂模式：如 ExtenstionLoader.getExtenstionLoader(Protocol.class).getAdaptiveExtenstion()。</p>
<h4 id="17-Spring-当中用到了哪些设计模式？"><a href="#17-Spring-当中用到了哪些设计模式？" class="headerlink" title="17.Spring 当中用到了哪些设计模式？"></a>17.Spring 当中用到了哪些设计模式？</h4><p>模板方法模式：例如 jdbcTemplate，通过封装固定的数据库访问比如获取 connection、获取 statement，关闭 connection、关闭 statement 等<br> 然后将特殊的 sql 操作交给用户自己实现。</p>
<p>策略模式：Spring 在初始化对象的时候，可以选择单例或者原型模式。</p>
<p>简单工厂：Spring 中的 BeanFactory 就是简单工厂模式的体现，根据传入一个唯一的标识来获得 bean 对象。</p>
<p>工厂方法模式：一般情况下,应用程序有自己的工厂对象来创建 bean.如果将应用程序自己的工厂对象交给 Spring 管理, 那么 Spring 管理的就不是普通的 bean,而是工厂 Bean。</p>
<p>单例模式：保证全局只有唯一一个对象。</p>
<p>适配器模式：SpringAOP 的 Advice 有如下：BeforeAdvice、AfterAdvice、AfterAdvice，而需要将这些增强转为 aop 框架所需的<br> 对应的拦截器 MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptor。</p>
<p>代理模式：Spring 的 Proxy 模式在 aop 中有体现，比如 JdkDynamicAopProxy 和 Cglib2AopProxy。</p>
<p>装饰者模式：如 HttpServletRequestWrapper，自定义请求包装器包装请求，将字符编码转换的工作添加到 getParameter()方法中。</p>
<p>观察者模式：如启动初始化 Spring 时的 ApplicationListener 监听器。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.cnblogs.com/study-makes-me-happy/p/7839052.html">https://www.cnblogs.com/study-makes-me-happy/p/7839052.html</a></p>
<p><a href="https://ld246.com/article/1583476977456">https://ld246.com/article/1583476977456</a></p>
<p><a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</a></p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/">https://creativecommons.org/licenses/by-sa/4.0/</a></p>
]]></content>
  </entry>
  <entry>
    <title>防火墙命令</title>
    <url>/2021/11/13/fang-huo-qiang-ming-ling/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>查看防火墙状态：firewall-cmd –state<br>查看防火墙：firewall-cmd –list-all<br>更新防火墙：firewall-cmd  –reload<br>临时增加 (reload之后消失)：不需要reload<br>firewall-cmd –add-port&#x3D;999&#x2F;tcp<br>永久增加 ：reload后生效<br>firewall-cmd  –permanent –add-port&#x3D;999&#x2F;tcp<br>firewall-cmd  –reload<br>移除端口<br>firewall-cmd –remove-port&#x3D;999&#x2F;tcp</p>
<p>firewall-cmd  –permanent –remove-port&#x3D;999&#x2F;tcp<br>firewall-cmd  –reload<br>查询端口<br>firewall-cmd –query-port&#x3D;999&#x2F;tcp<br>查看所有放行端口<br>firewall-cmd –list-ports<br>防火墙服务的状态：<br>systemctl status firewalld.service<br>systemctl start firewalld.service<br>systemctl stop firewalld.service<br>所有支持的服务<br>firewall-cmd –get-services<br>临时增加服务<br>firewall-cmd –add-service&#x3D;http<br>删除服务： (临时删除)<br>firewall-cmd –remove-service&#x3D;http<br>查询服务：<br>firewall-cmd –query-service&#x3D;http</p>
<pre><code class="prettyprint">Usage: firewall-cmd [OPTIONS...]

General Options
  -h, --help           Prints a short help text and exists
  -V, --version        Print the version string of firewalld
  -q, --quiet          Do not print status messages

Status Options
  --state              Return and print firewalld state
  --reload             Reload firewall and keep state information
  --complete-reload    Reload firewall and lose state information
  --runtime-to-permanent
                       Create permanent from runtime configuration

Log Denied Options
  --get-log-denied     Print the log denied value
  --set-log-denied=&lt;value&gt;
                       Set log denied value

Automatic Helpers Options
  --get-automatic-helpers
                       Print the automatic helpers value
  --set-automatic-helpers=&lt;value&gt;
                       Set automatic helpers value

Permanent Options
  --permanent          Set an option permanently
                       Usable for options marked with [P]

Zone Options
  --get-default-zone   Print default zone for connections and interfaces
  --set-default-zone=&lt;zone&gt;
                       Set default zone
  --get-active-zones   Print currently active zones
  --get-zones          Print predefined zones [P]
  --get-services       Print predefined services [P]
  --get-icmptypes      Print predefined icmptypes [P]
  --get-zone-of-interface=&lt;interface&gt;
                       Print name of the zone the interface is bound to [P]
  --get-zone-of-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;
                       Print name of the zone the source is bound to [P]
  --list-all-zones     List everything added for or enabled in all zones [P]
  --new-zone=&lt;zone&gt;    Add a new zone [P only]
  --new-zone-from-file=&lt;filename&gt; [--name=&lt;zone&gt;]
                       Add a new zone from file with optional name [P only]
  --delete-zone=&lt;zone&gt; Delete an existing zone [P only]
  --load-zone-defaults=&lt;zone&gt;
                       Load zone default settings [P only] [Z]
  --zone=&lt;zone&gt;        Use this zone to set or query options, else default zone
                       Usable for options marked with [Z]
  --get-target         Get the zone target [P only] [Z]
  --set-target=&lt;target&gt;
                       Set the zone target [P only] [Z]
  --info-zone=&lt;zone&gt;   Print information about a zone
  --path-zone=&lt;zone&gt;   Print file path of a zone [P only]

IPSet Options
  --get-ipset-types    Print the supported ipset types
  --new-ipset=&lt;ipset&gt; --type=&lt;ipset type&gt; [--option=&lt;key&gt;[=&lt;value&gt;]]..
                       Add a new ipset [P only]
  --new-ipset-from-file=&lt;filename&gt; [--name=&lt;ipset&gt;]
                       Add a new ipset from file with optional name [P only]
  --delete-ipset=&lt;ipset&gt;
                       Delete an existing ipset [P only]
  --load-ipset-defaults=&lt;ipset&gt;
                       Load ipset default settings [P only]
  --info-ipset=&lt;ipset&gt; Print information about an ipset
  --path-ipset=&lt;ipset&gt; Print file path of an ipset [P only]
  --get-ipsets         Print predefined ipsets
  --ipset=&lt;ipset&gt; --set-description=&lt;description&gt;
                       Set new description to ipset [P only]
  --ipset=&lt;ipset&gt; --get-description
                       Print description for ipset [P only]
  --ipset=&lt;ipset&gt; --set-short=&lt;description&gt;
                       Set new short description to ipset [P only]
  --ipset=&lt;ipset&gt; --get-short
                       Print short description for ipset [P only]
  --ipset=&lt;ipset&gt; --add-entry=&lt;entry&gt;
                       Add a new entry to an ipset [P]
  --ipset=&lt;ipset&gt; --remove-entry=&lt;entry&gt;
                       Remove an entry from an ipset [P]
  --ipset=&lt;ipset&gt; --query-entry=&lt;entry&gt;
                       Return whether ipset has an entry [P]
  --ipset=&lt;ipset&gt; --get-entries
                       List entries of an ipset [P]
  --ipset=&lt;ipset&gt; --add-entries-from-file=&lt;entry&gt;
                       Add a new entries to an ipset [P]
  --ipset=&lt;ipset&gt; --remove-entries-from-file=&lt;entry&gt;
                       Remove entries from an ipset [P]

IcmpType Options
  --new-icmptype=&lt;icmptype&gt;
                       Add a new icmptype [P only]
  --new-icmptype-from-file=&lt;filename&gt; [--name=&lt;icmptype&gt;]
                       Add a new icmptype from file with optional name [P only]
  --delete-icmptype=&lt;icmptype&gt;
                       Delete an existing icmptype [P only]
  --load-icmptype-defaults=&lt;icmptype&gt;
                       Load icmptype default settings [P only]
  --info-icmptype=&lt;icmptype&gt;
                       Print information about an icmptype
  --path-icmptype=&lt;icmptype&gt;
                       Print file path of an icmptype [P only]
  --icmptype=&lt;icmptype&gt; --set-description=&lt;description&gt;
                       Set new description to icmptype [P only]
  --icmptype=&lt;icmptype&gt; --get-description
                       Print description for icmptype [P only]
  --icmptype=&lt;icmptype&gt; --set-short=&lt;description&gt;
                       Set new short description to icmptype [P only]
  --icmptype=&lt;icmptype&gt; --get-short
                       Print short description for icmptype [P only]
  --icmptype=&lt;icmptype&gt; --add-destination=&lt;ipv&gt;
                       Enable destination for ipv in icmptype [P only]
  --icmptype=&lt;icmptype&gt; --remove-destination=&lt;ipv&gt;
                       Disable destination for ipv in icmptype [P only]
  --icmptype=&lt;icmptype&gt; --query-destination=&lt;ipv&gt;
                       Return whether destination ipv is enabled in icmptype [P only]
  --icmptype=&lt;icmptype&gt; --get-destinations
                       List destinations in icmptype [P only]

Service Options
  --new-service=&lt;service&gt;
                       Add a new service [P only]
  --new-service-from-file=&lt;filename&gt; [--name=&lt;service&gt;]
                       Add a new service from file with optional name [P only]
  --delete-service=&lt;service&gt;
                       Delete an existing service [P only]
  --load-service-defaults=&lt;service&gt;
                       Load icmptype default settings [P only]
  --info-service=&lt;service&gt;
                       Print information about a service
  --path-service=&lt;service&gt;
                       Print file path of a service [P only]
  --service=&lt;service&gt; --set-description=&lt;description&gt;
                       Set new description to service [P only]
  --service=&lt;service&gt; --get-description
                       Print description for service [P only]
  --service=&lt;service&gt; --set-short=&lt;description&gt;
                       Set new short description to service [P only]
  --service=&lt;service&gt; --get-short
                       Print short description for service [P only]
  --service=&lt;service&gt; --add-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Add a new port to service [P only]
  --service=&lt;service&gt; --remove-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Remove a port from service [P only]
  --service=&lt;service&gt; --query-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Return whether the port has been added for service [P only]
  --service=&lt;service&gt; --get-ports
                       List ports of service [P only]
  --service=&lt;service&gt; --add-protocol=&lt;protocol&gt;
                       Add a new protocol to service [P only]
  --service=&lt;service&gt; --remove-protocol=&lt;protocol&gt;
                       Remove a protocol from service [P only]
  --service=&lt;service&gt; --query-protocol=&lt;protocol&gt;
                       Return whether the protocol has been added for service [P only]
  --service=&lt;service&gt; --get-protocols
                       List protocols of service [P only]
  --service=&lt;service&gt; --add-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Add a new source port to service [P only]
  --service=&lt;service&gt; --remove-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Remove a source port from service [P only]
  --service=&lt;service&gt; --query-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Return whether the source port has been added for service [P only]
  --service=&lt;service&gt; --get-source-ports
                       List source ports of service [P only]
  --service=&lt;service&gt; --add-module=&lt;module&gt;
                       Add a new module to service [P only]
  --service=&lt;service&gt; --remove-module=&lt;module&gt;
                       Remove a module from service [P only]
  --service=&lt;service&gt; --query-module=&lt;module&gt;
                       Return whether the module has been added for service [P only]
  --service=&lt;service&gt; --get-modules
                       List modules of service [P only]
  --service=&lt;service&gt; --set-destination=&lt;ipv&gt;:&lt;address&gt;[/&lt;mask&gt;]
                       Set destination for ipv to address in service [P only]
  --service=&lt;service&gt; --remove-destination=&lt;ipv&gt;
                       Disable destination for ipv i service [P only]
  --service=&lt;service&gt; --query-destination=&lt;ipv&gt;:&lt;address&gt;[/&lt;mask&gt;]
                       Return whether destination ipv is set for service [P only]
  --service=&lt;service&gt; --get-destinations
                       List destinations in service [P only]

Options to Adapt and Query Zones
  --list-all           List everything added for or enabled in a zone [P] [Z]
  --list-services      List services added for a zone [P] [Z]
  --timeout=&lt;timeval&gt;  Enable an option for timeval time, where timeval is
                       a number followed by one of letters &#39;s&#39; or &#39;m&#39; or &#39;h&#39;
                       Usable for options marked with [T]
  --set-description=&lt;description&gt;
                       Set new description to zone [P only] [Z]
  --get-description    Print description for zone [P only] [Z]
  --set-short=&lt;description&gt;
                       Set new short description to zone [P only] [Z]
  --get-short          Print short description for zone [P only] [Z]
  --add-service=&lt;service&gt;
                       Add a service for a zone [P] [Z] [T]
  --remove-service=&lt;service&gt;
                       Remove a service from a zone [P] [Z]
  --query-service=&lt;service&gt;
                       Return whether service has been added for a zone [P] [Z]
  --list-ports         List ports added for a zone [P] [Z]
  --add-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Add the port for a zone [P] [Z] [T]
  --remove-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Remove the port from a zone [P] [Z]
  --query-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Return whether the port has been added for zone [P] [Z]
  --list-protocols     List protocols added for a zone [P] [Z]
  --add-protocol=&lt;protocol&gt;
                       Add the protocol for a zone [P] [Z] [T]
  --remove-protocol=&lt;protocol&gt;
                       Remove the protocol from a zone [P] [Z]
  --query-protocol=&lt;protocol&gt;
                       Return whether the protocol has been added for zone [P] [Z]
  --list-source-ports  List source ports added for a zone [P] [Z]
  --add-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Add the source port for a zone [P] [Z] [T]
  --remove-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Remove the source port from a zone [P] [Z]
  --query-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Return whether the source port has been added for zone [P] [Z]
  --list-icmp-blocks   List Internet ICMP type blocks added for a zone [P] [Z]
  --add-icmp-block=&lt;icmptype&gt;
                       Add an ICMP block for a zone [P] [Z] [T]
  --remove-icmp-block=&lt;icmptype&gt;
                       Remove the ICMP block from a zone [P] [Z]
  --query-icmp-block=&lt;icmptype&gt;
                       Return whether an ICMP block has been added for a zone
                       [P] [Z]
  --add-icmp-block-inversion
                       Enable inversion of icmp blocks for a zone [P] [Z]
  --remove-icmp-block-inversion
                       Disable inversion of icmp blocks for a zone [P] [Z]
  --query-icmp-block-inversion
                       Return whether inversion of icmp blocks has been enabled
                       for a zone [P] [Z]
  --list-forward-ports List IPv4 forward ports added for a zone [P] [Z]
  --add-forward-port=port=&lt;portid&gt;[-&lt;portid&gt;]:proto=&lt;protocol&gt;[:toport=&lt;portid&gt;[-&lt;portid&gt;]][:toaddr=&lt;address&gt;[/&lt;mask&gt;]]
                       Add the IPv4 forward port for a zone [P] [Z] [T]
  --remove-forward-port=port=&lt;portid&gt;[-&lt;portid&gt;]:proto=&lt;protocol&gt;[:toport=&lt;portid&gt;[-&lt;portid&gt;]][:toaddr=&lt;address&gt;[/&lt;mask&gt;]]
                       Remove the IPv4 forward port from a zone [P] [Z]
  --query-forward-port=port=&lt;portid&gt;[-&lt;portid&gt;]:proto=&lt;protocol&gt;[:toport=&lt;portid&gt;[-&lt;portid&gt;]][:toaddr=&lt;address&gt;[/&lt;mask&gt;]]
                       Return whether the IPv4 forward port has been added for
                       a zone [P] [Z]
  --add-masquerade     Enable IPv4 masquerade for a zone [P] [Z] [T]
  --remove-masquerade  Disable IPv4 masquerade for a zone [P] [Z]
  --query-masquerade   Return whether IPv4 masquerading has been enabled for a
                       zone [P] [Z]
  --list-rich-rules    List rich language rules added for a zone [P] [Z]
  --add-rich-rule=&lt;rule&gt;
                       Add rich language rule &#39;rule&#39; for a zone [P] [Z] [T]
  --remove-rich-rule=&lt;rule&gt;
                       Remove rich language rule &#39;rule&#39; from a zone [P] [Z]
  --query-rich-rule=&lt;rule&gt;
                       Return whether a rich language rule &#39;rule&#39; has been
                       added for a zone [P] [Z]

Options to Handle Bindings of Interfaces
  --list-interfaces    List interfaces that are bound to a zone [P] [Z]
  --add-interface=&lt;interface&gt;
                       Bind the &lt;interface&gt; to a zone [P] [Z]
  --change-interface=&lt;interface&gt;
                       Change zone the &lt;interface&gt; is bound to [Z]
  --query-interface=&lt;interface&gt;
                       Query whether &lt;interface&gt; is bound to a zone [P] [Z]
  --remove-interface=&lt;interface&gt;
                       Remove binding of &lt;interface&gt; from a zone [P] [Z]

Options to Handle Bindings of Sources
  --list-sources       List sources that are bound to a zone [P] [Z]
  --add-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;
                       Bind the source to a zone [P] [Z]
  --change-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;
                       Change zone the source is bound to [Z]
  --query-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;
                       Query whether the source is bound to a zone [P] [Z]
  --remove-source=&lt;source&gt;[/&lt;mask&gt;]|&lt;MAC&gt;|ipset:&lt;ipset&gt;
                       Remove binding of the source from a zone [P] [Z]

Helper Options
  --new-helper=&lt;helper&gt; --module=&lt;module&gt; [--family=&lt;family&gt;]
                       Add a new helper [P only]
  --new-helper-from-file=&lt;filename&gt; [--name=&lt;helper&gt;]
                       Add a new helper from file with optional name [P only]
  --delete-helper=&lt;helper&gt;
                       Delete an existing helper [P only]
  --load-helper-defaults=&lt;helper&gt;
                       Load helper default settings [P only]
  --info-helper=&lt;helper&gt; Print information about an helper
  --path-helper=&lt;helper&gt; Print file path of an helper [P only]
  --get-helpers         Print predefined helpers
  --helper=&lt;helper&gt; --set-description=&lt;description&gt;
                       Set new description to helper [P only]
  --helper=&lt;helper&gt; --get-description
                       Print description for helper [P only]
  --helper=&lt;helper&gt; --set-short=&lt;description&gt;
                       Set new short description to helper [P only]
  --helper=&lt;helper&gt; --get-short
                       Print short description for helper [P only]
  --helper=&lt;helper&gt; --add-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Add a new port to helper [P only]
  --helper=&lt;helper&gt; --remove-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Remove a port from helper [P only]
  --helper=&lt;helper&gt; --query-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;
                       Return whether the port has been added for helper [P only]
  --helper=&lt;helper&gt; --get-ports
                       List ports of helper [P only]
  --helper=&lt;helper&gt; --set-module=&lt;module&gt;
                       Set module to helper [P only]
  --helper=&lt;helper&gt; --get-module
                       Get module from helper [P only]
  --helper=&lt;helper&gt; --set-family=&#123;ipv4|ipv6|&#125;
                       Set family for helper [P only]
  --helper=&lt;helper&gt; --get-family
                       Get module from helper [P only]

Direct Options
  --direct             First option for all direct options
  --get-all-chains
                       Get all chains [P]
  --get-chains &#123;ipv4|ipv6|eb&#125; &lt;table&gt;
                       Get all chains added to the table [P]
  --add-chain &#123;ipv4|ipv6|eb&#125; &lt;table&gt; &lt;chain&gt;
                       Add a new chain to the table [P]
  --remove-chain &#123;ipv4|ipv6|eb&#125; &lt;table&gt; &lt;chain&gt;
                       Remove the chain from the table [P]
  --query-chain &#123;ipv4|ipv6|eb&#125; &lt;table&gt; &lt;chain&gt;
                       Return whether the chain has been added to the table [P]
  --get-all-rules
                       Get all rules [P]
  --get-rules &#123;ipv4|ipv6|eb&#125; &lt;table&gt; &lt;chain&gt;
                       Get all rules added to chain in table [P]
  --add-rule &#123;ipv4|ipv6|eb&#125; &lt;table&gt; &lt;chain&gt; &lt;priority&gt; &lt;arg&gt;...
                       Add rule to chain in table [P]
  --remove-rule &#123;ipv4|ipv6|eb&#125; &lt;table&gt; &lt;chain&gt; &lt;priority&gt; &lt;arg&gt;...
                       Remove rule with priority from chain in table [P]
  --remove-rules &#123;ipv4|ipv6|eb&#125; &lt;table&gt; &lt;chain&gt;
                       Remove rules from chain in table [P]
  --query-rule &#123;ipv4|ipv6|eb&#125; &lt;table&gt; &lt;chain&gt; &lt;priority&gt; &lt;arg&gt;...
                       Return whether a rule with priority has been added to
                       chain in table [P]
  --passthrough &#123;ipv4|ipv6|eb&#125; &lt;arg&gt;...
                       Pass a command through (untracked by firewalld)
  --get-all-passthroughs
                       Get all tracked passthrough rules [P]
  --get-passthroughs &#123;ipv4|ipv6|eb&#125; &lt;arg&gt;...
                       Get tracked passthrough rules [P]
  --add-passthrough &#123;ipv4|ipv6|eb&#125; &lt;arg&gt;...
                       Add a new tracked passthrough rule [P]
  --remove-passthrough &#123;ipv4|ipv6|eb&#125; &lt;arg&gt;...
                       Remove a tracked passthrough rule [P]
  --query-passthrough &#123;ipv4|ipv6|eb&#125; &lt;arg&gt;...
                       Return whether the tracked passthrough rule has been
                       added [P]

Lockdown Options
  --lockdown-on        Enable lockdown.
  --lockdown-off       Disable lockdown.
  --query-lockdown     Query whether lockdown is enabled

Lockdown Whitelist Options
  --list-lockdown-whitelist-commands
                       List all command lines that are on the whitelist [P]
  --add-lockdown-whitelist-command=&lt;command&gt;
                       Add the command to the whitelist [P]
  --remove-lockdown-whitelist-command=&lt;command&gt;
                       Remove the command from the whitelist [P]
  --query-lockdown-whitelist-command=&lt;command&gt;
                       Query whether the command is on the whitelist [P]
  --list-lockdown-whitelist-contexts
                       List all contexts that are on the whitelist [P]
  --add-lockdown-whitelist-context=&lt;context&gt;
                       Add the context context to the whitelist [P]
  --remove-lockdown-whitelist-context=&lt;context&gt;
                       Remove the context from the whitelist [P]
  --query-lockdown-whitelist-context=&lt;context&gt;
                       Query whether the context is on the whitelist [P]
  --list-lockdown-whitelist-uids
                       List all user ids that are on the whitelist [P]
  --add-lockdown-whitelist-uid=&lt;uid&gt;
                       Add the user id uid to the whitelist [P]
  --remove-lockdown-whitelist-uid=&lt;uid&gt;
                       Remove the user id uid from the whitelist [P]
  --query-lockdown-whitelist-uid=&lt;uid&gt;
                       Query whether the user id uid is on the whitelist [P]
  --list-lockdown-whitelist-users
                       List all user names that are on the whitelist [P]
  --add-lockdown-whitelist-user=&lt;user&gt;
                       Add the user name user to the whitelist [P]
  --remove-lockdown-whitelist-user=&lt;user&gt;
                       Remove the user name user from the whitelist [P]
  --query-lockdown-whitelist-user=&lt;user&gt;
                       Query whether the user name user is on the whitelist [P]

Panic Options
  --panic-on           Enable panic mode
  --panic-off          Disable panic mode
  --query-panic        Query whether panic mode is enabled
</code></pre>
]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
  </entry>
  <entry>
    <title>加密算法之java实现SM4简单版</title>
    <url>/2022/04/18/jia-mi-suan-fa-zhi-java-shi-xian-sm4-jian-dan-ban/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>HexUtil</code>字节字符转换工具</p>
<pre><code class="prettyprint">public class HexUtil
&#123;
    private static final char[] DIGITS_LOWER = &#123; &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; &#125;;

    private static final char[] DIGITS_UPPER = &#123; &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39; &#125;;

    public static byte[] intToBytes(int num)
    &#123;
        byte[] bytes = new byte[4];
        bytes[0] = (byte)(0xFF &amp; num &gt;&gt; 0);
        bytes[1] = (byte)(0xFF &amp; num &gt;&gt; 8);
        bytes[2] = (byte)(0xFF &amp; num &gt;&gt; 16);
        bytes[3] = (byte)(0xFF &amp; num &gt;&gt; 24);
        return bytes;
    &#125;

    public static int byteToInt(byte[] bytes)
    &#123;
        int num = 0;

        int temp = (0xFF &amp; bytes[0]) &lt;&lt; 0;
        num |= temp;
        temp = (0xFF &amp; bytes[1]) &lt;&lt; 8;
        num |= temp;
        temp = (0xFF &amp; bytes[2]) &lt;&lt; 16;
        num |= temp;
        temp = (0xFF &amp; bytes[3]) &lt;&lt; 24;
        num |= temp;
        return num;
    &#125;

    public static byte[] longToBytes(long num)
    &#123;
        byte[] bytes = new byte[8];
        for (int i = 0; i &lt; 8; i++) &#123;
            bytes[i] = (byte)(int)(0xFF &amp; num &gt;&gt; i * 8);
        &#125;

        return bytes;
    &#125;

    public static byte[] byteConvert32Bytes(BigInteger n)
    &#123;
        byte[] tmpd = (byte[])null;
        if (n == null) &#123;
            return null;
        &#125;

        if (n.toByteArray().length == 33) &#123;
            tmpd = new byte[32];
            System.arraycopy(n.toByteArray(), 1, tmpd, 0, 32);
        &#125; else if (n.toByteArray().length == 32) &#123;
            tmpd = n.toByteArray();
        &#125; else &#123;
            tmpd = new byte[32];
            for (int i = 0; i &lt; 32 - n.toByteArray().length; i++) &#123;
                tmpd[i] = 0;
            &#125;
            System.arraycopy(n.toByteArray(), 0, tmpd, 32 - n.toByteArray().length, n.toByteArray().length);
        &#125;
        return tmpd;
    &#125;

    public static BigInteger byteConvertInteger(byte[] b)
    &#123;
        if (b[0] &lt; 0) &#123;
            byte[] temp = new byte[b.length + 1];
            temp[0] = 0;
            System.arraycopy(b, 0, temp, 1, b.length);
            return new BigInteger(temp);
        &#125;
        return new BigInteger(b);
    &#125;

    public static String getHexString(byte[] bytes)
    &#123;
        return getHexString(bytes, true);
    &#125;

    public static String getHexString(byte[] bytes, boolean upperCase)
    &#123;
        String ret = &quot;&quot;;
        for (int i = 0; i &lt; bytes.length; i++) &#123;
            ret = ret + Integer.toString((bytes[i] &amp; 0xFF) + 256, 16).substring(1);
        &#125;
        return upperCase ? ret.toUpperCase() : ret;
    &#125;

    public static void printHexString(byte[] bytes)
    &#123;
        for (int i = 0; i &lt; bytes.length; i++) &#123;
            String hex = Integer.toHexString(bytes[i] &amp; 0xFF);
            if (hex.length() == 1)
                hex = &#39;0&#39; + hex;
        &#125;
    &#125;

    public static byte[] hexStringToBytes(String hexString)
    &#123;
        if ((hexString == null) || (hexString.equals(&quot;&quot;))) &#123;
            return null;
        &#125;

        hexString = hexString.toUpperCase();
        int length = hexString.length() / 2;
        char[] hexChars = hexString.toCharArray();
        byte[] d = new byte[length];
        for (int i = 0; i &lt; length; i++) &#123;
            int pos = i * 2;
            d[i] = (byte)(charToByte(hexChars[pos]) &lt;&lt; 4 | charToByte(hexChars[(pos + 1)]));
        &#125;
        return d;
    &#125;

    public static byte charToByte(char c)
    &#123;
        return (byte)&quot;0123456789ABCDEF&quot;.indexOf(c);
    &#125;

    public static char[] encodeHex(byte[] data)
    &#123;
        return encodeHex(data, true);
    &#125;

    public static char[] encodeHex(byte[] data, boolean toLowerCase)
    &#123;
        return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);
    &#125;

    protected static char[] encodeHex(byte[] data, char[] toDigits)
    &#123;
        int l = data.length;
        char[] out = new char[l &lt;&lt; 1];

        int i = 0; for (int j = 0; i &lt; l; i++) &#123;
        out[(j++)] = toDigits[((0xF0 &amp; data[i]) &gt;&gt;&gt; 4)];
        out[(j++)] = toDigits[(0xF &amp; data[i])];
    &#125;
        return out;
    &#125;

    public static String encodeHexString(byte[] data)
    &#123;
        return encodeHexString(data, true);
    &#125;

    public static String encodeHexString(byte[] data, boolean toLowerCase)
    &#123;
        return encodeHexString(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);
    &#125;

    protected static String encodeHexString(byte[] data, char[] toDigits)
    &#123;
        return new String(encodeHex(data, toDigits));
    &#125;

    public static byte[] decodeHex(char[] data)
    &#123;
        int len = data.length;

        if ((len &amp; 0x1) != 0) &#123;
            throw new RuntimeException(&quot;Odd number of characters.&quot;);
        &#125;

        byte[] out = new byte[len &gt;&gt; 1];

        int i = 0; for (int j = 0; j &lt; len; i++) &#123;
        int f = toDigit(data[j], j) &lt;&lt; 4;
        j++;
        f |= toDigit(data[j], j);
        j++;
        out[i] = (byte)(f &amp; 0xFF);
    &#125;

        return out;
    &#125;

    protected static int toDigit(char ch, int index)
    &#123;
        int digit = Character.digit(ch, 16);
        if (digit == -1) &#123;
            throw new RuntimeException(&quot;Illegal hexadecimal character &quot; + ch + &quot; at index &quot; + index);
        &#125;

        return digit;
    &#125;

    public static String StringToAsciiString(String content)
    &#123;
        String result = &quot;&quot;;
        int max = content.length();
        for (int i = 0; i &lt; max; i++) &#123;
            char c = content.charAt(i);
            String b = Integer.toHexString(c);
            result = result + b;
        &#125;
        return result;
    &#125;

    public static String hexStringToString(String hexString, int encodeType)
    &#123;
        String result = &quot;&quot;;
        int max = hexString.length() / encodeType;
        for (int i = 0; i &lt; max; i++) &#123;
            char c = (char)hexStringToAlgorism(hexString.substring(i * encodeType, (i + 1) * encodeType));

            result = result + c;
        &#125;
        return result;
    &#125;

    public static int hexStringToAlgorism(String hex)
    &#123;
        hex = hex.toUpperCase();
        int max = hex.length();
        int result = 0;
        for (int i = max; i &gt; 0; i--) &#123;
            char c = hex.charAt(i - 1);
            int algorism = 0;
            if ((c &gt;= &#39;0&#39;) &amp;&amp; (c &lt;= &#39;9&#39;))
                algorism = c - &#39;0&#39;;
            else &#123;
                algorism = c - &#39;7&#39;;
            &#125;
            result = (int)(result + Math.pow(16.0D, max - i) * algorism);
        &#125;
        return result;
    &#125;

    public static String hexStringToBinary(String hex)
    &#123;
        hex = hex.toUpperCase();
        String result = &quot;&quot;;
        int max = hex.length();
        for (int i = 0; i &lt; max; i++) &#123;
            char c = hex.charAt(i);
            switch (c) &#123;
                case &#39;0&#39;:
                    result = result + &quot;0000&quot;;
                    break;
                case &#39;1&#39;:
                    result = result + &quot;0001&quot;;
                    break;
                case &#39;2&#39;:
                    result = result + &quot;0010&quot;;
                    break;
                case &#39;3&#39;:
                    result = result + &quot;0011&quot;;
                    break;
                case &#39;4&#39;:
                    result = result + &quot;0100&quot;;
                    break;
                case &#39;5&#39;:
                    result = result + &quot;0101&quot;;
                    break;
                case &#39;6&#39;:
                    result = result + &quot;0110&quot;;
                    break;
                case &#39;7&#39;:
                    result = result + &quot;0111&quot;;
                    break;
                case &#39;8&#39;:
                    result = result + &quot;1000&quot;;
                    break;
                case &#39;9&#39;:
                    result = result + &quot;1001&quot;;
                    break;
                case &#39;A&#39;:
                    result = result + &quot;1010&quot;;
                    break;
                case &#39;B&#39;:
                    result = result + &quot;1011&quot;;
                    break;
                case &#39;C&#39;:
                    result = result + &quot;1100&quot;;
                    break;
                case &#39;D&#39;:
                    result = result + &quot;1101&quot;;
                    break;
                case &#39;E&#39;:
                    result = result + &quot;1110&quot;;
                    break;
                case &#39;F&#39;:
                    result = result + &quot;1111&quot;;
                case &#39;:&#39;:
                case &#39;;&#39;:
                case &#39;&lt;&#39;:
                case &#39;=&#39;:
                case &#39;&gt;&#39;:
                case &#39;?&#39;:
                case &#39;@&#39;: &#125;  &#125; return result;
    &#125;

    public static String AsciiStringToString(String content)
    &#123;
        String result = &quot;&quot;;
        int length = content.length() / 2;
        for (int i = 0; i &lt; length; i++) &#123;
            String c = content.substring(i * 2, i * 2 + 2);
            int a = hexStringToAlgorism(c);
            char b = (char)a;
            String d = String.valueOf(b);
            result = result + d;
        &#125;
        return result;
    &#125;

    public static String algorismToHexString(int algorism, int maxLength)
    &#123;
        String result = &quot;&quot;;
        result = Integer.toHexString(algorism);

        if (result.length() % 2 == 1) &#123;
            result = &quot;0&quot; + result;
        &#125;
        return patchHexString(result.toUpperCase(), maxLength);
    &#125;

    public static String byteToString(byte[] bytearray)
    &#123;
        String result = &quot;&quot;;

        int length = bytearray.length;
        for (int i = 0; i &lt; length; i++) &#123;
            char temp = (char)bytearray[i];
            result = result + temp;
        &#125;
        return result;
    &#125;

    public static int binaryToAlgorism(String binary)
    &#123;
        int max = binary.length();
        int result = 0;
        for (int i = max; i &gt; 0; i--) &#123;
            char c = binary.charAt(i - 1);
            int algorism = c - &#39;0&#39;;
            result = (int)(result + Math.pow(2.0D, max - i) * algorism);
        &#125;
        return result;
    &#125;

    public static String algorismToHEXString(int algorism)
    &#123;
        String result = &quot;&quot;;
        result = Integer.toHexString(algorism);

        if (result.length() % 2 == 1) &#123;
            result = &quot;0&quot; + result;
        &#125;

        result = result.toUpperCase();

        return result;
    &#125;

    public static String patchHexString(String str, int maxLength)
    &#123;
        String temp = &quot;&quot;;
        for (int i = 0; i &lt; maxLength - str.length(); i++) &#123;
            temp = &quot;0&quot; + temp;
        &#125;
        str = (temp + str).substring(0, maxLength);
        return str;
    &#125;

    public static int parseToInt(String s, int defaultInt, int radix)
    &#123;
        int i = 0;
        try &#123;
            i = Integer.parseInt(s, radix);
        &#125; catch (NumberFormatException ex) &#123;
            i = defaultInt;
        &#125;
        return i;
    &#125;

    public static int parseToInt(String s, int defaultInt)
    &#123;
        int i = 0;
        try &#123;
            i = Integer.parseInt(s);
        &#125; catch (NumberFormatException ex) &#123;
            i = defaultInt;
        &#125;
        return i;
    &#125;

    public static byte[] hexToByte(String hex)
            throws IllegalArgumentException
    &#123;
        if (hex.length() % 2 != 0) &#123;
            throw new IllegalArgumentException();
        &#125;
        char[] arr = hex.toCharArray();
        byte[] b = new byte[hex.length() / 2];
        int i = 0; int j = 0; for (int l = hex.length(); i &lt; l; j++) &#123;
        String swap = &quot;&quot; + arr[(i++)] + arr[i];
        int byteint = Integer.parseInt(swap, 16) &amp; 0xFF;
        b[j] = new Integer(byteint).byteValue();

        i++;
    &#125;

        return b;
    &#125;

    public static String byteToHex(byte[] b)
    &#123;
        if (b == null) &#123;
            throw new IllegalArgumentException(&quot;Argument b ( byte array ) is null! &quot;);
        &#125;

        String hs = &quot;&quot;;
        String stmp = &quot;&quot;;
        for (int n = 0; n &lt; b.length; n++) &#123;
            stmp = Integer.toHexString(b[n] &amp; 0xFF);
            if (stmp.length() == 1)
                hs = hs + &quot;0&quot; + stmp;
            else &#123;
                hs = hs + stmp;
            &#125;
        &#125;
        return hs.toUpperCase();
    &#125;

    public static byte[] subByte(byte[] input, int startIndex, int length) &#123;
        byte[] bt = new byte[length];
        for (int i = 0; i &lt; length; i++) &#123;
            bt[i] = input[(i + startIndex)];
        &#125;
        return bt;
    &#125;
&#125;
</code></pre>
<p><code>SM4Context</code></p>
<pre><code class="prettyprint">public class SM4Context &#123;

    public int mode = 1;
    public long[] sk = new long[32];
    public boolean isPadding = true;

    public SM4Context() &#123;
    &#125;
&#125;
</code></pre>
<p><code>SM4</code></p>
<pre><code class="prettyprint">public class SM4 &#123;
    public static final int SM4_ENCRYPT = 1;

    public static final int SM4_DECRYPT = 0;

    private long GET_ULONG_BE(byte[] b, int i) &#123;
        long n = (long) (b[i] &amp; 0xff) &lt;&lt; 24 | (long) ((b[i + 1] &amp; 0xff) &lt;&lt; 16) | (long) ((b[i + 2] &amp; 0xff) &lt;&lt; 8) | (long) (b[i + 3] &amp; 0xff) &amp; 0xffffffffL;
        return n;
    &#125;

    private void PUT_ULONG_BE(long n, byte[] b, int i) &#123;
        b[i] = (byte) (int) (0xFF &amp; n &gt;&gt; 24);
        b[i + 1] = (byte) (int) (0xFF &amp; n &gt;&gt; 16);
        b[i + 2] = (byte) (int) (0xFF &amp; n &gt;&gt; 8);
        b[i + 3] = (byte) (int) (0xFF &amp; n);
    &#125;

    private long SHL(long x, int n) &#123;
        return (x &amp; 0xFFFFFFFF) &lt;&lt; n;
    &#125;

    private long ROTL(long x, int n) &#123;
        return SHL(x, n) | x &gt;&gt; (32 - n);
    &#125;

    private void SWAP(long[] sk, int i) &#123;
        long t = sk[i];
        sk[i] = sk[(31 - i)];
        sk[(31 - i)] = t;
    &#125;

    public static final byte[] SboxTable = &#123;
            (byte) 0xd6, (byte) 0x90, (byte) 0xe9, (byte) 0xfe,
            (byte) 0xcc, (byte) 0xe1, 0x3d, (byte) 0xb7, 0x16, (byte) 0xb6,
            0x14, (byte) 0xc2, 0x28, (byte) 0xfb, 0x2c, 0x05, 0x2b, 0x67,
            (byte) 0x9a, 0x76, 0x2a, (byte) 0xbe, 0x04, (byte) 0xc3,
            (byte) 0xaa, 0x44, 0x13, 0x26, 0x49, (byte) 0x86, 0x06,
            (byte) 0x99, (byte) 0x9c, 0x42, 0x50, (byte) 0xf4, (byte) 0x91,
            (byte) 0xef, (byte) 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43,
            (byte) 0xed, (byte) 0xcf, (byte) 0xac, 0x62, (byte) 0xe4,
            (byte) 0xb3, 0x1c, (byte) 0xa9, (byte) 0xc9, 0x08, (byte) 0xe8,
            (byte) 0x95, (byte) 0x80, (byte) 0xdf, (byte) 0x94, (byte) 0xfa,
            0x75, (byte) 0x8f, 0x3f, (byte) 0xa6, 0x47, 0x07, (byte) 0xa7,
            (byte) 0xfc, (byte) 0xf3, 0x73, 0x17, (byte) 0xba, (byte) 0x83,
            0x59, 0x3c, 0x19, (byte) 0xe6, (byte) 0x85, 0x4f, (byte) 0xa8,
            0x68, 0x6b, (byte) 0x81, (byte) 0xb2, 0x71, 0x64, (byte) 0xda,
            (byte) 0x8b, (byte) 0xf8, (byte) 0xeb, 0x0f, 0x4b, 0x70, 0x56,
            (byte) 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, (byte) 0xd1,
            (byte) 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, (byte) 0x87,
            (byte) 0xd4, 0x00, 0x46, 0x57, (byte) 0x9f, (byte) 0xd3, 0x27,
            0x52, 0x4c, 0x36, 0x02, (byte) 0xe7, (byte) 0xa0, (byte) 0xc4,
            (byte) 0xc8, (byte) 0x9e, (byte) 0xea, (byte) 0xbf, (byte) 0x8a,
            (byte) 0xd2, 0x40, (byte) 0xc7, 0x38, (byte) 0xb5, (byte) 0xa3,
            (byte) 0xf7, (byte) 0xf2, (byte) 0xce, (byte) 0xf9, 0x61, 0x15,
            (byte) 0xa1, (byte) 0xe0, (byte) 0xae, 0x5d, (byte) 0xa4,
            (byte) 0x9b, 0x34, 0x1a, 0x55, (byte) 0xad, (byte) 0x93, 0x32,
            0x30, (byte) 0xf5, (byte) 0x8c, (byte) 0xb1, (byte) 0xe3, 0x1d,
            (byte) 0xf6, (byte) 0xe2, 0x2e, (byte) 0x82, 0x66, (byte) 0xca,
            0x60, (byte) 0xc0, 0x29, 0x23, (byte) 0xab, 0x0d, 0x53, 0x4e, 0x6f,
            (byte) 0xd5, (byte) 0xdb, 0x37, 0x45, (byte) 0xde, (byte) 0xfd,
            (byte) 0x8e, 0x2f, 0x03, (byte) 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b,
            0x51, (byte) 0x8d, 0x1b, (byte) 0xaf, (byte) 0x92, (byte) 0xbb,
            (byte) 0xdd, (byte) 0xbc, 0x7f, 0x11, (byte) 0xd9, 0x5c, 0x41,
            0x1f, 0x10, 0x5a, (byte) 0xd8, 0x0a, (byte) 0xc1, 0x31,
            (byte) 0x88, (byte) 0xa5, (byte) 0xcd, 0x7b, (byte) 0xbd, 0x2d,
            0x74, (byte) 0xd0, 0x12, (byte) 0xb8, (byte) 0xe5, (byte) 0xb4,
            (byte) 0xb0, (byte) 0x89, 0x69, (byte) 0x97, 0x4a, 0x0c,
            (byte) 0x96, 0x77, 0x7e, 0x65, (byte) 0xb9, (byte) 0xf1, 0x09,
            (byte) 0xc5, 0x6e, (byte) 0xc6, (byte) 0x84, 0x18, (byte) 0xf0,
            0x7d, (byte) 0xec, 0x3a, (byte) 0xdc, 0x4d, 0x20, 0x79,
            (byte) 0xee, 0x5f, 0x3e, (byte) 0xd7, (byte) 0xcb, 0x39, 0x48
    &#125;;

    public static final int[] FK = &#123;0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc&#125;;

    public static final int[] CK = &#123;0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,
            0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,
            0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,
            0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,
            0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,
            0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,
            0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,
            0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279&#125;;

    private byte sm4Sbox(byte inch) &#123;
        int i = inch &amp; 0xFF;
        byte retVal = SboxTable[i];
        return retVal;
    &#125;

    private long sm4Lt(long ka) &#123;
        long bb = 0L;
        long c = 0L;
        byte[] a = new byte[4];
        byte[] b = new byte[4];
        PUT_ULONG_BE(ka, a, 0);
        b[0] = sm4Sbox(a[0]);
        b[1] = sm4Sbox(a[1]);
        b[2] = sm4Sbox(a[2]);
        b[3] = sm4Sbox(a[3]);
        bb = GET_ULONG_BE(b, 0);
        c = bb ^ ROTL(bb, 2) ^ ROTL(bb, 10) ^ ROTL(bb, 18) ^ ROTL(bb, 24);
        return c;
    &#125;

    private long sm4F(long x0, long x1, long x2, long x3, long rk) &#123;
        return x0 ^ sm4Lt(x1 ^ x2 ^ x3 ^ rk);
    &#125;

    private long sm4CalciRK(long ka) &#123;
        long bb = 0L;
        long rk = 0L;
        byte[] a = new byte[4];
        byte[] b = new byte[4];
        PUT_ULONG_BE(ka, a, 0);
        b[0] = sm4Sbox(a[0]);
        b[1] = sm4Sbox(a[1]);
        b[2] = sm4Sbox(a[2]);
        b[3] = sm4Sbox(a[3]);
        bb = GET_ULONG_BE(b, 0);
        rk = bb ^ ROTL(bb, 13) ^ ROTL(bb, 23);
        return rk;
    &#125;

    private void sm4_setkey(long[] SK, byte[] key) &#123;
        long[] MK = new long[4];
        long[] k = new long[36];
        int i = 0;
        MK[0] = GET_ULONG_BE(key, 0);
        MK[1] = GET_ULONG_BE(key, 4);
        MK[2] = GET_ULONG_BE(key, 8);
        MK[3] = GET_ULONG_BE(key, 12);
        k[0] = MK[0] ^ (long) FK[0];
        k[1] = MK[1] ^ (long) FK[1];
        k[2] = MK[2] ^ (long) FK[2];
        k[3] = MK[3] ^ (long) FK[3];
        for (; i &lt; 32; i++) &#123;
            k[(i + 4)] = (k[i] ^ sm4CalciRK(k[(i + 1)] ^ k[(i + 2)] ^ k[(i + 3)] ^ (long) CK[i]));
            SK[i] = k[(i + 4)];
        &#125;
    &#125;

    private void sm4_one_round(long[] sk, byte[] input, byte[] output) &#123;
        int i = 0;
        long[] ulbuf = new long[36];
        ulbuf[0] = GET_ULONG_BE(input, 0);
        ulbuf[1] = GET_ULONG_BE(input, 4);
        ulbuf[2] = GET_ULONG_BE(input, 8);
        ulbuf[3] = GET_ULONG_BE(input, 12);
        while (i &lt; 32) &#123;
            ulbuf[(i + 4)] = sm4F(ulbuf[i], ulbuf[(i + 1)], ulbuf[(i + 2)], ulbuf[(i + 3)], sk[i]);
            i++;
        &#125;
        PUT_ULONG_BE(ulbuf[35], output, 0);
        PUT_ULONG_BE(ulbuf[34], output, 4);
        PUT_ULONG_BE(ulbuf[33], output, 8);
        PUT_ULONG_BE(ulbuf[32], output, 12);
    &#125;

    private byte[] padding(byte[] input, int mode) &#123;
        if (input == null) &#123;
            return null;
        &#125;

        byte[] ret = (byte[]) null;
        if (mode == SM4_ENCRYPT) &#123;
            int p = 16 - input.length % 16;
            ret = new byte[input.length + p];
            System.arraycopy(input, 0, ret, 0, input.length);
            for (int i = 0; i &lt; p; i++) &#123;
                ret[input.length + i] = (byte) p;
            &#125;
        &#125; else &#123;
            int p = input[input.length - 1];
            ret = new byte[input.length - p];
            System.arraycopy(input, 0, ret, 0, input.length - p);
        &#125;
        return ret;
    &#125;

    public void sm4_setkey_enc(SM4Context ctx, byte[] key) throws Exception &#123;
        if (ctx == null) &#123;
            throw new Exception(&quot;ctx is null!&quot;);
        &#125;

        if (key == null || (key.length != 16 &amp;&amp; key.length != 32)) &#123;
            throw new Exception(&quot;key error!&quot;);
        &#125;

        ctx.mode = SM4_ENCRYPT;
        sm4_setkey(ctx.sk, key);
    &#125;

    public void sm4_setkey_dec(SM4Context ctx, byte[] key) throws Exception &#123;
        if (ctx == null) &#123;
            throw new Exception(&quot;ctx is null!&quot;);
        &#125;

        if (key == null || (key.length != 16 &amp;&amp; key.length != 32)) &#123;
            throw new Exception(&quot;key error!&quot;);
        &#125;

        int i = 0;
        ctx.mode = SM4_DECRYPT;
        sm4_setkey(ctx.sk, key);
        for (i = 0; i &lt; 16; i++) &#123;
            SWAP(ctx.sk, i);
        &#125;
    &#125;

    public byte[] sm4_crypt_ecb(SM4Context ctx, byte[] input) throws Exception &#123;
        if (input == null) &#123;
            throw new Exception(&quot;input is null!&quot;);
        &#125;

        if ((ctx.isPadding) &amp;&amp; (ctx.mode == SM4_ENCRYPT)) &#123;
            input = padding(input, SM4_ENCRYPT);
        &#125;

        int length = input.length;
        ByteArrayInputStream bins = new ByteArrayInputStream(input);
        ByteArrayOutputStream bous = new ByteArrayOutputStream();
        for (; length &gt; 0; length -= 16) &#123;
            byte[] in = new byte[16];
            byte[] out = new byte[16];
            int read = bins.read(in);
            sm4_one_round(ctx.sk, in, out);
            bous.write(out);
        &#125;

        byte[] output = bous.toByteArray();
        if (ctx.isPadding &amp;&amp; ctx.mode == SM4_DECRYPT) &#123;
            output = padding(output, SM4_DECRYPT);
        &#125;
        bins.close();
        bous.close();
        return output;
    &#125;

    public byte[] sm4_crypt_cbc(SM4Context ctx, byte[] iv, byte[] input) throws Exception &#123;
        if (iv == null || (iv.length != 16 &amp;&amp; iv.length != 32)) &#123;
            throw new Exception(&quot;iv error!&quot;);
        &#125;

        if (input == null) &#123;
            throw new Exception(&quot;input is null!&quot;);
        &#125;

        if (ctx.isPadding &amp;&amp; ctx.mode == SM4_ENCRYPT) &#123;
            input = padding(input, SM4_ENCRYPT);
        &#125;

        int i = 0;
        int length = input.length;
        ByteArrayInputStream bins = new ByteArrayInputStream(input);
        ByteArrayOutputStream bous = new ByteArrayOutputStream();
        if (ctx.mode == SM4_ENCRYPT) &#123;
            for (; length &gt; 0; length -= 16) &#123;
                byte[] in = new byte[16];
                byte[] out = new byte[16];
                byte[] out1 = new byte[16];

                int read = bins.read(in);
                for (i = 0; i &lt; 16; i++) &#123;
                    out[i] = ((byte) (in[i] ^ iv[i]));
                &#125;
                sm4_one_round(ctx.sk, out, out1);
                System.arraycopy(out1, 0, iv, 0, 16);
                bous.write(out1);
            &#125;
        &#125; else &#123;
            byte[] temp = new byte[16];
            for (; length &gt; 0; length -= 16) &#123;
                byte[] in = new byte[16];
                byte[] out = new byte[16];
                byte[] out1 = new byte[16];

                int read = bins.read(in);
                System.arraycopy(in, 0, temp, 0, 16);
                sm4_one_round(ctx.sk, in, out);
                for (i = 0; i &lt; 16; i++) &#123;
                    out1[i] = ((byte) (out[i] ^ iv[i]));
                &#125;
                System.arraycopy(temp, 0, iv, 0, 16);
                bous.write(out1);
            &#125;
        &#125;

        byte[] output = bous.toByteArray();
        if (ctx.isPadding &amp;&amp; ctx.mode == SM4_DECRYPT) &#123;
            output = padding(output, SM4_DECRYPT);
        &#125;
        bins.close();
        bous.close();
        return output;
    &#125;
&#125;
</code></pre>
<p><code>SM4SimpleUtil</code>SM4工具类</p>
<pre><code class="prettyprint">public class SM4SimpleUtil extends HexUtil &#123;
    //自己定义
    public static String SM4_KEY_VALUE = &quot;&quot;;
    public static String encrypt(String plainText, String secretKey) &#123;
        try &#123;
            SM4Context ctx = new SM4Context();
            ctx.isPadding = true;
            ctx.mode = 1;
            byte[] keyBytes = null;
            if (secretKey.length() &lt; 32) &#123;
                keyBytes = hexToByte(getHexString(secretKey.getBytes()));
            &#125; else &#123;
                keyBytes = hexStringToBytes(secretKey);
            &#125;
            SM4 sm4 = new SM4();
            sm4.sm4_setkey_enc(ctx, keyBytes);
            byte[] encrypted = sm4.sm4_crypt_ecb(ctx, plainText.getBytes(&quot;UTF-8&quot;));
            return getHexString(encrypted);
        &#125; catch (Exception var8) &#123;
            var8.printStackTrace();
            return null;
        &#125;
    &#125;
    public static String decrypt(String cipherTextString, String secretKey) &#123;
        try &#123;
            SM4Context ctx = new SM4Context();
            ctx.isPadding = true;
            ctx.mode = 0;
            byte[] keyBytes = null;
            if (secretKey.length() &lt; 32) &#123;
                keyBytes = hexToByte(getHexString(secretKey.getBytes()));
            &#125; else &#123;
                keyBytes = hexStringToBytes(secretKey);
            &#125;
            byte[] cipherText = hexToByte(cipherTextString);
            SM4 sm4 = new SM4();
            sm4.sm4_setkey_dec(ctx, keyBytes);
            byte[] decrypted = sm4.sm4_crypt_ecb(ctx, cipherText);
            return new String(decrypted);
        &#125; catch (Exception var6) &#123;
            var6.printStackTrace();
            return null;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="prettyprint">public class SM4 &#123;
    public static final int SM4_ENCRYPT = 1;

    public static final int SM4_DECRYPT = 0;

    private long GET_ULONG_BE(byte[] b, int i) &#123;
        long n = (long) (b[i] &amp; 0xff) &lt;&lt; 24 | (long) ((b[i + 1] &amp; 0xff) &lt;&lt; 16) | (long) ((b[i + 2] &amp; 0xff) &lt;&lt; 8) | (long) (b[i + 3] &amp; 0xff) &amp; 0xffffffffL;
        return n;
    &#125;

    private void PUT_ULONG_BE(long n, byte[] b, int i) &#123;
        b[i] = (byte) (int) (0xFF &amp; n &gt;&gt; 24);
        b[i + 1] = (byte) (int) (0xFF &amp; n &gt;&gt; 16);
        b[i + 2] = (byte) (int) (0xFF &amp; n &gt;&gt; 8);
        b[i + 3] = (byte) (int) (0xFF &amp; n);
    &#125;

    private long SHL(long x, int n) &#123;
        return (x &amp; 0xFFFFFFFF) &lt;&lt; n;
    &#125;

    private long ROTL(long x, int n) &#123;
        return SHL(x, n) | x &gt;&gt; (32 - n);
    &#125;

    private void SWAP(long[] sk, int i) &#123;
        long t = sk[i];
        sk[i] = sk[(31 - i)];
        sk[(31 - i)] = t;
    &#125;

    public static final byte[] SboxTable = &#123;
            (byte) 0xd6, (byte) 0x90, (byte) 0xe9, (byte) 0xfe,
            (byte) 0xcc, (byte) 0xe1, 0x3d, (byte) 0xb7, 0x16, (byte) 0xb6,
            0x14, (byte) 0xc2, 0x28, (byte) 0xfb, 0x2c, 0x05, 0x2b, 0x67,
            (byte) 0x9a, 0x76, 0x2a, (byte) 0xbe, 0x04, (byte) 0xc3,
            (byte) 0xaa, 0x44, 0x13, 0x26, 0x49, (byte) 0x86, 0x06,
            (byte) 0x99, (byte) 0x9c, 0x42, 0x50, (byte) 0xf4, (byte) 0x91,
            (byte) 0xef, (byte) 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43,
            (byte) 0xed, (byte) 0xcf, (byte) 0xac, 0x62, (byte) 0xe4,
            (byte) 0xb3, 0x1c, (byte) 0xa9, (byte) 0xc9, 0x08, (byte) 0xe8,
            (byte) 0x95, (byte) 0x80, (byte) 0xdf, (byte) 0x94, (byte) 0xfa,
            0x75, (byte) 0x8f, 0x3f, (byte) 0xa6, 0x47, 0x07, (byte) 0xa7,
            (byte) 0xfc, (byte) 0xf3, 0x73, 0x17, (byte) 0xba, (byte) 0x83,
            0x59, 0x3c, 0x19, (byte) 0xe6, (byte) 0x85, 0x4f, (byte) 0xa8,
            0x68, 0x6b, (byte) 0x81, (byte) 0xb2, 0x71, 0x64, (byte) 0xda,
            (byte) 0x8b, (byte) 0xf8, (byte) 0xeb, 0x0f, 0x4b, 0x70, 0x56,
            (byte) 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, (byte) 0xd1,
            (byte) 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, (byte) 0x87,
            (byte) 0xd4, 0x00, 0x46, 0x57, (byte) 0x9f, (byte) 0xd3, 0x27,
            0x52, 0x4c, 0x36, 0x02, (byte) 0xe7, (byte) 0xa0, (byte) 0xc4,
            (byte) 0xc8, (byte) 0x9e, (byte) 0xea, (byte) 0xbf, (byte) 0x8a,
            (byte) 0xd2, 0x40, (byte) 0xc7, 0x38, (byte) 0xb5, (byte) 0xa3,
            (byte) 0xf7, (byte) 0xf2, (byte) 0xce, (byte) 0xf9, 0x61, 0x15,
            (byte) 0xa1, (byte) 0xe0, (byte) 0xae, 0x5d, (byte) 0xa4,
            (byte) 0x9b, 0x34, 0x1a, 0x55, (byte) 0xad, (byte) 0x93, 0x32,
            0x30, (byte) 0xf5, (byte) 0x8c, (byte) 0xb1, (byte) 0xe3, 0x1d,
            (byte) 0xf6, (byte) 0xe2, 0x2e, (byte) 0x82, 0x66, (byte) 0xca,
            0x60, (byte) 0xc0, 0x29, 0x23, (byte) 0xab, 0x0d, 0x53, 0x4e, 0x6f,
            (byte) 0xd5, (byte) 0xdb, 0x37, 0x45, (byte) 0xde, (byte) 0xfd,
            (byte) 0x8e, 0x2f, 0x03, (byte) 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b,
            0x51, (byte) 0x8d, 0x1b, (byte) 0xaf, (byte) 0x92, (byte) 0xbb,
            (byte) 0xdd, (byte) 0xbc, 0x7f, 0x11, (byte) 0xd9, 0x5c, 0x41,
            0x1f, 0x10, 0x5a, (byte) 0xd8, 0x0a, (byte) 0xc1, 0x31,
            (byte) 0x88, (byte) 0xa5, (byte) 0xcd, 0x7b, (byte) 0xbd, 0x2d,
            0x74, (byte) 0xd0, 0x12, (byte) 0xb8, (byte) 0xe5, (byte) 0xb4,
            (byte) 0xb0, (byte) 0x89, 0x69, (byte) 0x97, 0x4a, 0x0c,
            (byte) 0x96, 0x77, 0x7e, 0x65, (byte) 0xb9, (byte) 0xf1, 0x09,
            (byte) 0xc5, 0x6e, (byte) 0xc6, (byte) 0x84, 0x18, (byte) 0xf0,
            0x7d, (byte) 0xec, 0x3a, (byte) 0xdc, 0x4d, 0x20, 0x79,
            (byte) 0xee, 0x5f, 0x3e, (byte) 0xd7, (byte) 0xcb, 0x39, 0x48
    &#125;;

    public static final int[] FK = &#123;0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc&#125;;

    public static final int[] CK = &#123;0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,
            0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,
            0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,
            0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,
            0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,
            0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,
            0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,
            0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279&#125;;

    private byte sm4Sbox(byte inch) &#123;
        int i = inch &amp; 0xFF;
        byte retVal = SboxTable[i];
        return retVal;
    &#125;

    private long sm4Lt(long ka) &#123;
        long bb = 0L;
        long c = 0L;
        byte[] a = new byte[4];
        byte[] b = new byte[4];
        PUT_ULONG_BE(ka, a, 0);
        b[0] = sm4Sbox(a[0]);
        b[1] = sm4Sbox(a[1]);
        b[2] = sm4Sbox(a[2]);
        b[3] = sm4Sbox(a[3]);
        bb = GET_ULONG_BE(b, 0);
        c = bb ^ ROTL(bb, 2) ^ ROTL(bb, 10) ^ ROTL(bb, 18) ^ ROTL(bb, 24);
        return c;
    &#125;

    private long sm4F(long x0, long x1, long x2, long x3, long rk) &#123;
        return x0 ^ sm4Lt(x1 ^ x2 ^ x3 ^ rk);
    &#125;

    private long sm4CalciRK(long ka) &#123;
        long bb = 0L;
        long rk = 0L;
        byte[] a = new byte[4];
        byte[] b = new byte[4];
        PUT_ULONG_BE(ka, a, 0);
        b[0] = sm4Sbox(a[0]);
        b[1] = sm4Sbox(a[1]);
        b[2] = sm4Sbox(a[2]);
        b[3] = sm4Sbox(a[3]);
        bb = GET_ULONG_BE(b, 0);
        rk = bb ^ ROTL(bb, 13) ^ ROTL(bb, 23);
        return rk;
    &#125;

    private void sm4_setkey(long[] SK, byte[] key) &#123;
        long[] MK = new long[4];
        long[] k = new long[36];
        int i = 0;
        MK[0] = GET_ULONG_BE(key, 0);
        MK[1] = GET_ULONG_BE(key, 4);
        MK[2] = GET_ULONG_BE(key, 8);
        MK[3] = GET_ULONG_BE(key, 12);
        k[0] = MK[0] ^ (long) FK[0];
        k[1] = MK[1] ^ (long) FK[1];
        k[2] = MK[2] ^ (long) FK[2];
        k[3] = MK[3] ^ (long) FK[3];
        for (; i &lt; 32; i++) &#123;
            k[(i + 4)] = (k[i] ^ sm4CalciRK(k[(i + 1)] ^ k[(i + 2)] ^ k[(i + 3)] ^ (long) CK[i]));
            SK[i] = k[(i + 4)];
        &#125;
    &#125;

    private void sm4_one_round(long[] sk, byte[] input, byte[] output) &#123;
        int i = 0;
        long[] ulbuf = new long[36];
        ulbuf[0] = GET_ULONG_BE(input, 0);
        ulbuf[1] = GET_ULONG_BE(input, 4);
        ulbuf[2] = GET_ULONG_BE(input, 8);
        ulbuf[3] = GET_ULONG_BE(input, 12);
        while (i &lt; 32) &#123;
            ulbuf[(i + 4)] = sm4F(ulbuf[i], ulbuf[(i + 1)], ulbuf[(i + 2)], ulbuf[(i + 3)], sk[i]);
            i++;
        &#125;
        PUT_ULONG_BE(ulbuf[35], output, 0);
        PUT_ULONG_BE(ulbuf[34], output, 4);
        PUT_ULONG_BE(ulbuf[33], output, 8);
        PUT_ULONG_BE(ulbuf[32], output, 12);
    &#125;

    private byte[] padding(byte[] input, int mode) &#123;
        if (input == null) &#123;
            return null;
        &#125;

        byte[] ret = (byte[]) null;
        if (mode == SM4_ENCRYPT) &#123;
            int p = 16 - input.length % 16;
            ret = new byte[input.length + p];
            System.arraycopy(input, 0, ret, 0, input.length);
            for (int i = 0; i &lt; p; i++) &#123;
                ret[input.length + i] = (byte) p;
            &#125;
        &#125; else &#123;
            int p = input[input.length - 1];
            ret = new byte[input.length - p];
            System.arraycopy(input, 0, ret, 0, input.length - p);
        &#125;
        return ret;
    &#125;

    public void sm4_setkey_enc(SM4Context ctx, byte[] key) throws Exception &#123;
        if (ctx == null) &#123;
            throw new Exception(&quot;ctx is null!&quot;);
        &#125;

        if (key == null || (key.length != 16 &amp;&amp; key.length != 32)) &#123;
            throw new Exception(&quot;key error!&quot;);
        &#125;

        ctx.mode = SM4_ENCRYPT;
        sm4_setkey(ctx.sk, key);
    &#125;

    public void sm4_setkey_dec(SM4Context ctx, byte[] key) throws Exception &#123;
        if (ctx == null) &#123;
            throw new Exception(&quot;ctx is null!&quot;);
        &#125;

        if (key == null || (key.length != 16 &amp;&amp; key.length != 32)) &#123;
            throw new Exception(&quot;key error!&quot;);
        &#125;

        int i = 0;
        ctx.mode = SM4_DECRYPT;
        sm4_setkey(ctx.sk, key);
        for (i = 0; i &lt; 16; i++) &#123;
            SWAP(ctx.sk, i);
        &#125;
    &#125;

    public byte[] sm4_crypt_ecb(SM4Context ctx, byte[] input) throws Exception &#123;
        if (input == null) &#123;
            throw new Exception(&quot;input is null!&quot;);
        &#125;

        if ((ctx.isPadding) &amp;&amp; (ctx.mode == SM4_ENCRYPT)) &#123;
            input = padding(input, SM4_ENCRYPT);
        &#125;

        int length = input.length;
        ByteArrayInputStream bins = new ByteArrayInputStream(input);
        ByteArrayOutputStream bous = new ByteArrayOutputStream();
        for (; length &gt; 0; length -= 16) &#123;
            byte[] in = new byte[16];
            byte[] out = new byte[16];
            int read = bins.read(in);
            sm4_one_round(ctx.sk, in, out);
            bous.write(out);
        &#125;

        byte[] output = bous.toByteArray();
        if (ctx.isPadding &amp;&amp; ctx.mode == SM4_DECRYPT) &#123;
            output = padding(output, SM4_DECRYPT);
        &#125;
        bins.close();
        bous.close();
        return output;
    &#125;

    public byte[] sm4_crypt_cbc(SM4Context ctx, byte[] iv, byte[] input) throws Exception &#123;
        if (iv == null || (iv.length != 16 &amp;&amp; iv.length != 32)) &#123;
            throw new Exception(&quot;iv error!&quot;);
        &#125;

        if (input == null) &#123;
            throw new Exception(&quot;input is null!&quot;);
        &#125;

        if (ctx.isPadding &amp;&amp; ctx.mode == SM4_ENCRYPT) &#123;
            input = padding(input, SM4_ENCRYPT);
        &#125;

        int i = 0;
        int length = input.length;
        ByteArrayInputStream bins = new ByteArrayInputStream(input);
        ByteArrayOutputStream bous = new ByteArrayOutputStream();
        if (ctx.mode == SM4_ENCRYPT) &#123;
            for (; length &gt; 0; length -= 16) &#123;
                byte[] in = new byte[16];
                byte[] out = new byte[16];
                byte[] out1 = new byte[16];

                int read = bins.read(in);
                for (i = 0; i &lt; 16; i++) &#123;
                    out[i] = ((byte) (in[i] ^ iv[i]));
                &#125;
                sm4_one_round(ctx.sk, out, out1);
                System.arraycopy(out1, 0, iv, 0, 16);
                bous.write(out1);
            &#125;
        &#125; else &#123;
            byte[] temp = new byte[16];
            for (; length &gt; 0; length -= 16) &#123;
                byte[] in = new byte[16];
                byte[] out = new byte[16];
                byte[] out1 = new byte[16];

                int read = bins.read(in);
                System.arraycopy(in, 0, temp, 0, 16);
                sm4_one_round(ctx.sk, in, out);
                for (i = 0; i &lt; 16; i++) &#123;
                    out1[i] = ((byte) (out[i] ^ iv[i]));
                &#125;
                System.arraycopy(temp, 0, iv, 0, 16);
                bous.write(out1);
            &#125;
        &#125;

        byte[] output = bous.toByteArray();
        if (ctx.isPadding &amp;&amp; ctx.mode == SM4_DECRYPT) &#123;
            output = padding(output, SM4_DECRYPT);
        &#125;
        bins.close();
        bous.close();
        return output;
    &#125;
&#125;
</code></pre>
<p>测试调用</p>
<pre><code class="prettyprint">@Test
    public void encodeAndDecode()&#123;
        //        String data = &quot;阿斯达斯&quot;;
        SecureRandom random = new SecureRandom();
        String data = String.valueOf(random.nextInt(50));
        data += &quot;123456789789456123&quot;;
        String secretKey = SM4SimpleUtil.SM4_KEY_VALUE;
        System.out.println(&quot;传输数据:&quot;+data);
        //加密
        String encrypte = SM4SimpleUtil.encrypt(data, secretKey);
        System.out.println(encrypte+&quot;，长度：&quot;+encrypte.length());
        //数据解密
        String decryptDatas = SM4SimpleUtil.decrypt(encrypte, secretKey);
        System.out.println(decryptDatas);
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发</title>
    <url>/2022/05/28/java-bing-fa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="synchronized特性"><a href="#synchronized特性" class="headerlink" title="synchronized特性"></a>synchronized特性</h3><ul>
<li><p>对普通方法加锁，锁是当前实例对象</p>
<pre><code class="prettyprint">public synchronized void test(Object obj)&#123;
   //TODO 
&#125;
</code></pre>
</li>
<li><p>对静态方法加锁，锁是当前类实例，因为类数据存在永久代&#x2F;元空间，因此静态方法锁就是该类的全局锁</p>
<pre><code class="prettyprint">public static synchronized void test(Object obj)&#123;
   //TODO 
&#125;
</code></pre>
</li>
<li><p>对对象加锁，锁是<code>synchronized</code>括号里的对象实例</p>
<pre><code class="prettyprint">synchronized(Object o) &#123;
    //TODO
&#125;
</code></pre>
</li>
</ul>
<h3 id="synchronized的同步实现"><a href="#synchronized的同步实现" class="headerlink" title="synchronized的同步实现"></a>synchronized的同步实现</h3><ul>
<li><p><code>synchronized</code>的锁的实现是基于JVM进入和退出monitor对象来实现的。</p>
</li>
<li><p>monitor对象有2个关键指令monitorenter和monitorexit,具体就是在编译过程中把monitorenter指令插入到同步代码块开始位置，把monitorexit指令插入退出或异常的位置。</p>
</li>
<li><p>线程执行同步代码块的时首先需要获取锁，即尝试获取monitor对象的所有权，具体过程如下</p>
<p>​		首先线程执行指令monitorenter指令尝试获取monitor的所有权，如果monitor的进入数为0，则线程进入进入monitor，并且把进入修改为1，当前线程就持有了锁；如果线程进入monitor时，发现进入数大于0，则会判断monitor的持有者是否为当前线程，如果是当前线程则表示只是重新进入，则对monitor的进入数+1；如果monitor的所有权不是被当前线程持有，线程进入阻塞状态，直到monitor的进入数等于0，再次重新获取monitor的所有权。</p>
</li>
</ul>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>每个对象分为三块区域:<em>对象头、实例数据和对齐填充</em>。</p>
<ul>
<li>对象头包含两部分，第一部分是Mark Word，用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等，这一部分占一个字节。第二部分是Klass Pointer（类型指针），是对象指向它的类元数据的指针，<em>虚拟机通过这个指针来确定这个对象是哪个类的实例</em>，这部分也占一个字节。(<em>如果对象是数组类型的，则需要3个字节来存储对象头，因为还需要一个字节存储数组的长度</em>)</li>
<li>实例数据存放的是类属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，<em>这部分内存按4字节对齐</em>。</li>
<li>填充数据是因为虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</li>
</ul>
<p>对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机 中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码(HashCode)，4Bits用于存储对象分代年龄，2Bits用于存储锁标志 位，1Bit固定为0，在其他状态(轻量级锁定、重量级锁定、GC标记、可偏向)下对象的存储内容如下表所示</p>
<img src="/2022/05/28/java-bing-fa/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70.png" class="asset-class" title="对象头存储结构">

<p>从对象头的存储内容可以看出<strong>锁的状态都保存在对象头</strong>中，Synchronized也不例外，当其从轻量级锁膨胀为重量级锁时，锁标识位为10，其中<em>指针指向的是monitor对象</em>(也称为管程或监视器锁)的起始地址。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提升程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。<br>但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p>
<ul>
<li>获取锁</li>
</ul>
<ol>
<li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li>
<li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤(5)，否则执行步骤(3)；</li>
<li>如果线程ID不为当前线程ID，则<strong>通过CAS操作竞争锁</strong>，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程(4)；</li>
<li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li>
<li>执行同步代码块</li>
</ol>
<ul>
<li>释放锁</li>
</ul>
<p>偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）</p>
<ol>
<li>暂停拥有偏向锁的线程，判断锁对象是否还处于被锁定状态；</li>
<li>撤销偏向锁，恢复到无锁状态(01)或者轻量级锁的状态；</li>
</ol>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>引入轻量级锁的主要原因是，对绝大部分的锁，在整个同步周期内都不存在竞争，可能是交替获取锁然后执行。(<strong>与偏向锁的区别是，引入偏向锁是假设同一个锁都是由同一线程多次获得，而轻量级锁是假设同一个锁是由n个线程交替获得；相同点是都是假设不存在多线程竞争</strong>)<br>引入轻量级锁的主要目的是，在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗(多指时间消耗)。<br>触发轻量级锁的条件是当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，此时Mark Word的结构也变为轻量级锁的结构。<strong>如果存在多个线程同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁</strong>。</p>
<ul>
<li>获取锁<ol>
<li>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的<em>栈帧</em>中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</li>
<li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li>
<li>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li>
</ol>
</li>
<li>释放锁<ol>
<li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li>
<li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li>
<li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li>
</ol>
</li>
</ul>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p>
<p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。如果自旋之后依然没有获取到锁，也就只能升级为重量级锁了。</p>
<ol>
<li>当一个线程(假设叫A线程)想要获得锁时，首先检查对象头中的锁标志，如果是偏向锁，则跳转到2,如果是无锁状态，则跳转到3</li>
<li>检查对象头中的偏向线程id是否指向A线程，是,则直接执行同步代码块,不是则3。</li>
<li>使用cas操作将替换对象头中的偏向线程id,成功，则直接执行同步代码块。失败则说明其他的线程(假设叫B线程)已经拥有偏向锁了,那么进行偏向锁的撤销(因为这里有竞争了)，此时执行4。</li>
<li>B线程运行到全局安全点后，暂停该线程，检查它的状态,如果处于不活动或者已经退出同步代码块则原持有偏向锁的线程释放锁，然后A再次执行3。如果仍处于活动状态，则需要升级为轻量级锁，此时执行5。</li>
<li>在B线程的栈中分配锁记录，拷贝对象头中的MarkWord到锁记录中，然后将MarkWord改为指向B线程，同时将对象头中的锁标志信息改为轻量级锁的00,然后唤醒B线程，也就是从安全点处继续执行。</li>
<li>由于锁升级为轻量级锁, A线程也进行相同的操作，即，在A线程的栈中分配锁记录，拷贝对象头中的Mark Word到锁记录中，然后使用cas操作替换MarkWord,因为此时B线程拥有锁，因此, A线程自旋。如果自旋一定次数内成功获得锁，那么A线程获得轻量级锁，执行同步代码块。若自旋后仍未获得锁，A升级为重量级锁，将对象头中的锁标志信息改为重量级的10，同时阻塞,此时请看7。</li>
<li>B线程在释放锁的时候，使用cas将MarkWord中的信息替换，成功，则表示无竞争(这个时候还是轻量级锁, A线程可能正在自旋中)直接释放。失败(因为这个时候锁已经膨胀)，那么释放之 后唤醒被挂起的线程(在这个例子中，也就是A)。</li>
</ol>
<h3 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h3><ul>
<li><p>自旋与自适应自旋</p>
<p>如果持有锁的线程能在很短时间内释放锁资源，就可以让线程执行一个忙循环（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。但是线程自旋需要消耗cpu的资源，如果一直得不到锁就会浪费cpu资源。因此在jdk1.6引入了自适应自旋锁，自旋等待的时候不固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
</li>
<li><p>锁消除</p>
<p>锁消除是指虚拟机即时编译器在运行时，对于一些代码上要求同步但是被检测不可能存在共享数据竞争的锁进行消除。例如String类型的连接操作，String是一个不可变对象，字符串的连接操作总是通过生成新的String对象来进行的，Javac编译器会对String连接做自动优化，在JDK1.5的版本中使用的是StringBuffer对象的append操作，StringBuffer的append方法是同步方法，这段代码在经过即时编译器编译之后就会忽略掉所有的同步直接执行。在JDK1.5之后是使用的StringBuilder对象的append操作来优化字符串连接的。</p>
</li>
<li><p>锁粗化</p>
<p>将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。例如每次调用StringBuffer.append方法都需要加锁，如果虚拟机检测到有一系列的连续操作都是对同一个对象反复加锁和解锁，就会将其合并成一个更大范围的加锁和解锁操作。</p>
</li>
</ul>
<h3 id="synchronized-方式的问题"><a href="#synchronized-方式的问题" class="headerlink" title="synchronized 方式的问题"></a>synchronized 方式的问题</h3><ul>
<li>同步块的阻塞无法中断（不能 Interruptibly）</li>
<li>同步块的阻塞无法控制超时（无法自动解锁）</li>
<li>同步块无法异步处理锁（即不能立即知道是否可以拿到锁）</li>
<li>同步块无法根据条件灵活的加锁解锁（即只能跟同步块范围一致）</li>
</ul>
<h2 id="juc"><a href="#juc" class="headerlink" title="juc"></a>juc</h2><h3 id="锁机制类"><a href="#锁机制类" class="headerlink" title="锁机制类"></a>锁机制类</h3><h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><ul>
<li><p>使用方式灵活可控</p>
</li>
<li><p>性能开销较小</p>
</li>
<li><p>接口设计</p>
<ul>
<li><p><code>void lock();</code>获取锁</p>
</li>
<li><p><code>void lockInterruptibly() throws InterruptedException;</code>获取锁; 允许打断;</p>
</li>
<li><p><code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</code>尝试获取锁; 成功则返回 true; 超时则退出</p>
</li>
<li><p><code>boolean tryLock();</code>尝试【无等待】获取锁; 成功则返回 true</p>
</li>
<li><p><code>void unlock</code>解锁；要求当前线程已获得锁; 类比同步块结束</p>
</li>
<li><p><code>Condition newCondition();</code>新增一个绑定到当前Lock的条件； </p>
<pre><code class="prettyprint">//示例: （类比: Object monitor） 
final Lock lock = new ReentrantLock(); 
final Condition notFull = lock.newCondition(); 
final Condition notEmpty = lock.newCondition();
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><ul>
<li><p>代码示例</p>
<ul>
<li><p><code>Count</code>类定义<code>ReentrantLock</code>的读写方法</p>
<pre><code class="prettyprint">public class Count &#123;

    final ReentrantLock lock = new ReentrantLock();

    public void get() &#123;
        try &#123;
            lock.lock();
            System.out.println(Thread.currentThread().getName() + &quot; get begin&quot;);
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + &quot; get end&quot;);
            lock.unlock();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public void put() &#123;
        try &#123;
            lock.lock();
            System.out.println(Thread.currentThread().getName() + &quot; put begin&quot;);
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + &quot; put end&quot;);
            lock.unlock();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p><code>ReentrantLockDemo</code>测试类</p>
<pre><code class="prettyprint">public class ReentrantLockDemo &#123;

    public static void main(String[] args) &#123;
        final Count count = new Count();

        for (int i = 0; i &lt; 2; i++) &#123;
            new Thread(count::get).start();
        &#125;

        for (int i = 0; i &lt; 2; i++) &#123;
            new Thread(count::put).start();
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>测试结果</p>
<img src="/2022/05/28/java-bing-fa/image-20220528215049400.png" class="asset-class" title="image-20220528215049400"></li>
</ul>
<h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><ul>
<li><p>ReadWriteLock 管理一组锁，一个读锁，一个写锁。</p>
</li>
<li><p>读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。</p>
</li>
<li><p>所有读写锁的实现必须确保写操作对读操作的内存影响。每次只能有一个写线程，但是 同时可以有多个线程并发地读数据。ReadWriteLock 适用于读多写少的并发情况。</p>
</li>
<li><p>代码示例</p>
<ul>
<li><p><code>Count2</code>类定义<code>ReentrantReadWriteLock</code>的读写方法</p>
<pre><code class="prettyprint">public class Count2 &#123;

    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();

    public void get() &#123;
        rwLock.readLock().lock();
        try &#123;
            System.out.println(Thread.currentThread().getName() + &quot; get begin&quot;);
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + &quot; get end&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            rwLock.readLock().unlock();
        &#125;
    &#125;

    public void put() &#123;
        rwLock.writeLock().lock();
        try &#123;
            System.out.println(Thread.currentThread().getName() + &quot; put begin&quot;);
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getName() + &quot; put end&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            rwLock.writeLock().unlock();
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p><code>ReentrantReadWriteLockDemo</code> 测试类</p>
<pre><code class="prettyprint">public class ReentrantReadWriteLockDemo &#123;

    public static void main(String[] args) &#123;
        final Count2 count = new Count2();

        for (int i = 0; i &lt; 5; i++) &#123;
            new Thread(() -&gt; count.get()).start();
        &#125;

        for (int i = 0; i &lt; 5; i++) &#123;
            new Thread(() -&gt; count.put()).start();
        &#125;
    &#125;
    // 读锁不互斥、写锁互斥
&#125;
</code></pre>
</li>
<li><p>运行结果</p>
<img src="/2022/05/28/java-bing-fa/image-20220528223705002.png" class="asset-class" title="image-20220528223705002"></li>
</ul>
</li>
</ul>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>通过 lock.newCondition()创建。 可以看做是 Lock 对象上的信号。类似于 wait&#x2F;notify。</p>
<ul>
<li><code>void await() throws  InterruptedException;</code> 等待信号; 类比 Object#wait() </li>
<li><code>void awaitUninterruptibly();</code> 等待信号;  </li>
<li><code>boolean await(long time, TimeUnit unit) throws InterruptedException;</code> 等待信号; 超时则返回 false </li>
<li><code>boolean awaitUntil(Date deadline) throws InterruptedException;</code> 等待信号; 超时则返回 false </li>
<li><code>void signal();</code>给一个等待线程发送唤醒信号; 类比 Object#notify () </li>
<li><code>void signalAll();</code> 给所有等待线程发送唤醒信号; 类比 Object#notifyAll()</li>
</ul>
<p>测试</p>
<pre><code class="prettyprint">class ConditionDemo &#123;
    final Lock lock = new ReentrantLock();
    final Condition notFull  = lock.newCondition();
    final Condition notEmpty = lock.newCondition();
    
    final Object[] items = new Object[10];
    int putptr, takeptr, count;
    
    public void put(Object x) throws InterruptedException &#123;
        lock.lock();
        try &#123;
            // 当count等于数组的大小时，当前线程等待，直到notFull通知，再进行生产
            while (count == items.length)
                notFull.await();
            items[putptr] = x;
            if (++putptr == items.length) putptr = 0;
            ++count;
            notEmpty.signal();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
    
    public Object take() throws InterruptedException &#123;
        lock.lock();
        try &#123;
            // 当count为0，进入等待，直到notEmpty通知，进行消费。
            while (count == 0)
                notEmpty.await();
            Object x = items[takeptr];
            if (++takeptr == items.length) takeptr = 0;
            --count;
            notFull.signal();
            return x;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="LockSupport–锁当前线程"><a href="#LockSupport–锁当前线程" class="headerlink" title="LockSupport–锁当前线程"></a>LockSupport–锁当前线程</h4><p>LockSupport 类似于 Thread 类的静态方法，专门处理（执行这个代码的）本线程的</p>
<p>为什么 unpark 需要加一个线程作为参数？ 因为一个 park 的线程，无法自己唤醒自己，所以需要其他线程来唤醒。</p>
<ul>
<li><code>public static void park(Object blocker)</code> 暂停当前线程</li>
<li><code>public static void parkNanos(Object blocker, long nanos)</code> 暂停当前线程，有超时时间的限制</li>
<li><code>public static void parkUntil(Object blocker, long deadline)</code> 暂定当前线程，直到某个时间</li>
<li><code>public static void park()</code> 无期限暂停当前线程</li>
<li><code>public static void parkNanos(long nanos)</code> 暂停当前线程，有超时时间限制</li>
<li><code>public static void parkUntil(long deadline)</code> 暂定当前线程，直到某个时间</li>
<li><code>public static void unpark(Thread thread)</code>恢复当前线程</li>
<li><code>public static Object getBlocker(Thread t)</code></li>
</ul>
<p>测试</p>
<pre><code class="prettyprint">public class LockSupportDemo &#123;
    
    public static Object u = new Object();
    static ChangeObjectThread t1 = new ChangeObjectThread(&quot;t1&quot;);
    static ChangeObjectThread t2 = new ChangeObjectThread(&quot;t2&quot;);
    
    public static class ChangeObjectThread extends Thread &#123;
        public ChangeObjectThread(String name) &#123;
            super(name);
        &#125;
        @Override public void run() &#123;
            synchronized (u) &#123;
                System.out.println(&quot;in &quot; + getName());
                LockSupport.park();
                if (Thread.currentThread().isInterrupted()) &#123;
                    System.out.println(Thread.currentThread().getName() + &quot;被中断了&quot;);
                &#125;
                System.out.println(Thread.currentThread().getName() + &quot;继续执行&quot;);
            &#125;
        &#125;
    &#125;
    
    public static void main(String[] args) throws InterruptedException &#123;
        t1.start();
        Thread.sleep(1000L);
        t2.start();
        Thread.sleep(3000L);
        t1.interrupt();
        LockSupport.unpark(t2);
        t1.join();
        t2.join();
    &#125;
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220528224817320.png" class="asset-class" title="image-20220528224817320">

<h3 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h3><h4 id="java-util-concurrent-atomic"><a href="#java-util-concurrent-atomic" class="headerlink" title="java.util.concurrent.atomic"></a>java.util.concurrent.atomic</h4><img src="/2022/05/28/java-bing-fa/image-20220528225129911.png" class="asset-class" title="image-20220528225129911">

<h4 id="无锁技术的底层实现原理"><a href="#无锁技术的底层实现原理" class="headerlink" title="无锁技术的底层实现原理"></a>无锁技术的底层实现原理</h4><ul>
<li><p>Unsafe API - Compare-And-Swap</p>
</li>
<li><p>CPU 硬件指令支持: CAS 指令</p>
</li>
<li><p>核心实现原理：</p>
<ul>
<li><p>volatile 保证读写操作都可见（注意不保证原子）； </p>
<img src="/2022/05/28/java-bing-fa/image-20220528225929218.png" class="asset-class" title="image-20220528225929218">
</li>
<li><p>使用 CAS 指令，作为乐观锁实现，通过自旋重试保证写入</p>
<img src="/2022/05/28/java-bing-fa/image-20220528230009442.png" class="asset-class" title="image-20220528230009442">

<img src="/2022/05/28/java-bing-fa/image-20220528230022453.png" class="asset-class" title="image-20220528230022453">

<img src="/2022/05/28/java-bing-fa/image-20220528230039040.png" class="asset-class" title="image-20220528230039040"></li>
</ul>
</li>
</ul>
<h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>CAS 本质上没有使用锁。 并发压力跟锁性能的关系： </p>
<ul>
<li>压力非常小，性能本身要求就不高； </li>
<li>压力一般的情况下，无锁更快，大部分都一次写入；</li>
<li>压力非常大时，自旋导致重试过多，资源消耗很大。</li>
</ul>
<p>代码示例</p>
<ul>
<li><p><code>Count</code>增加获取工具类，无锁，非同步</p>
<pre><code class="prettyprint">public class Count &#123;

    private int num = 0;

    public int add() &#123;
        return num++;
    &#125;

    public int getNum() &#123;
        return num;
    &#125;
&#125;
</code></pre>
</li>
<li><p><code>SyncCount</code>增加和获取工具类，同步</p>
</li>
<li><p><code>AtomicCount</code>增加和获取工具类，原子类</p>
<pre><code class="prettyprint">public class AtomicCount &#123;

    private AtomicInteger num = new AtomicInteger();

    public int add() &#123;
        return num.getAndIncrement();
    &#125;

    public int getNum() &#123;
        return num.get();
    &#125;
&#125;
</code></pre>
</li>
<li><p>测试类</p>
<pre><code class="prettyprint">public class AtomicMain &#123;

    public static void main(String[] args) &#123;
//        final Count count = new Count(); // &lt;1000000
//        final SyncCount count = new SyncCount(); // 1000000
        final AtomicCount count = new AtomicCount(); // 1000000
        for (int i = 0; i &lt; 100; i++) &#123;
            new Thread(() -&gt; &#123;
                for (int j = 0; j &lt; 10000; j++) &#123;
                    count.add();
                &#125;
            &#125;).start();
        &#125;

        try &#123;
            Thread.sleep(5000L);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;

        System.out.println(&quot;num=&quot; + count.getNum());
    &#125;

&#125;
</code></pre>
<h4 id="LongAdder-对-AtomicLong-的改进"><a href="#LongAdder-对-AtomicLong-的改进" class="headerlink" title="LongAdder 对 AtomicLong 的改进"></a>LongAdder 对 AtomicLong 的改进</h4><pre><code class="prettyprint">LongAdder 的改进思路：
1、AtomicInteger 和 AtomicLong 里的 value 是所有
线程竞争读写的热点数据；
2、将单个 value 拆分成跟线程一样多的数组 Cell[]；
3、每个线程写自己的 Cell[i]++，最后对数组求和。
</code></pre>
</li>
</ul>
<h3 id="线程池相关类"><a href="#线程池相关类" class="headerlink" title="线程池相关类"></a>线程池相关类</h3><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><ul>
<li>单个线程&#x2F;任务的执行结果</li>
</ul>
<pre><code class="prettyprint">public class FutureDemo &#123;
    public static void main(String[] args) &#123;
        ExecutorService executor = Executors.newCachedThreadPool();
        Future&lt;Integer&gt; result = executor.submit(new Callable&lt;Integer&gt;() &#123;
            public Integer call() throws Exception &#123;
                return new Random().nextInt();
            &#125;
        &#125;);
        executor.shutdown();
        try &#123;
            System.out.println(&quot;result:&quot; + result.get());
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; catch (ExecutionException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><ul>
<li>单个线程&#x2F;任务的执行结果</li>
</ul>
<pre><code class="prettyprint">public class FutureTask &#123;
    public static void main(String[] args) &#123;
        //第一种方式
        FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123;
            @Override
            public Integer call() throws Exception &#123;
                return new Random().nextInt();
            &#125;
        &#125;);
        new Thread(task).start();
        //第二种方方式
//        ExecutorService executor = Executors.newSingleThreadExecutor();
//        FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123;
//            @Override
//            public Integer call() throws Exception &#123;
//                return new Random().nextInt();
//            &#125;
//        &#125;);
//        executor.submit(task);
        
        try &#123;
            System.out.println(&quot;result: &quot; + task.get());
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; catch (ExecutionException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    
&#125;
</code></pre>
<h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><ul>
<li>异步，回调，组合, 功能强大</li>
</ul>
<pre><code class="prettyprint">public class CompletableFutureDemo &#123;
    
    public static void main(String[] args)&#123;
        // 1.变换结果
        System.out.println(&quot;=====&gt;1.变换结果&quot;);
        String result1 = CompletableFuture.supplyAsync(()-&gt;&#123;
            return &quot;Hello &quot;;
        &#125;).thenApplyAsync(v -&gt; v + &quot;world&quot;)
                .join();
        System.out.println(result1);
        // 2.消费
        CompletableFuture.supplyAsync(()-&gt;&#123;return &quot;Hello &quot;;&#125;)
                .thenAccept(v -&gt; &#123;
                    System.out.println(&quot;=====&gt;2.消费&quot;);
                    System.out.println(&quot;consumer: &quot; + v);
                &#125;);
        
        // 3.组合
        System.out.println(&quot;=====&gt;3.组合&quot;);
        String result3 = CompletableFuture.supplyAsync(()-&gt;&#123;
            try &#123;
                Thread.sleep(1000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            return &quot;Hello&quot;;
        &#125;).thenCombine(CompletableFuture.supplyAsync(()-&gt;&#123;         
            try &#123;
                Thread.sleep(2000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            return &quot;world&quot;;
        &#125;),(s1,s2)-&gt;&#123;return s1 + &quot; &quot; + s2;&#125;).join();
        System.out.println(&quot;thenCombine:&quot;+result3);
    
        CompletableFuture.supplyAsync(() -&gt; &quot;Hello, java course.&quot;)
                .thenApply(String::toUpperCase).thenCompose(s -&gt; CompletableFuture.supplyAsync(s::toLowerCase))
                .thenAccept(v -&gt; &#123; System.out.println(&quot;thenCompose:&quot;+v);&#125;);
        // 4.竞争
        System.out.println(&quot;=====&gt;4.竞争&quot;);
        String result4 = CompletableFuture.supplyAsync(()-&gt;&#123;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            return &quot;Hi Boy&quot;;
        &#125;).applyToEither(CompletableFuture.supplyAsync(()-&gt;&#123;
            try &#123;
                Thread.sleep(300);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            return &quot;Hi Girl&quot;;
        &#125;),(s)-&gt;&#123;return s;&#125;).join();
        System.out.println(result4);
        // 5.补偿异常
        System.out.println(&quot;=====&gt;5.补偿异常&quot;);
        String result5 = CompletableFuture.supplyAsync(()-&gt;&#123;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            if(true) &#123;
                throw new RuntimeException(&quot;exception test!&quot;);
            &#125;
            return &quot;Hi Boy&quot;;
        &#125;).exceptionally(e-&gt;&#123;                // Fluent API      
            System.out.println(e.getMessage());
            return &quot;Hello world!&quot;;
        &#125;).join();
        System.out.println(result5); 
    &#125;   
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220528234046204.png" class="asset-class" title="image-20220528234046204">

<h3 id="信号量三种工具类"><a href="#信号量三种工具类" class="headerlink" title="信号量三种工具类"></a>信号量三种工具类</h3><h4 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore - 信号量"></a>Semaphore - 信号量</h4><ul>
<li>准入数量为N</li>
<li>N&#x3D;1时则等价于独占锁</li>
<li>使用场景，同一时间控制并发线程数</li>
</ul>
<pre><code class="prettyprint">public Semaphore(int permits) &#123;          //参数permits表示许可数目，即同时可以允许多少线程进行访问
    sync = new NonfairSync(permits);
&#125;
public Semaphore(int permits, boolean fair) &#123;    //这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可
    sync = (fair)? new FairSync(permits) : new NonfairSync(permits);
&#125;
public void acquire() throws InterruptedException &#123;  &#125;     //获取一个许可
public void acquire(int permits) throws InterruptedException &#123; &#125;    //获取permits个许可
public void release() &#123; &#125;          //释放一个许可
public void release(int permits) &#123; &#125;    //释放permits个许可
</code></pre>
<p>代码示例<code>SemaphoreDemo</code></p>
<pre><code class="prettyprint">public class SemaphoreDemo &#123;
    
    public static void main(String[] args) &#123;
        int N = 8;            //工人数
        Semaphore semaphore = new Semaphore(2); //机器数目
        for (int i = 0; i &lt; N; i++)
            new Worker(i, semaphore).start();
    &#125;
    static class Worker extends Thread &#123;
        private int num;
        private Semaphore semaphore;
        public Worker(int num, Semaphore semaphore) &#123;
            this.num = num;
            this.semaphore = semaphore;
        &#125;
        @Override
        public void run() &#123;
            try &#123;
                semaphore.acquire();  // 在子线程里控制资源占用
                System.out.println(&quot;工人&quot; + this.num + &quot;占用一个机器在生产...&quot;);
                Thread.sleep(2000);
                System.out.println(&quot;工人&quot; + this.num + &quot;释放出机器&quot;);
                semaphore.release();   // 在子线程里控制释放资源占用
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220528231859010.png" class="asset-class" title="image-20220528231859010">

<p>代码示例<code>SemaphoreDemo2</code>获取多个许可</p>
<pre><code class="prettyprint">public class SemaphoreDemo2 &#123;
    private final static int threadCount = 20;
    public static void main(String[] args) throws Exception &#123;
        ExecutorService exec = Executors.newCachedThreadPool();
        final Semaphore semaphore = new Semaphore(7);
        for (int i = 0; i &lt; threadCount; i++) &#123;
            final int threadNum = i;
            exec.execute(() -&gt; &#123;
                try &#123;
                    semaphore.acquire(3); // 获取全部许可，退化成串行执行
                    test(threadNum);
                    semaphore.release(3); // 释放多个许可
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;);
        &#125;
        exec.shutdown();
    &#125;
    private static void test(int threadNum) throws Exception &#123;
        System.out.println(&quot;id:&quot; + threadNum + &quot;,&quot; + Thread.currentThread().getName());
        Thread.sleep(1000);
    &#125;
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220528232146316.png" class="asset-class" title="image-20220528232146316">

<h4 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h4><p>Master 线程等待 Worker 线程把任务执行完（做减号，只能使用一次,在主线程await()）</p>
<pre><code class="prettyprint">public CountDownLatch(int count) &#123;  &#125;;  //参数count为计数值
public void await() throws InterruptedException &#123; &#125;;//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;;  //和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行
public void countDown() &#123; &#125;;  //将count值减1
</code></pre>
<p>代码示例<code>CountDownLatchDemo</code></p>
<pre><code class="prettyprint">public class CountDownLatchDemo &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        CountDownLatch countDownLatch = new CountDownLatch(5);
        for(int i=0;i&lt;5;i++)&#123;
            new Thread(new readNum(i,countDownLatch)).start();
        &#125;
        countDownLatch.await(); // 注意跟CyclicBarrier不同，这里在主线程await
        System.out.println(&quot;==&gt;各个子线程执行结束。。。。&quot;);
        System.out.println(&quot;==&gt;主线程执行结束。。。。&quot;);
    &#125;
    static class readNum  implements Runnable&#123;
        private int id;
        private CountDownLatch latch;
        public readNum(int id,CountDownLatch latch)&#123;
            this.id = id;
            this.latch = latch;
        &#125;
        @Override
        public void run() &#123;
            synchronized (this)&#123;
                System.out.println(&quot;id:&quot;+id+&quot;,&quot;+Thread.currentThread().getName());
                //latch.countDown();
                System.out.println(&quot;线程组任务&quot;+id+&quot;结束，其他任务继续&quot;);
                latch.countDown();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220528232409607.png" class="asset-class" title="image-20220528232409607">

<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>任务执行到一定阶段, 等待其他任务对齐(做加号，可再次使用,在子线程await()通过回调判断)</p>
<pre><code class="prettyprint">public CyclicBarrier(int parties, Runnable barrierAction) &#123;&#125;//parties：让多少个线程或者任务等待至barrier状态，barrierAction：parties线程结束的回调
public CyclicBarrier(int parties) &#123;&#125;//parties：让多少个线程或者任务等待至barrier状态
public int await() throws InterruptedException, BrokenBarrierException &#123; &#125;;//来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务；
public int await(long timeout, TimeUnit unit)throws InterruptedException,BrokenBarrierException,TimeoutException &#123; &#125;;//这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务
</code></pre>
<p>代码示例<code>CyclicBarrierDemo</code></p>
<pre><code class="prettyprint">public class CyclicBarrierDemo &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        CyclicBarrier cyclicBarrier = new CyclicBarrier(5, new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;回调&gt;&gt;&quot;+Thread.currentThread().getName());
                System.out.println(&quot;回调&gt;&gt;线程组执行结束&quot;);
                System.out.println(&quot;==&gt;各个子线程执行结束。。。。&quot;);
            &#125;
        &#125;);
        for (int i = 0; i &lt; 5; i++) &#123;
            new Thread(new readNum(i,cyclicBarrier)).start();
        &#125;
        
        System.out.println(&quot;==&gt;主线程执行结束。。。。&quot;);
        
        //CyclicBarrier 可以重复利用，
        // 这个是CountDownLatch做不到的
//        for (int i = 11; i &lt; 16; i++) &#123;
//            new Thread(new readNum(i,cyclicBarrier)).start();
//        &#125;
    &#125;
    static class readNum  implements Runnable&#123;
        private int id;
        private CyclicBarrier cyc;
        public readNum(int id,CyclicBarrier cyc)&#123;
            this.id = id;
            this.cyc = cyc;
        &#125;
        @Override
        public void run() &#123;
            synchronized (this)&#123;
                System.out.println(&quot;id:&quot;+id+&quot;,&quot;+Thread.currentThread().getName());
                try &#123;
                    cyc.await();
                    System.out.println(&quot;线程组任务&quot; + id + &quot;结束，其他任务继续&quot;);
//                    cyc.await();   // 注意跟CountDownLatch不同，这里在子线程await
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220528232738351.png" class="asset-class" title="image-20220528232738351">

<p>代码示例<code>CyclicBarrierDemo2</code></p>
<pre><code class="prettyprint">public class CyclicBarrierDemo2 &#123;
    public static void main(String[] args) &#123;
        int N = 4;
        CyclicBarrier barrier  = new CyclicBarrier(N);
        for(int i=0;i&lt;N;i++) &#123;
            new Writer(barrier).start();
        &#125;
        try &#123;
            Thread.sleep(10000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;====&gt;  CyclicBarrier重用&quot;);
        
        for(int i=0;i&lt;N;i++) &#123;
            new Writer(barrier).start();
        &#125;
    &#125;
    static class Writer extends Thread&#123;
        private CyclicBarrier cyclicBarrier;
        public Writer(CyclicBarrier cyclicBarrier) &#123;
            this.cyclicBarrier = cyclicBarrier;
        &#125;
        @Override
        public void run() &#123;
            System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;正在写入数据...&quot;);
            try &#123;
                Thread.sleep(3000);      //以睡眠来模拟写入数据操作
                System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);
                
                cyclicBarrier.await();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;catch(BrokenBarrierException e)&#123;
                e.printStackTrace();
            &#125;
            System.out.println(Thread.currentThread().getName()+&quot;所有线程写入完毕，继续处理其他任务...&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220528232836700.png" class="asset-class" title="image-20220528232836700">

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><img src="/2022/05/28/java-bing-fa/image-20220528232908736.png" class="asset-class" title="image-20220528232908736">

<ul>
<li>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：	<ul>
<li>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；</li>
<li>而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</li>
</ul>
</li>
</ul>
<p>　　　　另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。</p>
<ul>
<li>Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</li>
</ul>
<h3 id="并发集合类"><a href="#并发集合类" class="headerlink" title="并发集合类"></a>并发集合类</h3><h4 id="List线程安全"><a href="#List线程安全" class="headerlink" title="List线程安全"></a>List线程安全</h4><p>既然线程安全是写冲突和读写冲突导致的 最简单办法就是，读写都加锁</p>
<ul>
<li><p>ArrayList 的方法都加上 synchronized -&gt; Vector</p>
</li>
<li><p>Collections.synchronizedList，强制将 List 的操作加上同步</p>
</li>
<li><p>Arrays.asList，不允许添加删除，但是可以 set 替换元素</p>
</li>
<li><p>Collections.unmodifiableList，不允许修改内容，包括添加删除和 set</p>
</li>
</ul>
<pre><code class="prettyprint">public class SyncListDemo &#123;
    public static void main(String[] args) &#123;
        List list0 = Arrays.asList(1,2,3,4,5,6,7,8,8);
        list0.set(8,9);        // 可以修改内容，不能变动元素数量
        // list0.add(10)  will throw an error
        
        List list = new ArrayList(); // 正常List，可以操作
        list.addAll(list0);
        List list1 = Collections.synchronizedList(list);
        // 多线程操作
        // to do something
        System.out.println(Arrays.toString(list1.toArray()));
        
        Collections.shuffle(list1);
        System.out.println(Arrays.toString(list1.toArray()));
        
        // 假如不再修改
        List list2 = Collections.unmodifiableList(list1);
        System.out.println(list2.getClass());
        
        list2.set(8,10);
        System.out.println(Arrays.toString(list2.toArray()));
        
        list2.add(11);
        System.out.println(Arrays.toString(list2.toArray()));
    &#125; 
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220528234607137.png" class="asset-class" title="image-20220528234607137">

<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><ul>
<li><p>写加锁，保证不会写混乱</p>
</li>
<li><p>写在一个 Copy 副本上，而不是原始数据上(读写分离，最终一致)</p>
</li>
<li><p><code>add</code> 插入元素时，在新副本操作，不影响旧引用</p>
<pre><code class="prettyprint">public boolean add(E e) &#123;
    final ReentrantLock lock = this.lock;
    lock.lock();
    try &#123;
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    &#125; finally &#123;
        lock.unlock();
    &#125;
&#125;
</code></pre>
</li>
<li><p><code>remove</code> 删除末尾元素，直接 使用前 N-1 个元素创建 一个新数组；删除其他位置元素， 创建新数组，将剩余元素 复制到新数组</p>
<pre><code class="prettyprint">public E remove(int index) &#123;
    final ReentrantLock lock = this.lock;
    lock.lock();
    try &#123;
        Object[] elements = getArray();
        int len = elements.length;
        E oldValue = get(elements, index);
        int numMoved = len - index - 1;
        if (numMoved == 0)
            setArray(Arrays.copyOf(elements, len - 1));
        else &#123;
            Object[] newElements = new Object[len - 1];
            System.arraycopy(elements, 0, newElements, 0, index);
            System.arraycopy(elements, index + 1, newElements, index,
                             numMoved);
            setArray(newElements);
        &#125;
        return oldValue;
    &#125; finally &#123;
        lock.unlock();
    &#125;
&#125;
</code></pre>
</li>
<li><p><code>get</code> 读取无需加锁</p>
<pre><code class="prettyprint">private E get(Object[] a, int index) &#123;
    return (E) a[index];
&#125;

/**
     * &#123;@inheritDoc&#125;
     *
     * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;
     */
public E get(int index) &#123;
    return get(getArray(), index);
&#125;
</code></pre>
</li>
<li><p><code>COWIterator</code> 使用迭代器，直接拿当前的数组对象做 一个快照，此后的 List 元素变动，就跟这次迭代 没关系了</p>
<ul>
<li><p>获取迭代器</p>
<pre><code class="prettyprint"> public Iterator&lt;E&gt; iterator() &#123;
     return new COWIterator&lt;E&gt;(getArray(), 0);
 &#125;

/**
     * &#123;@inheritDoc&#125;
     *
     * &lt;p&gt;The returned iterator provides a snapshot of the state of the list
     * when the iterator was constructed. No synchronization is needed while
     * traversing the iterator. The iterator does &lt;em&gt;NOT&lt;/em&gt; support the
     * &#123;@code remove&#125;, &#123;@code set&#125; or &#123;@code add&#125; methods.
     */
public ListIterator&lt;E&gt; listIterator() &#123;
    return new COWIterator&lt;E&gt;(getArray(), 0);
&#125;
</code></pre>
</li>
</ul>
<p><code>COWIterator</code></p>
<pre><code class="prettyprint">static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;
    /** Snapshot of the array 快照*/
    private final Object[] snapshot; 
    /** Index of element to be returned by subsequent call to next.  */
    private int cursor;

    private COWIterator(Object[] elements, int initialCursor) &#123;
        cursor = initialCursor;
        snapshot = elements;
    &#125;

    public boolean hasNext() &#123;
        return cursor &lt; snapshot.length;
    &#125;

    public boolean hasPrevious() &#123;
        return cursor &gt; 0;
    &#125;

    @SuppressWarnings(&quot;unchecked&quot;)
    public E next() &#123;
        if (! hasNext())
            throw new NoSuchElementException();
        return (E) snapshot[cursor++];
    &#125;

    @SuppressWarnings(&quot;unchecked&quot;)
    public E previous() &#123;
        if (! hasPrevious())
            throw new NoSuchElementException();
        return (E) snapshot[--cursor];
    &#125;

    public int nextIndex() &#123;
        return cursor;
    &#125;

    public int previousIndex() &#123;
        return cursor-1;
    &#125;

    /**
         * Not supported. Always throws UnsupportedOperationException.
         * @throws UnsupportedOperationException always; &#123;@code remove&#125;
         *         is not supported by this iterator.
         */
    public void remove() &#123;
        throw new UnsupportedOperationException();
    &#125;

    /**
         * Not supported. Always throws UnsupportedOperationException.
         * @throws UnsupportedOperationException always; &#123;@code set&#125;
         *         is not supported by this iterator.
         */
    public void set(E e) &#123;
        throw new UnsupportedOperationException();
    &#125;

    /**
         * Not supported. Always throws UnsupportedOperationException.
         * @throws UnsupportedOperationException always; &#123;@code add&#125;
         *         is not supported by this iterator.
         */
    public void add(E e) &#123;
        throw new UnsupportedOperationException();
    &#125;

    @Override
    public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;
        Objects.requireNonNull(action);
        Object[] elements = snapshot;
        final int size = elements.length;
        for (int i = cursor; i &lt; size; i++) &#123;
            @SuppressWarnings(&quot;unchecked&quot;) E e = (E) elements[i];
            action.accept(e);
        &#125;
        cursor = size;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><h5 id="Java7-分段锁"><a href="#Java7-分段锁" class="headerlink" title="Java7 分段锁"></a>Java7 分段锁</h5><ul>
<li>默认16个Segment，降低锁粒度。 concurrentLevel &#x3D; 16</li>
</ul>
<img src="/2022/05/28/java-bing-fa/image-20220528235452123.png" class="asset-class" title="image-20220528235452123">

<h5 id="Java8-自旋"><a href="#Java8-自旋" class="headerlink" title="Java8-自旋"></a>Java8-自旋</h5><img src="/2022/05/28/java-bing-fa/image-20220528235602891.png" class="asset-class" title="image-20220528235602891">

<pre><code class="prettyprint">public class ConcurrentHashMapDemo &#123;
    
    public static void main(String[] args) &#123;
        demo1();
    &#125;
    public static void demo1() &#123;
        final Map&lt;String, AtomicInteger&gt; count = new ConcurrentHashMap&lt;&gt;();
        final CountDownLatch endLatch = new CountDownLatch(2);
        Runnable task = new Runnable() &#123;
            @Override
            public void run() &#123;
                AtomicInteger oldValue;
                for (int i = 0; i &lt; 5; i++) &#123;
                    oldValue = count.get(&quot;a&quot;);
                    if (null == oldValue) &#123;
                        AtomicInteger zeroValue = new AtomicInteger(0);
                        oldValue = count.putIfAbsent(&quot;a&quot;, zeroValue);
                        if (null == oldValue) &#123;
                            oldValue = zeroValue;
                        &#125;
                    &#125;
                    oldValue.incrementAndGet();
                &#125;
                endLatch.countDown();
            &#125;
        &#125;;
        new Thread(task).start();
        new Thread(task).start();
        try &#123;
            endLatch.await();
            System.out.println(count);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><ul>
<li><p>常用方法</p>
<ul>
<li><p><code>public ThreadLocal()</code>构造方法 </p>
</li>
<li><p><code>protected T initialValue()</code> 覆写-设置初始默认值 </p>
</li>
<li><p><code>void set(T value)</code> 设置本线程对应的值 </p>
</li>
<li><p><code>void remove()</code> 清理本线程对应的值 </p>
</li>
<li><p><code>T get()</code> 获取本线程对应的值</p>
</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li>线程本地变量 </li>
<li>场景: 每个线程一个副本 </li>
<li>不改方法签名静默传参 </li>
<li>及时进行清理</li>
</ul>
</li>
<li><p>可以看做是 Context 模式，减少显式传递参数</p>
</li>
</ul>
<pre><code class="prettyprint">public class ThreadLocalDemo &#123;
    
    private static ThreadLocal&lt;Integer&gt; seqNum = new ThreadLocal&lt;Integer&gt;() &#123;
        public Integer initialValue() &#123;
            return 0;
        &#125;
    &#125;;
    public ThreadLocal&lt;Integer&gt; getThreadLocal() &#123;
        return seqNum;
    &#125;
    public int getNextNum() &#123;
        seqNum.set(seqNum.get() + 1);
        return seqNum.get();
    &#125;
    public static void main(String[] args) &#123;
        ThreadLocalDemo threadLocalMain = new ThreadLocalDemo();
    
        SnThread client1 = new SnThread(threadLocalMain);
        SnThread client2 = new SnThread(threadLocalMain);
        SnThread client3 = new SnThread(threadLocalMain);
        
        client1.start();
        client2.start();
        client3.start();
    &#125;
    private static class SnThread extends Thread &#123;
        private ThreadLocalDemo sn;
        public SnThread(ThreadLocalDemo sn) &#123;
            this.sn = sn;
        &#125;
        public void run() &#123;
            for (int i = 0; i &lt; 3; i++) &#123;
                System.out.println(&quot;thread[&quot; + Thread.currentThread().getName() + &quot;] ---&gt; sn [&quot; + sn.getNextNum() + &quot;]&quot;);
            &#125;
            sn.getThreadLocal().remove();
        &#125;
    &#125;
&#125;
</code></pre>
<img src="/2022/05/28/java-bing-fa/image-20220529000224433.png" class="asset-class" title="image-20220529000224433">

<h2 id="并行Stream"><a href="#并行Stream" class="headerlink" title="并行Stream"></a>并行Stream</h2><pre><code class="prettyprint">public class StreamParallelDemo &#123;
    public static void main(String[] args) &#123;
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        IntStream.range(1, 10000).forEach(i -&gt; list.add(i));
        BlockingQueue&lt;Long&gt; blockingQueue = new LinkedBlockingQueue(10000);
        List&lt;Long&gt; longList = list.stream().parallel()
                .map(i -&gt; i.longValue())
                .sorted()
                .collect(Collectors.toList());
//      // 串行，单线程
//      longList.stream().forEach(
        // 并行，默认使用CPU * 2个线程
        longList.stream().parallel().forEach(
                i -&gt; &#123;
            try &#123;
                blockingQueue.put(i);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;);
        System.out.println(&quot;blockingQueue:&quot; + blockingQueue.toString());
    &#125;   
&#125;
</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置学习</title>
    <url>/2022/06/05/nginx-pei-zhi-xue-xi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>Nginx</code> 是开源、高性能、高可靠的 <code>Web</code> 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，即使运行几个月也不需要重新启动，还能在不间断服务的情况下对软件版本进行热更新。性能是 <code>Nginx</code> 最重要的考量，其占用内存少、并发能力强、能支持高达 5w 个并发连接数，最重要的是， <code>Nginx</code> 是免费的并可以商业化，配置使用也比较简单。</p>
<p><strong>Nginx 特点</strong></p>
<ul>
<li>高并发、高性能；</li>
<li>模块化架构使得它的扩展性非常好；</li>
<li>异步非阻塞的事件驱动模型这点和 <code>Node.js</code> 相似；</li>
<li>相对于其它服务器来说它可以连续几个月甚至更长而不需要重启服务器使得它具有高可靠性；</li>
<li>热部署、平滑升级；</li>
<li>完全开源，生态繁荣；</li>
</ul>
<h1 id="Nginx-作用"><a href="#Nginx-作用" class="headerlink" title="Nginx 作用"></a>Nginx 作用</h1><p>Nginx 的最重要的几个使用场景：</p>
<ol>
<li>静态资源服务，通过本地文件系统提供服务；</li>
<li>反向代理服务，延伸出包括缓存、负载均衡等；</li>
<li><code>API</code> 服务， <code>OpenResty</code> ；</li>
</ol>
<p>对于前端来说 <code>Node.js</code> 并不陌生， <code>Nginx</code> 和 <code>Node.js</code> 的很多理念类似， <code>HTTP</code> 服务器、事件驱动、异步非阻塞等，且 <code>Nginx</code> 的大部分功能使用 <code>Node.js</code> 也可以实现，但 <code>Nginx</code> 和<code>Node.js</code> 并不冲突，都有自己擅长的领域。<code>Nginx</code> 擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等）， <code>Node.js</code> 更擅长上层具体业务逻辑的处理，两者可以完美组合。</p>
<p>用一张图表示：</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640.png" class="asset-class" title="图片">

<p><strong>Nginx 安装</strong></p>
<p>本文演示的是 <code>Linux</code> <code>centOS 7.x</code> 的操作系统上安装 <code>Nginx</code> ，至于在其它操作系统上进行安装可以网上自行搜索，都非常简单的。</p>
<p>使用 <code>yum</code> 安装 <code>Nginx</code> ：</p>
<pre><code>yum install nginx -y
</code></pre>
<p>安装完成后，通过 <code>rpm \-ql nginx</code> 命令查看 <code>Nginx</code> 的安装信息：</p>
<pre><code># Nginx配置文件
/etc/nginx/nginx.conf # nginx 主配置文件
/etc/nginx/nginx.conf.default

# 可执行程序文件
/usr/bin/nginx-upgrade
/usr/sbin/nginx

# nginx库文件
/usr/lib/systemd/system/nginx.service # 用于配置系统守护进程
/usr/lib64/nginx/modules # Nginx模块目录

# 帮助文档
/usr/share/doc/nginx-1.16.1
/usr/share/doc/nginx-1.16.1/CHANGES
/usr/share/doc/nginx-1.16.1/README
/usr/share/doc/nginx-1.16.1/README.dynamic
/usr/share/doc/nginx-1.16.1/UPGRADE-NOTES-1.6-to-1.10

# 静态资源目录
/usr/share/nginx/html/404.html
/usr/share/nginx/html/50x.html
/usr/share/nginx/html/index.html

# 存放Nginx日志文件
/var/log/nginx
</code></pre>
<p>主要关注的文件夹有两个：</p>
<p><code>1. /etc/nginx/conf.d/</code> 是子配置项存放处， <code>/etc/nginx/nginx.conf</code> 主配置文件会默认把这个文件夹中所有子配置项都引入；</p>
<p><code>2. /usr/share/nginx/html/</code> 静态文件都放在这个文件夹，也可以根据你自己的习惯放在其他地方；</p>
<p><strong>Nginx 常用命令</strong></p>
<p><code>systemctl</code> 系统命令：</p>
<pre><code># 开机配置
systemctl enable nginx # 开机自动启动
systemctl disable nginx # 关闭开机自动启动

# 启动Nginx
systemctl start nginx # 启动Nginx成功后，可以直接访问主机IP，此时会展示Nginx默认页面

# 停止Nginx
systemctl stop nginx

# 重启Nginx
systemctl restart nginx

# 重新加载Nginx
systemctl reload nginx

# 查看 Nginx 运行状态
systemctl status nginx

# 查看Nginx进程
ps -ef | grep nginx

# 杀死Nginx进程
kill -9 pid # 根据上面查看到的Nginx进程号，杀死Nginx进程，-9 表示强制结束进程
</code></pre>
<p><code>Nginx</code> 应用程序命令：</p>
<pre><code>nginx -s reload # 向主进程发送信号，重新加载配置文件，热重启
nginx -s reopen # 重启 Nginx
nginx -s stop # 快速关闭
nginx -s quit # 等待工作进程处理完成后关闭
nginx -T # 查看当前 Nginx 最终的配置
nginx -t # 检查配置是否有问题
</code></pre>
<h1 id="Nginx-核心配置"><a href="#Nginx-核心配置" class="headerlink" title="Nginx 核心配置"></a>Nginx 核心配置</h1><h2 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h2><p><code>Nginx</code> 的典型配置示例：</p>
<pre><code># main段配置信息
user  nginx; # 运行用户，默认即是nginx，可以不进行设置
worker_processes  auto; # Nginx 进程数，一般设置为和 CPU 核数一样
error_log  /var/log/nginx/error.log warn; # Nginx 的错误日志存放目录
pid        /var/run/nginx.pid; # Nginx 服务启动时的 pid 存放位置

# events段配置信息
events &#123;
    use epoll; # 使用epoll的I/O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的)
    worker_connections 1024; # 每个进程允许最大并发数
&#125;

# http段配置信息
# 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置
http &#123; 
    # 设置日志模式
    log_format  main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;

    access_log  /var/log/nginx/access.log main; # Nginx访问日志存放位置

    sendfile            on; # 开启高效传输模式
    tcp_nopush          on; # 减少网络报文段的数量
    tcp_nodelay         on;
    keepalive_timeout   65; # 保持连接的时间，也叫超时时间，单位秒
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types; # 文件扩展名与类型映射表
    default_type        application/octet-stream; # 默认文件类型

    include /etc/nginx/conf.d/*.conf; # 加载子配置项
    
    # server段配置信息
    server &#123;
     listen       80; # 配置监听的端口
     server_name  localhost; # 配置的域名
      
     # location段配置信息
     location / &#123;
      root   /usr/share/nginx/html; # 网站根目录
      index  index.html index.htm; # 默认首页文件
      deny 172.168.22.11; # 禁止访问的ip地址，可以为all
      allow 172.168.33.44；# 允许访问的ip地址，可以为all
     &#125;
     
     error_page 500 502 503 504 /50x.html; # 默认50x对应的访问页面
     error_page 400 404 error.html; # 同上
    &#125;
&#125;
</code></pre>
<ul>
<li>全局配置，对全局生效；</li>
<li><code>events</code> 配置影响 <code>Nginx</code> 服务器与用户的网络连接；</li>
<li><code>http</code> 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置；</li>
<li><code>server</code> 配置虚拟主机的相关参数，一个 <code>http</code> 块中可以有多个 <code>server</code> 块；</li>
<li><code>location</code> 用于配置匹配的 <code>uri</code> ；</li>
<li><code>upstream</code> 配置后端服务器具体地址，负载均衡配置不可或缺的部分；</li>
</ul>
<p>用一张图清晰的展示它的层级结构：</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550491.png" class="asset-class" title="图片">

<h2 id="配置文件-main-段核心参数"><a href="#配置文件-main-段核心参数" class="headerlink" title="配置文件 main 段核心参数"></a>配置文件 main 段核心参数</h2><h2 id="user"><a href="#user" class="headerlink" title="user"></a>user</h2><p>指定运行 <code>Nginx</code> 的 <code>woker</code> 子进程的属主和属组，其中组可以不指定。</p>
<pre><code>user USERNAME [GROUP]

user nginx lion; # 用户是nginx;组是lion
</code></pre>
<p><strong>pid</strong></p>
<p>指定运行 <code>Nginx</code> <code>master</code> 主进程的 <code>pid</code> 文件存放路径。</p>
<pre><code>pid /opt/nginx/logs/nginx.pid # master主进程的的pid存放在nginx.pid的文件
</code></pre>
<h3 id="worker-rlimit-nofile-number"><a href="#worker-rlimit-nofile-number" class="headerlink" title="worker_rlimit_nofile_number"></a>worker_rlimit_nofile_number</h3><p>指定 <code>worker</code> 子进程可以打开的最大文件句柄数。</p>
<pre><code>worker_rlimit_nofile 20480; # 可以理解成每个worker子进程的最大连接数量。
</code></pre>
<p><strong>worker_rlimit_core</strong></p>
<p>指定 <code>worker</code> 子进程异常终止后的 <code>core</code> 文件，用于记录分析问题。</p>
<pre><code>worker_rlimit_core 50M; # 存放大小限制
working_directory /opt/nginx/tmp; # 存放目录
</code></pre>
<h3 id="worker-processes-number"><a href="#worker-processes-number" class="headerlink" title="worker_processes_number"></a>worker_processes_number</h3><p>指定 <code>Nginx</code> 启动的 <code>worker</code> 子进程数量。</p>
<pre><code>worker_processes 4; # 指定具体子进程数量
worker_processes auto; # 与当前cpu物理核心数一致
</code></pre>
<h3 id="worker-cpu-affinity"><a href="#worker-cpu-affinity" class="headerlink" title="worker_cpu_affinity"></a>worker_cpu_affinity</h3><p>将每个 <code>worker</code> 子进程与我们的 <code>cpu</code> 物理核心绑定。</p>
<pre><code>worker_cpu_affinity 0001 0010 0100 1000; # 4个物理核心，4个worker子进程
</code></pre>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550492.png" class="asset-class" title="图片">



<p>将每个 <code>worker</code> 子进程与特定 <code>CPU</code> 物理核心绑定，优势在于，避免同一个 <code>worker</code> 子进程在不同的 <code>CPU</code> 核心上切换，缓存失效，降低性能。但其并不能真正的避免进程切换。</p>
<p><strong>worker_priority</strong></p>
<p>指定 <code>worker</code> 子进程的 <code>nice</code> 值，以调整运行 <code>Nginx</code> 的优先级，通常设定为负值，以优先调用<code>Nginx</code> 。</p>
<pre><code>worker_priority -10; # 120-10=110，110就是最终的优先级
</code></pre>
<p><code>Linux</code> 默认进程的优先级值是120，值越小越优先；<code>nice</code> 定范围为 <code>-20</code> 到 <code>+19</code> 。</p>
<p>[备注] 应用的默认优先级值是120加上 <code>nice</code> 值等于它最终的值，这个值越小，优先级越高。</p>
<h3 id="worker-shutdown-timeout"><a href="#worker-shutdown-timeout" class="headerlink" title="worker_shutdown_timeout"></a>worker_shutdown_timeout</h3><p>指定 <code>worker</code> 子进程优雅退出时的超时时间。</p>
<pre><code>worker_shutdown_timeout 5s;
</code></pre>
<h3 id="timer-resolution"><a href="#timer-resolution" class="headerlink" title="timer_resolution"></a>timer_resolution</h3><p><code>worker</code> 子进程内部使用的计时器精度，调整时间间隔越大，系统调用越少，有利于性能提升；反之，系统调用越多，性能下降。</p>
<pre><code>timer_resolution 100ms;
</code></pre>
<p>在 <code>Linux</code> 系统中，用户需要获取计时器时需要向操作系统内核发送请求，有请求就必然会有开销，因此这个间隔越大开销就越小。</p>
<p><strong>daemon</strong></p>
<p>指定 <code>Nginx</code> 的运行方式，前台还是后台，前台用于调试，后台用于生产。</p>
<pre><code>daemon off; # 默认是on，后台运行模式
</code></pre>
<h2 id="配置文件-events-段核心参数"><a href="#配置文件-events-段核心参数" class="headerlink" title="配置文件 events 段核心参数"></a>配置文件 events 段核心参数</h2><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p><code>Nginx</code> 使用何种事件驱动模型。</p>
<pre><code>use method; # 不推荐配置它，让nginx自己选择

method 可选值为：select、poll、kqueue、epoll、/dev/poll、eventport
</code></pre>
<h3 id="worker-connections"><a href="#worker-connections" class="headerlink" title="worker_connections"></a>worker_connections</h3><p><code>worker</code> 子进程能够处理的最大并发连接数。</p>
<pre><code>worker_connections 1024 # 每个子进程的最大连接数为1024
</code></pre>
<p><strong>accept_mutex</strong></p>
<p>是否打开负载均衡互斥锁。</p>
<pre><code>accept_mutex on # 默认是off关闭的，这里推荐打开
</code></pre>
<p><strong>server_name 指令</strong></p>
<p>指定虚拟主机域名。</p>
<pre><code>server_name name1 name2 name3

# 示例：
server_name www.nginx.com;
</code></pre>
<p>域名匹配的四种写法：</p>
<ul>
<li>精确匹配：<code>server_name www.nginx.com</code> ;</li>
<li>左侧通配：<code>server_name *.nginx.com</code> ;</li>
<li>右侧统配：<code>server_name www.nginx.*</code> ;</li>
<li>正则匹配：<code>server_name ~^www\.nginx\.*$</code> ;</li>
</ul>
<p>匹配优先级：<strong>精确匹配 &gt; 左侧通配符匹配 &gt; 右侧通配符匹配 &gt; 正则表达式匹配</strong></p>
<p><code>server_name</code> 配置实例：</p>
<p>1、配置本地 <code>DNS</code> 解析 <code>vim /etc/hosts</code> （ <code>macOS</code> 系统）</p>
<pre><code># 添加如下内容，其中 121.42.11.34 是阿里云服务器IP地址
121.42.11.34 www.nginx-test.com
121.42.11.34 mail.nginx-test.com
121.42.11.34 www.nginx-test.org
121.42.11.34 doc.nginx-test.com
121.42.11.34 www.nginx-test.cn
121.42.11.34 fe.nginx-test.club
</code></pre>
<p>[注意] 这里使用的是虚拟域名进行测试，因此需要配置本地 <code>DNS</code> 解析，如果使用阿里云上购买的域名，则需要在阿里云上设置好域名解析。</p>
<p>2、配置阿里云 <code>Nginx</code> ，<code>vim /etc/nginx/nginx.conf</code></p>
<pre><code># 这里只列举了http端中的sever端配置

# 左匹配
server &#123;
 listen 80;
 server_name *.nginx-test.com;
 root /usr/share/nginx/html/nginx-test/left-match/;
 location / &#123;
  index index.html;
 &#125;
&#125;

# 正则匹配
server &#123;
 listen 80;
 server_name ~^.*\.nginx-test\..*$;
 root /usr/share/nginx/html/nginx-test/reg-match/;
 location / &#123;
  index index.html;
 &#125;
&#125;

# 右匹配
server &#123;
 listen 80;
 server_name www.nginx-test.*;
 root /usr/share/nginx/html/nginx-test/right-match/;
 location / &#123;
  index index.html;
 &#125;
&#125;

# 完全匹配
server &#123;
 listen 80;
 server_name www.nginx-test.com;
 root /usr/share/nginx/html/nginx-test/all-match/;
 location / &#123;
  index index.html;
 &#125;
&#125;
</code></pre>
<p>3、访问分析</p>
<ul>
<li>当访问 <code>www.nginx-test.com</code> 时，都可以被匹配上，因此选择优先级最高的“完全匹配”；</li>
<li>当访问 <code>mail.nginx-test.com</code> 时，会进行“左匹配”；</li>
<li>当访问 <code>www.nginx-test.org</code> 时，会进行“右匹配”；</li>
<li>当访问 <code>doc.nginx-test.com</code> 时，会进行“左匹配”；</li>
<li>当访问 <code>www.nginx-test.cn</code> 时，会进行“右匹配”；</li>
<li>当访问 <code>fe.nginx-test.club</code> 时，会进行“正则匹配”；</li>
</ul>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>指定静态资源目录位置，它可以写在 <code>http</code> 、 <code>server</code> 、 <code>location</code> 等配置中。</p>
<pre><code>root path

例如：
location /image &#123;
 root /opt/nginx/static;
&#125;

当用户访问 www.test.com/image/1.png 时，实际在服务器找的路径是 /opt/nginx/static/image/1.png
</code></pre>
<p>[注意] <code>root</code> 会将定义路径与 <code>URI</code> 叠加， <code>alias</code> 则只取定义路径。</p>
<h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>它也是指定静态资源目录位置，它只能写在 <code>location</code> 中。</p>
<pre><code>location /image &#123;
 alias /opt/nginx/static/image/;
&#125;

当用户访问 www.test.com/image/1.png 时，实际在服务器找的路径是 /opt/nginx/static/image/1.png
</code></pre>
<p>[注意] 使用 alias 末尾一定要添加 <code>/</code> ，并且它只能位于 <code>location</code> 中。</p>
<p><strong>location</strong></p>
<p>配置路径。</p>
<pre><code>location [ = | ~ | ~* | ^~ ] uri &#123;
 ...
&#125;
</code></pre>
<p>匹配规则：</p>
<ul>
<li><code>=</code> 精确匹配；</li>
<li><code>~</code> 正则匹配，区分大小写；</li>
<li><code>~*</code> 正则匹配，不区分大小写；</li>
<li><code>^~</code> 匹配到即停止搜索；</li>
</ul>
<p>匹配优先级：<code>=</code> &gt; <code>^~</code> &gt; <code>~</code> &gt; <code>~*</code> &gt; 不带任何字符。</p>
<p>实例：</p>
<pre><code>server &#123;
  listen 80;
  server_name www.nginx-test.com;
  
  # 只有当访问 www.nginx-test.com/match_all/ 时才会匹配到/usr/share/nginx/html/match_all/index.html
  location = /match_all/ &#123;
      root /usr/share/nginx/html
      index index.html
  &#125;
  
  # 当访问 www.nginx-test.com/1.jpg 等路径时会去 /usr/share/nginx/images/1.jpg 找对应的资源
  location ~ \.(jpeg|jpg|png|svg)$ &#123;
   root /usr/share/nginx/images;
  &#125;
  
  # 当访问 www.nginx-test.com/bbs/ 时会匹配上 /usr/share/nginx/html/bbs/index.html
  location ^~ /bbs/ &#123;
   root /usr/share/nginx/html;
    index index.html index.htm;
  &#125;
&#125;
</code></pre>
<p><strong>location 中的反斜线</strong></p>
<pre><code>location /test &#123;
 ...
&#125;

location /test/ &#123;
 ...
&#125;
</code></pre>
<ul>
<li>不带 <code>/</code> 当访问 <code>www.nginx-test.com/test</code> 时， <code>Nginx</code> 先找是否有 <code>test</code> 目录，如果有则找<code>test</code> 目录下的 <code>index.html</code> ；如果没有 <code>test</code> 目录， <code>nginx</code> 则会找是否有 <code>test</code> 文件。</li>
<li>带 <code>/</code> 当访问 <code>www.nginx-test.com/test</code> 时， <code>Nginx</code> 先找是否有 <code>test</code> 目录，如果有则找<code>test</code> 目录下的 <code>index.html</code> ，如果没有它也不会去找是否存在 <code>test</code> 文件。</li>
</ul>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>停止处理请求，直接返回响应码或重定向到其他 <code>URL</code> ；执行 <code>return</code> 指令后， <code>location</code> 中后续指令将不会被执行。</p>
<pre><code>return code [text];
return code URL;
return URL;

例如：
location / &#123;
 return 404; # 直接返回状态码
&#125;

location / &#123;
 return 404 &quot;pages not found&quot;; # 返回状态码 + 一段文本
&#125;

location / &#123;
 return 302 /bbs ; # 返回状态码 + 重定向地址
&#125;

location / &#123;
 return https://www.baidu.com ; # 返回重定向地址
&#125;
</code></pre>
<h2 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h2><p>根据指定正则表达式匹配规则，重写 <code>URL</code> 。</p>
<pre><code>语法：rewrite 正则表达式 要替换的内容 [flag];

上下文：server、location、if

示例：rewirte /images/(.*\.jpg)$ /pic/$1; # $1是前面括号(.*\.jpg)的反向引用
</code></pre>
<p><code>flag</code> 可选值的含义：</p>
<ul>
<li><code>last</code> 重写后的 <code>URL</code> 发起新请求，再次进入 <code>server</code> 段，重试 <code>location</code> 的中的匹配；</li>
<li><code>break</code> 直接使用重写后的 <code>URL</code> ，不再匹配其它 <code>location</code> 中语句；</li>
<li><code>redirect</code> 返回302临时重定向；</li>
<li><code>permanent</code> 返回301永久重定向；</li>
</ul>
<pre><code>server&#123;
  listen 80;
  server_name fe.lion.club; # 要在本地hosts文件进行配置
  root html;
  location /search &#123;
   rewrite ^/(.*) https://www.baidu.com redirect;
  &#125;
  
  location /images &#123;
   rewrite /images/(.*) /pics/$1;
  &#125;
  
  location /pics &#123;
   rewrite /pics/(.*) /photos/$1;
  &#125;
  
  location /photos &#123;
  
  &#125;
&#125;
</code></pre>
<p>按照这个配置我们来分析：</p>
<ul>
<li>当访问 <code>fe.lion.club/search</code> 时，会自动帮我们重定向到 <code>https://www.baidu.com</code>。</li>
<li>当访问 <code>fe.lion.club/images/1.jpg</code> 时，第一步重写 <code>URL</code> 为 <code>fe.lion.club/pics/1.jpg</code> ，找到 <code>pics</code> 的 <code>location</code> ，继续重写 <code>URL</code> 为 <code>fe.lion.club/photos/1.jpg</code> ，找到 <code>/photos</code> 的<code>location</code> 后，去 <code>html/photos</code> 目录下寻找 <code>1.jpg</code> 静态资源。</li>
</ul>
<h2 id="if-指令"><a href="#if-指令" class="headerlink" title="if 指令"></a>if 指令</h2><pre><code>语法：if (condition) &#123;...&#125;

上下文：server、location

示例：
if($http_user_agent ~ Chrome)&#123;
  rewrite /(.*)/browser/$1 break;
&#125;
</code></pre>
<p><code>condition</code> 判断条件：</p>
<ul>
<li><code>$variable</code> 仅为变量时，值为空或以0开头字符串都会被当做 <code>false</code> 处理；</li>
<li><code>=</code> 或 <code>!=</code> 相等或不等；</li>
<li><code>~</code> 正则匹配；</li>
<li><code>! ~</code> 非正则匹配；</li>
<li><code>~*</code> 正则匹配，不区分大小写；</li>
<li><code>-f</code> 或 <code>! -f</code> 检测文件存在或不存在；</li>
<li><code>-d</code> 或 <code>! -d</code> 检测目录存在或不存在；</li>
<li><code>-e</code> 或 <code>! -e</code> 检测文件、目录、符号链接等存在或不存在；</li>
<li><code>-x</code> 或 <code>! -x</code> 检测文件可以执行或不可执行；</li>
</ul>
<p>实例：</p>
<pre><code>server &#123;
  listen 8080;
  server_name localhost;
  root html;
  
  location / &#123;
   if ( $uri = &quot;/images/&quot; )&#123;
     rewrite (.*) /pics/ break;
    &#125;
  &#125;
&#125;
</code></pre>
<p>当访问 <code>localhost:8080/images/</code> 时，会进入 <code>if</code> 判断里面执行 <code>rewrite</code> 命令。</p>
<p><strong>autoindex</strong></p>
<p>用户请求以 <code>/</code> 结尾时，列出目录结构，可以用于快速搭建静态资源下载网站。</p>
<p><code>autoindex.conf</code> 配置信息：</p>
<pre><code>server &#123;
  listen 80;
  server_name fe.lion-test.club;
  
  location /download/ &#123;
    root /opt/source;
    
    autoindex on; # 打开 autoindex，，可选参数有 on | off
    autoindex_exact_size on; # 修改为off，以KB、MB、GB显示文件大小，默认为on，以bytes显示出⽂件的确切⼤⼩
    autoindex_format html; # 以html的方式进行格式化，可选参数有 html | json | xml
    autoindex_localtime off; # 显示的⽂件时间为⽂件的服务器时间。默认为off，显示的⽂件时间为GMT时间
  &#125;
&#125;
</code></pre>
<p>当访问 <code>fe.lion.com/download/</code> 时，会把服务器 <code>/opt/source/download/</code> 路径下的文件展示出来，如下图所示：</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550493.png" class="asset-class" title="图片">


<p><strong>变量</strong></p>
<p><code>Nginx</code> 提供给使用者的变量非常多，但是终究是一个完整的请求过程所产生数据， <code>Nginx</code> 将这些数据以变量的形式提供给使用者。</p>
<p>下面列举些项目中常用的变量：</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550504.png" class="asset-class" title="图片">

<p>实例演示 <code>var.conf</code> ：</p>
<pre><code>server&#123;
 listen 8081;
 server_name var.lion-test.club;
 root /usr/share/nginx/html;
 location / &#123;
  return 200 &quot;
remote_addr: $remote_addr
remote_port: $remote_port
server_addr: $server_addr
server_port: $server_port
server_protocol: $server_protocol
binary_remote_addr: $binary_remote_addr
connection: $connection
uri: $uri
request_uri: $request_uri
scheme: $scheme
request_method: $request_method
request_length: $request_length
args: $args
arg_pid: $arg_pid
is_args: $is_args
query_string: $query_string
host: $host
http_user_agent: $http_user_agent
http_referer: $http_referer
http_via: $http_via
request_time: $request_time
https: $https
request_filename: $request_filename
document_root: $document_root
&quot;;
 &#125;
&#125;
</code></pre>
<p>当我们访问 <code>http://var.lion-test.club:8081/test?pid=121414&amp;cid=sadasd</code> 时，由于 <code>Nginx</code>中写了 <code>return</code> 方法，因此 <code>chrome</code> 浏览器会默认为我们下载一个文件，下面展示的就是下载的文件内容：</p>
<pre><code>remote_addr: 27.16.220.84
remote_port: 56838
server_addr: 172.17.0.2
server_port: 8081
server_protocol: HTTP/1.1
binary_remote_addr: 茉
connection: 126
uri: /test/
request_uri: /test/?pid=121414&amp;cid=sadasd
scheme: http
request_method: GET
request_length: 518
args: pid=121414&amp;cid=sadasd
arg_pid: 121414
is_args: ?
query_string: pid=121414&amp;cid=sadasd
host: var.lion-test.club
http_user_agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36
http_referer: 
http_via: 
request_time: 0.000
https: 
request_filename: /usr/share/nginx/html/test/
document_root: /usr/share/nginx/html
</code></pre>
<p><code>Nginx</code> 的配置还有非常多，以上只是罗列了一些常用的配置，在实际项目中还是要学会查阅文档。</p>
<p><strong>Nginx 应用核心概念</strong></p>
<p>代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。</p>
<p>不管是正向代理还是反向代理，实现的都是上面的功能。</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550505.png" class="asset-class" title="图片">

<p><strong>正向代理</strong></p>
<blockquote>
<p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>
</blockquote>
<p>正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。</p>
<p>正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。</p>
<p><strong>反向代理</strong></p>
<blockquote>
<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
</blockquote>
<p>反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。</p>
<p>反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。</p>
<p>反向代理的优势：</p>
<ul>
<li>隐藏真实服务器；</li>
<li>负载均衡便于横向扩充后端动态服务；</li>
<li>动静分离，提升系统健壮性；</li>
</ul>
<p>那么“动静分离”是什么？负载均衡又是什么？</p>
<p><strong>动静分离</strong></p>
<p>动静分离是指在 <code>web</code> 服务器架构中，将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提示整个服务的访问性和可维护性。</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550506.png" class="asset-class" title="图片">


<p>一般来说，都需要将动态资源和静态资源分开，由于 <code>Nginx</code> 的高并发和静态资源缓存等特性，经常将静态资源部署在 <code>Nginx</code> 上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是动态资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。</p>
<p>使用前后端分离后，可以很大程度提升静态资源的访问速度，即使动态服务不可用，静态资源的访问也不会受到影响。</p>
<p><strong>负载均衡</strong></p>
<p>一般情况下，客户端发送多个请求到服务器，服务器处理请求，其中一部分可能要操作一些资源比如数据库、静态资源等，服务器处理完毕后，再将结果返回给客户端。</p>
<p>这种模式对于早期的系统来说，功能要求不复杂，且并发请求相对较少的情况下还能胜任，成本也低。随着信息数量不断增长，访问量和数据量飞速增长，以及系统业务复杂度持续增加，这种做法已无法满足要求，并发量特别大时，服务器容易崩。</p>
<p>很明显这是由于服务器性能的瓶颈造成的问题，除了堆机器之外，最重要的做法就是负载均衡。</p>
<p>请求爆发式增长的情况下，单个机器性能再强劲也无法满足要求了，这个时候集群的概念产生了，单个服务器解决不了的问题，可以使用多个服务器，然后将请求分发到各个服务器上，将负载分发到不同的服务器，这就是负载均衡，核心是「分摊压力」。<code>Nginx</code> 实现负载均衡，一般来说指的是将请求转发给服务器集群。</p>
<p>举个具体的例子，晚高峰乘坐地铁的时候，入站口经常会有地铁工作人员大喇叭“请走 <code>B</code> 口， <code>B</code>口人少车空….”，这个工作人员的作用就是负载均衡。</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550507.png" class="asset-class" title="图片">

<p><code>Nginx</code> 实现负载均衡的策略：</p>
<ul>
<li>轮询策略：默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</li>
<li>最小连接数策略：将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。</li>
<li>最快响应时间策略：优先分配给响应时间最短的服务器。</li>
<li>客户端 <code>ip</code> 绑定策略：来自同一个 <code>ip</code> 的请求永远只分配一台服务器，有效解决了动态网页存在的 <code>session</code> 共享问题。</li>
</ul>
<p><strong>Nginx 实战配置</strong></p>
<p>在配置反向代理和负载均衡等等功能之前，有两个核心模块是我们必须要掌握的，这两个模块应该说是 <code>Nginx</code> 应用配置中的核心，它们分别是：<code>upstream</code> 、<code>proxy_pass</code> 。</p>
<p><strong>upstream</strong></p>
<p>用于定义上游服务器（指的就是后台提供的应用服务器）的相关信息。</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550508.png" class="asset-class" title="图片">

<pre><code>语法：upstream name &#123;
 ...
&#125;

上下文：http

示例：
upstream back_end_server&#123;
  server 192.168.100.33:8081
&#125;
</code></pre>
<p>在 <code>upstream</code> 内可使用的指令：</p>
<ul>
<li><code>server</code> 定义上游服务器地址；</li>
<li><code>zone</code> 定义共享内存，用于跨 <code>worker</code> 子进程；</li>
<li><code>keepalive</code> 对上游服务启用长连接；</li>
<li><code>keepalive_requests</code> 一个长连接最多请求 <code>HTTP</code> 的个数；</li>
<li><code>keepalive_timeout</code> 空闲情形下，一个长连接的超时时长；</li>
<li><code>hash</code> 哈希负载均衡算法；</li>
<li><code>ip_hash</code> 依据 <code>IP</code> 进行哈希计算的负载均衡算法；</li>
<li><code>least_conn</code> 最少连接数负载均衡算法；</li>
<li><code>least_time</code> 最短响应时间负载均衡算法；</li>
<li><code>random</code> 随机负载均衡算法；</li>
</ul>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>定义上游服务器地址。</p>
<pre><code>语法：server address [parameters]

上下文：upstream
</code></pre>
<p><code>parameters</code> 可选值：</p>
<ul>
<li><code>weight=number</code> 权重值，默认为1；</li>
<li><code>max_conns=number</code> 上游服务器的最大并发连接数；</li>
<li><code>fail_timeout=time</code> 服务器不可用的判定时间；</li>
<li><code>max_fails=numer</code> 服务器不可用的检查次数；</li>
<li><code>backup</code> 备份服务器，仅当其他服务器都不可用时才会启用；</li>
<li><code>down</code> 标记服务器长期不可用，离线维护；</li>
</ul>
<h3 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h3><p>限制每个 <code>worker</code> 子进程与上游服务器空闲长连接的最大数量。</p>
<pre><code>keepalive connections;

上下文：upstream

示例：keepalive 16;
</code></pre>
<h3 id="keepalive-requests"><a href="#keepalive-requests" class="headerlink" title="keepalive_requests"></a>keepalive_requests</h3><p>单个长连接可以处理的最多 <code>HTTP</code> 请求个数。</p>
<pre><code>语法：keepalive_requests number;

默认值：keepalive_requests 100;

上下文：upstream
</code></pre>
<p><strong>keepalive_timeout</strong></p>
<p>空闲长连接的最长保持时间。</p>
<pre><code>语法：keepalive_timeout time;

默认值：keepalive_timeout 60s;

上下文：upstream
</code></pre>
<h3 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h3><pre><code>upstream back_end&#123;
 server 127.0.0.1:8081 weight=3 max_conns=1000 fail_timeout=10s max_fails=2;
  keepalive 32;
  keepalive_requests 50;
  keepalive_timeout 30s;
&#125;
</code></pre>
<h2 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h2><p>用于配置代理服务器。</p>
<pre><code>语法：proxy_pass URL;

上下文：location、if、limit_except

示例：
proxy_pass http://127.0.0.1:8081
proxy_pass http://127.0.0.1:8081/proxy
</code></pre>
<p><code>URL</code> 参数原则</p>
<ol>
<li><p><code>URL</code> 必须以 <code>http</code> 或 <code>https</code> 开头；</p>
</li>
<li><p><code>URL</code> 中可以携带变量；</p>
</li>
<li><p><code>URL</code> 中是否带 <code>URI</code> ，会直接影响发往上游请求的 <code>URL</code> ；</p>
</li>
</ol>
<p>接下来让我们来看看两种常见的 <code>URL</code> 用法：</p>
<ol>
<li><code>proxy_pass http://192.168.100.33:8081</code></li>
<li><code>proxy_pass http://192.168.100.33:8081/</code></li>
</ol>
<p>这两种用法的区别就是带 <code>/</code> 和不带 <code>/</code> ，在配置代理时它们的区别可大了：</p>
<ul>
<li>不带 <code>/</code> 意味着 <code>Nginx</code> 不会修改用户 <code>URL</code> ，而是直接透传给上游的应用服务器；</li>
<li>带 <code>/</code> 意味着 <code>Nginx</code> 会修改用户 <code>URL</code> ，修改方法是将 <code>location</code> 后的 <code>URL</code> 从用户 <code>URL</code> 中删除；</li>
</ul>
<p>不带 <code>/</code> 的用法：</p>
<pre><code>location /bbs/&#123;
  proxy_pass http://127.0.0.1:8080;
&#125;
</code></pre>
<p>分析：</p>
<ol>
<li><p>用户请求 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
</li>
<li><p>请求到达 <code>Nginx</code> 的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
</li>
<li><p>请求到达上游应用服务器的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
</li>
</ol>
<p>带 <code>/</code> 的用法：</p>
<pre><code>location /bbs/&#123;
  proxy_pass http://127.0.0.1:8080/;
&#125;
</code></pre>
<p>分析：</p>
<ol>
<li><p>用户请求 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
</li>
<li><p>请求到达 <code>Nginx</code> 的 <code>URL</code> ：<code>/bbs/abc/test.html</code></p>
</li>
<li><p>请求到达上游应用服务器的 <code>URL</code> ：<code>/abc/test.html</code></p>
</li>
</ol>
<p>并没有拼接上 <code>/bbs</code> ，这点和 <code>root</code> 与 <code>alias</code> 之间的区别是保持一致的。</p>
<p><strong>配置反向代理</strong></p>
<p>这里为了演示更加接近实际，作者准备了两台云服务器，它们的公网 <code>IP</code> 分别是：<code>121.42.11.34</code>与 <code>121.5.180.193</code> 。</p>
<p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置：</p>
<pre><code># /etc/nginx/conf.d/proxy.conf
server&#123;
  listen 8080;
  server_name localhost;
  
  location /proxy/ &#123;
    root /usr/share/nginx/html/proxy;
    index index.html;
  &#125;
&#125;

# /usr/share/nginx/html/proxy/index.html
&lt;h1&gt; 121.42.11.34 proxy html &lt;/h1&gt;
</code></pre>
<p>配置完成后重启 <code>Nginx</code> 服务器 <code>nginx \-s reload</code> 。</p>
<p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置：</p>
<pre><code># /etc/nginx/conf.d/proxy.conf
upstream back_end &#123;
  server 121.42.11.34:8080 weight=2 max_conns=1000 fail_timeout=10s max_fails=3;
  keepalive 32;
  keepalive_requests 80;
  keepalive_timeout 20s;
&#125;

server &#123;
  listen 80;
  server_name proxy.lion.club;
  location /proxy &#123;
   proxy_pass http://back_end/proxy;
  &#125;
&#125;
</code></pre>
<p>本地机器要访问 <code>proxy.lion.club</code> 域名，因此需要配置本地 <code>hosts</code> ，通过命令：<code>vim /etc/hosts</code>进入配置文件，添加如下内容：</p>
<pre><code>121.5.180.193 proxy.lion.club
</code></pre>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-16543972550509.png" class="asset-class" title="图片">

<p>分析：</p>
<p>当访问 <code>proxy.lion.club/proxy</code> 时通过 <code>upstream</code> 的配置找到 <code>121.42.11.34:8080</code> ；</p>
<p>因此访问地址变为 <code>http://121.42.11.34:8080/proxy</code> ；</p>
<p>连接到 <code>121.42.11.34</code> 服务器，找到 <code>8080</code> 端口提供的 <code>server</code> ；</p>
<p>通过 <code>server</code> 找到 <code>/usr/share/nginx/html/proxy/index.html</code> 资源，最终展示出来。</p>
<h2 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h2><p>配置负载均衡主要是要使用 <code>upstream</code> 指令。</p>
<p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置（ <code>/etc/nginx/conf.d/balance.conf</code>）：</p>
<pre><code>server&#123;
  listen 8020;
  location / &#123;
   return 200 &#39;return 8020 \n&#39;;
  &#125;
&#125;

server&#123;
  listen 8030;
  location / &#123;
   return 200 &#39;return 8030 \n&#39;;
  &#125;
&#125;

server&#123;
  listen 8040;
  location / &#123;
   return 200 &#39;return 8040 \n&#39;;
  &#125;
&#125;
</code></pre>
<p>配置完成后：</p>
<p><code>1. nginx -t</code> 检测配置是否正确；</p>
<p><code>2. nginx -s reload</code> 重启 <code>Nginx</code> 服务器；</p>
<p>\3. 执行 <code>ss -nlt</code> 命令查看端口是否被占用，从而判断 <code>Nginx</code> 服务是否正确启动。</p>
<p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置（ <code>/etc/nginx/conf.d/balance.conf</code>）：</p>
<pre><code>upstream demo_server &#123;
  server 121.42.11.34:8020;
  server 121.42.11.34:8030;
  server 121.42.11.34:8040;
&#125;

server &#123;
  listen 80;
  server_name balance.lion.club;
  
  location /balance/ &#123;
   proxy_pass http://demo_server;
  &#125;
&#125;
</code></pre>
<p>配置完成后重启 <code>Nginx</code> 服务器。并且在需要访问的客户端配置好 <code>ip</code> 和域名的映射关系。</p>
<pre><code># /etc/hosts

121.5.180.193 balance.lion.club
</code></pre>
<p>在客户端机器执行 <code>curl http://balance.lion.club/balance/</code> 命令：</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-165439725505010.png" class="asset-class" title="图片">

<p>不难看出，负载均衡的配置已经生效了，每次给我们分发的上游服务器都不一样。就是通过简单的轮询策略进行上游服务器分发。</p>
<p>接下来，我们再来了解下 <code>Nginx</code> 的其它分发策略。</p>
<p><strong>hash 算法</strong></p>
<p>通过制定关键字作为 <code>hash key</code> ，基于 <code>hash</code> 算法映射到特定的上游服务器中。关键字可以包含有变量、字符串。</p>
<pre><code>upstream demo_server &#123;
  hash $request_uri;
  server 121.42.11.34:8020;
  server 121.42.11.34:8030;
  server 121.42.11.34:8040;
&#125;

server &#123;
  listen 80;
  server_name balance.lion.club;
  
  location /balance/ &#123;
   proxy_pass http://demo_server;
  &#125;
&#125;
</code></pre>
<p><code>hash $request_uri</code> 表示使用 <code>request_uri</code> 变量作为 <code>hash</code> 的 <code>key</code> 值，只要访问的 <code>URI</code> 保持不变，就会一直分发给同一台服务器。</p>
<p><strong>ip_hash</strong></p>
<p>根据客户端的请求 <code>ip</code> 进行判断，只要 <code>ip</code> 地址不变就永远分配到同一台主机。它可以有效解决后台服务器 <code>session</code> 保持的问题。</p>
<pre><code>upstream demo_server &#123;
  ip_hash;
  server 121.42.11.34:8020;
  server 121.42.11.34:8030;
  server 121.42.11.34:8040;
&#125;

server &#123;
  listen 80;
  server_name balance.lion.club;
  
  location /balance/ &#123;
   proxy_pass http://demo_server;
  &#125;
&#125;
</code></pre>
<h3 id="最少连接数算法"><a href="#最少连接数算法" class="headerlink" title="最少连接数算法"></a>最少连接数算法</h3><p>各个 <code>worker</code> 子进程通过读取共享内存的数据，来获取后端服务器的信息。来挑选一台当前已建立连接数最少的服务器进行分配请求。</p>
<pre><code>语法：least_conn;

上下文：upstream;
</code></pre>
<p>示例：</p>
<pre><code>upstream demo_server &#123;
  zone test 10M; # zone可以设置共享内存空间的名字和大小
  least_conn;
  server 121.42.11.34:8020;
  server 121.42.11.34:8030;
  server 121.42.11.34:8040;
&#125;

server &#123;
  listen 80;
  server_name balance.lion.club;
  
  location /balance/ &#123;
   proxy_pass http://demo_server;
  &#125;
&#125;
</code></pre>
<p>最后你会发现，负载均衡的配置其实一点都不复杂。</p>
<p><strong>配置缓存</strong></p>
<p>缓存可以非常有效的提升性能，因此不论是客户端（浏览器），还是代理服务器（ <code>Nginx</code> ），乃至上游服务器都多少会涉及到缓存。可见缓存在每个环节都是非常重要的。下面让我们来学习<code>Nginx</code> 中如何设置缓存策略。</p>
<p><strong>proxy_cache</strong></p>
<p>存储一些之前被访问过、而且可能将要被再次访问的资源，使用户可以直接从代理服务器获得，从而减少上游服务器的压力，加快整个访问速度。</p>
<pre><code>语法：proxy_cache zone | off ; # zone 是共享内存的名称

默认值：proxy_cache off;

上下文：http、server、location
</code></pre>
<p><strong>proxy_cache_path</strong></p>
<p>设置缓存文件的存放路径。</p>
<pre><code>语法：proxy_cache_path path [level=levels] ...可选参数省略，下面会详细列举

默认值：proxy_cache_path off

上下文：http
</code></pre>
<p>参数含义：</p>
<ul>
<li><code>path</code> 缓存文件的存放路径；</li>
<li><code>level path</code> 的目录层级；</li>
<li><code>keys_zone</code> 设置共享内存；</li>
<li><code>inactive</code> 在指定时间内没有被访问，缓存会被清理，默认10分钟；</li>
</ul>
<h3 id="proxy-cache-key"><a href="#proxy-cache-key" class="headerlink" title="proxy_cache_key"></a>proxy_cache_key</h3><p>设置缓存文件的 <code>key</code> 。</p>
<pre><code>语法：proxy_cache_key

默认值：proxy_cache_key $scheme$proxy_host$request_uri;

上下文：http、server、location
</code></pre>
<p><strong>proxy_cache_valid</strong></p>
<p>配置什么状态码可以被缓存，以及缓存时长。</p>
<pre><code>语法：proxy_cache_valid [code...] time;

上下文：http、server、location

配置示例：proxy_cache_valid 200 304 2m;; # 说明对于状态为200和304的缓存文件的缓存时间是2分钟
</code></pre>
<h3 id="proxy-no-cache"><a href="#proxy-no-cache" class="headerlink" title="proxy_no_cache"></a>proxy_no_cache</h3><p>定义相应保存到缓存的条件，如果字符串参数的至少一个值不为空且不等于“ 0”，则将不保存该响应到缓存。</p>
<pre><code>语法：proxy_no_cache string;

上下文：http、server、location

示例：proxy_no_cache $http_pragma    $http_authorization;
</code></pre>
<h3 id="proxy-cache-bypass"><a href="#proxy-cache-bypass" class="headerlink" title="proxy_cache_bypass"></a>proxy_cache_bypass</h3><p>定义条件，在该条件下将不会从缓存中获取响应。</p>
<pre><code>语法：proxy_cache_bypass string;

上下文：http、server、location

示例：proxy_cache_bypass $http_pragma    $http_authorization;
</code></pre>
<h3 id="upstream-cache-status-变量"><a href="#upstream-cache-status-变量" class="headerlink" title="upstream_cache_status 变量"></a>upstream_cache_status 变量</h3><p>它存储了缓存是否命中的信息，会设置在响应头信息中，在调试中非常有用。</p>
<pre><code>MISS: 未命中缓存
HIT：命中缓存
EXPIRED: 缓存过期
STALE: 命中了陈旧缓存
REVALIDDATED: Nginx验证陈旧缓存依然有效
UPDATING: 内容陈旧，但正在更新
BYPASS: X响应从原始服务器获取
</code></pre>
<h3 id="配置实例-1"><a href="#配置实例-1" class="headerlink" title="配置实例"></a>配置实例</h3><p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置（ <code>/etc/nginx/conf.d/cache.conf</code>）：</p>
<pre><code>server &#123;
  listen 1010;
  root /usr/share/nginx/html/1010;
  location / &#123;
   index index.html;
  &#125;
&#125;

server &#123;
  listen 1020;
  root /usr/share/nginx/html/1020;
  location / &#123;
   index index.html;
  &#125;
&#125;
</code></pre>
<p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置（ <code>/etc/nginx/conf.d/cache.conf</code> ）：</p>
<pre><code>proxy_cache_path /etc/nginx/cache_temp levels=2:2 keys_zone=cache_zone:30m max_size=2g inactive=60m use_temp_path=off;

upstream cache_server&#123;
  server 121.42.11.34:1010;
  server 121.42.11.34:1020;
&#125;

server &#123;
  listen 80;
  server_name cache.lion.club;
  location / &#123;
    proxy_cache cache_zone; # 设置缓存内存，上面配置中已经定义好的
    proxy_cache_valid 200 5m; # 缓存状态为200的请求，缓存时长为5分钟
    proxy_cache_key $request_uri; # 缓存文件的key为请求的URI
    add_header Nginx-Cache-Status $upstream_cache_status # 把缓存状态设置为头部信息，响应给客户端
    proxy_pass http://cache_server; # 代理转发
  &#125;
&#125;
</code></pre>
<p>缓存就是这样配置，我们可以在 <code>/etc/nginx/cache_temp</code> 路径下找到相应的缓存文件。</p>
<p><strong>对于一些实时性要求非常高的页面或数据来说，就不应该去设置缓存，下面来看看如何配置不缓存的内容。</strong></p>
<pre><code>...

server &#123;
  listen 80;
  server_name cache.lion.club;
  # URI 中后缀为 .txt 或 .text 的设置变量值为 &quot;no cache&quot;
  if ($request_uri ~ \.(txt|text)$) &#123;
   set $cache_name &quot;no cache&quot;
  &#125;
  
  location / &#123;
    proxy_no_cache $cache_name; # 判断该变量是否有值，如果有值则不进行缓存，如果没有值则进行缓存
    proxy_cache cache_zone; # 设置缓存内存
    proxy_cache_valid 200 5m; # 缓存状态为200的请求，缓存时长为5分钟
    proxy_cache_key $request_uri; # 缓存文件的key为请求的URI
    add_header Nginx-Cache-Status $upstream_cache_status # 把缓存状态设置为头部信息，响应给客户端
    proxy_pass http://cache_server; # 代理转发
  &#125;
&#125;
</code></pre>
<p><strong>HTTPS</strong></p>
<p>在学习如何配置 <code>HTTPS</code> 之前，我们先来简单回顾下 <code>HTTPS</code> 的工作流程是怎么样的？它是如何进行加密保证安全的？</p>
<p><strong>HTTPS 工作流程</strong></p>
<ol>
<li><p>客户端（浏览器）访问 <code>https://www.baidu.com</code> 百度网站；</p>
</li>
<li><p>百度服务器返回 <code>HTTPS</code> 使用的 <code>CA</code> 证书；</p>
</li>
<li><p>浏览器验证 <code>CA</code> 证书是否为合法证书；</p>
</li>
<li><p>验证通过，证书合法，生成一串随机数并使用公钥（证书中提供的）进行加密；</p>
</li>
<li><p>发送公钥加密后的随机数给百度服务器；</p>
</li>
<li><p>百度服务器拿到密文，通过私钥进行解密，获取到随机数（公钥加密，私钥解密，反之也可以）；</p>
</li>
<li><p>百度服务器把要发送给浏览器的内容，使用随机数进行加密后传输给浏览器；</p>
</li>
<li><p>此时浏览器可以使用随机数进行解密，获取到服务器的真实传输内容；</p>
</li>
</ol>
<p>这就是 <code>HTTPS</code> 的基本运作原理，使用对称加密和非对称机密配合使用，保证传输内容的安全性。</p>
<p>关于HTTPS更多知识，可以查看作者的另外一篇文章《学习 HTTP 协议》。</p>
<h3 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h3><p>下载证书的压缩文件，里面有个 <code>Nginx</code> 文件夹，把 <code>xxx.crt</code> 和 <code>xxx.key</code> 文件拷贝到服务器目录，再进行如下配置：</p>
<pre><code>server &#123;
  listen 443 ssl http2 default_server; # SSL 访问端口号为 443
  server_name lion.club; # 填写绑定证书的域名(我这里是随便写的)
  ssl_certificate /etc/nginx/https/lion.club_bundle.crt; # 证书地址
  ssl_certificate_key /etc/nginx/https/lion.club.key; # 私钥地址
  ssl_session_timeout 10m;
  ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 支持ssl协议版本，默认为后三个，主流版本是[TLSv1.2]
 
  location / &#123;
    root         /usr/share/nginx/html;
    index        index.html index.htm;
  &#125;
&#125;
</code></pre>
<p>如此配置后就能正常访问 <code>HTTPS</code> 版的网站了。</p>
<p><strong>配置跨域 CORS</strong></p>
<p>先简单回顾下跨域究竟是怎么回事。</p>
<p><strong>跨域的定义</strong></p>
<p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。</p>
<p><strong>同源的定义</strong></p>
<p>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</p>
<p>下面给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例:</p>
<pre><code>http://store.company.com/dir2/other.html 同源
https://store.company.com/secure.html 不同源，协议不同
http://store.company.com:81/dir/etc.html 不同源，端口不同
http://news.company.com/dir/other.html 不同源，主机不同
</code></pre>
<p>不同源会有如下限制：</p>
<ul>
<li><code>Web</code> 数据层面，同源策略限制了不同源的站点读取当前站点的 <code>Cookie</code> 、 <code>IndexDB</code> 、<code>LocalStorage</code> 等数据。</li>
<li><code>DOM</code> 层面，同源策略限制了来自不同源的 <code>JavaScript</code> 脚本对当前 <code>DOM</code> 对象读和写的操作。</li>
<li>网络层面，同源策略限制了通过 <code>XMLHttpRequest</code> 等方式将站点的数据发送给不同源的站点。</li>
</ul>
<h3 id="Nginx-解决跨域的原理"><a href="#Nginx-解决跨域的原理" class="headerlink" title="Nginx 解决跨域的原理"></a>Nginx 解决跨域的原理</h3><p>例如：</p>
<ul>
<li>前端 <code>server</code> 的域名为：<code>fe.server.com</code></li>
<li>后端服务的域名为：<code>dev.server.com</code></li>
</ul>
<p>现在我在 <code>fe.server.com</code> 对 <code>dev.server.com</code> 发起请求一定会出现跨域。</p>
<p>现在我们只需要启动一个 <code>Nginx</code> 服务器，将 <code>server_name</code> 设置为 <code>fe.server.com</code> 然后设置相应的 <code>location</code> 以拦截前端需要跨域的请求，最后将请求代理回 <code>dev.server.com</code> 。如下面的配置：</p>
<pre><code>server &#123;
 listen      80;
 server_name  fe.server.com;
 location / &#123;
  proxy_pass dev.server.com;
 &#125;
&#125;
</code></pre>
<p>这样可以完美绕过浏览器的同源策略：<code>fe.server.com</code> 访问 <code>Nginx</code> 的 <code>fe.server.com</code> 属于同源访问，而 <code>Nginx</code> 对服务端转发的请求不会触发浏览器的同源策略。</p>
<p><strong>配置开启 gzip 压缩</strong></p>
<p><code>GZIP</code> 是规定的三种标准 <code>HTTP</code> 压缩格式之一。目前绝大多数的网站都在使用 <code>GZIP</code> 传输 <code>HTML</code>、<code>CSS</code> 、 <code>JavaScript</code> 等资源文件。</p>
<p>对于文本文件， <code>GZiP</code> 的效果非常明显，开启后传输所需流量大约会降至 <code>1/4~1/3</code> 。</p>
<p>并不是每个浏览器都支持 <code>gzip</code> 的，如何知道客户端是否支持 <code>gzip</code> 呢，请求头中的 <code>Accept-Encoding</code> 来标识对压缩的支持。</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-165439725505111.png" class="asset-class" title="图片">


<p>启用 <code>gzip</code> 同时需要客户端和服务端的支持，如果客户端支持 <code>gzip</code> 的解析，那么只要服务端能够返回 <code>gzip</code> 的文件就可以启用 <code>gzip</code> 了,我们可以通过 <code>Nginx</code> 的配置来让服务端支持 <code>gzip</code> 。下面的 <code>respone</code> 中 <code>content-encoding:gzip</code> ，指服务端开启了 <code>gzip</code> 的压缩方式。</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-165439725505112.png" class="asset-class" title="图片">


<p>在 <code>/etc/nginx/conf.d/</code> 文件夹中新建配置文件 <code>gzip.conf</code> ：</p>
<pre><code># # 默认off，是否开启gzip
gzip on; 
# 要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用；
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;

# ---- 以上两个参数开启就可以支持Gzip压缩了 ---- #

# 默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容；
gzip_static on;

# 默认 off，nginx做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩；
gzip_proxied any;

# 用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩；
gzip_vary on;

# gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；
gzip_comp_level 6;

# 获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得；
gzip_buffers 16 8k;

# 允许压缩的页面最小字节数，页面字节数从header头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；
# gzip_min_length 1k;

# 默认 1.1，启用 gzip 所需的 HTTP 最低版本；
gzip_http_version 1.1;
</code></pre>
<p>其实也可以通过前端构建工具例如 <code>webpack</code> 、<code>rollup</code> 等在打生产包时就做好 <code>Gzip</code> 压缩，然后放到 <code>Nginx</code> 服务器中，这样可以减少服务器的开销，加快访问速度。</p>
<p>关于 <code>Nginx</code> 的实际应用就学习到这里，相信通过掌握了 <code>Nginx</code> 核心配置以及实战配置，之后再遇到什么需求，我们也能轻松应对。接下来，让我们再深入一点学习下 <code>Nginx</code> 的架构。</p>
<p><strong>Nginx 架构</strong></p>
<p><strong>进程结构</strong></p>
<p>多进程结构 <code>Nginx</code> 的进程模型图：</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-165439725505113.png" class="asset-class" title="图片">



<p>多进程中的 <code>Nginx</code> 进程架构如下图所示，会有一个父进程（ <code>Master Process</code> ），它会有很多子进程（ <code>Child Processes</code> ）。</p>
<ul>
<li><p><code>Master Process</code> 用来管理子进程的，其本身并不真正处理用户请求。</p>
<ul>
<li>某个子进程 <code>down</code> 掉的话，它会向 <code>Master</code> 进程发送一条消息，表明自己不可用了，此时 <code>Master</code> 进程会去新起一个子进程。</li>
<li>某个配置文件被修改了 <code>Master</code> 进程会去通知 <code>work</code> 进程获取新的配置信息，这也就是我们所说的热部署。</li>
</ul>
</li>
<li><p>子进程间是通过共享内存的方式进行通信的。</p>
</li>
</ul>
<h2 id="配置文件重载原理"><a href="#配置文件重载原理" class="headerlink" title="配置文件重载原理"></a>配置文件重载原理</h2><p><code>reload</code> 重载配置文件的流程：</p>
<ol>
<li><p>向 <code>master</code> 进程发送 <code>HUP</code> 信号（ <code>reload</code> 命令）；</p>
</li>
<li><p><code>master</code> 进程检查配置语法是否正确；</p>
</li>
<li><p><code>master</code> 进程打开监听端口；</p>
</li>
<li><p><code>master</code> 进程使用新的配置文件启动新的 <code>worker</code> 子进程；</p>
</li>
<li><p><code>master</code> 进程向老的 <code>worker</code> 子进程发送 <code>QUIT</code> 信号；</p>
</li>
<li><p>老的 <code>worker</code> 进程关闭监听句柄，处理完当前连接后关闭进程；</p>
</li>
<li><p>整个过程 <code>Nginx</code> 始终处于平稳运行中，实现了平滑升级，用户无感知；</p>
</li>
</ol>
<h2 id="Nginx-模块化管理机制"><a href="#Nginx-模块化管理机制" class="headerlink" title="Nginx 模块化管理机制"></a>Nginx 模块化管理机制</h2><p><code>Nginx</code> 的内部结构是由核心部分和一系列的功能模块所组成。这样划分是为了使得每个模块的功能相对简单，便于开发，同时也便于对系统进行功能扩展。<code>Nginx</code> 的模块是互相独立的,低耦合高内聚。</p>
<img src="/2022/06/05/nginx-pei-zhi-xue-xi/640-165439725505114.png" class="asset-class" title="图片">

<p>转载：<a href="https://juejin.cn/post/6942607113118023710">https://juejin.cn/post/6942607113118023710</a></p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>杂乱无章.md</title>
    <url>/2021/08/31/za-luan-wu-zhang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、在js里面引入js或css"><a href="#一、在js里面引入js或css" class="headerlink" title="一、在js里面引入js或css"></a>一、在js里面引入js或css</h2><pre><code class="javascript">//论坛首页 各模块铁贴数
var new_element=document.createElement(&quot;script&quot;);
new_element.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);
new_element.setAttribute(&quot;src&quot;,&quot;../prompt/prompt.js&quot;);// 在这里引入了a.js
document.body.appendChild(new_element);
function loadStyle(url)&#123;
    var link = document.createElement(&#39;link&#39;);
        link.type = &#39;text/css&#39;;
        link.rel = &#39;stylesheet&#39;;
        link.href = url;
        var head = document.getElementsByTagName(&#39;head&#39;)[0];
        head.appendChild(link);
    &#125;
loadStyle(&#39;../prompt/prompt.css&#39;);
</code></pre>
<h2 id="二、自定义confirm"><a href="#二、自定义confirm" class="headerlink" title="二、自定义confirm"></a>二、自定义confirm</h2><h3 id="1、javascript部分"><a href="#1、javascript部分" class="headerlink" title="1、javascript部分"></a>1、javascript部分</h3><pre><code class="prettyprint">function showPop(string,callback)&#123;
    function set()&#123;
        let popDom = &#39;&lt;div class=&quot;popUps_mask&quot;&gt;&#39;;
        popDom += &#39;&lt;div&gt;&#39;;
        popDom += &#39;&lt;div class=&quot;shutDown&quot;&gt;+&lt;/div&gt;&#39;;
        popDom += &#39;&lt;div class=&quot;theme&quot;&gt;&#39;+string+&#39;&lt;/div&gt;&#39;;
        popDom += &#39;&lt;div class=&quot;buttonList&quot;&gt;&lt;button class=&quot;cancel&quot;&gt;取消&lt;/button&gt;&lt;button class=&quot;confirm&quot;&gt;确认&lt;/button&gt;&lt;/div&gt;&#39;;
        popDom += &#39;&lt;/div&gt;&#39;;
        popDom += &#39;&lt;/div&gt;&#39;;
        $(&#39;body&#39;).append(popDom);
    &#125;
    set();
    $(&#39;.shutDown&#39;).click(function()&#123;
        $(&#39;.popUps_mask&#39;).remove();
    &#125;);
    $(&#39;.cancel&#39;).click(function()&#123;
        $(&#39;.popUps_mask&#39;).remove();
    &#125;);
    $(&#39;.confirm&#39;).click(function()&#123;
        callback&amp;&amp;callback();
        $(&#39;.popUps_mask&#39;).remove();
    &#125;)
&#125;
</code></pre>
<h3 id="2、css部分"><a href="#2、css部分" class="headerlink" title="2、css部分"></a>2、css部分</h3><pre><code class="prettyprint">.popUps_mask&#123;
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    z-index: 1024;
&#125;

.popUps_mask &gt;div&#123;
    width: 350px;
    box-shadow: 0px 0px 7px #8e8787;
    height: 210px;
    background: white;
    margin: 10% auto;
    position: relative;
&#125;

.popUps_mask &gt;div .shutDown&#123;
    font-size: 35px;
    position: absolute;
    top: -4px;
    right: 7px;
    color: #d6d0d0;
    transform: rotate(45deg);
    -ms-transform: rotate(45deg);
    -moz-transform: rotate(45deg);
    -webkit-transform: rotate(45deg);
    -o-transform: rotate(45deg);
    cursor: pointer;
&#125;    

.popUps_mask &gt;div .theme&#123;
    text-align: center;
    font-size: 25px;
    color: black;
    padding-top: 60px;
&#125;    

.popUps_mask &gt;div .buttonList&#123;
    text-align: center;
    margin-top: 35px;
&#125;    

.popUps_mask &gt;div .buttonList .cancel&#123;
    width: 70px;
    border: 1px solid #e1e1e1;
    border-radius: 4px;
    height: 30px;
    background: #f8f8f8;
&#125;

.popUps_mask &gt;div .buttonList .cancel&#123;
    width: 70px;
    border: 1px solid #e1e1e1;
    border-radius: 4px;
    height: 30px;
    background: #f8f8f8;
    margin-right: 5px;
    cursor: pointer;
&#125;

.popUps_mask &gt;div .buttonList .confirm&#123;
    width: 70px;
    border: 1px solid #277BAD;
    border-radius: 4px;
    height: 30px;
    background: white;
    color: #277BAD;
    margin-left: 5px;
    cursor: pointer;
&#125;
</code></pre>
<h3 id="3、调用方式"><a href="#3、调用方式" class="headerlink" title="3、调用方式"></a>3、调用方式</h3><pre><code class="prettyprint">showPop(&quot;是否确认删除！&quot;,
        function()&#123;
                //doSomething
        &#125;)
</code></pre>
<h2 id="三、常用的js方法"><a href="#三、常用的js方法" class="headerlink" title="三、常用的js方法"></a>三、常用的js方法</h2><pre><code class="prettyprint">// 日期格式化
Date.prototype.format = function (fmt) &#123;
    var o = &#123;
        &quot;y+&quot;: this.getYear(),
        &quot;M+&quot;: this.getMonth() + 1, //月份 
        &quot;d+&quot;: this.getDate(), //日 
        &quot;h+&quot;: this.getHours(), //小时 
        &quot;m+&quot;: this.getMinutes(), //分 
        &quot;s+&quot;: this.getSeconds(), //秒 
        &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), //季度 
        &quot;S&quot;: this.getMilliseconds() //毫秒 
    &#125;;
    if (/(y+)/.test(fmt)) &#123;
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length));
    &#125;
    for (var k in o)&#123;
        if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt))&#123;
            fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)));
        &#125;
    &#125;
    return fmt;
&#125;
var commonUtils = &#123;
        sleep:function(numberMillis)&#123;
             var now = new Date();
                var exitTime = now.getTime() + numberMillis;
                while (true) &#123;
                    now = new Date();
                    if (now.getTime() &gt; exitTime)
                        return;
                &#125;
        &#125;,
        round:function(src,pos)&#123;
            if(typeof src !==&#39;number&#39;)&#123;
                src = parseFloat(src);
                if(isNaN(src))&#123;
                    src = 0;
                &#125;
            &#125;
            if(!pos)&#123;
                pos = 2;
            &#125;
            return (Math.round(src*Math.pow(10, pos))/Math.pow(10, pos)).toFixed(pos);
        &#125;,
        
        booleanValueOf:function(value)&#123;
            if(value==true || /^true$/ig.test(value))&#123;
                return true;
            &#125;else&#123;
                return false;
            &#125;
        &#125;,
        getLength:function(object) &#123;
            var count = 0;
            for(var i in object) count++;
            return count;
        &#125;,
        isObject: function(obj)&#123;
            return Object.prototype.toString.call(obj) === &quot;[object Object]&quot;;
        &#125;,
        isArray: function(obj)&#123;
            return Object.prototype.toString.call(obj) === &quot;[object Array]&quot;;
        &#125;,
        isFunction: function(obj)&#123;
            return Object.prototype.toString.call(obj) === &quot;[object Function]&quot;;
        &#125;,
        isBoolean: function(obj)&#123;
            return Object.prototype.toString.call(obj) === &quot;[object Boolean]&quot;;
        &#125;,
        isNumber: function(obj)&#123;
            return Object.prototype.toString.call(obj) === &quot;[object Number]&quot;;
        &#125;,
        isString: function(obj)&#123;
            return Object.prototype.toString.call(obj) === &quot;[object String]&quot;;
        &#125;,
        isUndefined: function(obj)&#123;
            return Object.prototype.toString.call(obj) === &quot;[object Undefined]&quot;;
        &#125;,
        isEmpty: function(obj)&#123;
            if(obj == null || obj == &#39;undefined&#39; || obj == undefined || obj.length==0)&#123;
                return true;
            &#125;else&#123;
                return false;
            &#125;
            
        &#125;,
        //设置百分率
        setRate: function (data)&#123;
            data = data +&quot;&quot;;
            return data.indexOf(&quot;NaN&quot;) != - 1?&quot;0.00&quot;:parseFloat(data).toFixed(2)+&quot;&quot;;
        &#125;,
        //去除空格
        trim: function (str)&#123; 
            
          return String(str).replace(/(^\s*)|(\s*$)/g, &quot;&quot;); 
        &#125;,
        /**
         * 计算输入值得最小整数值
         * @param &#123;Object&#125; val
         */
        getYMinVal : function(min,max)&#123;
            if((min + Math.abs(min)) != 0)&#123;
                var minS = &quot;&quot;;
                var minC = min+&quot;&quot;;
                if(minC.indexOf(&quot;.&quot;) != -1 &amp;&amp; &quot;0&quot; == (minC.substring(0,minC.indexOf(&quot;.&quot;))))&#123;
                    if(max &lt;3)&#123;
                        minS =  minC.substring(0,minC.indexOf(&quot;.&quot;)+2);
                    &#125;else&#123;
                        minS = &quot;0&quot;;
                    &#125;
                &#125;else &#123;
                	if(minC.indexOf(&quot;.&quot;)!=-1)&#123;
                		if(max &lt; 5)&#123;
                			minS = ((minC * 0.98)+&quot;&quot;).substring(0,((minC * 0.98)+&quot;&quot;).indexOf(&quot;.&quot;)+2)
                		&#125;else if(max &lt; 10)&#123;
                			minS = ((minC * 0.95)+&quot;&quot;).substring(0,((minC * 0.95)+&quot;&quot;).indexOf(&quot;.&quot;)+2)
                		&#125;else if(max &lt; 20)&#123;
                			minS = ((minC * 0.9)+&quot;&quot;).substring(0,((minC * 0.9)+&quot;&quot;).indexOf(&quot;.&quot;)+2)
                		&#125;else&#123;
                			minS = minC.substring(0,minC.indexOf(&quot;.&quot;));
                			if(minS.length == 1)&#123;
                                if(max &gt; 30)&#123;
                                    minS = &quot;0&quot;;
                                &#125;
                            &#125;else if(minS.length &lt; 3)&#123;
                                var zeros = &quot;&quot;;
                                for(var i=0;i&lt;minS.length-1;i++)&#123;
                                    zeros += &quot;0&quot;;
                                &#125;
                                minS = minS.substring(0,1)+zeros;
                            &#125;else&#123;
                                var zeros = &quot;&quot;;
                                for(var i=0;i&lt;minS.length-2;i++)&#123;
                                    zeros += &quot;0&quot;;
                                &#125;
                                minS = minS.substring(0,2)+zeros;
                            &#125;
                		&#125;
                	&#125;else&#123;
                		minS = minC;
                		if(minS.length == 1)&#123;
                            if(max &lt; 30)&#123;
                                minCS = &quot;0&quot;;
                            &#125;
                        &#125;else if(minS.length &lt;= 3)&#123;
                            var zeros = &quot;&quot;;
                            for(var i=0;i&lt;minS.length-1;i++)&#123;
                                zeros += &quot;0&quot;;
                            &#125;
                            minS = minS.substring(0,1)+zeros;
                        &#125;else&#123;
                            var zeros = &quot;&quot;;
                            for(var i=0;i&lt;minS.length-2;i++)&#123;
                                zeros += &quot;0&quot;;
                            &#125;
                            minS = minS.substring(0,2)+zeros;
                        &#125;
                	&#125;
                &#125;

                return minS.indexOf(&quot;.&quot;) != -1?parseFloat(minS):parseInt(minS);
            &#125;
            
            if(isNaN(min) || min==0)&#123;
                return 0;
            &#125;
            if(max-min&lt;=5)&#123;
                return Math.floor(min);
            &#125;
            
            var t_val = Math.abs(min);
            var temp = 0;
            
            if(t_val&lt;100)&#123;
                temp = Math.floor((min)/5)*5;
            &#125;else if(t_val&gt;=100 &amp;&amp; t_val&lt;1000)&#123;
                temp = Math.floor((min)/50)*50;
            &#125;else if(t_val&gt;=1000 &amp;&amp; t_val&lt;10000)&#123;
                temp = Math.floor((min)/500)*500;
            &#125;else if(t_val&gt;=10000 &amp;&amp; t_val&lt;100000)&#123;
                temp = Math.floor((min)/5000)*5000;
            &#125;else if(t_val&gt;=100000)&#123;
                temp = Math.floor((min)/50000)*50000;
            &#125;
            if(min&gt;0 &amp;&amp; max&gt;0 &amp;&amp; temp&lt;0)&#123;
                return 0;
            &#125;else&#123;
                return temp;
            &#125;
        &#125;,
        getIndexWithArr: function(_arr,_obj) &#123;
            var len = _arr.length;
            for(var i = 0; i &lt; len; i++)
            &#123;
                if(_arr[i] == _obj)
                &#123;
                    return parseInt(i);
                &#125;
            &#125;
            return -1;
        &#125;,
        removeObjWithArr :function (_arr,_obj) &#123;
            var length = _arr.length;
            for(var i = 0; i &lt; length; i++)&#123;
                if(_arr[i] == _obj)&#123;
                	return _arr.splice(i,1);
                    if(i == 0)&#123;
                        _arr.shift(); //删除并返回数组的第一个元素
                        return;
                    &#125;else if(i == length-1)&#123;
                        _arr.pop();  //删除并返回数组的最后一个元素
                        return;
                    &#125;else&#123;
                    	return _arr.splice(i,1); //删除下标为i的元素
                        
                    &#125;
                &#125;
            &#125;
        &#125;,
        /*比较对象*/
        compare:function(objA, objB) &#123;
            var flag = true;
            if(!commonUtils.isObject(objA) || !commonUtils.isObject(objB))&#123;
            	flag = false; //判断类型是否正确
            &#125;
            if(commonUtils.getLength(objA) != commonUtils.getLength(objB))&#123;
            	flag = false; //判断长度是否一致
            &#125;
            for(var key in objA) &#123;
                if(!flag) //跳出整个循环
                    break;
                if(!objB.hasOwnProperty(key)) &#123;
                    flag = false;
                    break;
                &#125;
                if(!commonUtils.isArray(objA[key])) &#123; //子级不是数组时,比较属性值
                    if(objB[key] != objA[key]) &#123;
                        flag = false;
                        break;
                    &#125;
                &#125; else &#123;
                    if(!commonUtils.isArray(objB[key])) &#123;
                        flag = false;
                        break;
                    &#125;
                    var oA = objA[key],
                        oB = objB[key];
                    if(oA.length != oB.length) &#123;
                        flag = false;
                        break;
                    &#125;
                    for(var k in oA) &#123;
                        if(!flag) //这里跳出循环是为了不让递归继续
                            break;
                        flag = CompareObj(oA[k], oB[k], flag);
                    &#125;
                &#125;
            &#125;
            return flag;
        &#125;
&#125;
</code></pre>
<h2 id="四、java里面一些日期处理方法"><a href="#四、java里面一些日期处理方法" class="headerlink" title="四、java里面一些日期处理方法"></a>四、java里面一些日期处理方法</h2><pre><code class="prettyprint">public class DateUtils &#123;

    /**
     * 
     * 方法说明：获取当前日期最近的星期五 Author： PengP Create Date： 2018年7月27日 上午10:06:37
     * 如果是星期五获取上个星期五的数据
     * @param date
     *            日期 2018-7-27
     * @param format
     *            yyyy-MM-dd
     * @return
     * @throws ParseException
     */
    public static String getLastForWeekForInit(Date dateParam)&#123;
        SimpleDateFormat sdfDefault = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Date date = null;
        try &#123;
            String yzTime = getTimeInterval(dateParam,&quot;yyyy-MM-dd&quot;);// 获取选中日期本周时间区间
            String array[] = yzTime.split(&quot;,&quot;);
            String startTime = array[0];// 本周第一天
            String endTime = array[1]; // 本周最后一天
            // 格式化日期
            Date dBegin = sdfDefault.parse(startTime);
            Date dEnd = sdfDefault.parse(endTime);
            List&lt;Date&gt; lDate = findDates(dBegin, dEnd);// 获取这周所有date
            if (lDate.get(4).getTime() &gt; dateParam.getTime() - 24 * 3600 * 1000) &#123;
                date = new Date(lDate.get(4).getTime() - 7 * 24 * 3600 * 1000);
            &#125;else&#123;
                date = lDate.get(4);
            &#125;
        &#125; catch (ParseException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        return sdfDefault.format(date);
    &#125;
    /**
     * 
     * 方法说明：获取当前日期最近的星期五
     * 如果是星期五获取这个星期五的数据
     * Author： PengP               
     * Create Date： 2018年8月2日 上午10:46:09
     * @param dateParam
     * @return
     */
    public static String getLastForWeek(Date dateParam)&#123;
        SimpleDateFormat sdfDefault = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Date date = null;
        try &#123;
            String yzTime = getTimeInterval(dateParam,&quot;yyyy-MM-dd&quot;);// 获取选中日期本周时间区间
            String array[] = yzTime.split(&quot;,&quot;);
            String startTime = array[0];// 本周第一天
            String endTime = array[1]; // 本周最后一天
            // 格式化日期
            Date dBegin = sdfDefault.parse(startTime);
            Date dEnd = sdfDefault.parse(endTime);
            List&lt;Date&gt; lDate = findDates(dBegin, dEnd);// 获取这周所有date
            if (lDate.get(4).getTime() &gt; dateParam.getTime()) &#123;
                date = new Date(lDate.get(4).getTime() - 7 * 24 * 3600 * 1000);
            &#125;else&#123;
                date = lDate.get(4);
            &#125;
        &#125; catch (ParseException e) &#123;
            // TODO Auto-generated catch block
            e.printStackTrace();
        &#125;
        return sdfDefault.format(date);
    &#125;
    /**
     * 
     * 方法说明：获取当前日期最近的星期五 Author： PengP Create Date： 2018年7月27日 上午10:06:37
     * 今天星期五就上个星期五
     * @param date
     *            日期 2018-7-27
     * @param format
     *            yyyy-MM-dd
     * @return
     * @throws ParseException
     */
    public static String getLastForWeekForInit(String dateStr, String format)&#123;
        Date date = null;
        SimpleDateFormat sdf = new SimpleDateFormat(format);
        try&#123;
            String yzTime = getTimeInterval(sdf.parse(dateStr),format);// 获取选中日期本周时间区间
            String array[] = yzTime.split(&quot;,&quot;);
            String startTime = array[0];// 本周第一天
            String endTime = array[1]; // 本周最后一天
            // 格式化日期
            Date dBegin = sdf.parse(startTime);
            Date dEnd = sdf.parse(endTime);
            List&lt;Date&gt; lDate = findDates(dBegin, dEnd);// 获取这周所有date
            if (lDate.get(4).getTime() &gt; sdf.parse(dateStr).getTime()-24 * 3600 * 1000) &#123;
                date = new Date(lDate.get(4).getTime() - 7 * 24 * 3600 * 1000);
            &#125;else&#123;
                date = lDate.get(4);
            &#125;
        &#125; catch (ParseException e) &#123;
            e.printStackTrace();
        &#125;
        return sdf.format(date);
    &#125;
    /**
     * 
     * 方法说明：获取当前日期最近的星期五 Author： PengP Create Date： 2018年7月27日 上午10:06:37
     * 今天星期五就星期五
     * @param date
     *            日期 2018-7-27
     * @param format
     *            yyyy-MM-dd
     * @return
     * @throws ParseException
     */
    public static String getLastForWeek(String dateStr, String format)&#123;
        Date date = null;
        SimpleDateFormat sdf = new SimpleDateFormat(format);
        try&#123;
            String yzTime = getTimeInterval(sdf.parse(dateStr),format);// 获取选中日期本周时间区间
            String array[] = yzTime.split(&quot;,&quot;);
            String startTime = array[0];// 本周第一天
            String endTime = array[1]; // 本周最后一天
            // 格式化日期
            Date dBegin = sdf.parse(startTime);
            Date dEnd = sdf.parse(endTime);
            List&lt;Date&gt; lDate = findDates(dBegin, dEnd);// 获取这周所有date
            if (lDate.get(4).getTime() &gt; sdf.parse(dateStr).getTime()) &#123;
                date = new Date(lDate.get(4).getTime() - 7 * 24 * 3600 * 1000);
            &#125;else&#123;
                date = lDate.get(4);
            &#125;
        &#125; catch (ParseException e) &#123;
            e.printStackTrace();
        &#125;
        return sdf.format(date);
    &#125;
    /**
     * 
     * 方法说明：根据当前日期获得上个月月份  Author： HaoRanY Create Date： 2018年8月24日
     * 上午11:11:30
     * 
     * @param date
     * @return
     */
     public static String getLastMonthDate(Date dateParam) &#123;
         SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMM&quot;);
         Calendar c = Calendar.getInstance();
         c.setTime(dateParam);
         c.add(Calendar.MONTH, -1);
 
         return sdf.format(c.getTime());
     &#125;
     
    /**
     * 方法说明：根据当前日期获得上个月月份 
     * @author haokaih，2018年8月29日
     * @param dateParam date参数
     * @param format 以什么格式返回 如 &quot;yyyy-MM&quot;
     * @return 根据参数进行转化 如 &quot;2018-08&quot;
     */
    public static String getLastMonth(Date dateParam, String format) &#123;
        SimpleDateFormat sdf = new SimpleDateFormat(format);
        Calendar c = Calendar.getInstance();
        c.setTime(dateParam);
        c.add(Calendar.MONTH, -1);
        return sdf.format(c.getTime());
    &#125;

    /**
     * 
     * 方法说明：根据当前日期获得所在周的日期区间（周一和周日日期） Author： PengP Create Date： 2018年7月27日
     * 上午10:20:30
     * 
     * @param date
     * @return
     */
    public static String getTimeInterval(Date date,String format) &#123;
        SimpleDateFormat sdf = new SimpleDateFormat(format);
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        // 判断要计算的日期是否是周日，如果是则减一天计算周六的，否则会出问题，计算到下一周去了
        int dayWeek = cal.get(Calendar.DAY_OF_WEEK);// 获得当前日期是一个星期的第几天
        if (1 == dayWeek) &#123;
            cal.add(Calendar.DAY_OF_MONTH, -1);
        &#125;
        // System.out.println(&quot;要计算日期为:&quot; + sdf.format(cal.getTime())); // 输出要计算日期
        // 设置一个星期的第一天，按中国的习惯一个星期的第一天是星期一
        cal.setFirstDayOfWeek(Calendar.MONDAY);
        // 获得当前日期是一个星期的第几天
        int day = cal.get(Calendar.DAY_OF_WEEK);
        // 根据日历的规则，给当前日期减去星期几与一个星期第一天的差值
        cal.add(Calendar.DATE, cal.getFirstDayOfWeek() - day);
        String imptimeBegin = sdf.format(cal.getTime());
        // System.out.println(&quot;所在周星期一的日期：&quot; + imptimeBegin);
        cal.add(Calendar.DATE, 6);
        String imptimeEnd = sdf.format(cal.getTime());
        // System.out.println(&quot;所在周星期日的日期：&quot; + imptimeEnd);
        return imptimeBegin + &quot;,&quot; + imptimeEnd;
    &#125;
    public static String getLastForWeekForInit(String dateStr)&#123;
        return DateUtils.getLastForWeekForInit(dateStr, &quot;yyyy-MM-dd&quot;);
    &#125;
    public static String getLastForWeek(String dateStr)&#123;
        return DateUtils.getLastForWeek(dateStr, &quot;yyyy-MM-dd&quot;);
    &#125;
    /**
     * 
     * 方法说明：根据当前日期获得上周的日期区间（上周周一和周日日期） Author： PengP Create Date： 2018年7月27日
     * 上午10:20:13
     * 
     * @return
     */
    public static String getLastTimeInterval() &#123;
        SimpleDateFormat sdfDefault = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Calendar calendar1 = Calendar.getInstance();
        Calendar calendar2 = Calendar.getInstance();
        int dayOfWeek = calendar1.get(Calendar.DAY_OF_WEEK) - 1;
        int offset1 = 1 - dayOfWeek;
        int offset2 = 7 - dayOfWeek;
        calendar1.add(Calendar.DATE, offset1 - 7);
        calendar2.add(Calendar.DATE, offset2 - 7);
        // System.out.println(sdf.format(calendar1.getTime()));// last Monday
        String lastBeginDate = sdfDefault.format(calendar1.getTime());
        // System.out.println(sdf.format(calendar2.getTime()));// last Sunday
        String lastEndDate = sdfDefault.format(calendar2.getTime());
        return lastBeginDate + &quot;,&quot; + lastEndDate;
    &#125;

    /**
     * 
     * 方法说明：获取一周开始到结束的list集合 Author： PengP Create Date： 2018年7月27日 上午10:19:37
     * 
     * @param dBegin
     *            开始日期
     * @param dEnd
     *            结束日期
     * @return
     */
    public static List&lt;Date&gt; findDates(Date dBegin, Date dEnd) &#123;
        List&lt;Date&gt; lDate = new ArrayList&lt;Date&gt;();
        lDate.add(dBegin);
        Calendar calBegin = Calendar.getInstance();
        // 使用给定的 Date 设置此 Calendar 的时间
        calBegin.setTime(dBegin);
        Calendar calEnd = Calendar.getInstance();
        // 使用给定的 Date 设置此 Calendar 的时间
        calEnd.setTime(dEnd);
        // 测试此日期是否在指定日期之后
        while (dEnd.after(calBegin.getTime())) &#123;
            // 根据日历的规则，为给定的日历字段添加或减去指定的时间量
            calBegin.add(Calendar.DAY_OF_MONTH, 1);
            lDate.add(calBegin.getTime());
        &#125;
        return lDate;
    &#125;
    /**
     * 
     * 方法说明：根据格式获取日期字符串
     * Author： PengP               
     * Create Date： 2018年7月27日 上午11:34:57
     * @param Date
     * @param format
     * @return
     */
    public static String getStrDate(Date date,String format)&#123;
        return new SimpleDateFormat(format).format(date);
    &#125;
    /**
     * 
     * 方法说明：根据默认格式获取日期字符串
     * Author： PengP               
     * Create Date： 2018年7月27日 上午11:36:48
     * @param date
     * @return
     */
    public static String getStrDate(Date date)&#123;
        return getStrDate(date, &quot;yyyy-MM-dd&quot;);
    &#125;

    /**
     * 获取指定日期(不包括指定日期)的前指定数量周日期数据
     * 日期参数和格式参数要一致，返回的格式也是由格式参数决定
     * @param dateStr 20180727
     * @param period 指定周期数
     * @param formatter yyyyMMdd
     * @return
     */
    public static List&lt;String&gt; getDateStrList(String dateStr, int period, String formatter) &#123;
        List&lt;String&gt; dateStrs = new ArrayList&lt;String&gt;();
        try &#123;
            SimpleDateFormat dateFormat = new SimpleDateFormat(formatter);
            Calendar calendar = Calendar.getInstance();
            Date date = dateFormat.parse(dateStr);
            calendar.setTime(date);
            for (int i = 1; i &lt; period; i++) &#123;
                calendar.add(Calendar.WEEK_OF_MONTH, -1);
                dateStrs.add(dateFormat.format(calendar.getTime()));
            &#125;
        &#125; catch (ParseException e) &#123;
            e.printStackTrace();
        &#125;
        return dateStrs;
    &#125;
    
    /**
     * 
     * 方法说明：获取传入时间的最近十二个月
     * Author：lve               
     * Create Date： 2018年8月24日 上午9:06:50
     * @param time 支持 2018-01的时间字符串格式
     * @return
     */
    public static List&lt;String&gt; getLast12Months(String time)&#123;  
        //处理月份输入条件
        if(time.length()==7)&#123;
            time=time+&quot;-01 00:00:00&quot;;
        &#125;else if(time.length()==110)&#123;
            time=time.substring(0,7)+&quot;-01 00:00:00&quot;;
        &#125;
        Date date = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);  
        try &#123;
             date= sdf.parse(time);
        &#125; catch (ParseException e) &#123;
            return null;
        &#125; 
        
        Calendar cal = Calendar.getInstance();
        //设置输入条件时间
        cal.setTime(date);
        
        cal.set(Calendar.MONTH, cal.get(Calendar.MONTH)+1); //要先+1,才能把本月的算进去
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        for(int i=0; i&lt;11; i++)&#123; 
            cal.set(Calendar.MONTH, cal.get(Calendar.MONTH)-1); //逐次往前推1个月  
            list.add(cal.get(Calendar.YEAR)+ &quot;&quot; + addZeroForNum(String.valueOf(cal.get(Calendar.MONTH)+1), 2));  
        &#125;  
        return list;  
    &#125;  
    /**
     * 
     * 方法说明：时间格式补0
     * Author： lve               
     * Create Date： 2018年8月24日 上午9:08:53
     * @param str
     * @param strLength
     * @return
     */
    public static String addZeroForNum(String str, int strLength) &#123;  
        int strLen = str.length();  
        if (strLen &lt; strLength) &#123;  
            while (strLen &lt; strLength) &#123;  
                StringBuffer sb = new StringBuffer();  
                sb.append(&quot;0&quot;).append(str);// 左补0    
                str = sb.toString();  
                strLen = str.length();  
            &#125;  
        &#125;  
        return str;  
    &#125;  

    public static void main(String[] args) &#123;
        System.out.println(getLast12Months(&quot;2018-07&quot;));
    &#125;
    
&#125;
</code></pre>
<h2 id="五、oracle-SQL小技巧"><a href="#五、oracle-SQL小技巧" class="headerlink" title="五、oracle SQL小技巧"></a>五、oracle SQL小技巧</h2><h3 id="1、megre-into"><a href="#1、megre-into" class="headerlink" title="1、megre into"></a>1、megre into</h3><pre><code class="prettyprint">MERGE INTO table1 T1
        USING (SELECT  &#39;&#39; cloumn 
                 FROM DUAL) T2
        ON (T1.cloumn      = T2.cloumn)
        WHEN MATCHED THEN
          UPDATE
             SET T1.cloumn1      = T2.cloumn1
        WHEN NOT MATCHED THEN
        insert
          (cloumn1)
        values
          (T2.cloumn1)
</code></pre>
<h3 id="2、连续前几周连续的周日期数据-2019W14-2019W25"><a href="#2、连续前几周连续的周日期数据-2019W14-2019W25" class="headerlink" title="2、连续前几周连续的周日期数据(2019W14-2019W25)"></a>2、连续前几周连续的周日期数据(2019W14-2019W25)</h3><pre><code class="prettyprint">select to_char(t.statCycle, &#39;yyyyMMdd&#39;) statCycleDay,
       to_char(t.statCycle, &#39;yyyy&#39;) || &#39;W&#39; || to_char(t.statCycle, &#39;WW&#39;) statCycle
  from (select Rownum rn,
               (trunc(to_date(&#39;20190622&#39;, &#39;yyyyMMdd&#39;) + Rownum - 7 * 12,
                      &#39;dd&#39;)) statCycle
          from dual
        connect by rownum &lt;= 7 * 12) t
 where t.rn / 7 = cast(t.rn / 7 as int)
 order by t.rn
</code></pre>
<h3 id="3、获取前几天的天日期数据"><a href="#3、获取前几天的天日期数据" class="headerlink" title="3、获取前几天的天日期数据"></a>3、获取前几天的天日期数据</h3><pre><code class="prettyprint">select Rownum rn,
       to_char((trunc(to_date(&#39;20190622&#39;, &#39;yyyyMMdd&#39;) + Rownum - 12, &#39;dd&#39;)),
               &#39;yyyyMMdd&#39;) statCycle
  from dual
connect by rownum &lt;= 12
</code></pre>
<h3 id="4、获取前几个月的月日期数据"><a href="#4、获取前几个月的月日期数据" class="headerlink" title="4、获取前几个月的月日期数据"></a>4、获取前几个月的月日期数据</h3><pre><code class="prettyprint">select k.stat_cycle statCycle
  from (select t.stat_cycle, rownum rn
          from (select to_char(to_date(&#39;201906&#39;, &#39;yyyyMM&#39;), &#39;yyyy&#39;) - 1 ||
                       lpad(level, 2, 0) stat_cycle
                  from dual
                 start with level = 0
                connect by level &lt;= 12
                union all
                select to_char(to_date(&#39;201906&#39;, &#39;yyyyMM&#39;), &#39;yyyy&#39;) ||
                       lpad(level, 2, 0) stat_cycle
                  from dual
                connect by level &lt;=
                           to_char(to_date(&#39;201906&#39;, &#39;yyyyMM&#39;), &#39;MM&#39;)) t) k
 where k.rn &gt; to_char(to_date(&#39;201906&#39;, &#39;yyyyMM&#39;), &#39;MM&#39;)
</code></pre>
<h3 id="5、获取最近24小时数据"><a href="#5、获取最近24小时数据" class="headerlink" title="5、获取最近24小时数据"></a>5、获取最近24小时数据</h3><pre><code class="prettyprint">select Rownum, trunc(sysdate, &#39;hh&#39;) + rownum / 24 past24
  from dual
connect by rownum &lt;= 24
</code></pre>
<h3 id="6、字符串’aaa-bbb-ccc’转表数据’aaa’-’bbb’-’ccc’"><a href="#6、字符串’aaa-bbb-ccc’转表数据’aaa’-’bbb’-’ccc’" class="headerlink" title="6、字符串’aaa,bbb,ccc’转表数据’aaa’,’bbb’,’ccc’"></a>6、字符串’aaa,bbb,ccc’转表数据’aaa’,’bbb’,’ccc’</h3><pre><code class="prettyprint">select regexp_substr(&#39;aaa,bbb,ccc&#39;, &#39;[^,]+&#39;, 1, level)
  from dual
connect by level &lt;=
           length(&#39;aaa,bbb,ccc&#39;) - length(replace(&#39;aaa,bbb,ccc&#39;, &#39;,&#39;)) + 1
</code></pre>
<h3 id="7、Oracle中rank-over-dense-rank-row-number-的区别"><a href="#7、Oracle中rank-over-dense-rank-row-number-的区别" class="headerlink" title="7、Oracle中rank() over, dense_rank(), row_number() 的区别"></a>7、Oracle中rank() over, dense_rank(), row_number() 的区别</h3><pre><code class="prettyprint">--1. rank over ()可以实现对学生排名，特点是成绩相同的两名是并列，如下1 2 2 4 5
select name,
      course,
      rank() over(partition by course order by score desc) as rank
  from student;
--2. dense_rank()和rank over()很像，但学生成绩并列后并不会空出并列所占的名次，如下1 2 2 3 4
 
select name,
      course,
      dense_rank() over(partition by course order by score desc) as rank
  from student;
--3. row_number这个函数不需要考虑是否并列，那怕根据条件查询出来的数值相同也会进行连续排名
select name,
      course,
      row_number() over(partition by course order by score desc) as rank
  from student;
</code></pre>
<h3 id="8、group-by-与-partition-by-区别"><a href="#8、group-by-与-partition-by-区别" class="headerlink" title="8、group by 与 partition by 区别"></a>8、group by 与 partition by 区别</h3><pre><code class="prettyprint">1. partition by用于给结果集进行分区。
2. partition by和group by有何区别？
partition by只是将原始数据进行名次排列(记录数不变)
group by是对原始数据进行聚合统计(记录数可能变少, 每组返回一条)
3. 使用rank over()的时候，空值是最大的，如果排序字段为null, 可能造成null字段排在最前面，影响排序结果。
可以这样： rank over(partition by course order by score desc nulls last)
</code></pre>
<h3 id="9、DDL"><a href="#9、DDL" class="headerlink" title="9、DDL"></a>9、DDL</h3><pre><code class="prettyprint">--修改字段类型
ALTER TABLE ADDRESS MODIFY COLUMN CITY CHAR(30);
--修改字段长度
ALTER TABLE ADDRESS MODIFY COLUMN CITY VARCHAR(32);
--新增字段
ALTER TABLE ADDRESS ADD (CITY VARCHAR2(256));
-- 给字段添加注释
COMMENT ON COLUMN ADDRESS.CITY
  IS &#39;发帖人联系方式&#39;;
</code></pre>
<h3 id="10、plsq注册码"><a href="#10、plsq注册码" class="headerlink" title="10、plsq注册码"></a>10、plsq注册码</h3><p>​	Product Code：4t46t6vydkvsxekkvf3fjnpzy5wbuhphqz</p>
<p>​	serial Number：601769</p>
<p>​	password：xs374ca</p>
<h3 id="11、行转列"><a href="#11、行转列" class="headerlink" title="11、行转列"></a>11、行转列</h3><p>​	<em>LISTAGG</em>(BUY,’,’) WITHIN GROUP(ORDERBYBUYDESC)</p>
<h3 id="12、根据某一个字段排序获取序号"><a href="#12、根据某一个字段排序获取序号" class="headerlink" title="12、根据某一个字段排序获取序号"></a>12、根据某一个字段排序获取序号</h3><p>​	ROW_NUMBER() OVER(PARTITION BY A.org_no ORDER BY a.det_id DESC) rowflag</p>
<h3 id="13、根据某一个字段获取数量"><a href="#13、根据某一个字段获取数量" class="headerlink" title="13、根据某一个字段获取数量"></a>13、根据某一个字段获取数量</h3><p>​	count(*) over(partition by A.org_no) coutflag</p>
<h3 id="14、数据库赋权"><a href="#14、数据库赋权" class="headerlink" title="14、数据库赋权"></a>14、数据库赋权</h3><p>Grant select on iima_comm.table to iima_idx</p>
<h2 id="六、css"><a href="#六、css" class="headerlink" title="六、css"></a>六、css</h2><h3 id="1、google浏览器自动填充颜色"><a href="#1、google浏览器自动填充颜色" class="headerlink" title="1、google浏览器自动填充颜色"></a>1、google浏览器自动填充颜色</h3><pre><code class="prettyprint">input:-webkit-autofill &#123;
    -webkit-box-shadow: 0 0 0px 1000px #fff inset !important;
    -webkit-text-fill-color: rgba(255,255,255,1)!important;

&#125;
</code></pre>
<p>​		<a href="https://www.cnblogs.com/garfieldzhong/p/4759690.html">input:-webkit-autofill 导致chrome的输入框背景颜色变成黄色</a></p>
<h3 id="2、滚动条改造"><a href="#2、滚动条改造" class="headerlink" title="2、滚动条改造"></a>2、滚动条改造</h3><pre><code class="prettyprint">/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/
#table tbody::-webkit-scrollbar&#123;
    width: 16px;
    height: 16px;
    background-color: rgba(24, 13, 120, 1);
&#125;
/*定义滚动条轨道 内阴影+圆角*/
#table tbody::-webkit-scrollbar-track&#123;
    -webkit-box-shadow: inset 0 0 6px #8ab1ff;
    background-color: rgba(24, 13, 120, 1);
&#125;
/*定义滑块 内阴影+圆角*/
#table tbody::-webkit-scrollbar-thumb&#123;
    border-radius: 10px;
    -webkit-box-shadow: inset 0 0 6px #8ab1ff;
    background-color: rgba(95, 137, 220, 1);
&#125;
</code></pre>
<h3 id="3、select下拉框改造"><a href="#3、select下拉框改造" class="headerlink" title="3、select下拉框改造"></a>3、select下拉框改造</h3><pre><code class="prettyprint">#page select::-ms-expand&#123;display:none;&#125;
#page select&#123;
  appearance:none;
 -moz-appearance:none;
 -webkit-appearance:none;
&#125;
#page select &#123;
    appearance:none;
    -moz-appearance:none;
     -webkit-appearance:none;
    -webkit-appearance: menulist;
    box-sizing: border-box;
    align-items: center;
    white-space: pre;
    -webkit-rtl-ordering: logical;
    color: #8ab1ff;
    background-color: rgba(255, 255, 255, -0.6);
    cursor: default;
    border-width: 1px;
    border-style: solid;
    border-color: initial;
    border-image: initial;
    border-radius: 3px;
    height: 22px;
    width: 60px;
    font-size: 16px;
&#125;
#page option &#123;
    background-color: rgb(27,17,117);
&#125;
</code></pre>
<h2 id="七、mysql"><a href="#七、mysql" class="headerlink" title="七、mysql"></a>七、mysql</h2><h3 id="1、this-is-incompatible-with-sql-mode-x3D-only-full-group-by"><a href="#1、this-is-incompatible-with-sql-mode-x3D-only-full-group-by" class="headerlink" title="1、this is incompatible with sql_mode&#x3D;only_full_group_by"></a>1、this is incompatible with sql_mode&#x3D;only_full_group_by</h3><pre><code class="prettyprint">--  mysql 7、8问题
SELECT @@global.sql_mode  
--结果
&#39;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;
--修改方式
SET @@global.sql_mode = &#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;
</code></pre>
<h3 id="2、日期获取"><a href="#2、日期获取" class="headerlink" title="2、日期获取"></a>2、日期获取</h3><pre><code class="prettyprint">SELECT @num:=@num+1 num,DATE_FORMAT(ADDDATE(&#39;2018-06-10&#39;, INTERVAL @num DAY),&#39;%Y-%m-%d&#39;) AS DATE
FROM pt_code,(SELECT @num:=0) t WHERE ADDDATE(&#39;2018-06-10&#39;, INTERVAL @num DAY) &lt;= DATE_FORMAT(CURDATE(),&#39;%Y-%m-%d&#39;)
LIMIT 0,30
</code></pre>
<h3 id="3、转化成数字排序"><a href="#3、转化成数字排序" class="headerlink" title="3、转化成数字排序"></a>3、转化成数字排序</h3><pre><code class="prettyprint">ORDER BY CAST(DATA1 AS SIGNED)
</code></pre>
<h3 id="4、CSV文件导入数据"><a href="#4、CSV文件导入数据" class="headerlink" title="4、CSV文件导入数据"></a>4、CSV文件导入数据</h3><pre><code class="prettyprint">LOAD DATA LOCAL INFILE 
    &#39;C:\\Users\\Administrator\\Desktop\\AAA.csv&#39;
    INTO TABLE `blog`.`k_lrp`
FIELDS ESCAPED BY &#39;\\&#39;  
TERMINATED BY &#39;,&#39;   
ENCLOSED BY &#39;&quot;&#39;  
LINES TERMINATED BY   &#39;\r\n&#39;  
(`LRP_ID`, `ORG_NO`, `YM`, `X_VALUE`, `DATA_OPER_TIME`, `DATA_OPER_TYPE`,`Y_VAULE`)
</code></pre>
<h3 id="5、前2个月"><a href="#5、前2个月" class="headerlink" title="5、前2个月"></a>5、前2个月</h3><pre><code class="prettyprint">SELECT 
  DATE_FORMAT(
    DATE_ADD(
      STR_TO_DATE(CONCAT(&#39;20201210&#39;, &#39;01&#39;), &#39;%Y%m%d&#39;),
      INTERVAL (1 - CAST(k.rn AS SIGNED INTEGER)) MONTH
    ),
    &#39;%Y%m&#39;
  ) stat_cycle 
FROM
  (SELECT 
    @rn := @rn + 1 rn 
  FROM
    pt_code g,
    (SELECT 
      @rn := 0) f 
  LIMIT 0, 31) k 
WHERE k.rn &lt;= 12 
</code></pre>
<h3 id="6、前30天数据"><a href="#6、前30天数据" class="headerlink" title="6、前30天数据"></a>6、前30天数据</h3><pre><code class="prettyprint">--不包含当天
SELECT @num:=@num+1 num,DATE_FORMAT(ADDDATE(&#39;20201210&#39;, INTERVAL -@num DAY),&#39;%Y%m%d&#39;) AS stat_cycle
FROM pt_code,(SELECT @num:=0) t
LIMIT 0,30
--包含当天
SELECT @num:=@num+1 num,DATE_FORMAT(ADDDATE(&#39;20201210&#39;, INTERVAL 1-@num DAY),&#39;%Y%m%d&#39;) AS stat_cycle
FROM pt_code,(SELECT @num:=0) t
LIMIT 0,30
</code></pre>
<h2 id="八、nginx"><a href="#八、nginx" class="headerlink" title="八、nginx"></a>八、nginx</h2><h3 id="1、win启动"><a href="#1、win启动" class="headerlink" title="1、win启动"></a>1、win启动</h3><p>cmd进入nginx根目录执行   <code>nginx -t -c conf\nginx.conf</code></p>
<p>重启：nginx -s reload</p>
<p>启动：start nginx</p>
<p>停止：nginx -s stop</p>
<h3 id="2、简单配置"><a href="#2、简单配置" class="headerlink" title="2、简单配置"></a>2、简单配置</h3><pre><code class="prettyprint.conf"> server &#123;
        listen       8088;
        server_name  172.19.3.229;
        location /http-bind&#123;
            #重定向openfire请求
            proxy_pass http://172.19.3.229:17070/http-bind;
            proxy_buffering off;
            proxy_redirect off;
            proxy_read_timeout 120;
            proxy_connect_timeout 600;
        &#125;
        error_page   500 502 503 504  /50x.html;
        location = /50x.html &#123;
            root   html;
        &#125;
    &#125;
</code></pre>
<h2 id="九、javascript"><a href="#九、javascript" class="headerlink" title="九、javascript"></a>九、javascript</h2><h3 id="1、变化title"><a href="#1、变化title" class="headerlink" title="1、变化title"></a>1、变化title</h3><pre><code class="prettyprint">document.addEventListener(&#39;visibilitychange&#39;,function()&#123;
    if(document.visibilityState==&#39;hidden&#39;)&#123;
        normal_title=document.title;
        document.title=&#39;来啊.快活啊&#39;;
    &#125;else&#123;
        document.title=normal_title;
    &#125;
&#125;);
</code></pre>
<h3 id="3、js实现模态框拖拽"><a href="#3、js实现模态框拖拽" class="headerlink" title="3、js实现模态框拖拽"></a>3、js实现模态框拖拽</h3><pre><code class="prettyprint">//拖拽功能(主要是触发三个事件：onmousedown\onmousemove\onmouseup) 
var drag = document.getElementById(&#39;drag&#39;);
//点击某物体时，用drag对象即可，move和up是全局区域，也就是整个文档通用，应该使用document对象而不是drag对象(否则，采用drag对象时物体只能往右方或下方移动) 
drag.onmousedown = function(e) &#123;
    var e = e || window.event; //兼容ie浏览器 
    var diffX = e.clientX - drag.offsetLeft; //鼠标点击物体那一刻相对于物体左侧边框的距离=点击时的位置相对于浏览器最左边的距离-物体左边框相对于浏览器最左边的距离 
    var diffY = e.clientY - drag.offsetTop;
    /*低版本ie bug:物体被拖出浏览器可是窗口外部时，还会出现滚动条， 
              解决方法是采用ie浏览器独有的2个方法setCapture()\releaseCapture(),这两个方法， 
              可以让鼠标滑动到浏览器外部也可以捕获到事件，而我们的bug就是当鼠标移出浏览器的时候， 
              限制超过的功能就失效了。用这个方法，即可解决这个问题。注：这两个方法用于onmousedown和onmouseup中*/
    if(typeof drag.setCapture != &#39;undefined&#39;) &#123;
        drag.setCapture();
    &#125;
    document.onmousemove = function(e) &#123;
        var e = e || window.event; //兼容ie浏览器 
        var left = e.clientX - diffX;
        var top = e.clientY - diffY;
        //控制拖拽物体的范围只能在浏览器视窗内，不允许出现滚动条 
        if(left &lt; 0) &#123;
            left = 0;
        &#125; else if(left &gt; window.innerWidth - drag.offsetWidth) &#123;
            left = window.innerWidth - drag.offsetWidth;
        &#125;
        if(top &lt; 0) &#123;
            top = 0;
        &#125; else if(top &gt; window.innerHeight - drag.offsetHeight) &#123;
            top = window.innerHeight - drag.offsetHeight;
        &#125;
        //移动时重新得到物体的距离，解决拖动时出现晃动的现象 
        drag.style.left = left + &#39;px&#39;;
        drag.style.top = top + &#39;px&#39;;
    &#125;;
    document.onmouseup = function(e) &#123; //当鼠标弹起来的时候不再移动 
        this.onmousemove = null;
        this.onmouseup = null; //预防鼠标弹起来后还会循环（即预防鼠标放上去的时候还会移动） 
        //修复低版本ie bug 
        if(typeof drag.releaseCapture != &#39;undefined&#39;) &#123;
            drag.releaseCapture();
        &#125;
    &#125;;
&#125;;
</code></pre>
<h3 id="3、字符转义"><a href="#3、字符转义" class="headerlink" title="3、字符转义"></a>3、字符转义</h3><pre><code class="prettyprint">var HtmlUtil = &#123;
    /*1.用浏览器内部转换器实现html转码*/
    htmlEncode:function (html)&#123;
        //1.首先动态创建一个容器标签元素，如DIV
        var temp = document.createElement (&quot;div&quot;);
        //2.然后将要转换的字符串设置为这个元素的innerText(ie支持)或者textContent(火狐，google支持)
        (temp.textContent != undefined ) ? (temp.textContent = html) : (temp.innerText = html);
        //3.最后返回这个元素的innerHTML，即得到经过HTML编码转换的字符串了
        var output = temp.innerHTML;
        temp = null;
        return output;
    &#125;,
    /*2.用浏览器内部转换器实现html解码*/
    htmlDecode:function (text)&#123;
        //1.首先动态创建一个容器标签元素，如DIV
        var temp = document.createElement(&quot;div&quot;);
        //2.然后将要转换的字符串设置为这个元素的innerHTML(ie，火狐，google都支持)
        temp.innerHTML = text;
        //3.最后返回这个元素的innerText(ie支持)或者textContent(火狐，google支持)，即得到经过HTML解码的字符串了。
        var output = temp.innerText || temp.textContent;
        temp = null;
        return output;
    &#125;,
    /*3.用正则表达式实现html转码*/
    htmlEncodeByRegExp:function (str)&#123;  
        var s = &quot;&quot;;
        if(str.length == 0) return &quot;&quot;;
        s = str.replace(/&amp;/g,&quot;&amp;amp;&quot;);
        s = s.replace(/&lt;/g,&quot;&amp;lt;&quot;);
        s = s.replace(/&gt;/g,&quot;&amp;gt;&quot;);
        s = s.replace(/ /g,&quot;&amp;nbsp;&quot;);
        s = s.replace(/\&#39;/g,&quot;&amp;#39;&quot;);
        s = s.replace(/\&quot;/g,&quot;&amp;quot;&quot;);
        return s;  
    &#125;,
    /*4.用正则表达式实现html解码*/
    htmlDecodeByRegExp:function (str)&#123;  
        var s = &quot;&quot;;
        if(str.length == 0) return &quot;&quot;;
        s = str.replace(/&amp;amp;/g,&quot;&amp;&quot;);
        s = s.replace(/&amp;lt;/g,&quot;&lt;&quot;);
        s = s.replace(/&amp;gt;/g,&quot;&gt;&quot;);
        s = s.replace(/&amp;nbsp;/g,&quot; &quot;);
        s = s.replace(/&amp;#39;/g,&quot;\&#39;&quot;);
        s = s.replace(/&amp;quot;/g,&quot;\&quot;&quot;);
        return s;  
    &#125;
&#125;;
</code></pre>
<h3 id="4、js关闭页面"><a href="#4、js关闭页面" class="headerlink" title="4、js关闭页面"></a>4、js关闭页面</h3><pre><code class="prettyprint">function CloseWebPage() &#123;
    if (navigator.userAgent.indexOf(&quot;MSIE&quot;) &gt; 0) &#123;
        if (navigator.userAgent.indexOf(&quot;MSIE 6.0&quot;) &gt; 0) &#123;
            window.opener = null;
            window.close();
        &#125; else &#123;
            window.open(&#39; &#39;, &#39;_top&#39;);
            window.top.close();
        &#125;
    &#125; else if (navigator.userAgent.indexOf(&quot;Firefox&quot;) &gt; 0) &#123;
        window.opener = null;
        window.open(&#39; &#39;, &#39;_top&#39;);
        window.close();
    &#125; else if (navigator.userAgent.indexOf(&quot;Chrome&quot;) &gt; 0) &#123;
        window.opener = null;
        window.open(&#39; &#39;, &#39;_self&#39;);
        window.close();
    &#125; else &#123;
        window.opener = null;
        window.open(&#39; &#39;, &#39;_self&#39;);
        window.close();
    &#125;
&#125;
</code></pre>
<h3 id="5、div滚动播放"><a href="#5、div滚动播放" class="headerlink" title="5、div滚动播放"></a>5、div滚动播放</h3><pre><code class="prettyprint">&lt;div class=&quot;scroll-div&quot;&gt;
    &lt;ul&gt;
        &lt;li&gt;
            aaaa
        &lt;/li&gt;
        &lt;li&gt;
            bbb
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="prettyprint">/*滚动js*/
$(&#39;.scroll-div li:even&#39;).addClass(&#39;lieven&#39;);

$(&quot;div.scroll-div&quot;).myScroll(&#123;
    speed:13, //数值越大，速度越慢
    rowHeight:270 //li的高度
&#125;);
$.fn.myScroll = function(options)&#123;
        //默认配置
        var defaults = &#123;
            speed:40,  //滚动速度,值越大速度越慢
            rowHeight:24 //每行的高度
        &#125;;
        var opts = $.extend(&#123;&#125;, defaults, options),intId = [];
        this.each(function(i)&#123;
            var sh = opts[&quot;rowHeight&quot;];
            var speed = opts[&quot;speed&quot;];
            var _this = $(this);
            intId[i] = setInterval(function()&#123;
                marquee(_this, sh);
            &#125;, speed);

            _this.hover(function()&#123;
                clearInterval(intId[i]);
            &#125;,function()&#123;
                intId[i] = setInterval(function()&#123;
                    marquee(_this, sh);
                &#125;, speed);
            &#125;);
        
        &#125;);
        //滚动效果
        function marquee(obj, step)&#123;
            obj.find(&quot;ul&quot;).animate(&#123;
                marginTop: &#39;-=1&#39;
            &#125;,0,function()&#123;
                var s = Math.abs(parseInt($(this).css(&quot;margin-top&quot;)));
                if(s &gt;= step)&#123;
                    $(this).find(&quot;li&quot;).slice(0, 1).appendTo($(this));
                    $(this).css(&quot;margin-top&quot;, 0);
                &#125;
            &#125;);
        &#125;
    &#125;
&#125;)(jQuery);
</code></pre>
<pre><code class="prettyprint">.scroll-div&#123;
    overflow:hidden;
    font-size:13px; 
    margin-top: 12px;
    height: 268px;
&#125;
.scroll-div ul,
.scroll-div ul li&#123;
    height: 273px;
    width: 100%;
&#125;
</code></pre>
<h2 id="十、redis"><a href="#十、redis" class="headerlink" title="十、redis"></a>十、redis</h2><h3 id="1、查看连接数"><a href="#1、查看连接数" class="headerlink" title="1、查看连接数"></a>1、查看连接数</h3><p>​	netstat -an|grep 6379|wc -l</p>
<h2 id="十一、正则表达式"><a href="#十一、正则表达式" class="headerlink" title="十一、正则表达式"></a>十一、正则表达式</h2><h3 id="1、阶段替换"><a href="#1、阶段替换" class="headerlink" title="1、阶段替换"></a>1、阶段替换</h3><pre><code class="prettyprint">String sql = &quot;select * from a where a.no = #&#123;no,jdbcType=VARCHAR&#125; and a.name = #&#123;name,jdbcType=VARCHAR&#125;&quot;;
sql.replaceAll(&quot;\\#\\&#123;.+?\\&#125;&quot;,&quot;?&quot;); 
//sql = select * from a where a.no = ? and a.name = ? 
</code></pre>
<h2 id="十二、cron范例"><a href="#十二、cron范例" class="headerlink" title="十二、cron范例"></a>十二、cron范例</h2><pre><code>每隔5秒执行一次：*/5 * * * * ?

每隔1分钟执行一次：0 */1 * * * ?

每天23点执行一次：0 0 23 * * ?

每天凌晨1点执行一次：0 0 1 * * ?

每月1号凌晨1点执行一次：0 0 1 1 * ?

每月最后一天23点执行一次：0 0 23 L * ?

每周星期天凌晨1点实行一次：0 0 1 ? * L

在26分、29分、33分执行一次：0 26,29,33 * * * ?

每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?
</code></pre>
]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
  </entry>
  <entry>
    <title>测试图标</title>
    <url>/2022/04/17/ce-shi-tu-biao/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div>
    <a href="/archives/"><i class="fa fa-glass" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-music" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-search" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-envelope-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-heart" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-star" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-star-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-user" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-film" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-th-large" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-th" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-th-list" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-check" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-remove" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-search-plus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-search-minus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-power-off" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-signal" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gear" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-trash-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-home" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-clock-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-road" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-download" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-circle-o-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-circle-o-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-inbox" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-play-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-rotate-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-refresh" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-list-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-lock" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-flag" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-headphones" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-volume-off" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-volume-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-volume-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-qrcode" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-barcode" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tag" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tags" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-book" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bookmark" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-print" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-camera" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-font" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bold" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-italic" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-text-height" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-text-width" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-align-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-align-center" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-align-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-align-justify" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-list" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-dedent" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-indent" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-video-camera" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-photo" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pencil" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-map-marker" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-adjust" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tint" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-edit" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-share-square-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-check-square-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrows" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-step-backward" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fast-backward" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-backward" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-play" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pause" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-stop" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-forward" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fast-forward" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-step-forward" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-eject" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chevron-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chevron-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-plus-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-minus-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-times-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-check-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-question-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-info-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-crosshairs" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-times-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-check-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ban" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mail-forward" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-expand" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-compress" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-plus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-minus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-asterisk" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-exclamation-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gift" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-leaf" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fire" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-eye" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-eye-slash" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-warning" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-plane" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-calendar" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-random" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-comment" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-magnet" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chevron-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chevron-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-retweet" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-shopping-cart" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-folder" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-folder-open" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrows-v" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrows-h" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bar-chart-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-twitter-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-facebook-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-camera-retro" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-key" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gears" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-comments" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thumbs-o-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thumbs-o-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-star-half" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-heart-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sign-out" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-linkedin-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thumb-tack" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-external-link" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sign-in" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-trophy" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-github-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-upload" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-lemon-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-phone" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-square-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bookmark-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-phone-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-twitter" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-facebook-f" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-github" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-unlock" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-credit-card" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-feed" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hdd-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bullhorn" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bell" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-certificate" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-o-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-o-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-o-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-o-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-circle-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-circle-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-circle-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-circle-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-globe" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wrench" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tasks" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-filter" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-briefcase" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrows-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-group" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chain" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cloud" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-flask" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cut" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-copy" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-paperclip" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-save" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-navicon" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-list-ul" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-list-ol" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-strikethrough" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-underline" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-table" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-magic" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-truck" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pinterest" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pinterest-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-google-plus-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-google-plus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-money" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-caret-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-caret-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-caret-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-caret-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-columns" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-unsorted" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sort-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sort-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-envelope" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-linkedin" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-rotate-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-legal" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-dashboard" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-comment-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-comments-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-flash" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sitemap" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-umbrella" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-paste" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-lightbulb-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-exchange" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cloud-download" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cloud-upload" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-user-md" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-stethoscope" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-suitcase" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bell-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-coffee" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cutlery" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-text-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-building-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hospital-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ambulance" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-medkit" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fighter-jet" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-beer" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-h-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-plus-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angle-double-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angle-double-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angle-double-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angle-double-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angle-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angle-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angle-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angle-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-desktop" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-laptop" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tablet" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mobile-phone" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-quote-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-quote-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-spinner" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mail-reply" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-github-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-folder-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-folder-open-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-smile-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-frown-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-meh-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gamepad" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-keyboard-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-flag-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-flag-checkered" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-terminal" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-code" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mail-reply-all" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-star-half-empty" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-location-arrow" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-crop" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-code-fork" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-unlink" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-question" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-info" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-exclamation" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-superscript" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-subscript" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-eraser" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-puzzle-piece" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-microphone" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-microphone-slash" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-shield" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-calendar-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fire-extinguisher" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-rocket" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-maxcdn" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chevron-circle-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chevron-circle-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chevron-circle-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chevron-circle-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-html5" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-css3" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-anchor" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-unlock-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bullseye" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ellipsis-h" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ellipsis-v" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-rss-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-play-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ticket" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-minus-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-minus-square-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-level-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-level-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-check-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pencil-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-external-link-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-share-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-compass" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-toggle-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-toggle-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-toggle-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-euro" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gbp" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-dollar" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-rupee" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cny" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ruble" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-won" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bitcoin" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-text" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sort-alpha-asc" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sort-alpha-desc" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sort-amount-asc" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sort-amount-desc" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sort-numeric-asc" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sort-numeric-desc" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thumbs-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thumbs-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-youtube-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-youtube" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-xing" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-xing-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-youtube-play" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-dropbox" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-stack-overflow" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-instagram" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-flickr" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-adn" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bitbucket" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bitbucket-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tumblr" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tumblr-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-long-arrow-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-long-arrow-up" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-long-arrow-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-long-arrow-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-apple" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-windows" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-android" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-linux" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-dribbble" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-skype" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-foursquare" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-trello" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-female" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-male" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gittip" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sun-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-moon-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-archive" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bug" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-vk" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-weibo" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-renren" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pagelines" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-stack-exchange" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-circle-o-right" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-arrow-circle-o-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-toggle-left" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-dot-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wheelchair" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-vimeo-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-turkish-lira" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-plus-square-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-space-shuttle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-slack" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-envelope-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wordpress" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-openid" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-institution" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mortar-board" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-yahoo" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-google" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-reddit" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-reddit-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-stumbleupon-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-stumbleupon" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-delicious" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-digg" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pied-piper-pp" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pied-piper-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-drupal" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-joomla" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-language" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fax" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-building" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-child" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-paw" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-spoon" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cube" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cubes" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-behance" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-behance-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-steam" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-steam-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-recycle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-automobile" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cab" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tree" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-spotify" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-deviantart" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-soundcloud" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-database" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-pdf-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-word-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-excel-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-powerpoint-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-photo-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-zip-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-sound-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-movie-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-file-code-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-vine" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-codepen" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-jsfiddle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-life-bouy" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-circle-o-notch" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ra" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ge" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-git-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-git" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-y-combinator-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tencent-weibo" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-qq" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wechat" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-send" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-send-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-history" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-circle-thin" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-header" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-paragraph" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sliders" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-share-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-share-alt-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bomb" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-soccer-ball-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tty" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-binoculars" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-plug" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-slideshare" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-twitch" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-yelp" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-newspaper-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wifi" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-calculator" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-paypal" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-google-wallet" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc-visa" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc-mastercard" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc-discover" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc-amex" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc-paypal" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc-stripe" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bell-slash" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bell-slash-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-trash" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-copyright" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-at" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-eyedropper" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-paint-brush" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-birthday-cake" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-area-chart" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pie-chart" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-line-chart" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-lastfm" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-lastfm-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-toggle-off" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-toggle-on" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bicycle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ioxhost" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-angellist" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-shekel" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-meanpath" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-buysellads" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-connectdevelop" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-dashcube" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-forumbee" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-leanpub" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sellsy" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-shirtsinbulk" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-simplybuilt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-skyatlas" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cart-plus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cart-arrow-down" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-diamond" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ship" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-user-secret" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-motorcycle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-street-view" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-heartbeat" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-venus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mars" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mercury" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-intersex" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-transgender-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-venus-double" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mars-double" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-venus-mars" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mars-stroke" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mars-stroke-v" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mars-stroke-h" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-neuter" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-genderless" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-facebook-official" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pinterest-p" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-whatsapp" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-server" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-user-plus" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-user-times" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hotel" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-viacoin" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-train" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-subway" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-medium" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-yc" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-optin-monster" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-opencart" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-expeditedssl" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-battery-4" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-battery-3" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-battery-2" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-battery-1" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-battery-0" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mouse-pointer" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-i-cursor" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-object-group" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-object-ungroup" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sticky-note" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-sticky-note-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc-jcb" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-cc-diners-club" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-clone" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-balance-scale" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hourglass-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hourglass-1" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hourglass-2" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hourglass-3" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hourglass" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-grab-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-stop-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-scissors-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-lizard-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-spock-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-pointer-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hand-peace-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-trademark" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-registered" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-creative-commons" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gg" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gg-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tripadvisor" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-odnoklassniki" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-odnoklassniki-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-get-pocket" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wikipedia-w" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-safari" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-chrome" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-firefox" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-opera" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-internet-explorer" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-tv" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-contao" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-500px" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-amazon" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-calendar-plus-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-calendar-minus-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-calendar-times-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-calendar-check-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-industry" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-map-pin" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-map-signs" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-map-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-map" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-commenting" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-commenting-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-houzz" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-vimeo" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-black-tie" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fonticons" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-reddit-alien" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-edge" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-credit-card-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-codiepie" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-modx" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fort-awesome" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-usb" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-product-hunt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-mixcloud" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-scribd" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pause-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pause-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-stop-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-stop-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-shopping-bag" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-shopping-basket" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-hashtag" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bluetooth" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bluetooth-b" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-percent" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-gitlab" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wpbeginner" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wpforms" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-envira" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-universal-access" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wheelchair-alt" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-question-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-blind" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-audio-description" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-volume-control-phone" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-braille" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-assistive-listening-systems" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-asl-interpreting" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-deafness" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-glide" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-glide-g" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-signing" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-low-vision" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-viadeo" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-viadeo-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-snapchat" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-snapchat-ghost" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-snapchat-square" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-pied-piper" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-first-order" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-yoast" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-themeisle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-google-plus-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-fa" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-handshake-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-envelope-open" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-envelope-open-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-linode" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-address-book" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-address-book-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-vcard" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-vcard-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-user-circle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-user-circle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-user-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-id-badge" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-drivers-license" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-drivers-license-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-quora" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-free-code-camp" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-telegram" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thermometer-4" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thermometer-3" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thermometer-2" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thermometer-1" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-thermometer-0" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-shower" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bathtub" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-podcast" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-window-maximize" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-window-minimize" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-window-restore" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-times-rectangle" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-times-rectangle-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-bandcamp" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-grav" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-etsy" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-imdb" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-ravelry" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-eercast" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-microchip" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-snowflake-o" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-superpowers" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-wpexplorer" aria-hidden="true"></i> </a>
<a href="/archives/"><i class="fa fa-meetup" aria-hidden="true"></i> </a>
</div>








]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title>redis淘汰算法及策略</title>
    <url>/2022/06/07/redis-tao-tai-suan-fa-ji-ce-lue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><blockquote>
<p>创建一个定时器，当key设置有过期时间且过期时间到达时，由定时器任务立即执行对键的删除操作</p>
<p>优点：节省内存，快速释放</p>
<p>缺点：cpu压力大，删除操作会影响redis响应时间和吞吐量</p>
</blockquote>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><blockquote>
<p>redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的 key</p>
<p>默认每100ms扫描一次，但是不会遍历所有的key，使用贪心策略</p>
</blockquote>
<ul>
<li>从过期字典中随机20gekey</li>
<li>删除者20个key中已经过期了的key</li>
<li>如果过期比例超过1&#x2F;4，重复步骤1</li>
</ul>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><blockquote>
<p>客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西</p>
<p>定期删除可能会导致很多过期key到了时间并没有被删除掉。所以就有了惰性删除</p>
</blockquote>
<p><strong>定期删除是集中处理，惰性删除是零散处理</strong></p>
<h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><ul>
<li><p><code>noeviction</code>：当内存使用超过配置的时候会返回错误，不会驱逐任何键</p>
</li>
<li><p><code>allkeys-lru</code>：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键</p>
</li>
<li><p><code>volatile-lru</code>：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键</p>
</li>
<li><p><code>allkeys-random</code>：加入键的时候如果过限，从所有key随机删除</p>
</li>
<li><p><code>volatile-random</code>：加入键的时候如果过限，从过期键的集合中随机驱逐</p>
</li>
<li><p><code>volatile-ttl</code>：从配置了过期时间的键中驱逐马上就要过期的键</p>
</li>
<li><p><code>volatile-lfu</code>：从所有配置了过期时间的键中驱逐使用频率最少的键</p>
</li>
<li><p><code>allkeys-lfu</code>：从所有键中驱逐使用频率最少的键</p>
</li>
</ul>
<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><img src="/2022/06/07/redis-tao-tai-suan-fa-ji-ce-lue/v2-9374e1c1ef6c7c8d14491b4092d79f80_720w.jpg" class="asset-class" title="img">

<ul>
<li>新增key value的时候首先在链表结尾添加Node节点，如果超过LRU设置的阈值就淘汰队头的节点并删除掉HashMap中对应的节点。</li>
<li>修改key对应的值的时候先修改对应的Node中的值，然后把Node节点移动队尾。</li>
<li>访问key对应的值的时候把访问的Node节点移动到队尾即可。</li>
</ul>
<pre><code class="prettyprint">package LRU;

import java.util.HashMap;

/**
 * @author RocPengHua
 * @program CLRS
 * @description LRU(最近最少使用)缓存机制
 * @date 2022年06月07日 21:03
 */
public class LRUCache &#123;
    private HashMap&lt;Integer,LinkedNode&gt; cache = new HashMap&lt;&gt;();
    int size;
    int capacity;
    private LinkedNode head,tail;
    class LinkedNode &#123;
        int key;
        int value;
        LinkedNode pre;
        LinkedNode next;
    &#125;

    public LRUCache(int capacity) &#123;
        this.size = 0;
        this.capacity = capacity;
        head = new LinkedNode();
        tail = new LinkedNode();
        head.next = tail;
        tail.pre = head;
    &#125;

    /**
     * 写入数据
     * @param key
     * @param value
     */
    public void put(int key, int value)&#123;
        LinkedNode node = cache.get(key);

        /**
         * 存在
         */
        if(node != null)&#123;
            //更新数据
            node.value = value;
            moveToHead(node);
        &#125;else&#123;
            LinkedNode newNode = new LinkedNode();
            newNode.key = key;
            newNode.value = value;
            //更新map
            cache.put(key,newNode);
            //添加节点到头部
            addNode(newNode);
            //更新节点数
            size++;
            //如果节点数目大于容量，删除最后一个节点
            if(size &gt; capacity) &#123;
                //获取最后一个节点
                LinkedNode tailPre = tail.pre;
                //从map中删除
                cache.remove(tailPre.key);
                //删除节点
                removeNode(tailPre);
                size--;
            &#125;
        &#125;
    &#125;

    public int get(int key)&#123;
        LinkedNode node = cache.get(key);
        if(node != null)&#123;
            moveToHead(node);
        &#125;else&#123;
            return -1;
        &#125;
        return node.value;
    &#125;
    /**
     * 将节点移到头部
     * @param node
     */
    private void moveToHead(LinkedNode node) &#123;
        removeNode(node);
        addNode(node);
    &#125;

    /**
     * 添加到头部
     * @param node
     */
    private void addNode(LinkedNode node) &#123;
        node.pre = head;
        node.next = head.next;
        head.next.pre = node;
        head.next = node;
    &#125;

    /**
     * 删除节点
     * @param node
     */
    private void removeNode(LinkedNode node) &#123;
        LinkedNode preNode = node.pre;
        LinkedNode nextNode = node.next;
        preNode.next = nextNode;
        nextNode.pre = preNode;

    &#125;

    public static void main(String[] args) &#123;
        LRUCache cache = new LRUCache(2);
        cache.put(1,1);
        cache.put(2,2);
        System.out.println(cache.get(1));
        cache.put(3,3);
        System.out.println(cache.get(2));
        cache.put(4,4);
        cache.put(5,5);
        cache.put(6,6);
        System.out.println(cache.get(4));
        System.out.println(cache.get(5));
        System.out.println(cache.get(6));
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存穿透、击穿、雪崩</title>
    <url>/2022/06/08/huan-cun-chuan-tou-ji-chuan-xue-beng/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><blockquote>
<p>大量并发查询不存在的KEY，导致都直接将压力透传到数据库</p>
</blockquote>
<p><strong>解决方法</strong></p>
<ul>
<li>缓存空值的KEY，这样第一次不存在也会被加载会记录，下次拿到有这个KEY</li>
<li>Bloom过滤或RoaringBitmap 判断KEY是否存</li>
<li>完全以缓存为准，使用 延迟异步加载 的策略</li>
</ul>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><blockquote>
<p>某个KEY失效的时候，正好有大量并发请求访问这个KEY</p>
</blockquote>
<p><strong>解决方法</strong></p>
<ul>
<li>KEY的更新操作添加全局互斥锁(异步双删)</li>
<li>完全以缓存为准，使用 延迟异步加载 的策略</li>
</ul>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><blockquote>
<p>当某一时刻发生大规模的缓存失效的情况，会有大量的请求进来直接打到数据库，导致数 据库压力过大升值宕机</p>
</blockquote>
<p><strong>解决方法</strong></p>
<ul>
<li>更新策略在时间上做到比较均匀</li>
<li>使用的热数据尽量分散到不同的机器上</li>
<li>多台机器做主从复制或者多副本，实现高可用</li>
<li>实现熔断限流机制，对系统进行负载能力控制</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis配置详解</title>
    <url>/2022/06/08/redis-pei-zhi-xiang-jie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="redis-conf"><a href="#redis-conf" class="headerlink" title="redis.conf"></a>redis.conf</h4><pre><code class="prettyprint"># 注意单位: 当需要配置内存大小时, 可能需要指定像1k,5GB,4M等常见格式
# 1k =&gt; 1000 bytes
# 1kb =&gt; 1024 bytes
# 1m =&gt; 1000000 bytes
# 1mb =&gt; 1024*1024 bytes
# 1g =&gt; 1000000000 bytes
# 1gb =&gt; 1024*1024*1024 bytes
#
# units are case insensitive so 1GB 1Gb 1gB are all the same.
# 内存配置对大小写不敏感
 
# 可以在这里包含一个或多个其他的配置文件。如果你有一个适用于所有Redis服务器的标准配置模板
# 但也需要一些每个服务器自定义的设置，这个功能将很有用。被包含的配置文件也可以包含其他配置文件，
# 所以需要谨慎的使用这个功能。
#
# 注意“inclue”选项不能被admin或Redis哨兵的&quot;CONFIG REWRITE&quot;命令重写。
# 因为Redis总是使用最后解析的配置行最为配置指令的值, 你最好在这个文件的开头配置includes来
# 避免它在运行时重写配置。
# 如果相反你想用includes的配置覆盖原来的配置，你最好在该文件的最后使用include
#
# include /path/to/local.conf
# include /path/to/other.conf
 
################################ GENERAL #####################################
 
# 默认Rdis不会作为守护进程运行。如果需要的话配置成&#39;yes&#39;
# 注意配置成守护进程后Redis会将进程号写入文件/var/run/redis.pid
daemonize no
 
# 当以守护进程方式运行时，默认Redis会把进程ID写到 /var/run/redis.pid。你可以在这里修改路径。
pidfile /var/run/redis.pid
 
# 接受连接的特定端口，默认是6379
# 如果端口设置为0，Redis就不会监听TCP套接字。
port 6379
 
# TCP listen() backlog.
#
# 在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核默默地将这个值减小
# 到/proc/sys/net/core/somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog
# 两个值来达到想要的效果。
tcp-backlog 511
 
# 默认Redis监听服务器上所有可用网络接口的连接。可以用&quot;bind&quot;配置指令跟一个或多个ip地址来实现
# 监听一个或多个网络接口
#
# 示例:
#
# bind 192.168.1.100 10.0.0.1
# bind 127.0.0.1
 
# 指定用来监听Unix套套接字的路径。没有默认值，所以在没有指定的情况下Redis不会监听Unix套接字
#
# unixsocket /tmp/redis.sock
# unixsocketperm 755
 
# 一个客户端空闲多少秒后关闭连接。(0代表禁用，永不关闭)
timeout 0
 
# TCP keepalive.
#
# 如果非零，则设置SO_KEEPALIVE选项来向空闲连接的客户端发送ACK，由于以下两个原因这是很有用的：
#
# 1）能够检测无响应的对端
# 2）让该连接中间的网络设备知道这个连接还存活
#
# 在Linux上，这个指定的值(单位：秒)就是发送ACK的时间间隔。
# 注意：要关闭这个连接需要两倍的这个时间值。
# 在其他内核上这个时间间隔由内核配置决定
#
# 这个选项的一个合理值是60秒
tcp-keepalive 0
 
# 指定服务器调试等级
# 可能值：
# debug （大量信息，对开发/测试有用）
# verbose （很多精简的有用信息，但是不像debug等级那么多）
# notice （适量的信息，基本上是你生产环境中需要的）
# warning （只有很重要/严重的信息会记录下来）
loglevel notice
 
# 指明日志文件名。也可以使用&quot;stdout&quot;来强制让Redis把日志信息写到标准输出上。
# 注意:如果Redis以守护进程方式运行，而设置日志显示到标准输出的话，日志会发送到/dev/null
logfile &quot;&quot;
 
# 要使用系统日志记录器，只要设置 &quot;syslog-enabled&quot; 为 &quot;yes&quot; 就可以了。
# 然后根据需要设置其他一些syslog参数就可以了。
# syslog-enabled no
 
# 指明syslog身份
# syslog-ident redis
 
# 指明syslog的设备。必须是user或LOCAL0 ~ LOCAL7之一。
# syslog-facility local0
 
# 设置数据库个数。默认数据库是 DB 0，
# 可以通过select &lt;dbid&gt; (0 &lt;= dbid &lt;= &#39;databases&#39; - 1 ）来为每个连接使用不同的数据库。
databases 16
 
################################ SNAPSHOTTING ################################
#
# 把数据库存到磁盘上:
#
# save &lt;seconds&gt; &lt;changes&gt;
#
# 会在指定秒数和数据变化次数之后把数据库写到磁盘上。
#
# 下面的例子将会进行把数据写入磁盘的操作:
# 900秒（15分钟）之后，且至少1次变更
# 300秒（5分钟）之后，且至少10次变更
# 60秒之后，且至少10000次变更
#
# 注意：你要想不写磁盘的话就把所有 &quot;save&quot; 设置注释掉就行了。
#
# 通过添加一条带空字符串参数的save指令也能移除之前所有配置的save指令
# 像下面的例子：
# save &quot;&quot;
 
save 900 1
save 300 10
save 60 10000
 
# 默认如果开启RDB快照(至少一条save指令)并且最新的后台保存失败，Redis将会停止接受写操作
# 这将使用户知道数据没有正确的持久化到硬盘，否则可能没人注意到并且造成一些灾难。
#
# 如果后台保存进程能重新开始工作，Redis将自动允许写操作
#
# 然而如果你已经部署了适当的Redis服务器和持久化的监控，你可能想关掉这个功能以便于即使是
# 硬盘，权限等出问题了Redis也能够像平时一样正常工作，
stop-writes-on-bgsave-error yes
 
# 当导出到 .rdb 数据库时是否用LZF压缩字符串对象？
# 默认设置为 &quot;yes&quot;，因为几乎在任何情况下它都是不错的。
# 如果你想节省CPU的话你可以把这个设置为 &quot;no&quot;，但是如果你有可压缩的key和value的话，
# 那数据文件就会更大了。
rdbcompression yes
 
# 因为版本5的RDB有一个CRC64算法的校验和放在了文件的最后。这将使文件格式更加可靠但在
# 生产和加载RDB文件时，这有一个性能消耗(大约10%)，所以你可以关掉它来获取最好的性能。
#
# 生成的关闭校验的RDB文件有一个0的校验和，它将告诉加载代码跳过检查
rdbchecksum yes
 
# 持久化数据库的文件名
dbfilename dump.rdb
 
# 工作目录
#
# 数据库会写到这个目录下，文件名就是上面的 &quot;dbfilename&quot; 的值。
#
# 累加文件也放这里。
#
# 注意你这里指定的必须是目录，不是文件名。
dir ./
 
################################# REPLICATION #################################
# 主从同步。通过 slaveof 指令来实现Redis实例的备份。
# 注意，这里是本地从远端复制数据。也就是说，本地可以有不同的数据库文件、绑定不同的IP、监听
# 不同的端口。
#
# slaveof &lt;masterip&gt; &lt;masterport&gt;
 
# 如果master设置了密码保护（通过 &quot;requirepass&quot; 选项来配置），那么slave在开始同步之前必须
# 进行身份验证，否则它的同步请求会被拒绝。
#
# masterauth &lt;master-password&gt;
 
# 当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能：
#
# 1) 如果 slave-serve-stale-data 设置为 &quot;yes&quot; (默认值)，slave会继续响应客户端请求，
# 可能是正常数据，也可能是还没获得值的空数据。
# 2) 如果 slave-serve-stale-data 设置为 &quot;no&quot;，slave会回复&quot;正在从master同步
# （SYNC with master in progress）&quot;来处理各种请求，除了 INFO 和 SLAVEOF 命令。
#
slave-serve-stale-data yes
 
# 你可以配置salve实例是否接受写操作。可写的slave实例可能对存储临时数据比较有用(因为写入salve
# 的数据在同master同步之后将很容被删除)，但是如果客户端由于配置错误在写入时也可能产生一些问题。
#
# 从Redis2.6默认所有的slave为只读
#
# 注意:只读的slave不是为了暴露给互联网上不可信的客户端而设计的。它只是一个防止实例误用的保护层。
# 一个只读的slave支持所有的管理命令比如config,debug等。为了限制你可以用&#39;rename-command&#39;来
# 隐藏所有的管理和危险命令来增强只读slave的安全性
slave-read-only yes
 
# slave根据指定的时间间隔向master发送ping请求。
# 时间间隔可以通过 repl_ping_slave_period 来设置。
# 默认10秒。
#
# repl-ping-slave-period 10
 
# 以下选项设置同步的超时时间
#
# 1）slave在与master SYNC期间有大量数据传输，造成超时
# 2）在slave角度，master超时，包括数据、ping等
# 3）在master角度，slave超时，当master发送REPLCONF ACK pings
#
# 确保这个值大于指定的repl-ping-slave-period，否则在主从间流量不高时每次都会检测到超时
#
# repl-timeout 60
 
# 是否在slave套接字发送SYNC之后禁用 TCP_NODELAY ？
#
# 如果你选择“yes”Redis将使用更少的TCP包和带宽来向slaves发送数据。但是这将使数据传输到slave
# 上有延迟，Linux内核的默认配置会达到40毫秒
#
# 如果你选择了 &quot;no&quot; 数据传输到salve的延迟将会减少但要使用更多的带宽
#
# 默认我们会为低延迟做优化，但高流量情况或主从之间的跳数过多时，把这个选项设置为“yes”
# 是个不错的选择。
repl-disable-tcp-nodelay no
 
# 设置数据备份的backlog大小。backlog是一个slave在一段时间内断开连接时记录salve数据的缓冲，
# 所以一个slave在重新连接时，不必要全量的同步，而是一个增量同步就足够了，将在断开连接的这段
# 时间内slave丢失的部分数据传送给它。
#
# 同步的backlog越大，slave能够进行增量同步并且允许断开连接的时间就越长。
#
# backlog只分配一次并且至少需要一个slave连接
#
# repl-backlog-size 1mb
 
# 当master在一段时间内不再与任何slave连接，backlog将会释放。以下选项配置了从最后一个
# slave断开开始计时多少秒后，backlog缓冲将会释放。
#
# 0表示永不释放backlog
#
# repl-backlog-ttl 3600
 
# slave的优先级是一个整数展示在Redis的Info输出中。如果master不再正常工作了，哨兵将用它来
# 选择一个slave提升=升为master。
#
# 优先级数字小的salve会优先考虑提升为master，所以例如有三个slave优先级分别为10，100，25，
# 哨兵将挑选优先级最小数字为10的slave。
#
# 0作为一个特殊的优先级，标识这个slave不能作为master，所以一个优先级为0的slave永远不会被
# 哨兵挑选提升为master
#
# 默认优先级为100
slave-priority 100
 
# 如果master少于N个延时小于等于M秒的已连接slave，就可以停止接收写操作。
#
# N个slave需要是“oneline”状态
#
# 延时是以秒为单位，并且必须小于等于指定值，是从最后一个从slave接收到的ping（通常每秒发送）
# 开始计数。
#
# This option does not GUARANTEES that N replicas will accept the write, but
# will limit the window of exposure for lost writes in case not enough slaves
# are available, to the specified number of seconds.
#
# 例如至少需要3个延时小于等于10秒的slave用下面的指令：
#
# min-slaves-to-write 3
# min-slaves-max-lag 10
#
# 两者之一设置为0将禁用这个功能。
#
# 默认 min-slaves-to-write 值是0（该功能禁用）并且 min-slaves-max-lag 值是10。
 
################################## SECURITY ###################################
 
# 要求客户端在处理任何命令时都要验证身份和密码。
# 这个功能在有你不信任的其它客户端能够访问redis服务器的环境里非常有用。
#
 
# 为了向后兼容的话这段应该注释掉。而且大多数人不需要身份验证(例如:它们运行在自己的服务器上)
#
# 警告：因为Redis太快了，所以外面的人可以尝试每秒150k的密码来试图破解密码。这意味着你需要
# 一个高强度的密码，否则破解太容易了。
#
# requirepass foobared
 
# 命令重命名
#
# 在共享环境下，可以为危险命令改变名字。比如，你可以为 CONFIG 改个其他不太容易猜到的名字，
# 这样内部的工具仍然可以使用，而普通的客户端将不行。
#
# 例如：
#
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#
# 也可以通过改名为空字符串来完全禁用一个命令
#
# rename-command CONFIG &quot;&quot;
#
# 请注意：改变命令名字被记录到AOF文件或被传送到从服务器可能产生问题。
 
################################### LIMITS ####################################
 
# 设置最多同时连接的客户端数量。默认这个限制是10000个客户端，然而如果Redis服务器不能配置
# 处理文件的限制数来满足指定的值，那么最大的客户端连接数就被设置成当前文件限制数减32（因
# 为Redis服务器保留了一些文件描述符作为内部使用）
#
# 一旦达到这个限制，Redis会关闭所有新连接并发送错误&#39;max number of clients reached&#39;
#
# maxclients 10000
 
# 不要用比设置的上限更多的内存。一旦内存使用达到上限，Redis会根据选定的回收策略（参见：
# maxmemmory-policy）删除key
#
# 如果因为删除策略Redis无法删除key，或者策略设置为 &quot;noeviction&quot;，Redis会回复需要更
# 多内存的错误信息给命令。例如，SET,LPUSH等等，但是会继续响应像Get这样的只读命令。
#
# 在使用Redis作为LRU缓存，或者为实例设置了硬性内存限制的时候（使用 &quot;noeviction&quot; 策略）
# 的时候，这个选项通常事很有用的。
#
# 警告：当有多个slave连上达到内存上限的实例时，master为同步slave的输出缓冲区所需
# 内存不计算在使用内存中。这样当驱逐key时，就不会因网络问题 / 重新同步事件触发驱逐key
# 的循环，反过来slaves的输出缓冲区充满了key被驱逐的DEL命令，这将触发删除更多的key，
# 直到这个数据库完全被清空为止
#
# 总之...如果你需要附加多个slave，建议你设置一个稍小maxmemory限制，这样系统就会有空闲
# 的内存作为slave的输出缓存区(但是如果最大内存策略设置为&quot;noeviction&quot;的话就没必要了)
#
# maxmemory &lt;bytes&gt;
 
# 最大内存策略：如果达到内存限制了，Redis如何选择删除key。你可以在下面五个行为里选：
#
# volatile-lru -&gt; 根据LRU算法生成的过期时间来删除。
# allkeys-lru -&gt; 根据LRU算法删除任何key。
# volatile-random -&gt; 根据过期设置来随机删除key。
# allkeys-&gt;random -&gt; 无差别随机删。
# volatile-ttl -&gt; 根据最近过期时间来删除（辅以TTL）
# noeviction -&gt; 谁也不删，直接在写操作时返回错误。
#
# 注意：对所有策略来说，如果Redis找不到合适的可以删除的key都会在写操作时返回一个错误。
#
 
# 目前为止涉及的命令：set setnx setex append
# incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
# sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
# zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
# getset mset msetnx exec sort
#
 
# 默认值如下：
#
# maxmemory-policy volatile-lru
 
# LRU和最小TTL算法的实现都不是很精确，但是很接近（为了省内存），所以你可以用样本量做检测。
# 例如：默认Redis会检查3个key然后取最旧的那个，你可以通过下面的配置指令来设置样本的个数。
#
# maxmemory-samples 3
 
############################## APPEND ONLY MODE ###############################
 
# 默认情况下，Redis是异步的把数据导出到磁盘上。这种模式在很多应用里已经足够好，但Redis进程
# 出问题或断电时可能造成一段时间的写操作丢失(这取决于配置的save指令)。
#
# AOF是一种提供了更可靠的替代持久化模式，例如使用默认的数据写入文件策略（参见后面的配置）
# 在遇到像服务器断电或单写情况下Redis自身进程出问题但操作系统仍正常运行等突发事件时，Redis
# 能只丢失1秒的写操作。
#
# AOF和RDB持久化能同时启动并且不会有问题。
# 如果AOF开启，那么在启动时Redis将加载AOF文件，它更能保证数据的可靠性。
#
# 请查看 http://redis.io/topics/persistence 来获取更多信息.
 
appendonly no
 
# 纯累加文件名字（默认：&quot;appendonly.aof&quot;）
 
appendfilename &quot;appendonly.aof&quot;
 
# fsync() 系统调用告诉操作系统把数据写到磁盘上，而不是等更多的数据进入输出缓冲区。
# 有些操作系统会真的把数据马上刷到磁盘上；有些则会尽快去尝试这么做。
#
# Redis支持三种不同的模式：
#
# no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。
# always：每次写操作都立刻写入到aof文件。慢，但是最安全。
# everysec：每秒写一次。折中方案。
#
# 默认的 &quot;everysec&quot; 通常来说能在速度和数据安全性之间取得比较好的平衡。根据你的理解来
# 决定，如果你能放宽该配置为&quot;no&quot; 来获取更好的性能(但如果你能忍受一些数据丢失，可以考虑使用
# 默认的快照持久化模式)，或者相反，用“always”会比较慢但比everysec要更安全。
#
# 请查看下面的文章来获取更多的细节
# http://antirez.com/post/redis-persistence-demystified.html
#
# 如果不能确定，就用 &quot;everysec&quot;
 
# appendfsync always
appendfsync everysec
# appendfsync no
 
# 如果AOF的同步策略设置成 &quot;always&quot; 或者 &quot;everysec&quot;，并且后台的存储进程（后台存储或写入AOF
# 日志）会产生很多磁盘I/O开销。某些Linux的配置下会使Redis因为 fsync()系统调用而阻塞很久。
# 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们同步的write(2)调用。
#
# 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止fsync()。
#
# 这就意味着如果有子进程在进行保存操作，那么Redis就处于&quot;不可同步&quot;的状态。
# 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。（默认Linux设定）
#
# 如果把这个设置成&quot;yes&quot;带来了延迟问题，就保持&quot;no&quot;，这是保存持久数据的最安全的方式。
 
no-appendfsync-on-rewrite no
 
# 自动重写AOF文件
# 如果AOF日志文件增大到指定百分比，Redis能够通过 BGREWRITEAOF 自动重写AOF日志文件。
#
# 工作原理：Redis记住上次重写时AOF文件的大小（如果重启后还没有写操作，就直接用启动时的AOF大小）
#
# 这个基准大小和当前大小做比较。如果当前大小超过指定比例，就会触发重写操作。你还需要指定被重写
# 日志的最小尺寸，这样避免了达到指定百分比但尺寸仍然很小的情况还要重写。
#
# 指定百分比为0会禁用AOF自动重写特性。
 
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb```
 
################################ LUA SCRIPTING ###############################
 
# Lua 脚本的最大执行时间，毫秒为单位
#
# 如果达到了最大的执行时间，Redis将要记录在达到最大允许时间之后一个脚本仍然在执行，并且将
# 开始对查询进行错误响应。
#
# 当一个长时间运行的脚本超过了最大执行时间，只有 SCRIPT KILL 和 SHUTDOWN NOSAVE 两个
# 命令可用。第一个可以用于停止一个还没有调用写命名的脚本。第二个是关闭服务器唯一方式，当
# 写命令已经通过脚本开始执行，并且用户不想等到脚本的自然终止。
#
# 设置成0或者负值表示不限制执行时间并且没有任何警告
lua-time-limit 5000
 
################################## SLOW LOG ###################################
 
# Redis慢查询日志可以记录超过指定时间的查询。运行时间不包括各种I/O时间，例如：连接客户端，
# 发送响应数据等，而只计算命令执行的实际时间（这只是线程阻塞而无法同时为其他请求服务的命令执
# 行阶段）
#
# 你可以为慢查询日志配置两个参数:一个指明Redis的超时时间(单位为微秒)来记录超过这个时间的命令
# 另一个是慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录从队列中移除。
#
# 下面的时间单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录
# 所有命令。
slowlog-log-slower-than 10000
 
# 这个长度没有限制。只是要主要会消耗内存。你可以通过 SLOWLOG RESET 来回收内存。
slowlog-max-len 128
 
############################# Event notification ##############################
 
# Redis 能通知 Pub/Sub 客户端关于键空间发生的事件
# 这个功能文档位于http://redis.io/topics/keyspace-events
#
# 例如：如果键空间事件通知被开启，并且客户端对 0 号数据库的键 foo 执行 DEL 命令时，将通过
# Pub/Sub发布两条消息：
# PUBLISH __keyspace@0__:foo del
# PUBLISH __keyevent@0__:del foo
#
# 可以在下表中选择Redis要通知的事件类型。事件类型由单个字符来标识：
#
# K 键空间通知，以__keyspace@&lt;db&gt;__为前缀
# E 键事件通知，以__keysevent@&lt;db&gt;__为前缀
# g DEL , EXPIRE , RENAME 等类型无关的通用命令的通知, ...
# $ String命令
# l List命令
# s Set命令
# h Hash命令
# z 有序集合命令
# x 过期事件（每次key过期时生成）
# e 驱逐事件（当key在内存满了被清除时生成）
# A g$lshzxe的别名，因此”AKE”意味着所有的事件
#
# notify-keyspace-events 带一个由0到多个字符组成的字符串参数。空字符串意思是通知被禁用。
#
# 例子：启用List和通用事件通知：
# notify-keyspace-events Elg
#
# 例子2：为了获取过期key的通知订阅名字为 __keyevent@__:expired 的频道，用以下配置
# notify-keyspace-events Ex
#
# 默认所用的通知被禁用，因为用户通常不需要该特性，并且该特性会有性能损耗。
# 注意如果你不指定至少K或E之一，不会发送任何事件。
notify-keyspace-events &quot;&quot;
 
############################### ADVANCED CONFIG ###############################
 
# 当hash只有少量的entry时，并且最大的entry所占空间没有超过指定的限制时，会用一种节省内存的
# 数据结构来编码。可以通过下面的指令来设定限制
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
 
# 与hash似，数据元素较少的list，可以用另一种方式来编码从而节省大量空间。
# 这种特殊的方式只有在符合下面限制时才可以用：
list-max-ziplist-entries 512
list-max-ziplist-value 64
 
# set有一种特殊编码的情况：当set数据全是十进制64位有符号整型数字构成的字符串时。
# 下面这个配置项就是用来设置set使用这种编码来节省内存的最大长度。
set-max-intset-entries 512
 
# 与hash和list相似，有序集合也可以用一种特别的编码方式来节省大量空间。
# 这种编码只适合长度和元素都小于下面限制的有序集合：
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
 
# HyperLogLog sparse representation bytes limit. The limit includes the
# 16 bytes header. When an HyperLogLog using the sparse representation crosses
# this limit, it is converted into the dense representation.
#
# A value greater than 16000 is totally useless, since at that point the
# dense representation is more memory efficient.
#
# The suggested value is ~ 3000 in order to have the benefits of
# the space efficient encoding without slowing down too much PFADD,
# which is O(N) with the sparse encoding. The value can be raised to
# ~ 10000 when CPU is not a concern, but space is, and the data set is
# composed of many HyperLogLogs with cardinality in the 0 - 15000 range.
hll-sparse-max-bytes 3000
 
# 启用哈希刷新，每100个CPU毫秒会拿出1个毫秒来刷新Redis的主哈希表（顶级键值映射表）。
# redis所用的哈希表实现（见dict.c）采用延迟哈希刷新机制：你对一个哈希表操作越多，哈希刷新
# 操作就越频繁；反之，如果服务器是空闲的，那么哈希刷新就不会完成，哈希表就会占用更多的一些
# 内存而已。
#
# 默认是每秒钟进行10次哈希表刷新，用来刷新字典，然后尽快释放内存。
#
# 建议：
# 如果你对延迟比较在意，不能够接受Redis时不时的对请求有2毫秒的延迟的话，就用
# &quot;activerehashing no&quot;，如果不太在意延迟而希望尽快释放内存就设置&quot;activerehashing yes&quot;
activerehashing yes
 
# 客户端的输出缓冲区的限制，可用于强制断开那些因为某种原因从服务器读取数据的速度不够快的客户端，
# （一个常见的原因是一个发布/订阅客户端消费消息的速度无法赶上生产它们的速度）
#
# 可以对三种不同的客户端设置不同的限制：
# normal -&gt; 正常客户端
# slave -&gt; slave和 MONITOR 客户端
# pubsub -&gt; 至少订阅了一个pubsub channel或pattern的客户端
#
# 下面是每个client-output-buffer-limit语法:
# client-output-buffer-limit &lt;class&gt;&lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;
 
# 一旦达到硬限制客户端会立即被断开，或者达到软限制并持续达到指定的秒数（连续的）。
# 例如，如果硬限制为32兆字节和软限制为16兆字节/10秒，客户端将会立即断开
# 如果输出缓冲区的大小达到32兆字节，或客户端达到16兆字节并连续超过了限制10秒，就将断开连接。
#
# 默认normal客户端不做限制，因为他们在不主动请求时不接收数据（以推的方式），只有异步客户端
# 可能会出现请求数据的速度比它可以读取的速度快的场景。
#
# pubsub和slave客户端会有一个默认值，因为订阅者和slaves以推的方式来接收数据
#
# 把硬限制和软限制都设置为0来禁用该功能
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
 
# Redis调用内部函数来执行许多后台任务，如关闭客户端超时的连接，清除未被请求过的过期Key等等。
#
# 不是所有的任务都以相同的频率执行，但Redis依照指定的“hz”值来执行检查任务。
#
# 默认情况下，“hz”的被设定为10。提高该值将在Redis空闲时使用更多的CPU时，但同时当有多个key
# 同时到期会使Redis的反应更灵敏，以及超时可以更精确地处理。
#
# 范围是1到500之间，但是值超过100通常不是一个好主意。
# 大多数用户应该使用10这个默认值，只有在非常低的延迟要求时有必要提高到100。
hz 10
 
# 当一个子进程重写AOF文件时，如果启用下面的选项，则文件每生成32M数据会被同步。为了增量式的
# 写入硬盘并且避免大的延迟高峰这个指令是非常有用的
aof-rewrite-incremental-fsync yes
</code></pre>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7安装redis6及哨兵</title>
    <url>/2022/06/09/centos7-an-zhuang-redis6-ji-shao-bing/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h3><pre><code class="prettyprint">#创建一个专门存放软件的目录
mkdir /opt/software
cd /opt/software
#下载
wget https://download.redis.io/releases/redis-6.2.6.tar.gz
#解压
tar -zxvf redis-6.2.6.tar.gz
#进入src目录安装
cd redis-6.2.6/src
#指定安装到目录
make PREFIX=/usr/local/redis install
#测试是否成功
cd /usr/local/redis/bin
#启动
./redis-server 
#访问
./redis-cli
</code></pre>
<h3 id="哨兵配置"><a href="#哨兵配置" class="headerlink" title="哨兵配置"></a>哨兵配置</h3><h4 id="准备三份配置文件"><a href="#准备三份配置文件" class="headerlink" title="准备三份配置文件"></a>准备三份配置文件</h4><pre><code class="prettyprint">cd /opt/software
mkdir redis-sentinel
cd redis-sentinel
#-r 包含目录复制
cp -r /opt/software/redis-6.2.6/ .
mv redis-6.2.6 redis-6.2.6-6380
cp -r redis-6.2.6-6380 redis-6.2.6-6381
cp -r redis-6.2.6-6380 redis-6.2.6-6382
</code></pre>
<h3 id="修改主节点配置"><a href="#修改主节点配置" class="headerlink" title="修改主节点配置"></a>修改主节点配置</h3><pre><code class="prettyprint">vim /opt/software/redis-sentinel/redis-6.2.6-6380/redis.conf
</code></pre>
<p>修改<code>redis.conf</code></p>
<pre><code class="prettyprint">#只需要修改端口
port 6380
</code></pre>
<p>修改<code>sentinel.conf</code></p>
<pre><code class="prettyprint">#修改port
port 26380
#开启守护线程
daemonize yes 
#sentinel monitor &lt;master-group-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;
#master-group-name是集群名称 quorum是需要同意主节点不可用的Sentinel的数量
sentinel monitor mymaster 192.168.101.123 6380 2
#主节点密码，如果有
#sentinel auth-pass &lt;master-name&gt; &lt;password&gt;
</code></pre>
<h4 id="修改两个从节点"><a href="#修改两个从节点" class="headerlink" title="修改两个从节点"></a>修改两个从节点</h4><pre><code class="prettyprint">vim /opt/software/redis-sentinel/redis-6.2.6-6381/redis.conf
</code></pre>
<p>修改<code>redis.conf</code></p>
<pre><code class="prettyprint">#修改port（一个为6381，另一个为6382）
port 6381
#主从复制 replicaof &lt;masterip&gt; &lt;masterport&gt;
replicaof 192.168.101.123 6380
#主节点密码 masterauth &lt;master-password&gt;
#masterauth 主节点密码
</code></pre>
<p>修改<code>sentinel.conf</code></p>
<pre><code class="prettyprint">#修改port（一个为26381，另一个为26382）
port 26381
#开启守护线程
daemonize yes 
#sentinel monitor &lt;master-group-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;
sentinel monitor mymaster 192.168.101.123 6380 2
#主节点密码
#sentinel auth-pass mymaster 主节点密码
</code></pre>
<h3 id="启动哨兵模式"><a href="#启动哨兵模式" class="headerlink" title="启动哨兵模式"></a>启动哨兵模式</h3><h4 id="maste和slave启动"><a href="#maste和slave启动" class="headerlink" title="maste和slave启动"></a>maste和slave启动</h4><pre><code class="prettyprint">cd /usr/local/redis/bin
# &amp; 后台启动
./redis-server /opt/software/redis-sentinel/redis-6.2.6-6380/redis.conf &amp;
./redis-server /opt/software/redis-sentinel/redis-6.2.6-6381/redis.conf &amp;
./redis-server /opt/software/redis-sentinel/redis-6.2.6-6382/redis.conf &amp;
</code></pre>
<h4 id="sentinel启动"><a href="#sentinel启动" class="headerlink" title="sentinel启动"></a>sentinel启动</h4><pre><code class="prettyprint">cd /usr/local/redis/bin

./redis-sentinel /opt/software/redis-sentinel/redis-6.2.6-6380/sentinel.conf
./redis-sentinel /opt/software/redis-sentinel/redis-6.2.6-6381/sentinel.conf
./redis-sentinel /opt/software/redis-sentinel/redis-6.2.6-6382/sentinel.conf
</code></pre>
<h4 id="测试哨兵模式"><a href="#测试哨兵模式" class="headerlink" title="测试哨兵模式"></a>测试哨兵模式</h4><blockquote>
<p>分别连接</p>
</blockquote>
<pre><code class="prettyprint">./redis-cli -p 6380
./redis-cli -p 6381
./redis-cli -p 6382
</code></pre>
<blockquote>
<p>查看角色信息</p>
</blockquote>
<pre><code class="prettyprint">192.168.101.123:6380&gt;info
#role:master
192.168.101.123:6381&gt;info
#role:slave
192.168.101.123:6382&gt;info
#role:slave
</code></pre>
<blockquote>
<p>测试master切换，手动shutdown主服务器,过一会重新启动6380</p>
</blockquote>
<pre><code>./redis-cli -p 6380 shutdown
./redis-server /opt/software/redis-sentinel/redis-6.2.6-6380/redis.conf &amp;
</code></pre>
<blockquote>
<p>再次查看角色信息</p>
</blockquote>
<pre><code class="prettyprint">192.168.101.123:6380&gt;info
#role:slave
192.168.101.123:6381&gt;info
#role:master
192.168.101.123:6382&gt;info
#role:slave
</code></pre>
<blockquote>
<p> 注意：</p>
<p>如果开始配置哨兵模式使用的ip是127.0.0.1,外部客户端无法连接，需要使用机器ip</p>
<p>修改redis.conf sentinel.conf中使用的ip之前停掉redis sentinel</p>
<p>.&#x2F;redis-cli -p 6380 shutdown</p>
<p>.&#x2F;redis-cli -p 6381 shutdown</p>
<p>.&#x2F;redis-cli -p 6382 shutdown</p>
<p>.&#x2F;redis-cli -p 26380 shutdown</p>
<p>.&#x2F;redis-cli -p 26382 shutdown</p>
<p>.&#x2F;redis-cli -p 26382 shutdown</p>
</blockquote>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>哨兵</tag>
      </tags>
  </entry>
  <entry>
    <title>redis脑裂</title>
    <url>/2022/06/09/redis-nao-lie/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="redis脑裂发生"><a href="#redis脑裂发生" class="headerlink" title="redis脑裂发生"></a>redis脑裂发生</h3><ul>
<li>假如有三台redis服务器</li>
<li>当master服务器出现网络问题，两个slave服务器无法和master服务器通信，然而客户端是可以的</li>
<li>那么sentine就会从两台slave服务器选取一个作为主服务器来处理客户端请求</li>
<li>此时就存在两个master了</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><blockquote>
<p>修改conf配置</p>
</blockquote>
<pre><code class="prettyprint">min-slaves-to-write 1 #要求至少有一个slave。

min-slaves-max-lag 10 #主从数据同步超时时间，10秒。
</code></pre>
<p>以上要求无法满足拒绝客户端请求，可以将master通信异常的数据丢失控制在10s</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat源码环境搭建</title>
    <url>/2022/06/10/tomcat-yuan-ma-huan-jing-da-jian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><p><a href="https://links.jianshu.com/go?to=https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.50/src/">https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.50/src/</a></p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>解压源码</li>
<li>新建<code>source</code>文件夹用来存放配置文件和页面文件，将<code>conf</code>和<code>webapps</code>目录移动到<code>source</code>目录下</li>
<li>在根目录下新建<code>pom.xml</code>导入依赖</li>
</ul>
<pre><code class="prettyprint">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;
    &lt;artifactId&gt;apache-tomcat-8.5.50-src&lt;/artifactId&gt;
    &lt;name&gt;Tomcat8.5&lt;/name&gt;
    &lt;version&gt;8.5&lt;/version&gt;
    &lt;build&gt;
        &lt;!--指定源目录--&gt;
        &lt;finalName&gt;Tomcat8.5&lt;/finalName&gt;
        &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;java&lt;/directory&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
        &lt;plugins&gt;
            &lt;!--引入编译插件--&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.1&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;
                    &lt;source&gt;8&lt;/source&gt;
                    &lt;target&gt;8&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
    &lt;!--tomcat依赖的基础包--&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.easymock&lt;/groupId&gt;
            &lt;artifactId&gt;easymock&lt;/artifactId&gt;
            &lt;version&gt;3.4&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ant&lt;/groupId&gt;
            &lt;artifactId&gt;ant&lt;/artifactId&gt;
            &lt;version&gt;1.7.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;wsdl4j&lt;/groupId&gt;
            &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt;
            &lt;version&gt;1.6.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.xml&lt;/groupId&gt;
            &lt;artifactId&gt;jaxrpc&lt;/artifactId&gt;
            &lt;version&gt;1.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt;
            &lt;artifactId&gt;ecj&lt;/artifactId&gt;
            &lt;version&gt;4.5.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.xml.soap&lt;/groupId&gt;
            &lt;artifactId&gt;javax.xml.soap-api&lt;/artifactId&gt;
            &lt;version&gt;1.4.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<ul>
<li>导入idea工具</li>
</ul>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ul>
<li>找到<code>org.apache.catalina.startup.Bootstrap#main</code>执行启动，如果有找不到包等问题可以直接用idea提示修改</li>
<li>配置VM.options</li>
</ul>
<pre><code class="prettyprint">-Dcatalina.home=E:/Download/apache-tomcat-8.5.50-src/source
-Dcatalina.base=E:/Download/apache-tomcat-8.5.50-src/source
-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager
-Djava.util.logging.config.file=/Download/apache-tomcat-8.5.50-src/source/conf/logging.properties
</code></pre>
<ul>
<li>初始化jsp解析引擎jasper,<code>org.apache.catalina.startup.ContextConfig#configureStart</code></li>
</ul>
<pre><code>context.addServletContainerInitializer(new JasperInitializer(), null);
</code></pre>
<img src="/2022/06/10/tomcat-yuan-ma-huan-jing-da-jian/1654832343643.png" class="asset-class" width="1654832343643">

<h3 id="中文乱码解决"><a href="#中文乱码解决" class="headerlink" title="中文乱码解决"></a>中文乱码解决</h3><ul>
<li><code>org.apache.tomcat.util.res.StringManager#getString(java.lang.String, java.lang.Object...)</code></li>
</ul>
<pre><code class="prettyprint">//RocPengHua
value = new String(value.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);
</code></pre>
<ul>
<li><code>org.apache.jasper.compiler.Localizer#getMessage(java.lang.String)</code></li>
</ul>
<pre><code class="prettyprint">//RocPengHua
errMsg = new String(errMsg.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);
</code></pre>
<ul>
<li><code>org.apache.jasper.compiler.Localizer#getMessage(java.lang.String, java.lang.Object...)</code></li>
</ul>
<pre><code class="prettyprint">errMsg = new String(errMsg.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);
</code></pre>
<blockquote>
<p>源码分析地址：</p>
<p><a href="https://www.jianshu.com/p/7c9401b85704?utm_campaign=haruki&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">一万字深度剖析Tomcat源码 - 简书 (jianshu.com)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
</search>
